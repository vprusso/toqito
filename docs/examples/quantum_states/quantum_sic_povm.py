"""Tutorial on SIC-POVMs: geometry, design structure, and quantum state discrimination.

A **Symmetric Informationally Complete Positive Operator-Valued Measure** (SIC-POVM) in
dimension :math:`d` is a set of :math:`d^2` unit vectors
:math:`\\{|\\psi_i\\rangle\\}_{i=1}^{d^2} \\subset \\mathbb{C}^d` satisfying the uniform
overlap condition :footcite:p:`renes2004symmetric`:

.. math::

    |\\langle \\psi_i | \\psi_j \\rangle|^2 = \\frac{1}{d+1}, \\quad \\forall\\, i \\neq j.

The POVM elements :math:`M_i = \\frac{1}{d}|\\psi_i\\rangle\\langle\\psi_i|` sum to the
identity, making SIC-POVMs both valid measurements and *informationally complete* any
quantum state can be reconstructed from the resulting statistics.

 SIC-POVMs are *projective 2-designs*: finite
constellations that exactly replicate Haar-random second-order integration
:footcite:p:`scott2006tight`. This tutorial explores both aspects using :code:`toqito`.

Constructing SIC-POVMs
----------------------

The :math:`d=2` SIC-POVM consists of four states whose Bloch vectors are the vertices of a
regular tetrahedron. The :math:`d=3` SIC-POVM (Hesse SIC) is generated by applying the nine
Weyl-Heisenberg displacement operators :math:`D_{jk} = \\tau^{jk} X^j Z^k` to a single
fiducial state :footcite:p:`appleby2005sicpovms`.

Gram Matrix
-----------

The Gram matrix :math:`G_{ij} = |\\langle\\psi_i|\\psi_j\\rangle|^2` has a constant
off-diagonal value â€” the defining visual signature of the SIC structure.

Design Geometry
---------------

A SIC-POVM is a *projective 2-design*: its order-2 frame potential

.. math::

    \\Phi^{(2)} = \\sum_{i,j} |\\langle\\psi_i|\\psi_j\\rangle|^{4}

saturates the theoretical minimum :math:`N^2 / \\binom{d+1}{2}`. All pairwise overlaps
collapse to a single spike at :math:`1/(d+1)`, and the second moment operator matches the
Haar integral :math:`\\Pi_{\\mathrm{sym}} / \\binom{d+1}{2}` to numerical precision.

Quantum State Discrimination
-----------------------------

For equal priors the analytic minimum-error success probability is
:footcite:p:`barnett2009quantum`:

.. math::

    P_{\\mathrm{succ}} = \\frac{2}{d(d+1)}.

:func:`toqito.state_opt.state_distinguishability` reproduces this exactly.

Informational Completeness
---------------------------

Any quantum state :math:`\\rho` can be recovered from SIC-POVM statistics
:math:`p_i = \\mathrm{Tr}(M_i\\rho)` via :footcite:p:`fuchs2004quantum`:

.. math::

    \\rho = \\sum_{i=1}^{d^2} \\left[(d+1)\\,p_i - \\frac{1}{d}\\right]
            |\\psi_i\\rangle\\langle\\psi_i|.

References
----------

.. footbibliography::
"""
import numpy as np
import matplotlib.pyplot as plt
from itertools import combinations
from math import comb

from toqito.state_opt import state_distinguishability, state_exclusion


#  SIC state constructors 

def sic_povm_d2() -> list[np.ndarray]:
    r"""Return the four d=2 SIC-POVM states (tetrahedral states on the Bloch sphere).

    These states satisfy :math:`|\langle\psi_i|\psi_j\rangle|^2 = 1/3` for all
    :math:`i \neq j` :footcite:p:`renes2004symmetric`.

    Examples
    ========

    >>> import numpy as np
    >>> from itertools import combinations
    >>> sic2 = sic_povm_d2()
    >>> all(np.isclose(abs(np.vdot(sic2[i], sic2[j]))**2, 1/3) for i, j in combinations(range(4), 2))
    True

    References
    ==========

    .. footbibliography::

    :return: List of four unit vectors in :math:`\mathbb{C}^2`.
    """
    psi_0 = np.array([1, 0], dtype=complex)
    psi_1 = np.array([1/np.sqrt(3), np.sqrt(2/3)], dtype=complex)
    psi_2 = np.array([1/np.sqrt(3), np.sqrt(2/3) * np.exp(1j * 2*np.pi/3)], dtype=complex)
    psi_3 = np.array([1/np.sqrt(3), np.sqrt(2/3) * np.exp(1j * 4*np.pi/3)], dtype=complex)
    return [psi_0, psi_1, psi_2, psi_3]


def sic_povm_d3() -> list[np.ndarray]:
    r"""Return the nine d=3 SIC-POVM states via the Weyl-Heisenberg group orbit.

    The Hesse SIC is generated as :math:`|\psi_{jk}\rangle = D_{jk}|\psi_0\rangle` where
    :math:`D_{jk} = \tau^{jk}X^jZ^k` :footcite:p:`appleby2005sicpovms`.

    Examples
    ========

    >>> import numpy as np
    >>> from itertools import combinations
    >>> sic3 = sic_povm_d3()
    >>> overlaps = [abs(np.vdot(sic3[i], sic3[j]))**2 for i, j in combinations(range(9), 2)]
    >>> np.allclose(overlaps, 0.25, atol=1e-8)
    True

    References
    ==========

    .. footbibliography::

    :return: List of nine unit vectors in :math:`\mathbb{C}^3`.
    """
    d = 3
    omega, tau = np.exp(2j * np.pi / d), np.exp(1j * np.pi / d)
    X = np.roll(np.eye(d), -1, axis=0)
    Z = np.diag([omega**m for m in range(d)])
    fiducial = np.array([0, 1, -np.exp(1j * np.arctan(np.sqrt(2)))], dtype=complex)
    fiducial /= np.linalg.norm(fiducial)
    return [
        tau**(j*k) * (np.linalg.matrix_power(X, j) @ np.linalg.matrix_power(Z, k)) @ fiducial
        for j in range(d) for k in range(d)
    ]


# POVM helpers

def build_povm(states: list[np.ndarray], d: int) -> list[np.ndarray]:
    r"""Build the POVM elements :math:`M_i = \frac{1}{d}|\psi_i\rangle\langle\psi_i|`.

    Examples
    ========

    >>> import numpy as np
    >>> povm2 = build_povm(sic_povm_d2(), d=2)
    >>> np.linalg.norm(sum(povm2) - np.eye(2)) < 1e-10
    True

    :param states: List of unit vectors.
    :param d: Hilbert space dimension.
    :return: List of POVM matrices.
    """
    return [np.outer(psi, psi.conj()) / d for psi in states]


#  Gram matrix 

def gram_matrix(states: list[np.ndarray]) -> np.ndarray:
    r"""Compute the Gram matrix :math:`G_{ij} = |\langle\psi_i|\psi_j\rangle|^2`.

    For a SIC-POVM every off-diagonal entry equals :math:`1/(d+1)`.

    Examples
    ========

    >>> import numpy as np
    >>> G = gram_matrix(sic_povm_d2())
    >>> np.allclose(G - np.diag(np.diag(G)), 1/3)
    True

    :param states: List of unit vectors.
    :return: Real-valued Gram matrix of shape ``(N, N)``.
    """
    n = len(states)
    return np.array([[abs(np.vdot(states[i], states[j]))**2
                      for j in range(n)] for i in range(n)])


#  Design geometry 

def frame_potential(states: list[np.ndarray]) -> float:
    r"""Compute the order-2 frame potential :math:`\Phi^{(2)} = \sum_{i,j}|\langle\psi_i|\psi_j\rangle|^4`.

    A set of :math:`N` states in :math:`\mathbb{C}^d` is a projective 2-design iff this
    equals :math:`N^2 / \binom{d+1}{2}` :footcite:p:`scott2006tight`.

    Examples
    ========

    >>> from math import comb
    >>> sic2 = sic_povm_d2()
    >>> abs(frame_potential(sic2) - 4**2 / comb(3, 2)) < 1e-10
    True

    References
    ==========

    .. footbibliography::

    :param states: List of unit vectors.
    :return: Frame potential value.
    """
    return sum(abs(np.vdot(a, b))**4 for a in states for b in states)


def moment_operator(states: list[np.ndarray], d: int) -> np.ndarray:
    r"""Compute the second moment operator :math:`\frac{1}{N}\sum_i(|\psi_i\rangle\langle\psi_i|)^{\otimes 2}`.

    A set is a projective 2-design iff this equals :math:`\Pi_{\mathrm{sym}}/\binom{d+1}{2}`
    :footcite:p:`scott2006tight`.

    Examples
    ========

    >>> import numpy as np
    >>> err = np.linalg.norm(moment_operator(sic_povm_d2(), 2) - haar_moment(2), "fro")
    >>> err < 1e-10
    True

    References
    ==========

    .. footbibliography::

    :param states: List of unit vectors.
    :param d: Hilbert space dimension.
    :return: Second moment operator of shape ``(d^2, d^2)``.
    """
    M = np.zeros((d**2, d**2), dtype=complex)
    for psi in states:
        rho = np.outer(psi, psi.conj())
        M  += np.kron(rho, rho)
    return M / len(states)


def haar_moment(d: int) -> np.ndarray:
    r"""Return the exact Haar second moment :math:`\Pi_{\mathrm{sym}} / \binom{d+1}{2}`.

    Examples
    ========

    >>> import numpy as np
    >>> H = haar_moment(2)
    >>> H.shape
    (4, 4)

    :param d: Hilbert space dimension.
    :return: Haar second moment of shape ``(d^2, d^2)``.
    """
    Pi = np.zeros((d**2, d**2), dtype=complex)
    e  = np.eye(d)
    for i in range(d):
        for j in range(d):
            eij = np.kron(e[i], e[j]); eji = np.kron(e[j], e[i])
            Pi += np.outer(eij, eij) + np.outer(eij, eji)
    return (Pi / 2) / comb(d + 1, 2)


# State reconstruction 
def sic_reconstruct(p: np.ndarray, states: list[np.ndarray], d: int) -> np.ndarray:
    r"""Reconstruct a density matrix from SIC-POVM measurement probabilities.

    Uses the closed-form inversion :footcite:p:`fuchs2004quantum`:

    .. math::

        \rho = \sum_{i=1}^{d^2} \left[(d+1)\,p_i - \frac{1}{d}\right]
               |\psi_i\rangle\langle\psi_i|.

    Examples
    ========

    >>> import numpy as np
    >>> np.random.seed(0)
    >>> A = np.random.randn(2, 2) + 1j * np.random.randn(2, 2)
    >>> rho = A @ A.conj().T; rho /= np.trace(rho)
    >>> sic2 = sic_povm_d2()
    >>> povm2 = build_povm(sic2, d=2)
    >>> p = np.array([np.trace(M @ rho).real for M in povm2])
    >>> np.linalg.norm(rho - sic_reconstruct(p, sic2, d=2)) < 1e-10
    True

    References
    ==========

    .. footbibliography::

    :param p: Measurement probability vector of length :math:`d^2`.
    :param states: SIC-POVM state vectors.
    :param d: Hilbert space dimension.
    :return: Reconstructed density matrix.
    """
    return sum(((d+1)*p[i] - 1/d) * np.outer(states[i], states[i].conj())
               for i in range(len(states)))
