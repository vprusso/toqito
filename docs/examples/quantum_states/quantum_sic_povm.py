"""Tutorial on SIC-POVMs: geometry, design structure, and quantum state discrimination.

A **Symmetric Informationally Complete Positive Operator-Valued Measure** (SIC-POVM) in
dimension :math:`d` is a set of :math:`d^2` unit vectors
:math:`\\{|\\psi_i\\rangle\\}_{i=1}^{d^2} \\subset \\mathbb{C}^d` satisfying the uniform
overlap condition :footcite:p:`renes2004symmetric`:

.. math::

    |\\langle \\psi_i | \\psi_j \\rangle|^2 = \\frac{1}{d+1}, \\quad \\forall\\, i \\neq j.

The POVM elements :math:`M_i = \\frac{1}{d}|\\psi_i\\rangle\\langle\\psi_i|` sum to the
identity, making SIC-POVMs both valid measurements and *informationally complete* — any
quantum state can be reconstructed from the resulting statistics.

SIC-POVMs are *projective 2-designs*: finite
constellations that exactly replicate Haar-random second-order integration
:footcite:p:`scott2006tight`. This tutorial explores both aspects using :code:`toqito`.

Constructing SIC-POVMs
----------------------

The :math:`d=2` SIC-POVM consists of four states whose Bloch vectors are the vertices of a
regular tetrahedron. The :math:`d=3` SIC-POVM (Hesse SIC) is generated by applying the nine
Weyl-Heisenberg displacement operators :math:`D_{jk} = \\tau^{jk} X^j Z^k` to a single
fiducial state :footcite:p:`appleby2005sicpovms`.

Bloch Sphere Visualization
---------------------------

The four :math:`d=2` SIC-POVM states have Bloch vectors
:math:`\\vec{r}_i = (\\langle\\sigma_x\\rangle, \\langle\\sigma_y\\rangle,
\\langle\\sigma_z\\rangle)` pointing to the vertices of a regular tetrahedron inscribed in
the unit sphere.

Gram Matrix
-----------

The Gram matrix :math:`G_{ij} = |\\langle\\psi_i|\\psi_j\\rangle|^2` has a constant
off-diagonal value — the defining visual signature of the SIC structure.

Design Geometry
---------------

A SIC-POVM is a *projective 2-design*: its order-2 frame potential

.. math::

    \\Phi^{(2)} = \\sum_{i,j} |\\langle\\psi_i|\\psi_j\\rangle|^{4}

saturates the theoretical minimum :math:`N^2 / \\binom{d+1}{2}`. All pairwise overlaps
collapse to a single spike at :math:`1/(d+1)`, and the second moment operator matches the
Haar integral :math:`\\Pi_{\\mathrm{sym}} / \\binom{d+1}{2}` to numerical precision.

Quantum State Discrimination
-----------------------------

For equal priors the analytic minimum-error success probability is
:footcite:p:`barnett2009quantum`:

.. math::

    P_{\\mathrm{succ}} = \\frac{2}{d(d+1)}.

:func:`toqito.state_opt.state_distinguishability` reproduces this exactly. State *exclusion*
— identifying which state was definitely *not* prepared — is computed via
:func:`toqito.state_opt.state_exclusion`. The formula above also shows that discrimination
becomes harder in higher dimensions as :math:`P_{\\mathrm{succ}}` decreases.

Weyl-Heisenberg Group Structure
---------------------------------

The displacement operators :math:`D_{jk} = \\tau^{jk} X^j Z^k` satisfy
:math:`\\mathrm{Tr}(D_{jk}^\\dagger D_{j'k'}) = d\\,\\delta_{jj'}\\delta_{kk'}`, forming
an orthonormal operator basis for :math:`\\mathcal{L}(\\mathbb{C}^d)`.

Informational Completeness
---------------------------

Any quantum state :math:`\\rho` can be recovered from SIC-POVM statistics
:math:`p_i = \\mathrm{Tr}(M_i\\rho)` via :footcite:p:`fuchs2004quantum`:

.. math::

    \\rho = \\sum_{i=1}^{d^2} \\left[(d+1)\\,p_i - \\frac{1}{d}\\right]
            |\\psi_i\\rangle\\langle\\psi_i|.

The :math:`d^2` rank-1 operators :math:`\\{|\\psi_i\\rangle\\langle\\psi_i|\\}` span the
full :math:`d^2`-dimensional space of Hermitian matrices, which can be verified by computing
the rank of the frame.

References
----------

.. footbibliography::
"""
import numpy as np
import matplotlib.pyplot as plt
from itertools import combinations
from math import comb

from toqito.states import trine
from toqito.state_opt import state_distinguishability, state_exclusion


# SIC state constructors

def sic_povm_d2() -> list[np.ndarray]:
    r"""Return the four d=2 SIC-POVM states (tetrahedral states on the Bloch sphere).

    These states satisfy :math:`|\langle\psi_i|\psi_j\rangle|^2 = 1/3` for all
    :math:`i \neq j` :footcite:p:`renes2004symmetric`.

    Examples
    ========

    >>> import numpy as np
    >>> from itertools import combinations
    >>> sic2 = sic_povm_d2()
    >>> all(np.isclose(abs(np.vdot(sic2[i], sic2[j]))**2, 1/3) for i, j in combinations(range(4), 2))
    True

    References
    ==========

    .. footbibliography::

    :return: List of four unit vectors in :math:`\mathbb{C}^2`.
    """
    psi_0 = np.array([1, 0], dtype=complex)
    psi_1 = np.array([1/np.sqrt(3), np.sqrt(2/3)], dtype=complex)
    psi_2 = np.array([1/np.sqrt(3), np.sqrt(2/3) * np.exp(1j * 2*np.pi/3)], dtype=complex)
    psi_3 = np.array([1/np.sqrt(3), np.sqrt(2/3) * np.exp(1j * 4*np.pi/3)], dtype=complex)
    return [psi_0, psi_1, psi_2, psi_3]


def sic_povm_d3() -> list[np.ndarray]:
    r"""Return the nine d=3 SIC-POVM states via the Weyl-Heisenberg group orbit.

    The Hesse SIC is generated as :math:`|\psi_{jk}\rangle = D_{jk}|\psi_0\rangle` where
    :math:`D_{jk} = \tau^{jk}X^jZ^k` :footcite:p:`appleby2005sicpovms`.

    Examples
    ========

    >>> import numpy as np
    >>> from itertools import combinations
    >>> sic3 = sic_povm_d3()
    >>> overlaps = [abs(np.vdot(sic3[i], sic3[j]))**2 for i, j in combinations(range(9), 2)]
    >>> np.allclose(overlaps, 0.25, atol=1e-8)
    True

    References
    ==========

    .. footbibliography::

    :return: List of nine unit vectors in :math:`\mathbb{C}^3`.
    """
    d = 3
    omega, tau = np.exp(2j * np.pi / d), np.exp(1j * np.pi / d)
    X = np.roll(np.eye(d), -1, axis=0)
    Z = np.diag([omega**m for m in range(d)])
    fiducial = np.array([0, 1, -np.exp(1j * np.arctan(np.sqrt(2)))], dtype=complex)
    fiducial /= np.linalg.norm(fiducial)
    return [
        tau**(j*k) * (np.linalg.matrix_power(X, j) @ np.linalg.matrix_power(Z, k)) @ fiducial
        for j in range(d) for k in range(d)
    ]


#  POVM helpers

def build_povm(states: list[np.ndarray], d: int) -> list[np.ndarray]:
    r"""Build the POVM elements :math:`M_i = \frac{1}{d}|\psi_i\rangle\langle\psi_i|`.

    Examples
    ========

    >>> import numpy as np
    >>> povm2 = build_povm(sic_povm_d2(), d=2)
    >>> np.linalg.norm(sum(povm2) - np.eye(2)) < 1e-10
    True

    :param states: List of unit vectors.
    :param d: Hilbert space dimension.
    :return: List of POVM matrices.
    """
    return [np.outer(psi, psi.conj()) / d for psi in states]


#  Bloch sphere 

def state_to_bloch(psi: np.ndarray) -> np.ndarray:
    r"""Convert a qubit pure state to its Bloch vector :math:`(r_x, r_y, r_z)`.

    The Bloch vector is :math:`r_k = \langle\psi|\sigma_k|\psi\rangle` where
    :math:`\sigma_x, \sigma_y, \sigma_z` are the Pauli matrices.

    Examples
    ========

    >>> import numpy as np
    >>> r = state_to_bloch(np.array([1, 0], dtype=complex))
    >>> np.allclose(r, [0, 0, 1])
    True

    :param psi: Unit vector in :math:`\mathbb{C}^2`.
    :return: Bloch vector of length 3.
    """
    rho = np.outer(psi, psi.conj())
    sx = np.array([[0, 1],  [1,  0]], dtype=complex)
    sy = np.array([[0, -1j],[1j, 0]], dtype=complex)
    sz = np.array([[1, 0],  [0, -1]], dtype=complex)
    return np.array([np.trace(rho @ s).real for s in [sx, sy, sz]])


def plot_bloch_sphere(states: list[np.ndarray]) -> None:
    r"""Plot the Bloch sphere with the d=2 SIC-POVM states as a tetrahedron.

    :param states: List of four qubit unit vectors forming the d=2 SIC-POVM.
    """
    bloch_vecs = [state_to_bloch(psi) for psi in states]

    fig = plt.figure(figsize=(7, 7))
    ax  = fig.add_subplot(111, projection="3d")

    u = np.linspace(0, 2*np.pi, 30)
    v = np.linspace(0, np.pi, 20)
    ax.plot_wireframe(np.outer(np.cos(u), np.sin(v)),
                      np.outer(np.sin(u), np.sin(v)),
                      np.outer(np.ones(30), np.cos(v)),
                      color="lightgray", alpha=0.2, linewidth=0.5)

    colors = ["#E63946", "#457B9D", "#2A9D8F", "#E9C46A"]
    labels = [r"$|\psi_0\rangle$", r"$|\psi_1\rangle$",
              r"$|\psi_2\rangle$", r"$|\psi_3\rangle$"]

    for bv, col, lab in zip(bloch_vecs, colors, labels):
        ax.scatter(*bv, color=col, s=120, zorder=5, label=lab)
        ax.quiver(0, 0, 0, *bv, color=col, alpha=0.7, arrow_length_ratio=0.1)
        ax.text(*(bv * 1.12), lab, fontsize=11, ha="center")

    for i, j in combinations(range(4), 2):
        pts = np.array([bloch_vecs[i], bloch_vecs[j]]).T
        ax.plot(*pts, "k--", alpha=0.3, linewidth=1)

    for vec, lbl in [([1.3,0,0],"x"), ([0,1.3,0],"y"), ([0,0,1.3],"z")]:
        ax.quiver(0, 0, 0, *vec, color="black", alpha=0.5, arrow_length_ratio=0.08)
        ax.text(*[v*1.05 for v in vec], lbl, fontsize=10)

    ax.set_xlim(-1.2, 1.2); ax.set_ylim(-1.2, 1.2); ax.set_zlim(-1.2, 1.2)
    ax.set_title("d=2 SIC-POVM: Tetrahedron on the Bloch Sphere", fontsize=12, pad=15)
    ax.legend(loc="upper left", fontsize=9)
    ax.set_box_aspect([1, 1, 1])
    plt.tight_layout()
    plt.show()


# Gram matrix 

def gram_matrix(states: list[np.ndarray]) -> np.ndarray:
    r"""Compute the Gram matrix :math:`G_{ij} = |\langle\psi_i|\psi_j\rangle|^2`.

    For a SIC-POVM every off-diagonal entry equals :math:`1/(d+1)`.

    Examples
    ========

    >>> import numpy as np
    >>> G = gram_matrix(sic_povm_d2())
    >>> np.allclose(G - np.diag(np.diag(G)), 1/3)
    True

    :param states: List of unit vectors.
    :return: Real-valued Gram matrix of shape ``(N, N)``.
    """
    n = len(states)
    return np.array([[abs(np.vdot(states[i], states[j]))**2
                      for j in range(n)] for i in range(n)])


#  Design geometry 

def frame_potential(states: list[np.ndarray]) -> float:
    r"""Compute the order-2 frame potential :math:`\Phi^{(2)} = \sum_{i,j}|\langle\psi_i|\psi_j\rangle|^4`.

    A set of :math:`N` states in :math:`\mathbb{C}^d` is a projective 2-design iff this
    equals :math:`N^2 / \binom{d+1}{2}` :footcite:p:`scott2006tight`.

    Examples
    ========

    >>> from math import comb
    >>> sic2 = sic_povm_d2()
    >>> abs(frame_potential(sic2) - 4**2 / comb(3, 2)) < 1e-10
    True

    References
    ==========

    .. footbibliography::

    :param states: List of unit vectors.
    :return: Frame potential value.
    """
    return sum(abs(np.vdot(a, b))**4 for a in states for b in states)


def moment_operator(states: list[np.ndarray], d: int) -> np.ndarray:
    r"""Compute the second moment operator :math:`\frac{1}{N}\sum_i(|\psi_i\rangle\langle\psi_i|)^{\otimes 2}`.

    A set is a projective 2-design iff this equals :math:`\Pi_{\mathrm{sym}}/\binom{d+1}{2}`
    :footcite:p:`scott2006tight`.

    Examples
    ========

    >>> import numpy as np
    >>> err = np.linalg.norm(moment_operator(sic_povm_d2(), 2) - haar_moment(2), "fro")
    >>> err < 1e-10
    True

    References
    ==========

    .. footbibliography::

    :param states: List of unit vectors.
    :param d: Hilbert space dimension.
    :return: Second moment operator of shape ``(d^2, d^2)``.
    """
    M = np.zeros((d**2, d**2), dtype=complex)
    for psi in states:
        rho = np.outer(psi, psi.conj())
        M  += np.kron(rho, rho)
    return M / len(states)


def haar_moment(d: int) -> np.ndarray:
    r"""Return the exact Haar second moment :math:`\Pi_{\mathrm{sym}} / \binom{d+1}{2}`.

    Examples
    ========

    >>> import numpy as np
    >>> H = haar_moment(2)
    >>> H.shape
    (4, 4)

    :param d: Hilbert space dimension.
    :return: Haar second moment of shape ``(d^2, d^2)``.
    """
    Pi = np.zeros((d**2, d**2), dtype=complex)
    e  = np.eye(d)
    for i in range(d):
        for j in range(d):
            eij = np.kron(e[i], e[j]); eji = np.kron(e[j], e[i])
            Pi += np.outer(eij, eij) + np.outer(eij, eji)
    return (Pi / 2) / comb(d + 1, 2)


# Quantum state discrimination 

def sic_discrimination(states: list[np.ndarray], d: int) -> tuple[float, float]:
    r"""Compute the optimal min-error discrimination probability for SIC-POVM states.

    For equal priors the analytic result is :math:`P_{\mathrm{succ}} = 2/[d(d+1)]`
    :footcite:p:`barnett2009quantum`. This function returns both the
    :func:`toqito.state_opt.state_distinguishability` value and the analytic bound.

    Examples
    ========

    >>> import numpy as np
    >>> val, ana = sic_discrimination(sic_povm_d2(), d=2)
    >>> np.isclose(val, ana, atol=1e-4)
    True

    References
    ==========

    .. footbibliography::

    :param states: List of SIC-POVM unit vectors.
    :param d: Hilbert space dimension.
    :return: Tuple of ``(toqito_value, analytic_value)``.
    """
    rhos = [np.outer(psi, psi.conj()) for psi in states]
    n    = len(rhos)
    val, _ = state_distinguishability(rhos, [1/n] * n)
    return val, 2 / (d * (d + 1))


def sic_exclusion(states: list[np.ndarray]) -> float:
    r"""Compute the optimal state-exclusion probability for SIC-POVM states.

    State exclusion asks: given a prepared state, which element was *not* the one
    prepared? It is computed via :func:`toqito.state_opt.state_exclusion`.

    Examples
    ========

    >>> sic2 = sic_povm_d2()
    >>> p_excl = sic_exclusion(sic2)
    >>> 0.0 <= p_excl <= 1.0
    True

    :param states: List of SIC-POVM unit vectors.
    :return: Optimal exclusion success probability.
    """
    rhos = [np.outer(psi, psi.conj()) for psi in states]
    n    = len(rhos)
    val, _ = state_exclusion(rhos, [1/n] * n)
    return val


def plot_discrimination_scaling() -> None:
    r"""Plot :math:`P_{\mathrm{succ}} = 2/[d(d+1)]` vs. random guessing :math:`1/d^2`.

    Illustrates that SIC-POVM state discrimination becomes harder with dimension,
    while remaining a fixed multiple above random chance.
    """
    dims     = range(2, 9)
    p_sic    = [2 / (d * (d + 1)) for d in dims]
    p_random = [1 / d**2          for d in dims]

    fig, ax = plt.subplots(figsize=(7, 4))
    ax.plot(dims, p_sic,    "o-",  color="#E63946", linewidth=2, markersize=8,
            label=r"SIC optimal: $\frac{2}{d(d+1)}$")
    ax.plot(dims, p_random, "s--", color="#457B9D", linewidth=2, markersize=8,
            label=r"Random guess: $\frac{1}{d^2}$")
    ax.set_xlabel("Dimension d", fontsize=12)
    ax.set_ylabel("Success probability", fontsize=12)
    ax.set_title("SIC-POVM Min-Error Discrimination vs. Dimension", fontsize=12)
    ax.legend(fontsize=11)
    ax.grid(True, alpha=0.3)
    ax.set_xticks(list(dims))
    plt.tight_layout()
    plt.show()


def mub_states_d2() -> list[np.ndarray]:
    r"""Return the six MUB states in d=2 (eigenstates of the three Pauli operators).

    Examples
    ========

    >>> import numpy as np
    >>> mubs = mub_states_d2()
    >>> len(mubs)
    6

    :return: List of six unit vectors in :math:`\mathbb{C}^2`.
    """
    return [
        np.array([1,  0],  dtype=complex),
        np.array([0,  1],  dtype=complex),
        np.array([1,  1],  dtype=complex) / np.sqrt(2),
        np.array([1, -1],  dtype=complex) / np.sqrt(2),
        np.array([1,  1j], dtype=complex) / np.sqrt(2),
        np.array([1, -1j], dtype=complex) / np.sqrt(2),
    ]


#  Weyl-Heisenberg group 

def displacement_operators(d: int) -> list[tuple[int, int, np.ndarray]]:
    r"""Return all :math:`d^2` Weyl-Heisenberg displacement operators for dimension d.

    Each operator is :math:`D_{jk} = \tau^{jk} X^j Z^k` where
    :math:`\tau = e^{i\pi/d}`, :math:`X|m\rangle = |m{+}1 \bmod d\rangle`, and
    :math:`Z|m\rangle = \omega^m|m\rangle` with :math:`\omega = e^{2\pi i/d}`.

    The operators satisfy :math:`\mathrm{Tr}(D_{jk}^\dagger D_{j'k'}) = d\,\delta_{jj'}\delta_{kk'}`.

    Examples
    ========

    >>> import numpy as np
    >>> disps = displacement_operators(3)
    >>> len(disps)
    9
    >>> all(np.allclose(D @ D.conj().T, np.eye(3)) for _, _, D in disps)
    True

    :param d: Hilbert space dimension.
    :return: List of ``(j, k, D_jk)`` tuples.
    """
    omega, tau = np.exp(2j * np.pi / d), np.exp(1j * np.pi / d)
    X = np.roll(np.eye(d), -1, axis=0)
    Z = np.diag([omega**m for m in range(d)])
    return [
        (j, k, tau**(j*k) * (np.linalg.matrix_power(X, j) @ np.linalg.matrix_power(Z, k)))
        for j in range(d) for k in range(d)
    ]


# Informational completeness 

def frame_operator_rank(states: list[np.ndarray], d: int) -> int:
    r"""Return the spanning rank of :math:`\{|\psi_i\rangle\langle\psi_i|\}` in operator space.

    A SIC-POVM is informationally complete iff this rank equals :math:`d^2`, i.e. the
    :math:`d^2` rank-1 operators span the full space of :math:`d\times d` Hermitian matrices.

    Examples
    ========

    >>> frame_operator_rank(sic_povm_d2(), d=2)
    4
    >>> frame_operator_rank(sic_povm_d3(), d=3)
    9

    :param states: List of unit vectors.
    :param d: Hilbert space dimension.
    :return: Rank of the frame, equal to :math:`d^2` iff informationally complete.
    """
    M = np.array([np.outer(psi, psi.conj()).ravel() for psi in states])
    return np.linalg.matrix_rank(M, tol=1e-8)


def sic_reconstruct(p: np.ndarray, states: list[np.ndarray], d: int) -> np.ndarray:
    r"""Reconstruct a density matrix from SIC-POVM measurement probabilities.

    Uses the closed-form inversion :footcite:p:`fuchs2004quantum`:

    .. math::

        \rho = \sum_{i=1}^{d^2} \left[(d+1)\,p_i - \frac{1}{d}\right]
               |\psi_i\rangle\langle\psi_i|.

    Examples
    ========

    >>> import numpy as np
    >>> np.random.seed(0)
    >>> A = np.random.randn(2, 2) + 1j * np.random.randn(2, 2)
    >>> rho = A @ A.conj().T; rho /= np.trace(rho)
    >>> sic2 = sic_povm_d2()
    >>> povm2 = build_povm(sic2, d=2)
    >>> p = np.array([np.trace(M @ rho).real for M in povm2])
    >>> np.linalg.norm(rho - sic_reconstruct(p, sic2, d=2)) < 1e-10
    True

    References
    ==========

    .. footbibliography::

    :param p: Measurement probability vector of length :math:`d^2`.
    :param states: SIC-POVM state vectors.
    :param d: Hilbert space dimension.
    :return: Reconstructed density matrix.
    """
    return sum(((d+1)*p[i] - 1/d) * np.outer(states[i], states[i].conj())
               for i in range(len(states)))
