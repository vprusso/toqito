"""Tutorial on SIC-POVMs: geometry, design structure, and quantum state discrimination.

A **Symmetric Informationally Complete Positive Operator-Valued Measure** (SIC-POVM) in
dimension :math:`d` is a set of :math:`d^2` unit vectors
:math:`\\{|\\psi_i\\rangle\\}_{i=1}^{d^2} \\subset \\mathbb{C}^d` satisfying the uniform
overlap condition :footcite:p:`renes2004symmetric`:

.. math::

    |\\langle \\psi_i | \\psi_j \\rangle|^2 = \\frac{1}{d+1}, \\quad \\forall\\, i \\neq j.

The POVM elements :math:`M_i = \\frac{1}{d}|\\psi_i\\rangle\\langle\\psi_i|` sum to the
identity, making SIC-POVMs both valid measurements and *informationally complete* — any
quantum state can be reconstructed from the resulting statistics.

SIC-POVMs are *projective 2-designs*: finite constellations that exactly replicate
Haar-random second-order integration :footcite:p:`scott2006tight`. This tutorial explores
both aspects using :code:`toqito`.

Constructing SIC-POVMs
----------------------

The :math:`d=2` SIC-POVM consists of four states whose Bloch vectors are the vertices of a
regular tetrahedron. The :math:`d=3` SIC-POVM (Hesse SIC) is generated by applying the nine
Weyl-Heisenberg displacement operators :math:`D_{jk} = \\tau^{jk} X^j Z^k` to a single
fiducial state :footcite:p:`appleby2005sicpovms`. The :math:`X^j Z^k` factors are produced
directly by :func:`toqito.matrices.gen_pauli`.

Bloch Sphere Visualization
---------------------------

The four :math:`d=2` SIC-POVM states have Bloch vectors
:math:`\\vec{r}_i = (\\langle\\sigma_x\\rangle, \\langle\\sigma_y\\rangle,
\\langle\\sigma_z\\rangle)` pointing to the vertices of a regular tetrahedron inscribed in
the unit sphere.

Gram Matrix
-----------

The Gram matrix :math:`G_{ij} = |\\langle\\psi_i|\\psi_j\\rangle|^2` has a constant
off-diagonal value — the defining visual signature of the SIC structure.
It is computed with :func:`toqito.matrix_ops.vectors_to_gram_matrix`, taking the
element-wise squared modulus of the returned complex inner-product matrix.

Design Geometry
---------------

A SIC-POVM is a *projective 2-design*: its order-2 frame potential

.. math::

    \\Phi^{(2)} = \\sum_{i,j} |\\langle\\psi_i|\\psi_j\\rangle|^{4}

saturates the theoretical minimum :math:`N^2 / \\binom{d+1}{2}`. All pairwise overlaps
collapse to a single spike at :math:`1/(d+1)`, and the second moment operator matches the
Haar integral :math:`\\Pi_{\\mathrm{sym}} / \\binom{d+1}{2}` to numerical precision.

Quantum State Discrimination
-----------------------------

For equal priors the analytic minimum-error success probability is
:footcite:p:`barnett2009quantum`:

.. math::

    P_{\\mathrm{succ}} = \\frac{2}{d(d+1)}.

:func:`toqito.state_opt.state_distinguishability` computes this directly. State *exclusion*
— identifying which state was definitely *not* prepared — is handled by
:func:`toqito.state_opt.state_exclusion`. Both are called directly in
:func:`demonstrate_discrimination`.

Weyl-Heisenberg Group Structure
---------------------------------

The displacement operators :math:`D_{jk} = \\tau^{jk} X^j Z^k` (discrete Weyl operators)
have their :math:`X^j Z^k` factor generated by :func:`toqito.matrices.gen_pauli`. They
satisfy :math:`\\mathrm{Tr}(D_{jk}^\\dagger D_{j'k'}) = d\\,\\delta_{jj'}\\delta_{kk'}`,
forming an orthonormal operator basis for :math:`\\mathcal{L}(\\mathbb{C}^d)`.

Mutually Unbiased Bases
-----------------------

:func:`toqito.states.mutually_unbiased_basis` generates the :math:`d+1` MUBs for prime
(or prime-power) dimensions directly. The six :math:`d=2` MUB vectors are the eigenstates
of the three Pauli operators.

Informational Completeness
---------------------------

Any quantum state :math:`\\rho` can be recovered from SIC-POVM statistics
:math:`p_i = \\mathrm{Tr}(M_i\\rho)` via :footcite:p:`fuchs2004quantum`:

.. math::

    \\rho = \\sum_{i=1}^{d^2} \\left[(d+1)\\,p_i - \\frac{1}{d}\\right]
            |\\psi_i\\rangle\\langle\\psi_i|.

The :math:`d^2` rank-1 operators :math:`\\{|\\psi_i\\rangle\\langle\\psi_i|\\}` span the
full :math:`d^2`-dimensional space of Hermitian matrices, which can be verified by computing
the rank of the frame.

References
----------

.. footbibliography::
"""
import numpy as np
import matplotlib.pyplot as plt
from itertools import combinations
from math import comb

from toqito.state_opt import state_distinguishability, state_exclusion
from toqito.matrix_ops import vectors_to_gram_matrix
from toqito.matrices import gen_pauli
from toqito.states import mutually_unbiased_basis


# 
# SIC state constructors
# 

def sic_povm_d2() -> list[np.ndarray]:
    r"""Return the four d=2 SIC-POVM states (tetrahedral states on the Bloch sphere).

    These states satisfy :math:`|\langle\psi_i|\psi_j\rangle|^2 = 1/3` for all
    :math:`i \neq j` :footcite:p:`renes2004symmetric`.

    Examples
    ========

    >>> import numpy as np
    >>> from itertools import combinations
    >>> sic2 = sic_povm_d2()
    >>> all(np.isclose(abs(np.vdot(sic2[i], sic2[j]))**2, 1/3) for i, j in combinations(range(4), 2))
    True

    References
    ==========

    .. footbibliography::

    :return: List of four unit vectors in :math:`\mathbb{C}^2`.
    """
    psi_0 = np.array([1, 0], dtype=complex)
    psi_1 = np.array([1/np.sqrt(3), np.sqrt(2/3)], dtype=complex)
    psi_2 = np.array([1/np.sqrt(3), np.sqrt(2/3) * np.exp(1j * 2*np.pi/3)], dtype=complex)
    psi_3 = np.array([1/np.sqrt(3), np.sqrt(2/3) * np.exp(1j * 4*np.pi/3)], dtype=complex)
    return [psi_0, psi_1, psi_2, psi_3]


def sic_povm_d3() -> list[np.ndarray]:
    r"""Return the nine d=3 SIC-POVM states via the Weyl-Heisenberg group orbit.

    The Hesse SIC is generated as :math:`|\psi_{jk}\rangle = D_{jk}|\psi_0\rangle` where
    :math:`D_{jk} = \tau^{jk}X^jZ^k`. The :math:`X^jZ^k` factor is produced directly by
    :func:`toqito.matrices.gen_pauli` :footcite:p:`appleby2005sicpovms`.

    Examples
    ========

    >>> import numpy as np
    >>> from itertools import combinations
    >>> sic3 = sic_povm_d3()
    >>> overlaps = [abs(np.vdot(sic3[i], sic3[j]))**2 for i, j in combinations(range(9), 2)]
    >>> np.allclose(overlaps, 0.25, atol=1e-8)
    True

    References
    ==========

    .. footbibliography::

    :return: List of nine unit vectors in :math:`\mathbb{C}^3`.
    """
    d = 3
    tau = np.exp(1j * np.pi / d)
    fiducial = np.array([0, 1, -np.exp(1j * np.arctan(np.sqrt(2)))], dtype=complex)
    fiducial /= np.linalg.norm(fiducial)
    # gen_pauli(j, k, d) produces X^j Z^k — the discrete Weyl / generalised Pauli operator.
    return [
        tau**(j*k) * gen_pauli(j, k, d) @ fiducial
        for j in range(d) for k in range(d)
    ]


# 
# POVM helpers
# 

def build_povm(states: list[np.ndarray], d: int) -> list[np.ndarray]:
    r"""Build the POVM elements :math:`M_i = \frac{1}{d}|\psi_i\rangle\langle\psi_i|`.

    Examples
    ========

    >>> import numpy as np
    >>> povm2 = build_povm(sic_povm_d2(), d=2)
    >>> np.linalg.norm(sum(povm2) - np.eye(2)) < 1e-10
    True

    :param states: List of unit vectors.
    :param d: Hilbert space dimension.
    :return: List of POVM matrices.
    """
    return [np.outer(psi, psi.conj()) / d for psi in states]


# 
# Bloch sphere
# 

def state_to_bloch(psi: np.ndarray) -> np.ndarray:
    r"""Convert a qubit pure state to its Bloch vector :math:`(r_x, r_y, r_z)`.

    The Bloch vector is :math:`r_k = \langle\psi|\sigma_k|\psi\rangle` where
    :math:`\sigma_x, \sigma_y, \sigma_z` are the Pauli matrices.

    Examples
    ========

    >>> import numpy as np
    >>> r = state_to_bloch(np.array([1, 0], dtype=complex))
    >>> np.allclose(r, [0, 0, 1])
    True

    :param psi: Unit vector in :math:`\mathbb{C}^2`.
    :return: Bloch vector of length 3.
    """
    rho = np.outer(psi, psi.conj())
    sx = np.array([[0, 1],  [1,  0]], dtype=complex)
    sy = np.array([[0, -1j],[1j, 0]], dtype=complex)
    sz = np.array([[1, 0],  [0, -1]], dtype=complex)
    return np.array([np.trace(rho @ s).real for s in [sx, sy, sz]])


def plot_bloch_sphere(states: list[np.ndarray]) -> None:
    r"""Plot the Bloch sphere with the d=2 SIC-POVM states as a tetrahedron.

    :param states: List of four qubit unit vectors forming the d=2 SIC-POVM.
    """
    bloch_vecs = [state_to_bloch(psi) for psi in states]

    fig = plt.figure(figsize=(7, 7))
    ax  = fig.add_subplot(111, projection="3d")

    u = np.linspace(0, 2*np.pi, 30)
    v = np.linspace(0, np.pi, 20)
    ax.plot_wireframe(np.outer(np.cos(u), np.sin(v)),
                      np.outer(np.sin(u), np.sin(v)),
                      np.outer(np.ones(30), np.cos(v)),
                      color="lightgray", alpha=0.2, linewidth=0.5)

    colors = ["#E63946", "#457B9D", "#2A9D8F", "#E9C46A"]
    labels = [r"$|\psi_0\rangle$", r"$|\psi_1\rangle$",
              r"$|\psi_2\rangle$", r"$|\psi_3\rangle$"]

    for bv, col, lab in zip(bloch_vecs, colors, labels):
        ax.scatter(*bv, color=col, s=120, zorder=5, label=lab)
        ax.quiver(0, 0, 0, *bv, color=col, alpha=0.7, arrow_length_ratio=0.1)
        ax.text(*(bv * 1.12), lab, fontsize=11, ha="center")

    for i, j in combinations(range(4), 2):
        pts = np.array([bloch_vecs[i], bloch_vecs[j]]).T
        ax.plot(*pts, "k--", alpha=0.3, linewidth=1)

    for vec, lbl in [([1.3, 0, 0], "x"), ([0, 1.3, 0], "y"), ([0, 0, 1.3], "z")]:
        ax.quiver(0, 0, 0, *vec, color="black", alpha=0.5, arrow_length_ratio=0.08)
        ax.text(*[v*1.05 for v in vec], lbl, fontsize=10)

    ax.set_xlim(-1.2, 1.2); ax.set_ylim(-1.2, 1.2); ax.set_zlim(-1.2, 1.2)
    ax.set_title("d=2 SIC-POVM: Tetrahedron on the Bloch Sphere", fontsize=12, pad=15)
    ax.legend(loc="upper left", fontsize=9)
    ax.set_box_aspect([1, 1, 1])
    plt.tight_layout()
    plt.show()


# 
# Gram matrix 
# 

def plot_gram_matrix(states: list[np.ndarray], title: str = "SIC-POVM Gram Matrix") -> None:
    r"""Plot the overlap-squared Gram matrix :math:`G_{ij} = |\langle\psi_i|\psi_j\rangle|^2`.

    Uses :func:`toqito.matrix_ops.vectors_to_gram_matrix` to compute the complex
    inner-product matrix; the element-wise squared modulus gives the overlap-squared
    form whose constant off-diagonal value is the defining signature of the SIC structure.

    Examples
    ========

    >>> import numpy as np
    >>> from toqito.matrix_ops import vectors_to_gram_matrix
    >>> G = np.abs(vectors_to_gram_matrix(sic_povm_d2()))**2
    >>> np.allclose(G - np.diag(np.diag(G)), 1/3)
    True

    :param states: List of unit vectors.
    :param title: Plot title.
    """
    # vectors_to_gram_matrix returns G[i,j] = <psi_i|psi_j>; |.|^2 gives overlap-squared.
    G = np.abs(vectors_to_gram_matrix(states))**2

    fig, ax = plt.subplots(figsize=(5, 4))
    im = ax.imshow(G, vmin=0, vmax=1, cmap="Blues")
    plt.colorbar(im, ax=ax)
    ax.set_title(title, fontsize=12)
    ax.set_xlabel("State index j")
    ax.set_ylabel("State index i")
    plt.tight_layout()
    plt.show()


# 
# Design geometry
# 

def frame_potential(states: list[np.ndarray]) -> float:
    r"""Compute the order-2 frame potential :math:`\Phi^{(2)} = \sum_{i,j}|\langle\psi_i|\psi_j\rangle|^4`.

    A set of :math:`N` states in :math:`\mathbb{C}^d` is a projective 2-design iff this
    equals :math:`N^2 / \binom{d+1}{2}` :footcite:p:`scott2006tight`.

    Uses :func:`toqito.matrix_ops.vectors_to_gram_matrix` to obtain all pairwise overlaps
    in a single vectorised call.

    Examples
    ========

    >>> from math import comb
    >>> sic2 = sic_povm_d2()
    >>> abs(frame_potential(sic2) - 4**2 / comb(3, 2)) < 1e-10
    True

    References
    ==========

    .. footbibliography::

    :param states: List of unit vectors.
    :return: Frame potential value.
    """
    # vectors_to_gram_matrix gives <psi_i|psi_j>; |.|^2 → overlap-squared, then sum |.|^4.
    G = np.abs(vectors_to_gram_matrix(states))**2
    return float(np.sum(G**2))


def moment_operator(states: list[np.ndarray], d: int) -> np.ndarray:
    r"""Compute the second moment operator :math:`\frac{1}{N}\sum_i(|\psi_i\rangle\langle\psi_i|)^{\otimes 2}`.

    A set is a projective 2-design iff this equals :math:`\Pi_{\mathrm{sym}}/\binom{d+1}{2}`
    :footcite:p:`scott2006tight`.

    Examples
    ========

    >>> import numpy as np
    >>> err = np.linalg.norm(moment_operator(sic_povm_d2(), 2) - haar_moment(2), "fro")
    >>> err < 1e-10
    True

    References
    ==========

    .. footbibliography::

    :param states: List of unit vectors.
    :param d: Hilbert space dimension.
    :return: Second moment operator of shape ``(d^2, d^2)``.
    """
    M = np.zeros((d**2, d**2), dtype=complex)
    for psi in states:
        rho = np.outer(psi, psi.conj())
        M += np.kron(rho, rho)
    return M / len(states)


def haar_moment(d: int) -> np.ndarray:
    r"""Return the exact Haar second moment :math:`\Pi_{\mathrm{sym}} / \binom{d+1}{2}`.

    Examples
    ========

    >>> import numpy as np
    >>> H = haar_moment(2)
    >>> H.shape
    (4, 4)

    :param d: Hilbert space dimension.
    :return: Haar second moment of shape ``(d^2, d^2)``.
    """
    Pi = np.zeros((d**2, d**2), dtype=complex)
    e  = np.eye(d)
    for i in range(d):
        for j in range(d):
            eij = np.kron(e[i], e[j]); eji = np.kron(e[j], e[i])
            Pi += np.outer(eij, eij) + np.outer(eij, eji)
    return (Pi / 2) / comb(d + 1, 2)



# Quantum state discrimination 
# 

def demonstrate_discrimination(states: list[np.ndarray], d: int) -> None:
    r"""Demonstrate min-error discrimination and state exclusion for SIC-POVM states.

    Calls :func:`toqito.state_opt.state_distinguishability` and
    :func:`toqito.state_opt.state_exclusion` directly and prints the results alongside
    the analytic bound :math:`P_{\mathrm{succ}} = 2/[d(d+1)]`
    :footcite:p:`barnett2009quantum`.

    Examples
    ========

    >>> demonstrate_discrimination(sic_povm_d2(), d=2)  # doctest: +SKIP

    References
    ==========

    .. footbibliography::

    :param states: List of SIC-POVM unit vectors.
    :param d: Hilbert space dimension.
    """
    rhos   = [np.outer(psi, psi.conj()) for psi in states]
    n      = len(rhos)
    priors = [1/n] * n

    # Min-error discrimination via toqito.state_opt.state_distinguishability
    p_succ, _ = state_distinguishability(rhos, priors)
    p_theory  = 2 / (d * (d + 1))
    print(f"d={d}  P_succ (toqito): {p_succ:.6f}  |  "
          f"analytic 2/[d(d+1)]: {p_theory:.6f}  |  "
          f"match: {np.isclose(p_succ, p_theory, atol=1e-4)}")

    # State exclusion via toqito.state_opt.state_exclusion
    p_excl, _ = state_exclusion(rhos, priors)
    print(f"d={d}  P_excl (toqito): {p_excl:.6f}")


def plot_discrimination_scaling() -> None:
    r"""Plot :math:`P_{\mathrm{succ}} = 2/[d(d+1)]` vs. random guessing :math:`1/d^2`.

    Illustrates that SIC-POVM state discrimination becomes harder with dimension,
    while remaining a fixed multiple above random chance.
    """
    dims     = range(2, 9)
    p_sic    = [2 / (d * (d + 1)) for d in dims]
    p_random = [1 / d**2          for d in dims]

    fig, ax = plt.subplots(figsize=(7, 4))
    ax.plot(dims, p_sic,    "o-",  color="#E63946", linewidth=2, markersize=8,
            label=r"SIC optimal: $\frac{2}{d(d+1)}$")
    ax.plot(dims, p_random, "s--", color="#457B9D", linewidth=2, markersize=8,
            label=r"Random guess: $\frac{1}{d^2}$")
    ax.set_xlabel("Dimension d", fontsize=12)
    ax.set_ylabel("Success probability", fontsize=12)
    ax.set_title("SIC-POVM Min-Error Discrimination vs. Dimension", fontsize=12)
    ax.legend(fontsize=11)
    ax.grid(True, alpha=0.3)
    ax.set_xticks(list(dims))
    plt.tight_layout()
    plt.show()



# Weyl-Heisenberg group 
# 
# The d^2 displacement operators D_{jk} = tau^{jk} * X^j Z^k are produced
# directly by toqito.matrices.gen_pauli, which implements X^{k1} Z^{k2} for
# any dimension.  No wrapper is needed; use gen_pauli inline, for example:
#
#   d   = 3
#   tau = np.exp(1j * np.pi / d)
#   for j in range(d):
#       for k in range(d):
#           D_jk = tau**(j*k) * gen_pauli(j, k, d)
#           assert np.allclose(D_jk @ D_jk.conj().T, np.eye(d))   # unitarity
#
# The operators satisfy Tr(D_jk† D_j'k') = d * δ_{jj'} δ_{kk'}, forming
# an orthonormal operator basis for L(C^d).



# Mutually Unbiased Bases uses toqito.states.mutually_unbiased_basis directly
# 

def plot_mub_overlaps(dim: int) -> None:
    r"""Plot the pairwise overlap matrix for the MUB states of a given prime dimension.

    Uses :func:`toqito.states.mutually_unbiased_basis` to obtain the MUB vectors and
    :func:`toqito.matrix_ops.vectors_to_gram_matrix` to compute overlaps. Between states
    from *different* bases the overlap-squared is exactly :math:`1/d`; within a basis it
    is 0 (orthogonality).

    Examples
    ========

    >>> plot_mub_overlaps(2)  # doctest: +SKIP

    :param dim: Prime (or prime-power) Hilbert space dimension.
    """
    # mutually_unbiased_basis returns all (d+1)*d MUB vectors concatenated.
    mubs = mutually_unbiased_basis(dim)

    # vectors_to_gram_matrix gives <psi_i|psi_j>; |.|^2 for overlap-squared.
    G = np.abs(vectors_to_gram_matrix(mubs))**2

    fig, ax = plt.subplots(figsize=(5, 4))
    im = ax.imshow(G, vmin=0, vmax=1, cmap="Purples")
    plt.colorbar(im, ax=ax)
    ax.set_title(f"MUB overlap-squared matrix  (d={dim})", fontsize=12)
    ax.set_xlabel("State index j")
    ax.set_ylabel("State index i")
    plt.tight_layout()
    plt.show()



# Informational completeness
# 

def frame_operator_rank(states: list[np.ndarray], d: int) -> int:
    r"""Return the spanning rank of :math:`\{|\psi_i\rangle\langle\psi_i|\}` in operator space.

    A SIC-POVM is informationally complete iff this rank equals :math:`d^2`, i.e. the
    :math:`d^2` rank-1 operators span the full space of :math:`d\times d` Hermitian matrices.

    Examples
    ========

    >>> frame_operator_rank(sic_povm_d2(), d=2)
    4
    >>> frame_operator_rank(sic_povm_d3(), d=3)
    9

    :param states: List of unit vectors.
    :param d: Hilbert space dimension.
    :return: Rank of the frame, equal to :math:`d^2` iff informationally complete.
    """
    M = np.array([np.outer(psi, psi.conj()).ravel() for psi in states])
    return np.linalg.matrix_rank(M, tol=1e-8)


def sic_reconstruct(p: np.ndarray, states: list[np.ndarray], d: int) -> np.ndarray:
    r"""Reconstruct a density matrix from SIC-POVM measurement probabilities.

    Uses the closed-form inversion :footcite:p:`fuchs2004quantum`:

    .. math::

        \rho = \sum_{i=1}^{d^2} \left[(d+1)\,p_i - \frac{1}{d}\right]
               |\psi_i\rangle\langle\psi_i|.

    Examples
    ========

    >>> import numpy as np
    >>> np.random.seed(0)
    >>> A = np.random.randn(2, 2) + 1j * np.random.randn(2, 2)
    >>> rho = A @ A.conj().T; rho /= np.trace(rho)
    >>> sic2 = sic_povm_d2()
    >>> povm2 = build_povm(sic2, d=2)
    >>> p = np.array([np.trace(M @ rho).real for M in povm2])
    >>> np.linalg.norm(rho - sic_reconstruct(p, sic2, d=2)) < 1e-10
    True

    References
    ==========

    .. footbibliography::

    :param p: Measurement probability vector of length :math:`d^2`.
    :param states: SIC-POVM state vectors.
    :param d: Hilbert space dimension.
    :return: Reconstructed density matrix.
    """
    return sum(
        ((d + 1) * p[i] - 1/d) * np.outer(states[i], states[i].conj())
        for i in range(len(states))
    )
