{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#toqito-theory-of-quantum-information-toolkit","title":"|toqito\u27e9: Theory of Quantum Information Toolkit","text":"<p>The |toqito\u27e9 package is an open-source Python library for studying various objects in quantum information, namely, states, channels, and measurements.</p> <p> </p> <p>|toqito\u27e9 focuses on providing numerical tools to study problems about entanglement theory, nonlocal games, matrix analysis, and other aspects of quantum information that are often associated with computer science.</p> <p>|toqito\u27e9 aims to fill the needs of quantum information researchers who want numerical and computational tools for manipulating quantum states, measurements, and channels. It can also be used as a tool to enhance the experience of students and instructors in classes about quantum information.</p>"},{"location":"#installing","title":"Installing","text":"<p>|toqito\u27e9 is available via PyPi for Linux, and macOS, with support for Python 3.10 to 3.13.</p> <pre><code>pip install toqito\n</code></pre>"},{"location":"#examples","title":"Examples","text":"<p>For the full documentation, please consult: Documentation | Examples</p>"},{"location":"#example-nonlocal-games","title":"Example: Nonlocal games","text":"<p>Nonlocal games are a mathematical framework that abstractly models a physical system. The CHSH game is a subtype of nonlocal game referred to as an XOR game that characterizes the seminal CHSH inequality. </p> <p>For XOR games, there exist optimization problems (that are provided via |toqito\u27e9) that one can compute to attain the optimal values of such games when the players use either a classical or quantum strategy.  </p> <p><pre><code># Calculate the classical and quantum value of the CHSH game.\nimport numpy as np\nfrom toqito.nonlocal_games.xor_game import XORGame\n\n# The probability matrix.\nprob_mat = np.array([[1/4, 1/4], [1/4, 1/4]])\n\n# The predicate matrix.\npred_mat = np.array([[0, 0], [0, 1]])\n\n# Define CHSH game from matrices.\nchsh = XORGame(prob_mat, pred_mat)\n\nchsh.classical_value()\n# 0.75\nchsh.quantum_value()\n# 0.8535533\n</code></pre> Indeed, using a quantum strategy for the CHSH game gives the known optimal result of \\(\\frac{1}{4}\\left(2 + \\sqrt{2}\\right) \\approx 0.8535...\\)</p>"},{"location":"#example-quantum-state-distinguishability","title":"Example: Quantum state distinguishability","text":"<p>Quantum state distinguishability is a fundamental task in quantum information theory. Consider the set of four Bell states:</p> \\[ \\begin{equation}     \\begin{aligned}         |\\psi_0\\rangle = \\frac{1}{\\sqrt{2}} \\left(|00\\rangle + |11\\rangle\\right), \\quad         |\\psi_1\\rangle = \\frac{1}{\\sqrt{2}} \\left(|00\\rangle - |11\\rangle\\right), \\\\          |\\psi_2\\rangle = \\frac{1}{\\sqrt{2}} \\left(|01\\rangle + |10\\rangle\\right), \\quad         |\\psi_3\\rangle = \\frac{1}{\\sqrt{2}} \\left(|01\\rangle - |10\\rangle\\right).     \\end{aligned} \\end{equation} \\] <p>The optimal probability of globally distinguishing the four Bell states (assuming an equal weighting of probability) is 1 (i.e., it can be performed perfectly). However, under a more restrictive set of measurements (such as PPT measurement operators), the optimal probability of distinguishing the four Bell states using PPT operators is 1/2.</p> <p>|toqito\u27e9 offers a wide suite of functionality for computing the distinguishability of quantum states:</p> <pre><code>from toqito.states import bell\nfrom toqito.state_opt import state_distinguishability, ppt_distinguishability\n\n# Define the set of states as the four Bell states:\nstates = [bell(0), bell(1), bell(2), bell(3)]\n\n# Distinguishing four Bell states (global measurements): 0.9999999999767388\npos_res, _ = state_distinguishability(states)\nprint(f\"Distinguishing four Bell states (global measurements): {pos_res}\")\n\n# Distinguishing four Bell states (PPT measurements): 0.5000000000098367\nppt_res, _ = ppt_distinguishability(states, subsystems=[0], dimensions=[2, 2])\nprint(f\"Distinguishing four Bell states (PPT measurements): {ppt_res}\")\n</code></pre> <p>Consult the quantum state tutorials for additional examples and information about quantum states within the context of |toqito\u27e9.</p>"},{"location":"#testing","title":"Testing","text":"<p>The <code>pytest</code> module is used for testing. To run the suite of tests for |toqito\u27e9, run the following command in the root directory of this project.</p> <pre><code>pytest --cov-report term-missing --cov=toqito\n</code></pre>"},{"location":"#citing","title":"Citing","text":"<p>You can cite |toqito\u27e9 using the following DOI: <code>10.5281/zenodo.4743211</code></p> <p>If you are using the |toqito\u27e9 software package in research work, please include an explicit mention of |toqito\u27e9 in your publication. Something along the lines of:</p> <pre><code>To solve problem \"X\", we used |toqito\u27e9; a package for studying certain\naspects of quantum information.\n</code></pre> <p>A BibTeX entry that you can use to cite |toqito\u27e9 is provided here:</p> <pre><code>@misc{toqito,\n   author       = {Vincent Russo},\n   title        = {toqito: A {P}ython toolkit for quantum information},\n   howpublished = {\\url{https://github.com/vprusso/toqito}},\n   month        = May,\n   year         = 2021,\n   doi          = {10.5281/zenodo.4743211}\n }\n</code></pre>"},{"location":"#research","title":"Research","text":"<p>The |toqito\u27e9 project is, first and foremost, a quantum information theory research tool. Consult the following open problems wiki page for a list of certain solved and unsolved problems in quantum information theory in which |toqito\u27e9 could be potentially helpful in probing. Feel free to add to this list and/or contribute solutions!</p> <p>The |toqito\u27e9 project has been used or referenced in the following works:</p> <ul> <li> <p> Lovitz, Benjamin and Johnston, Nathaniel and Russo, Vincent and Sikora, Jamie \"The complexity of perfect quantum state classification\", arXiv:2510.20789, (2025).</p> </li> <li> <p> Johnston, Nathaniel and Russo, Vincent and Sikora, Jamie \"Tight bounds for antidistinguishability and circulant sets of pure quantum states\", Quantum 9, 1622, (2025).</p> </li> <li> <p> Philip, Aby \"On Multipartite Entanglement and Its Use\", (2024).</p> </li> <li> <p> Almasi, Ali \"Quantum Guessing Games\", (2024).</p> </li> <li> <p> Gupta, Tathagata and Mushid, Shayeef and Russo, Vincent and Bandyopadhyay, Somshubhro \"Optimal discrimination of quantum sequences\", Physical Review A, 110, 062426, (2024).</p> </li> <li> <p> Bandyopadhyay, Somshubhro and Russo, Vincent \"Distinguishing a maximally entangled basis using LOCC and shared entanglement\", Physical Review A 110, 042406, (2024).</p> </li> <li> <p> Tavakoli, Armin and Pozas-Kerstjens, Alejandro and Brown, Peter and Ara\u00fajo, Mateus \"Semidefinite programming relaxations for quantum correlations\", Reviews of Modern Physics, Volume 96, (2024).</p> </li> <li> <p> Pelofske, Elijah and Bartschi, Andreas and Eidenbenz, Stephan and Garcia, Bryan and Kiefer, Boris \"Probing Quantum Telecloning on Superconducting Quantum Processors\", IEEE Transactions on Quantum Engineering, (2024).</p> </li> <li> <p> Philip, Aby and Rethinasamy, Soorya and Russo, Vincent and Wilde, Mark.  \"Quantum Steering Algorithm for Estimating Fidelity of Separability\", Quantum 8, 1366, (2023).</p> </li> <li> <p> Miszczak, Jaros\u0142aw Adam.  \"Symbolic quantum programming for supporting applications of quantum computing technologies\", Companion Proceedings of the 7th International Conference on the Art, Science, and Engineering of Programming, (2023).</p> </li> <li> <p> Casal\u00e9, Balthazar and Di Molfetta, Giuseppe and Anthoine, Sandrine and Kadri, Hachem.  \"Large-Scale Quantum Separability Through a Reproducible Machine Learning Lens\", (2023).</p> </li> <li> <p> Russo, Vincent and Sikora, Jamie \"Inner products of pure states and their antidistinguishability\", Physical Review A, Vol. 107, No. 3, (2023).</p> </li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>All contributions, bug reports, bug fixes, documentation improvements, enhancements, and ideas are welcome.</p> <p>A detailed overview of how to contribute can be found in the contributing guide.</p> <p>Chat with us in our |toqito\u27e9 channel on Discord. </p>"},{"location":"#license","title":"License","text":"<p>MIT License</p>"},{"location":"code-of-conduct/","title":"Code of Conduct","text":""},{"location":"code-of-conduct/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"code-of-conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual     attention or advances</li> <li>Trolling, insulting/derogatory comments, and personal or political     attacks</li> <li>Public or private harassment</li> <li>Publishing others\\' private information, such as a physical or     electronic address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in     a professional setting</li> </ul>"},{"location":"code-of-conduct/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"code-of-conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"code-of-conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.</p> <p>Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project\\'s leadership.</p>"},{"location":"code-of-conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant version 1.4</p> <ul> <li>Homepage</li> <li>Version</li> </ul>"},{"location":"contributing-guide/","title":"Contributing Guide","text":"<p>We welcome contributions from external contributors, and this document describes how to merge code changes into <code>|toqito\u27e9</code>.</p> <ol> <li>Make sure you have a GitHub     account.</li> <li>Fork this     repository on GitHub.</li> <li>On your local machine,     clone your     fork of the repository. You will have to install an editable version     on your local machine. Instructions are provided below.</li> </ol> <p>Warning</p> <p>Avoid ad-hoc <code>pip install -e .</code> workflows; the project standardizes on <code>uv</code> for syncing dependencies.</p> <ol> <li>As stated in Getting started, ensure you have Python 3.10 or greater installed on     your machine or in a virtual environment     (pyenv, pyenv     tutorial). Consider using a     virtual environment.     You can also use <code>pyenv</code> with <code>virtualenv</code> to manage different     Python versions or     <code>conda</code> to create virtual environments with different Python     versions.</li> <li>You will require uv to manage the     dependencies of <code>toqito</code>. Refer to the uv installation     guide for     platform-specific instructions.</li> <li>Now, navigate to your local clone of the <code>|toqito\u27e9</code> repository as     shown below.</li> </ol> <pre><code>$ cd toqito/\n</code></pre> <ol> <li>Use <code>uv</code> as shown below in the <code>|toqito\u27e9</code> folder. This installs an     editable version of <code>|toqito\u27e9</code> along with the default development     tools.</li> </ol> <pre><code>toqito/ $ uv sync\n</code></pre> <p>You are now free to make the desired changes in your fork of <code>|toqito\u27e9</code>.</p>"},{"location":"contributing-guide/#making-changes","title":"Making Changes","text":"<ol> <li>Add some really awesome code to your local fork. It\\'s usually a     good     idea     to make changes on a     branch     with the branch name relating to the feature you are going to add.</li> <li>When you are ready for others to examine and comment on your new     feature, navigate to your fork of <code>|toqito\u27e9</code> on GitHub and open a     pull     request(PR)     . Note that after you launch a PR from one of your fork\\'s branches,     all subsequent commits to that branch will be added to the open pull     request automatically. Each commit added to the PR will be validated     for mergeability, compilation and test suite compliance; the results     of these tests will be visible on the PR page.</li> <li>If you\\'re adding a new feature, you must add test cases and     documentation. See Adding a new feature for     a detailed checklist.</li> <li>When the code is ready to go, make sure you run the test suite using     <code>pytest</code>, <code>ruff</code>, etc.</li> <li>When you\\'re ready to be considered for merging, comment on your PR     that it is ready for a review to let the <code>|toqito\u27e9</code> devs know that     the changes are complete. The code will not be reviewed until you     have commented so, the continuous integration workflow passes, and     the primary developer approves the reviews.</li> </ol>"},{"location":"contributing-guide/#adding-a-new-feature","title":"Adding a new feature","text":"<p>If you add a new feature to <code>|toqito\u27e9</code>, make sure</p> <ul> <li>The function docstring follows the style guidelines as specified in     References in Docstrings.</li> <li>The docstring of a new feature should contain a theoretical     description of the feature, one or more examples in an <code>Examples</code>     subsection and a <code>References</code> subsection. The docstring code     examples should utilize fenced code blocks with <code>markdown-exec</code>.</li> <li>Added lines should show up as covered in the <code>pytest</code> code coverage     report. See Testing.</li> <li>Code and unit tests for the new feature should follow the style     guidelines as discussed in Code Style</li> <li>The new feature must be added to the <code>init</code> file of its module to     avoid import issues.</li> </ul>"},{"location":"contributing-guide/#testing","title":"Testing","text":"<p>A convenient way to verify if the installation procedure worked correctly, use [pytest]{.title-ref} in the <code>|toqito\u27e9</code> folder as shown below.</p> <pre><code>toqito/ $ uv run pytest\n</code></pre> <p>The <code>pytest</code> module is used for testing and <code>pytest-cov</code> can be used to generate coverage reports locally. In order to run and <code>pytest</code>, you will need to ensure it is installed on your machine along with <code>pytest-cov</code>. If the editable installation process worked without any issues, both <code>pytest</code> and <code>pytest-cov</code> should be installed in your local environment.</p> <p>If not, consult the pytest and pytest-cov websites for additional options on code coverage reports. For example, if your addition is not properly covered by tests, code coverage can be checked by using <code>--cov-report term-missing</code> options in <code>pytest-cov</code>.</p> <p>If you are making changes to <code>toqito.some_module</code>, the corresponding tests should be in <code>toqito/some_module/tests</code>.</p> <p>A beginner introduction to adding unit tests is available here .</p> <p>Note</p> <p>Performance benchmarks are not part of the standard test run. Trigger the <code>Benchmark Regression Analysis</code> GitHub workflow manually when you need timings or regression checks.</p>"},{"location":"contributing-guide/#code-style","title":"Code Style","text":"<p>We use <code>ruff</code> to check for formatting issues. Consult the documentation for ruff for additional information.</p> <p>Do not use an autoformatter like <code>black</code> as the configuration settings for <code>ruff</code> as specified in pyproject.toml might be incompatible with the changes made by <code>black</code>. This is discussed in detail at this link.</p> <p>Static typing is enforced with <code>mypy</code> (see mypy documentation). Before submitting a pull request, run the type checker against the source tree (the type checker lives in the <code>lint</code> dependency group):</p> <pre><code>uv run --group lint mypy toqito\n</code></pre>"},{"location":"contributing-guide/#setting-up-pre-commit-hooks","title":"Setting Up Pre-Commit Hooks","text":"<p>Pre-commit hooks ensure that the code meets our formatting and linting standards before it is committed to the repository. Install the hooks with the following command.</p> <pre><code>uv run pre-commit install\n</code></pre> <p>This integrates ruff checks into your workflow, ensuring consistent code quality across the project.</p> <p>Additionally, the commit-msg hook ensures adherence to the Conventional Commits format for all commit messages and helps maintain a standardized commit history.</p> <pre><code>uv run pre-commit install --hook-type commit-msg\n</code></pre>"},{"location":"contributing-guide/#references-in-docstrings","title":"References in Docstrings","text":"<p>If you are adding a new function, make sure the docstring of your function follows the formatting specifications in Code Style. A standard format for <code>|toqito\u27e9</code> docstring is provided below:</p> <pre><code>def my_new_function(some_parameter: parameter_type) -&gt; return_type:\n    r\"\"\"One liner description of the new function.\n\n        Detailed description of the function.\n\n        Examples\n        ==========\n        Demonstrate how the function works with expected output.\n\n        .. jupyter-execute::\n\n            import numpy as np\n            x = np.array([[1, 2], [3, 4]])\n            print(x)\n\n        References\n        ==========\n        .. footbibliography::\n\n\n        :param name_of_parameter: Description of the parameter.\n        :raises SomeError: Description for when the function raises an error.\n        :return: Description of what the function returns.\n\n    \"\"\"\n</code></pre> <p>Use <code>\\(\\)</code> for inline math and <code>\\[\\]</code> for display math in docstrings. Use `` for citations in docstrings.</p> <p>To add an attribution to a paper or a book, add your reference with <code>some_ref</code> as the citation key to <code>docs/content/refs.bib</code>. All references in <code>refs.bib</code> are arranged alphabetically according to the first author's last name. Take a look at the existing entries to get an idea of how to format the <code>bib</code> keys.</p>"},{"location":"contributing-guide/#documentation","title":"Documentation","text":"<p>We use <code>sphinx</code> to build the documentation. Sync the docs dependency group first (<code>uv sync --group docs</code>), then run:</p> <pre><code>toqito/docs$ uv run make clean html\n</code></pre> <p>If you would prefer to decrease the amount of time taken by <code>sphinx</code> to build the documentation locally, use <code>make html</code> instead after the documentation has been built once.</p> <p>A standard document has to follow the <code>.rst</code> format. For more information on <code>sphinx</code>, <code>rst</code> fromat and the documentation theme <code>furo</code>, visit sphinx documentation , rst primer &amp; furo documentation .</p>"},{"location":"contributing-guide/#additional-resources","title":"Additional Resources","text":"<ul> <li>General GitHub documentation</li> <li>PR best     practices</li> <li>A guide to contributing to software     packages</li> </ul>"},{"location":"getting-started/","title":"Getting started","text":"<p>Warning</p> <p>Efficiency of <code>|toqito\u27e9</code> has not been verified on Windows.</p>"},{"location":"getting-started/#installing","title":"Installing","text":"<p>1. Ensure you have Python 3.10 or greater installed on your machine or in a virtual environment (pyenv, pyenv tutorial).</p> <p>Note</p> <p>On macOS, the <code>cvxopt</code> dependency (pulled in by <code>picos</code>) may need to be built from source if a pre-built wheel is not available for your Python version and macOS version. If you encounter a build error mentioning  <code>umfpack.h</code>, install the required system library with:</p> <pre><code>brew install suite-sparse\n</code></pre> <p>2. Consider using a virtual environment. You can also use <code>pyenv</code> with <code>virtualenv</code> to manage different Python versions.</p> <p>3. The preferred way to install the <code>|toqito\u27e9</code> package is via <code>uv</code>, which keeps dependencies in sync with the project\\'s lockfile. An editable version of <code>|toqito\u27e9</code> can be installed through the instructions provided in the Contributing Guide.</p> <p>If you prefer to not install an editable version of <code>|toqito\u27e9</code>, use:</p> <pre><code>(local_venv) pip install toqito\n</code></pre> <p>Above command will also install other additional dependencies for <code>|toqito\u27e9</code>.</p> <p>The <code>|toqito\u27e9</code> module makes heavy use of the <code>cvxpy</code> module for solving various convex optimization problems that naturally arise for certain problems in quantum information. The installation instructions for <code>cvxpy</code> may be found on the project\\'s installation page. However these installation instructions can be ignored as <code>pip install toqito</code> will also install <code>cvxpy</code> as a dependency.</p> <p>Note</p> <p>macOS already ships with BLAS and LAPACK installed by default under the Accelerate framework.</p> <p>As a dependency for many of the solvers, you will need to ensure you have the <code>BLAS</code> and <code>LAPACK</code> mathematical libraries installed on your machine. If you have <code>numpy</code> working on your machine (installed as a <code>|toqito\u27e9</code> dependency), you already have these libraries on your machine. See NumPy docs. If you don't, <code>BLAS</code> and <code>LAPACK</code> can be installed using the following command:</p> <pre><code>(For Linux) sudo apt-get install -y libblas-dev liblapack-dev\n</code></pre> <p>The <code>cvxpy</code> module provides many different solvers to select from for solving SDPs. We tend to use the SCS solver. Ensure that you have the <code>scs</code> Python module installed and built for your machine. Again, this discussion can be ignored as <code>pip install toqito</code> will also install <code>SCS</code> as a dependency.</p>"},{"location":"getting-started/#contributing","title":"Contributing","text":"<p>All contributions, bug reports, bug fixes, documentation improvements, enhancements, and ideas are welcome.</p> <p>A detailed overview on how to contribute can be found in the Contributing Guide.</p>"},{"location":"getting-started/#reporting-issues","title":"Reporting Issues","text":"<p>Please report any issues you encounter on GitHub.</p>"},{"location":"getting-started/#citing","title":"Citing","text":"<p>You can cite <code>|toqito\u27e9</code> using the following DOI: 10.5281/zenodo.4743211.</p> <p>If you are using the <code>|toqito\u27e9</code> software package in research work, please include an explicit mention of <code>|toqito\u27e9</code> in your publication. Something along the lines of:</p> <pre><code>To solve problem \"X\" we used `toqito`; a package for studying certain aspects of quantum information.\n</code></pre> <p>A BibTeX entry that you can use to cite <code>|toqito\u27e9</code> is provided here:</p> <pre><code>@misc{toqito,\n   author       = {Vincent Russo},\n   title        = {toqito: A {P}ython toolkit for quantum information, version 1.0.0},\n   howpublished = {\\url{https://github.com/vprusso/toqito}},\n   month        = Mar,\n   year         = 2021,\n   doi          = {10.5281/zenodo.4743211}\n }\n</code></pre>"},{"location":"references/","title":"References","text":"<ol> <li> <p>Scott Aaronson. Lecture 6: mixed states. URL: https://www.scottaaronson.com/qclec/6.pdf.\u00a0\u21a9</p> </li> <li> <p>Srinivasan Arunachalam, Abel Molina, and Vincent Russo. Quantum hedging in two-round prover-verifier interactions. 2017. arXiv:1310.7954.\u00a0\u21a9</p> </li> <li> <p>Somshubhro Bandyopadhyay, Rahul Jain, Jonathan Oppenheim, and Christopher Perry. Conclusive exclusion of quantum states. Physical Review A, Feb 2014. URL: http://dx.doi.org/10.1103/PhysRevA.89.022336, doi:10.1103/physreva.89.022336.\u00a0\u21a9</p> </li> <li> <p>Somshubhro Bandyopadhyay, Alessandro Cosentino, Nathaniel Johnston, Vincent Russo, John Watrous, and Nengkun Yu. Limitations on separable measurements by convex optimization. IEEE Transactions on Information Theory, 61(6):3593\u20133604, jun 2015. URL: http://dx.doi.org/10.1109/TIT.2015.2417755, doi:10.1109/tit.2015.2417755.\u00a0\u21a9</p> </li> <li> <p>Francesco Barioli and Abraham Berman. The maximal CP-rank of rank \\(k\\) completely positive matrices. Linear Algebra and its Applications, 363:17\u201333, 2003. doi:10.1016/S0024-3795(02)00250-1.\u00a0\u21a9</p> </li> <li> <p>V. P. Belavkin. Optimal distinction of non-orthogonal quantum signals. Radio Engineering and Electronic Physics, 20:39\u201347, 1975.\u00a0\u21a9</p> </li> <li> <p>Charles H. Bennett and Stephen J. Wiesner. Communication via one- and two-particle operators on Einstein-P odolsky-Rosen states. Phys. Rev. Lett., 69:2881\u20132884, Nov 1992. URL: https://link.aps.org/doi/10.1103/PhysRevLett.69.2881, doi:10.1103/PhysRevLett.69.2881.\u00a0\u21a9</p> </li> <li> <p>Charles H. Bennett, David P. DiVincenzo, Christopher A. Fuchs, Tal Mor, Eric Rains, Peter W. Shor, John A. Smolin, and William K. Wootters. Quantum nonlocality without entanglement. Physical Review A, 59(2):1070\u20131091, Feb 1999. URL: http://dx.doi.org/10.1103/PhysRevA.59.1070, doi:10.1103/physreva.59.1070.\u00a0\u21a9</p> </li> <li> <p>Charles H. Bennett, David P. DiVincenzo, Tal Mor, Peter W. Shor, John A. Smolin, and Barbara M. Terhal. Unextendible product bases and bound entanglement. Physical Review Letters, 82(26):5385\u20135388, Jun 1999. URL: http://dx.doi.org/10.1103/PhysRevLett.82.5385, doi:10.1103/physrevlett.82.5385.\u00a0\u21a9</p> </li> <li> <p>Erik G Boman, Doron Chen, Ojas Parekh, and Sivan Toledo. On factor width and symmetric H-matrices. Linear algebra and its applications, 405:239\u2013248, 2005. doi:10.1016/j.laa.2005.03.029.\u00a0\u21a9</p> </li> <li> <p>Heinz-Peter Breuer. Optimal entanglement criterion for mixed quantum states. Phys. Rev. Lett., 97:080501, Aug 2006. URL: https://link.aps.org/doi/10.1103/PhysRevLett.97.080501, doi:10.1103/PhysRevLett.97.080501.\u00a0\u21a9</p> </li> <li> <p>Heinz-Peter Breuer. Optimal entanglement criterion for mixed quantum states. Physical Review Letters, Aug 2006. URL: http://dx.doi.org/10.1103/PhysRevLett.97.080501, doi:10.1103/physrevlett.97.080501.\u00a0\u21a9</p> </li> <li> <p>Dagmar Bru\u00df and Asher Peres. Construction of quantum states with bound entanglement. Phys. Rev. A, 61:030301, Feb 2000. URL: https://link.aps.org/doi/10.1103/PhysRevA.61.030301, doi:10.1103/PhysRevA.61.030301.\u00a0\u21a9</p> </li> <li> <p>Ad\u00e1n Cabello. \\(n\\)-particle \\(n\\)-level singlet states: some properties and applications. Phys. Rev. Lett., 89:100402, Aug 2002. URL: https://arxiv.org/abs/quant-ph/0203119.\u00a0\u21a9</p> </li> <li> <p>A. G. Campos, D. Schmid, L. Mamani, R. W. Spekkens, and I. Sainz. No epistemic model can explain anti-distinguishability of quantum mixed preparations. arXiv preprint arXiv:2401.17980v2, 2024. Preprint. URL: https://arxiv.org/abs/2401.17980.\u00a0\u21a9</p> </li> <li> <p>Daniel Cariello. Separability for weak irreducible matrices. 2013. arXiv:1311.7275.\u00a0\u21a9</p> </li> <li> <p>D. Cavalcanti, P. Skrzypczyk, G. H. Aguilar, R. V. Nery, P.H. Souto Ribeiro, and S. P. Walborn. Detection of entanglement in asymmetric quantum networks and multipartite quantum steering. Nature Communications, aug 2015. URL: http://dx.doi.org/10.1038/ncomms8941, doi:10.1038/ncomms8941.\u00a0\u21a9</p> </li> <li> <p>Kai Chen and Ling-An Wu. A matrix realignment method for recognizing entanglement. 2003. arXiv:quant-ph/0205017.\u00a0\u21a9</p> </li> <li> <p>Lin Chen and Dragomir \u017d \u0110okovi\u0107. Separability problem for multipartite states of rank at most 4. Journal of Physics A: Mathematical and Theoretical, 46(27):275304, jun 2013. URL: https://dx.doi.org/10.1088/1751-8113/46/27/275304, doi:10.1088/1751-8113/46/27/275304.\u00a0\u21a9</p> </li> <li> <p>Jianxin Chen, Zhengfeng Ji, David Kribs, Norbert L\u00fctkenhaus, and Bei Zeng. Symmetric extension of two-qubit states. Physical Review A, Sep 2014. URL: http://dx.doi.org/10.1103/PhysRevA.90.032318, doi:10.1103/physreva.90.032318.\u00a0\u21a9</p> </li> <li> <p>Sung Je Cho, Seung-Hyeok Kye, and Sa Ge Lee. Generalized choi maps in three-dimensional matrix algebra. Linear Algebra and its Applications, 171:213\u2013224, 1992. doi:https://doi.org/10.1016/0024-3795(92)90260-H.\u00a0\u21a9</p> </li> <li> <p>Dariusz Chru\u015bci\u0144ski and Andrzej Kossakowski. On the symmetry of the seminal horodecki state. Physics Letters A, 375(3):434\u2013436, Jan 2011. URL: https://arxiv.org/abs/1009.4385, doi:10.1016/j.physleta.2010.11.069.\u00a0\u21a9</p> </li> <li> <p>Michael A. Nielsen and Isaac L. Chuang. Quantum Computation and Quantum Information: 10th Anniversary Edition. Cambridge University Press, USA, 10th edition, 2011. ISBN 1107002176.\u00a0\u21a9</p> </li> <li> <p>Richard Cleve, William Slofstra, Falk Unger, and Sarvagya Upadhyay. Strong parallel repetition theorem for quantum xor proof systems. 2008. arXiv:quant-ph/0608146.\u00a0\u21a9</p> </li> <li> <p>Richard Cleve, Peter Hoyer, Ben Toner, and John Watrous. Consequences and limits of nonlocal strategies. 2010. arXiv:quant-ph/0404076.\u00a0\u21a9</p> </li> <li> <p>Richard Cleve, Li Liu, and William Slofstra. Perfect commuting-operator strategies for linear system games. Journal of Mathematical Physics, 2016. URL: https://pubs.aip.org/aip/jmp/article-abstract/58/1/012202/317604/Perfect-commuting-operator-strategies-for-linear?redirectedFrom=fulltext, doi:10.1063/1.4973422.\u00a0\u21a9</p> </li> <li> <p>Richard Cleve and Rajat Mittal. Characterization of binary constraint system games. In Automata, Languages, and Programming: 41st International Colloquium, ICALP 2014, Copenhagen, Denmark, July 8-11, 2014, Proceedings, Part I 41, 320\u2013331. Springer, 2014.\u00a0\u21a9</p> </li> <li> <p>Daniel Collins and Nicolas Gisin. A relevant two qubit bell inequality inequivalent to the chsh inequality. Journal of Physics A: Mathematical and General, 37(5):1775\u20131787, jan 2004. URL: http://dx.doi.org/10.1088/0305-4470/37/5/021, doi:10.1088/0305-4470/37/5/021.\u00a0\u21a9</p> </li> <li> <p>Alessandro Cosentino. Positive-partial-transpose-indistinguishable states via semidefinite programming. Physical Review A, Jan 2013. URL: http://dx.doi.org/10.1103/PhysRevA.87.012321, doi:10.1103/physreva.87.012321.\u00a0\u21a9</p> </li> <li> <p>Alessandro Cosentino and Vincent Russo. Small sets of locally indistinguishable orthogonal maximally entangled states. 2014. arXiv:1307.3232.\u00a0\u21a9</p> </li> <li> <p>Alessandro Cosentino. Quantum state local distinguishability via convex optimization. 2015. URL: https://uwspace.uwaterloo.ca/handle/10012/9572.\u00a0\u21a9</p> </li> <li> <p>G Mauro D\u2019Ariano, Massimiliano F Sacchi, and Jonas Kahn. Minimax discrimination of two pauli channels. Physical Review A\u2014Atomic, Molecular, and Optical Physics, 72(5):052302, 2005. arXiv:0507081.\u00a0\u21a9</p> </li> <li> <p>David P. DiVincenzo, Peter W. Shor, John A. Smolin, Barbara M. Terhal, and Ashish V. Thapliyal. Evidence for bound entangled states with negative partial transpose. Physical Review A, May 2000. URL: http://dx.doi.org/10.1103/PhysRevA.61.062312, doi:10.1103/physreva.61.062312.\u00a0\u21a9</p> </li> <li> <p>A. C. Doherty, Pablo A. Parrilo, and Federico M. Spedalieri. Distinguishing separable and entangled states. Physical Review Letters, Apr 2002. URL: http://dx.doi.org/10.1103/PhysRevLett.88.187904, doi:10.1103/physrevlett.88.187904.\u00a0\u21a9</p> </li> <li> <p>Andrew C. Doherty, Pablo A. Parrilo, and Federico M. Spedalieri. Complete family of separability criteria. Physical Review A, 69(2):022308, 2004. doi:10.1103/PhysRevA.69.022308.\u00a0\u21a9</p> </li> <li> <p>W. D\u00fcr, G. Vidal, and J. I. Cirac. Three qubits can be entangled in two inequivalent ways. Physical Review A, Nov 2000. URL: http://dx.doi.org/10.1103/PhysRevA.62.062314, doi:10.1103/physreva.62.062314.\u00a0\u21a9</p> </li> <li> <p>DSPRelated. Normalized dft. URL: https://www.dsprelated.com/freebooks/mdft/Normalized_DFT.html.\u00a0\u21a9</p> </li> <li> <p>Y.C. Eldar. A semidefinite programming approach to optimal unambiguous discrimination of quantum states. IEEE Transactions on Information Theory, 49(2):446\u2013456, Feb 2003. URL: http://dx.doi.org/10.1109/TIT.2002.807291, doi:10.1109/tit.2002.807291.\u00a0\u21a9</p> </li> <li> <p>Michael Elad. Sparse and redundant representations: from theory to applications in signal and image processing. Springer Science &amp; Business Media, 2010.\u00a0\u21a9</p> </li> <li> <p>Hamza Fawzi, Jo\u00e3o Gouveia, Pablo A Parrilo, Richard Z Robinson, and Rekha R Thomas. Positive semidefinite rank. Mathematical Programming, 153:133\u2013177, 2015. URL: https://arxiv.org/abs/1407.4095.\u00a0\u21a9</p> </li> <li> <p>N. Gisin. Hidden quantum nonlocality revealed by local filters. Physics Letters A, 210(3):151\u2013156, 1996. doi:https://doi.org/10.1016/S0375-9601(96)80001-6.\u00a0\u21a9</p> </li> <li> <p>Daniel M. Greenberger, Michael A. Horne, and Anton Zeilinger. Going beyond bell's theorem. 2007. arXiv:0712.0921.\u00a0\u21a9</p> </li> <li> <p>Tathagata Gupta, Shayeef Murshid, Vincent Russo, and Somshubhro Bandyopadhyay. Optimal discrimination of quantum sequences. arXiv preprint arXiv:2409.08705, 2024.\u00a0\u21a9</p> </li> <li> <p>Tathagata Gupta, Shayeef Murshid, and Somshubhro Bandyopadhyay. Unambiguous discrimination of sequences of quantum states. Physical Review A, may 2024. URL: http://dx.doi.org/10.1103/PhysRevA.109.052222, doi:10.1103/physreva.109.052222.\u00a0\u21a9</p> </li> <li> <p>Otfried G\u00fchne and G\u00e9za T\u00f3th. Entanglement detection. Physics Reports, 474(1):1\u201375, 2009. URL: https://arxiv.org/abs/0811.2803, doi:https://doi.org/10.1016/j.physrep.2009.02.004.\u00a0\u21a9</p> </li> <li> <p>Leonid Gurvits and Howard Barnum. Largest separable balls around the maximally mixed bipartite quantum state. Phys. Rev. A, 66:062311, Dec 2002. URL: https://link.aps.org/doi/10.1103/PhysRevA.66.062311, doi:10.1103/PhysRevA.66.062311.\u00a0\u21a9</p> </li> <li> <p>Leonid Gurvits and Howard Barnum. Largest separable balls around the maximally mixed bipartite quantum state. Physical Review A, Dec 2002. URL: http://dx.doi.org/10.1103/PhysRevA.66.062311, doi:10.1103/physreva.66.062311.\u00a0\u21a9</p> </li> <li> <p>Kil-Chan Ha and Seung-Hyeok Kye. Entanglement witnesses arising from exposed positive linear maps. 2011. arXiv:1108.0130.\u00a0\u21a9</p> </li> <li> <p>Kwang-Chang Ha and Seung-Hyeok Kye. Positive maps and entanglement in qudits. Physical Review A, 84(2):022314, 2011. doi:10.1103/PhysRevA.84.022314.\u00a0\u21a9</p> </li> <li> <p>Micha\u0142 Horodecki, Pawe\u0142 Horodecki, and Ryszard Horodecki. Operational criterion for the separability of low-rank density matrices. Physical Review Letters, 84(15):3494, 2000.\u00a0\u21a9</p> </li> <li> <p>William Hall. A new criterion for indecomposability of positive maps. Journal of Physics A: Mathematical and General, 39(46):14119, 2006. doi:10.1088/0305-4470/39/45/020.\u00a0\u21a9</p> </li> <li> <p>Patrick Hayden, Kevin Milner, and Mark M. Wilde. Two-message quantum interactive proofs and the quantum separability problem. In 2013 IEEE Conference on Computational Complexity. IEEE, Jun 2013. URL: http://dx.doi.org/10.1109/CCC.2013.24, doi:10.1109/ccc.2013.24.\u00a0\u21a9</p> </li> <li> <p>Roland Hildebrand. Positive partial transpose from spectra. Phys. Rev. A, 76:052325, Nov 2007. URL: https://link.aps.org/doi/10.1103/PhysRevA.76.052325, doi:10.1103/PhysRevA.76.052325.\u00a0\u21a9</p> </li> <li> <p>Teiko Heinosaari, Maria Anastasia Jivulescu, and Ion Nechita. Random positive operator valued measures. Journal of Mathematical Physics, Apr 2020. URL: http://dx.doi.org/10.1063/1.5131028, doi:10.1063/1.5131028.\u00a0\u21a9</p> </li> <li> <p>Teiko Heinosaari and Oskari Kerppo. Antidistinguishability of pure quantum states. Journal of Physics A: Mathematical and Theoretical, 51(36):365303, jul 2018. URL: https://arxiv.org/abs/1804.10457, doi:10.1088/1751-8121/aad1fc.\u00a0\u21a9</p> </li> <li> <p>Teiko Heinosaari and Mark Hillery. Can a qudit carry more information than a dit? arXiv preprint arXiv:2406.16566, 2024. URL: https://arxiv.org/abs/2406.16566.\u00a0\u21a9</p> </li> <li> <p>Roland Hildebrand. Comparison of the ppt cone and the separable cone for 2-by-n systems. 2005. URL: https://membres-ljk.imag.fr/Roland.Hildebrand/coreMPseminar2005_slides.pdf.\u00a0\u21a9</p> </li> <li> <p>Roland Hildebrand. Semidefinite descriptions of low-dimensional separable matrix cones. Linear Algebra and its Applications, 429(4):901\u2013932, 2008. URL: https://www.sciencedirect.com/science/article/pii/S0024379508001973, doi:https://doi.org/10.1016/j.laa.2008.04.018.\u00a0\u21a9</p> </li> <li> <p>Micha\u0142 Horodecki, Pawe\u0142 Horodecki, and Ryszard Horodecki. Separability of mixed states: necessary and sufficient conditions. Physics Letters A, 223(1):1\u20138, 1996. URL: https://arxiv.org/abs/quant-ph/9605038, doi:https://doi.org/10.1016/S0375-9601(96)00706-2.\u00a0\u21a9</p> </li> <li> <p>Pawel Horodecki. Separability criterion and inseparable mixed states with positive partial transposition. Physics Letters A, 232(5):333\u2013339, Aug 1997. URL: http://dx.doi.org/10.1016/S0375-9601(97)00416-7, doi:10.1016/s0375-9601(97)00416-7.\u00a0\u21a9</p> </li> <li> <p>Michal Horodecki and Pawel Horodecki. Reduction criterion of separability and limits for a class of protocols of entanglement distillation. 1998. arXiv:quant-ph/9708015.\u00a0\u21a9</p> </li> <li> <p>Pawe\u0142 Horodecki, Maciej Lewenstein, Guifr\u00e9 Vidal, and Ignacio Cirac. Operational criterion and constructive checks for the separability of low-rank density matrices. Phys. Rev. A, 62:032310, Aug 2000. URL: https://link.aps.org/doi/10.1103/PhysRevA.62.032310, doi:10.1103/PhysRevA.62.032310.\u00a0\u21a9</p> </li> <li> <p>Zixin Huang and Mark M. Wilde. Semi-definite optimization of the measured relative entropies of quantum states and channels. 2025. URL: https://arxiv.org/abs/2406.19060, arXiv:2406.19060.\u00a0\u21a9</p> </li> <li> <p>Lane P Hughston, Richard Jozsa, and William K Wootters. A complete classification of quantum ensembles having a given density matrix. Physics Letters A, 183(1):14\u201318, 1993.\u00a0\u21a9</p> </li> <li> <p>Roger A. Horn and Charles R. Johnson. Matrix Analysis. Cambridge University Press, 1985. doi:10.1017/CBO9780511810817.\u00a0\u21a9</p> </li> <li> <p>Maria Anastasia Jivulescu, Nicolae Lupa, Ion Nechita, and David Reeb. Positive reduction from spectra. Linear Algebra and its Applications, 469:276\u2013304, 2015. URL: https://www.sciencedirect.com/science/article/pii/S0024379514007666, doi:https://doi.org/10.1016/j.laa.2014.11.031.\u00a0\u21a9</p> </li> <li> <p>Nathaniel Johnston and David W. Kribs. A family of norms with applications in quantum information theory. Journal of Mathematical Physics, Aug 2010. URL: http://dx.doi.org/10.1063/1.3459068, doi:10.1063/1.3459068.\u00a0\u21a9</p> </li> <li> <p>Nathaniel Johnston, Benjamin Lovitz, Vincent Russo, and Jamie Sikora. The complexity of quantum state classification. 2025. arXiv:X.\u00a0\u21a9</p> </li> <li> <p>Nathaniel Johnston, Shirin Moein, and Sarah Plosker. The factor width rank of a matrix. Linear Algebra and its Applications, 716:32\u201359, 2025. doi:10.1016/j.laa.2025.03.016.\u00a0\u21a9</p> </li> <li> <p>Nathaniel Johnston. Norms and cones in the theory of quantum entanglement. 2012. arXiv:1207.1479.\u00a0\u21a9</p> </li> <li> <p>Nathaniel Johnston. Separability from spectrum for qubit-qudit states. Phys. Rev. A, 88:062330, Dec 2013. URL: https://link.aps.org/doi/10.1103/PhysRevA.88.062330, doi:10.1103/PhysRevA.88.062330.\u00a0\u21a9</p> </li> <li> <p>Nathaniel Johnston. Counting the possible orderings of pairwise multiplication. 2014. URL: http://njohnston.ca/2014/02/counting-the-possible-orderings-of-pairwise-multiplication/.\u00a0\u21a9</p> </li> <li> <p>Nathaniel Johnston, Rajat Mittal, Vincent Russo, and John Watrous. Extended non-local games and monogamy-of-entanglement games. Proceedings of the Royal Society A: Mathematical, Physical and Engineering Sciences, 472(2189):20160003, May 2016. URL: https://arxiv.org/abs/1510.02083.\u00a0\u21a9</p> </li> <li> <p>Nathaniel Johnston, Shirin Moein, Rajesh Pereira, and Sarah Plosker. Absolutely k-incoherent quantum states and spectral inequalities for the factor width of a matrix. Physical Review A, 106(5):052417, 2022.\u00a0\u21a9</p> </li> <li> <p>Nathaniel Johnston, Vincent Russo, and Jamie Sikora. Tight bounds for antidistinguishability and circulant sets of pure quantum states. Quantum, 9:1622, 2025.\u00a0\u21a9</p> </li> <li> <p>Nathaniel Johnston. QETLAB: A MATLAB toolbox for quantum entanglement. URL: https://github.com/nathanieljohnston/QETLAB, doi:10.5281/zenodo.44637.\u00a0\u21a9</p> </li> <li> <p>Vishal Katariya and Mark M. Wilde. Geometric distinguishability measures limit quantum channel estimation and discrimination. Quantum Information Processing, Feb 2021. URL: http://dx.doi.org/10.1007/s11128-021-02992-7, doi:10.1007/s11128-021-02992-7.\u00a0\u21a9</p> </li> <li> <p>Sumeet Khatri, Kunal Sharma, and Mark M. Wilde. Information-theoretic aspects of the generalized amplitude-damping channel. Phys. Rev. A, 102:012401, Jul 2020. URL: https://link.aps.org/doi/10.1103/PhysRevA.102.012401, doi:10.1103/PhysRevA.102.012401.\u00a0\u21a9</p> </li> <li> <p>Tamara G. Kolda and Brett W. Bader. Tensor decompositions and applications. SIAM Review, 51(3):455\u2013500, 2009. URL: https://epubs.siam.org/doi/10.1137/07070111X, doi:10.1137/07070111X.\u00a0\u21a9</p> </li> <li> <p>Sumeet Khatri. QuTIpy: Quantum Theory of Information for Python; pronounced \" cutie pie\". a package for performing calculations with quantum states and channels. URL: https://github.com/sumeetkhatri/QuTIpy.\u00a0\u21a9</p> </li> <li> <p>Yeong-Cherng Liang and Andrew C. Doherty. Bounds on quantum correlations in bell-inequality experiments. Physical Review A, Apr 2007. URL: http://dx.doi.org/10.1103/PhysRevA.75.042103, doi:10.1103/physreva.75.042103.\u00a0\u21a9</p> </li> <li> <p>Hoi-Kwong Lo and H. F. Chau. Why quantum bit commitment and ideal quantum coin tossing are impossible. 1997. arXiv:quant-ph/9711065.\u00a0\u21a9</p> </li> <li> <p>Cosmo Lupo, Paolo Aniello, and Antonello Scardicchio. Bipartite quantum systems: on the realignment criterion and beyond. Journal of Physics A: Mathematical and Theoretical, 41(41):415301, Sep 2008. URL: https://arxiv.org/abs/0802.2019.\u00a0\u21a9</p> </li> <li> <p>Keiji Matsumoto. Reverse test and quantum analogue of classical fidelity and generalized fidelity. 2010. arXiv:1006.0302.\u00a0\u21a9</p> </li> <li> <p>Dominic Mayers. Unconditionally secure quantum bit commitment is impossible. Phys. Rev. Lett., 78:3414\u20133417, Apr 1997. URL: https://link.aps.org/doi/10.1103/PhysRevLett.78.3414, doi:10.1103/PhysRevLett.78.3414.\u00a0\u21a9</p> </li> <li> <p>Caleb McIrvin, Ankith Mohan, and Jamie Sikora. The pretty bad measurement. 2024. arXiv:2403.17252.\u00a0\u21a9</p> </li> <li> <p>J. A. Miszczak, Z. Pucha\u0142a, P. Horodecki, A. Uhlmann, and K. \u017byczkowski. Sub\u2013 and super\u2013fidelity as bounds for quantum fidelity. 2008. arXiv:0805.2037.\u00a0\u21a9</p> </li> <li> <p>Abel Molina and John Watrous. Hedging bets with correlated quantum strategies. Proceedings of the Royal Society A: Mathematical, Physical and Engineering Sciences, 468(2145):2614\u20132629, Apr 2012. URL: https://arxiv.org/abs/1104.1140.\u00a0\u21a9</p> </li> <li> <p>Abel Molina, Thomas Vidick, and John Watrous. Optimal counterfeiting attacks and generalizations for wiesner's quantum money. 2012. arXiv:1202.4010.\u00a0\u21a9</p> </li> <li> <p>Martin M\u00fcller-Lennert, Fr\u00e9d\u00e9ric Dupuis, Oleg Szehr, Serge Fehr, and Marco Tomamichel. On quantum r\u00e9nyi entropies: a new generalization and some properties. Journal of Mathematical Physics, December 2013. URL: http://dx.doi.org/10.1063/1.4838856, doi:10.1063/1.4838856.\u00a0\u21a9</p> </li> <li> <p>Miguel Navascu\u00e9s, Stefano Pironio, and Antonio Ac\u00edn. A convergent hierarchy of semidefinite programs characterizing the set of quantum correlations. New Journal of Physics, 10(7):073013, Jul 2008. URL: http://dx.doi.org/10.1088/1367-2630/10/7/073013, doi:10.1088/1367-2630/10/7/073013.\u00a0\u21a9</p> </li> <li> <p>Miguel Navascu\u00e9s. Pure state estimation and the characterization of entanglement. Physical Review Letters, Feb 2008. URL: http://dx.doi.org/10.1103/PhysRevLett.100.070503, doi:10.1103/physrevlett.100.070503.\u00a0\u21a9</p> </li> <li> <p>Miguel Navascues, Gonzalo de la Torre, and Tamas Vertesi. Characterization of quantum correlations with local dimension constraints and its device-independent applications. Physical Review X, Jan 2014. URL: http://dx.doi.org/10.1103/PhysRevX.4.011011, doi:10.1103/PhysRevX.4.011011.\u00a0\u21a9</p> </li> <li> <p>Maris Ozols. How to generate a random unitary matrix. 2009. URL: http://home.lu.lv/~sd20008/papers/essays/Random%20unitary%20[paper].pdf.\u00a0\u21a9</p> </li> <li> <p>Asher Peres. Separability criterion for density matrices. Physical Review Letters, 77(8):1413\u20131415, Aug 1996. URL: http://dx.doi.org/10.1103/PhysRevLett.77.1413, doi:10.1103/physrevlett.77.1413.\u00a0\u21a9</p> </li> <li> <p>Aby Philip, Soorya Rethinasamy, Vincent Russo, and Mark M. Wilde. Schr\u00f6dinger as a quantum programmer: estimating entanglement via steering. 2023. arXiv:2303.07911.\u00a0\u21a9</p> </li> <li> <p>PlanetMath. Commutant. URL: https://planetmath.org/commutant.\u00a0\u21a9</p> </li> <li> <p>Matthew F. Pusey, Jonathan Barrett, and Terry Rudolph. On the reality of the quantum state. Nature Physics, 8(6):475\u2013478, May 2012. URL: http://dx.doi.org/10.1038/nphys2309, doi:10.1038/nphys2309.\u00a0\u21a9</p> </li> <li> <p>Quantiki. Entanglement of formation. URL: https://www.quantiki.org/wiki/entanglement-formation.\u00a0\u21a9</p> </li> <li> <p>Quantiki. Trace norm. URL: https://www.quantiki.org/wiki/trace-norm.\u00a0\u21a9</p> </li> <li> <p>Quantiki. Trace distance. URL: https://www.quantiki.org/wiki/trace-distance.\u00a0\u21a9</p> </li> <li> <p>Swapan Rana, Preeti Parashar, Andreas Winter, and Maciej Lewenstein. Logarithmic coherence: operational interpretation of \\(\\\\ensuremath  \\\\ell \\_1\\)-norm coherence. Phys. Rev. A, 96:052336, Nov 2017. URL: https://link.aps.org/doi/10.1103/PhysRevA.96.052336, doi:10.1103/PhysRevA.96.052336.\u00a0\u21a9</p> </li> <li> <p>Rigetti. Forest benchmarking. URL: https://github.com/rigetti/forest-benchmarking.\u00a0\u21a9</p> </li> <li> <p>Vincent Russo. Extended nonlocal games. 2017. arXiv:1704.07375.\u00a0\u21a9</p> </li> <li> <p>Stack Exchange Mathematics. Why do the columns of a unitary matrix form an orthonormal basis? URL: https://math.stackexchange.com/q/1688950.\u00a0\u21a9</p> </li> <li> <p>Akshay Seshadri. Minimax fidelity estimation. URL: https://github.com/akshayseshadri/minimax-fidelity-estimation.\u00a0\u21a9</p> </li> <li> <p>Akshay Seshadri, Martin Ringbauer, Thomas Monz, and Stephen Becker. Theory of versatile fidelity estimation with confidence. 2021. arXiv:2112.07947.\u00a0\u21a9</p> </li> <li> <p>Akshay Seshadri, Martin Ringbauer, Rainer Blatt, Thomas Monz, and Stephen Becker. Versatile fidelity estimation with confidence. 2021. arXiv:2112.07925.\u00a0\u21a9</p> </li> <li> <p>Jamie Sikora. Semidefinite programming in quantum theory (lecture series). Lecture Series, Perimeter Institute for Theoretical Physics; Lecture 2: \"Semidefinite programs for nice problems and popular functions\", 2019. URL: https://sites.google.com/site/jamiesikora/teaching/sdps-in-quantum-theory.\u00a0\u21a9</p> </li> <li> <p>Stack Overflow Post. Check if a large matrix is diagonal matrix in python. URL: https://stackoverflow.com/questions/43884189/.\u00a0\u21a9</p> </li> <li> <p>Denis Sych and Gerd Leuchs. A complete basis of generalized bell states. New Journal of Physics, 11(1):013006, Jan 2009. URL: https://dx.doi.org/10.1088/1367-2630/11/1/013006, doi:10.1088/1367-2630/11/1/013006.\u00a0\u21a9</p> </li> <li> <p>Barbara M. Terhal, David P. DiVincenzo, and Debbie W. Leung. Hiding bits in bell states. Physical Review Letters, 86(25):5807\u20135810, jun 2001. URL: http://dx.doi.org/10.1103/PhysRevLett.86.5807, doi:10.1103/physrevlett.86.5807.\u00a0\u21a9</p> </li> <li> <p>Marco Tomamichel, Serge Fehr, J\u0119drzej Kaniewski, and Stephanie Wehner. A monogamy-of-entanglement game with applications to device-independent quantum cryptography. New Journal of Physics, 15(10):103002, oct 2013. URL: http://dx.doi.org/10.1088/1367-2630/15/10/103002, doi:10.1088/1367-2630/15/10/103002.\u00a0\u21a9</p> </li> <li> <p>Guifr\u00e9 Vidal and Rolf Tarrach. Robustness of entanglement. Phys. Rev. A, 59:141\u2013155, Jan 1999. URL: https://link.aps.org/doi/10.1103/PhysRevA.59.141, doi:10.1103/PhysRevA.59.141.\u00a0\u21a9</p> </li> <li> <p>John Watrous. Semidefinite programs for completely bounded norms. 2009. arXiv:0901.4709.\u00a0\u21a9</p> </li> <li> <p>John Watrous. Theory of quantum information lecture notes. 2011. URL: https://cs.uwaterloo.ca/~watrous/TQI-notes/.\u00a0\u21a9</p> </li> <li> <p>John Watrous. Simpler semidefinite programs for completely bounded norms. 2012. arXiv:1207.5726.\u00a0\u21a9</p> </li> <li> <p>John Watrous. The Theory of Quantum Information. Cambridge University Press, 2018. URL: https://cs.uwaterloo.ca/~watrous/TQI/TQI.pdf, doi:10.1017/9781316848142.\u00a0\u21a9</p> </li> <li> <p>Stephen Wiesner. Conjugate coding. SIGACT News, 15(1):78\u201388, Jan 1983. URL: https://doi.org/10.1145/1008908.1008920, doi:10.1145/1008908.1008920.\u00a0\u21a9</p> </li> <li> <p>Reinhard F. Werner. Quantum states with einstein-podolsky-rosen correlations admitting a hidden-variable model. Phys. Rev. A, 40:4277\u20134281, Oct 1989. URL: https://link.aps.org/doi/10.1103/PhysRevA.40.4277, doi:10.1103/PhysRevA.40.4277.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Anti-symmetric operator. URL: https://en.wikipedia.org/wiki/Anti-symmetric_operator.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Bb84. URL: https://en.wikipedia.org/wiki/BB84.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Bell state. URL: https://en.wikipedia.org/wiki/Bell_state.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Bra-ket notation. URL: https://en.wikipedia.org/wiki/Bra%E2%80%93ket_notation.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Brauer algebra. URL: https://en.wikipedia.org/wiki/Brauer_algebra.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Bures distance. URL: https://en.wikipedia.org/wiki/Bures_metric#Bures_distance.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Circulant matrix. URL: https://en.wikipedia.org/wiki/Circulant_matrix.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Circulant matrix. URL: https://en.wikipedia.org/wiki/Circulant_matrix.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Circular law. URL: https://en.wikipedia.org/wiki/Circular_law.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Generalizations of pauli matrices. URL: https://en.wikipedia.org/wiki/Generalizations_of_Pauli_matrices.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Controlled not gate. URL: https://en.wikipedia.org/wiki/Controlled_NOT_gate.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Commuting matrices. URL: https://en.wikipedia.org/wiki/Commuting_matrices.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Comparison matrix. URL: https://en.wikipedia.org/wiki/Comparison_matrix.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Concurrence (quantum computing). URL: https://en.wikipedia.org/wiki/Concurrence_(quantum_computing).\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Cyclic permutation. URL: https://en.wikipedia.org/wiki/Cyclic_permutation.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Density matrix. URL: https://en.wikipedia.org/wiki/Density_matrix.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Quantum depolarizing channel. URL: https://en.wikipedia.org/wiki/Quantum_depolarizing_channel.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. DFT matrix. URL: https://en.wikipedia.org/wiki/DFT_matrix.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Diagonal matrix. URL: https://en.wikipedia.org/wiki/Diagonal_matrix.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Diagonally dominant matrix. URL: https://en.wikipedia.org/wiki/Diagonally_dominant_matrix.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Doubly stochastic matrix. URL: https://en.wikipedia.org/wiki/Doubly_stochastic_matrix.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Fidelity of quantum states. URL: https://en.wikipedia.org/wiki/Fidelity_of_quantum_states.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Gell-Mann matrices. URL: https://en.wikipedia.org/wiki/Gell-Mann_matrices.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Gram matrix. URL: https://en.wikipedia.org/wiki/Gram_matrix.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Hadamard transform. URL: https://en.wikipedia.org/wiki/Hadamard_transform.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Hermitian matrix. URL: https://en.wikipedia.org/wiki/Hermitian_matrix.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Skew-hermitian matrix. URL: https://en.wikipedia.org/wiki/Skew-Hermitian_matrix.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Hilbert-schmidt operator. URL: https://en.wikipedia.org/wiki/Hilbert%E2%80%93Schmidt_operator.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Holevo\u015b theorem. URL: https://en.wikipedia.org/wiki/Holevo%27s_theorem.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Idempotent matrix. URL: https://en.wikipedia.org/wiki/Idempotent_matrix.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Identity matrix. URL: https://en.wikipedia.org/wiki/Identity_matrix.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Inner product space. URL: https://en.wikipedia.org/wiki/Inner_product_space.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Linear independence. URL: https://en.wikipedia.org/wiki/Linear_independence.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Negativity. URL: https://en.wikipedia.org/wiki/Negativity_(quantum_mechanics).\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Kernel (linear algebra). URL: https://en.wikipedia.org/wiki/Kernel_(linear_algebra).\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Majorization. URL: https://en.wikipedia.org/wiki/Majorization.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Rank (linear algebra). URL: https://en.wikipedia.org/wiki/Rank_(linear_algebra).\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Quantum entanglement. URL: https://en.wikipedia.org/wiki/Quantum_entanglement.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Quantum state - mixed states. URL: https://en.wikipedia.org/wiki/Quantum_state#Mixed_states.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Mutually unbiased bases. URL: https://en.wikipedia.org/wiki/Mutually_unbiased_bases.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Mutual coherence (linear algebra). URL: https://en.wikipedia.org/wiki/Mutual_coherence_(linear_algebra).\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Nonnegative matrix. URL: https://en.wikipedia.org/wiki/Nonnegative_matrix.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Normal matrix. URL: https://en.wikipedia.org/wiki/Normal_matrix.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Orthogonality. URL: https://en.wikipedia.org/wiki/Orthogonality.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Outer product. URL: https://en.wikipedia.org/wiki/Outer_product.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Parity of a permutation. URL: https://en.wikipedia.org/wiki/Parity_of_a_permutation.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Pauli matrices. URL: https://en.wikipedia.org/wiki/Pauli_matrices.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Generalizations of Pauli matrices. URL: https://en.wikipedia.org/wiki/Generalizations_of_Pauli_matrices.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Partial trace. URL: https://en.wikipedia.org/wiki/Partial_trace.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Peres-horodecki criterion. URL: https://en.wikipedia.org/wiki/Peres%E2%80%93Horodecki_criterion.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Permutation matrix. URL: https://en.wikipedia.org/wiki/Permutation_matrix.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Definite matrix. URL: https://en.wikipedia.org/wiki/Definite_matrix.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. POVM. URL: https://en.wikipedia.org/wiki/POVM.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Projection matrix. URL: https://en.wikipedia.org/wiki/Projection_matrix.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Quantum state - pure states. URL: https://en.wikipedia.org/wiki/Quantum_state#Pure_states_of_wave_functions.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Purity (quantum mechanics). URL: https://en.wikipedia.org/wiki/Purity_(quantum_mechanics).\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Measurement in quantum mechanics. URL: https://en.wikipedia.org/wiki/Measurement_in_quantum_mechanics.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Reduction criterion. URL: https://en.wikipedia.org/wiki/Reduction_criterion.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Schmidt decomposition. URL: https://en.wikipedia.org/wiki/Schmidt_decomposition.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Separable state. URL: https://en.wikipedia.org/wiki/Separable_state.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Square matrix. URL: https://en.wikipedia.org/wiki/Square_matrix.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Symmetric matrix. URL: https://en.wikipedia.org/wiki/Symmetric_matrix.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Stochastic matrix. URL: https://en.wikipedia.org/wiki/Stochastic_matrix.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Tensor product. URL: https://en.wikipedia.org/wiki/Tensor_product.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Totally positive matrix. URL: https://en.wikipedia.org/wiki/Totally_positive_matrix.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Unitary matrix. URL: https://en.wikipedia.org/wiki/Unitary_matrix.\u00a0\u21a9</p> </li> <li> <p>Wikipedia. Von neumann entropy. URL: https://en.wikipedia.org/wiki/Von_Neumann_entropy.\u00a0\u21a9</p> </li> <li> <p>Jon Yard. Introduction to quantum information processing. URL: https://www.math.uwaterloo.ca/~jyard/qic710/F17/Qic710Lec11-2017.pdf.\u00a0\u21a9</p> </li> <li> <p>Nengkun Yu, Runyao Duan, and Mingsheng Ying. Four locally indistinguishable ququad-ququad orthogonal maximally entangled states. Physical Review Letters, Jul 2012. URL: http://dx.doi.org/10.1103/PhysRevLett.109.020506, doi:10.1103/physrevlett.109.020506.\u00a0\u21a9</p> </li> <li> <p>Cheng-Jie Zhang, Yong-Sheng Zhang, Shun Zhang, and Guang-Can Guo. Entanglement detection beyond the computable cross-norm or realignment criterion. Phys. Rev. A, 77:060301, Jun 2008. URL: https://link.aps.org/doi/10.1103/PhysRevA.77.060301, doi:10.1103/PhysRevA.77.060301.\u00a0\u21a9</p> </li> </ol>"},{"location":"generated/gallery/","title":"Examples","text":"<p>This gallery demonstrates how to utilize the functionality in <code>|toqito\u27e9</code>. </p>"},{"location":"generated/gallery/#basic-tutorials","title":"Basic Tutorials","text":"<p>The following rendered tutorials demonstrate introductory concepts:</p> <ul> <li>Introductory Tutorial</li> </ul> <p> Introductory Tutorial </p>"},{"location":"generated/gallery/#extended-nonlocal-games","title":"Extended Nonlocal Games","text":"<p>The following tutorials cover extended nonlocal game theory:</p> <ul> <li>Extended nonlocal games</li> <li>An extended nonlocal game with quantum advantage</li> <li>The BB84 extended nonlocal game</li> <li>The CHSH extended nonlocal game</li> <li>Modeling Bit Commitment Binding Failure</li> </ul> <p> Extended nonlocal games </p> <p> Modeling Bit Commitment Binding Failure </p> <p> An extended nonlocal game with quantum advantage </p> <p> The CHSH extended nonlocal game </p> <p> The BB84 extended nonlocal game </p>"},{"location":"generated/gallery/#nonlocal-games","title":"Nonlocal Games","text":"<p>The following tutorials cover nonlocal game theory:</p> <ul> <li>Nonlocal games</li> <li>Calculating the quantum and classical value of a two-player XOR game</li> </ul> <p> Calculating the quantum and classical value of a two-player XOR game </p> <p> Nonlocal games </p>"},{"location":"generated/gallery/#quantum-states","title":"Quantum States","text":"<p>The following tutorials cover quantum state analysis:</p> <ul> <li>Quantum state distinguishability</li> <li>Quantum state exclusion</li> <li>Quantum classification, factor width, k-incoherence</li> <li>Antidistinguishability of Circulant States and the Eigenvalue Criterion</li> <li>Equiangular States and the Antidistinguishability Threshold</li> <li>The Pretty Good and Pretty Bad Measurements</li> <li>The Pusey-Barrett-Rudolph (PBR) Theorem</li> </ul> <p> Quantum state distinguishability </p> <p> The Pusey-Barrett-Rudolph (PBR) Theorem </p> <p> Antidistinguishability of Circulant States and the Eigenvalue Criterion </p> <p> Quantum state exclusion </p> <p> Equiangular States and the Antidistinguishability Threshold </p> <p> Quantum classification, factor width, k-incoherence </p> <p> The Pretty Good and Pretty Bad Measurements </p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/basics/intro_tutorial/","title":"Introductory Tutorial","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/basics/intro_tutorial/#introductory-tutorial","title":"Introductory Tutorial","text":"<p>This tutorial illustrates the basics of how to use <code>|toqito\u27e9</code>. This will covers how to instantiate and use the fundamental objects that <code>|toqito\u27e9</code> provides; namely quantum states, channels, and measurements.</p> <p>This is an introduction to the functionality in <code>|toqito\u27e9</code> and is not meant to serve as an introduction to quantum information. For more information, please consult the book <sup>1</sup> or the freely available lecture notes <sup>2</sup>.</p> <p>This tutorial assumes you have <code>|toqito\u27e9</code> installed on your machine. If you do not, please consult the installation instructions in Getting Started.</p>"},{"location":"generated/gallery/basics/intro_tutorial/#states","title":"States","text":"<p>A quantum state is a density operator</p> \\[ \\rho \\in \\text{D}(\\mathcal{X}) \\] <p>where \\(\\mathcal{X}\\) is a complex Euclidean space and where \\(\\text{D}(\\cdot)\\) represents the set of density matrices, that is, the set of matrices that are positive semidefinite with trace equal to \\(1\\).</p>"},{"location":"generated/gallery/basics/intro_tutorial/#quantum-states","title":"Quantum States","text":"<p>A complete overview of the scope of quantum states can be found in the states module.</p> <p>The standard basis ket vectors given as \\(|0\\rangle\\) and \\(|1\\rangle\\) where</p> \\[ | 0 \\rangle = [1, 0]^{\\text{T}} \\quad \\text{and} \\quad | 1 \\rangle = [0, 1]^{\\text{T}} \\] <p>can be defined in <code>|toqito\u27e9</code> as such</p> <pre><code>from toqito.matrices import standard_basis\n\n# mkdocs_gallery_thumbnail_path = 'figures/logo.png'\n# |0&gt;\nstandard_basis(2)[0]\n</code></pre> <p>Out:</p> <pre><code>array([[1.],\n       [0.]])\n</code></pre> <p>To get the other ket</p> <pre><code># |1&gt;\nstandard_basis(2)[1]\n</code></pre> <p>Out:</p> <pre><code>array([[0.],\n       [1.]])\n</code></pre> <p>One may define one of the four Bell states written as</p> \\[ u_0 = \\frac{1}{\\sqrt{2}} \\left(| 00 \\rangle + | 11 \\rangle \\right) \\] <p>using <code>|toqito\u27e9</code> as</p> <pre><code>import numpy as np\n\ne_0, e_1 = standard_basis(2)\nu_0 = 1 / np.sqrt(2) * (np.kron(e_0, e_0) + np.kron(e_1, e_1))\nu_0\n</code></pre> <p>Out:</p> <pre><code>array([[0.70710678],\n       [0.        ],\n       [0.        ],\n       [0.70710678]])\n</code></pre> <p>The corresponding density operator of \\(u_0\\) can be obtained from</p> \\[ \\rho_0 = u_0 u_0^* = \\frac{1}{2} \\begin{pmatrix}     1 &amp; 0 &amp; 0 &amp; 1 \\\\     0 &amp; 0 &amp; 0 &amp; 0 \\\\     0 &amp; 0 &amp; 0 &amp; 0 \\\\     1 &amp; 0 &amp; 0 &amp; 1 \\end{pmatrix} \\in \\text{D}(\\mathcal{X}). \\] <p>In <code>|toqito\u27e9</code>, that can be obtained as</p> <pre><code>import numpy as np\n\ne_0, e_1 = standard_basis(2)\nu_0 = 1 / np.sqrt(2) * (np.kron(e_0, e_0) + np.kron(e_1, e_1))\nrho_0 = u_0 @ u_0.conj().T\nrho_0\n</code></pre> <p>Out:</p> <pre><code>array([[0.5, 0. , 0. , 0.5],\n       [0. , 0. , 0. , 0. ],\n       [0. , 0. , 0. , 0. ],\n       [0.5, 0. , 0. , 0.5]])\n</code></pre> <p>Alternatively, we may leverage the <code>bell</code> function in <code>|toqito\u27e9</code> to generate all four Bell states defined as</p> \\[ \\begin{equation}     \\begin{aligned}         u_0 = \\frac{1}{\\sqrt{2}} \\left(| 00 \\rangle + | 11 \\rangle \\right), &amp;\\quad         u_1 = \\frac{1}{\\sqrt{2}} \\left(| 00 \\rangle - | 11 \\rangle \\right), \\\\         u_2 = \\frac{1}{\\sqrt{2}} \\left(| 01 \\rangle + | 10 \\rangle \\right), &amp;\\quad         u_3 = \\frac{1}{\\sqrt{2}} \\left(| 01 \\rangle - | 10 \\rangle \\right),     \\end{aligned} \\end{equation} \\] <p>in a more concise manner as</p> <pre><code>import numpy as np\n\nfrom toqito.states import bell\n\nbell(0)\n</code></pre> <p>Out:</p> <pre><code>array([[0.70710678],\n       [0.        ],\n       [0.        ],\n       [0.70710678]])\n</code></pre> <p>The Bell states constitute one such well-known class of quantum states. There are many other classes of states that are widely used in the field of quantum For instance, the GHZ state</p> \\[ | GHZ \\rangle = \\frac{1}{\\sqrt{2}} \\left( | 000 \\rangle + | 111 \\rangle \\right) \\] <p>is a well-known 3-qubit quantum state. We can invoke this using <code>|toqito\u27e9</code> as</p> <pre><code>from toqito.states import ghz\n\nghz(2, 3)\n</code></pre> <p>Out:</p> <pre><code>array([[0.70710678],\n       [0.        ],\n       [0.        ],\n       [0.        ],\n       [0.        ],\n       [0.        ],\n       [0.        ],\n       [0.70710678]])\n</code></pre> <p>While the 3-qubit form of the GHZ state is arguably the most notable, it is possible to define a generalized GHZ state</p> \\[ | GHZ_n \\rangle = \\frac{1}{\\sqrt{n}} \\left( | 0 \\rangle^{\\otimes n} + | 1 \\rangle^{\\otimes n} \\right). \\] <p>This generalized state may be obtained in <code>|toqito\u27e9</code> as well. For instance, here is the GHZ state \\(\\mathbb{C}^{4^{\\otimes 7}}\\) as</p> \\[ \\frac{1}{\\sqrt{30}} \\left(| 0000000 \\rangle + 2| 1111111 \\rangle + 3| 2222222 \\rangle + 4| 3333333\\rangle \\right). \\] <pre><code>import numpy as np\n\nfrom toqito.states import ghz\n\ndim = 4\nnum_parties = 7\ncoeffs = [1 / np.sqrt(30), 2 / np.sqrt(30), 3 / np.sqrt(30), 4 / np.sqrt(30)]\nvec = ghz(dim, num_parties, coeffs)\nfor idx in np.nonzero(vec)[0]:\n    print(f\"Index: {int(idx)}, Value: {vec[idx][0]:.8f}\")\n</code></pre> <p>Out:</p> <pre><code>Index: 0, Value: 0.18257419\nIndex: 5461, Value: 0.36514837\nIndex: 10922, Value: 0.54772256\nIndex: 16383, Value: 0.73029674\n</code></pre>"},{"location":"generated/gallery/basics/intro_tutorial/#properties-of-quantum-states","title":"Properties of Quantum States","text":"<p>Given a quantum state, it is often useful to be able to determine certain properties of the state.</p> <p>For instance, we can check if a quantum state is pure, that is, if the density matrix that describes the state has rank 1.</p> <p>Any one of the Bell states serve as an example of a pure state</p> <pre><code>from toqito.state_props import is_pure\nfrom toqito.states import bell\n\nrho = bell(0) @ bell(0).conj().T\nis_pure(rho)\n</code></pre> <p>Out:</p> <pre><code>True\n</code></pre> <p>Another property that is useful is whether a given state is PPT (positive partial transpose), that is, whether the state remains positive after taking the partial transpose of the state.</p> <p>For quantum states consisting of shared systems of either dimension \\(2 \\otimes 2\\) or \\(2 \\otimes 3\\), the notion of whether a state is PPT serves as a method to determine whether a given quantum state is entangled or separable.</p> <p>As an example, any one of the Bell states constitute a canonical maximally entangled state over \\(2 \\otimes 2\\) and therefore should not satisfy the PPT criterion.</p> <pre><code>from toqito.state_props import is_ppt\nfrom toqito.states import bell\n\nrho = bell(2) @ bell(2).conj().T\nis_ppt(rho)\n</code></pre> <p>Out:</p> <pre><code>False\n</code></pre> <p>As we can see, the PPT criterion is <code>False</code> for an entangled state in \\(2 \\otimes 2\\).</p> <p>Determining whether a quantum state is separable or entangled is often useful but is, unfortunately, NP-hard. For a given density matrix represented by a quantum state, we can use <code>|toqito\u27e9</code> to run a number of separability tests from the literature to determine if it is separable or entangled.</p> <p>For instance, the following bound-entangled tile state is found to be entangled (i.e. not separable).</p> <pre><code>import numpy as np\n\nfrom toqito.state_props import is_separable\nfrom toqito.states import tile\n\nrho = np.identity(9)\nfor i in range(5):\n    rho -= tile(i) @ tile(i).conj().T\n\nrho /= 4\nis_separable(rho)\n</code></pre> <p>Out:</p> <pre><code>False\n</code></pre> <p>Further properties that one can check via <code>|toqito\u27e9</code> may be found in the state properties module.</p>"},{"location":"generated/gallery/basics/intro_tutorial/#distance-metrics-for-quantum-states","title":"Distance Metrics for Quantum States","text":"<p>Given two quantum states, it is often useful to have some way in which to quantify how similar or different one state is from another.</p> <p>One well known metric is the fidelity function defined for two quantum states. For two states \\(\\rho\\) and \\(\\sigma\\), one defines the fidelity between \\(\\rho\\) and \\(\\sigma\\) as</p> \\[ || \\sqrt{\\rho} \\sqrt{\\sigma} ||_1, \\] <p>where \\(|| \\cdot ||_1\\) denotes the trace norm.</p> <p>The fidelity function yields a value between \\(0\\) and \\(1\\), with \\(0\\) representing the scenario where \\(\\rho\\) and \\(\\sigma\\) are as different as can be and where a value of \\(1\\) indicates a scenario where \\(\\rho\\) and \\(\\sigma\\) are identical.</p> <p>Let us consider an example in <code>|toqito\u27e9</code> where we wish to calculate the fidelity function between quantum states that happen to be identical.</p> <pre><code>import numpy as np\n\nfrom toqito.state_metrics import fidelity\nfrom toqito.states import bell\n\n# Define two identical density operators.\nrho = bell(0) @ bell(0).conj().T\nsigma = bell(0) @ bell(0).conj().T\n\n# Calculate the fidelity between `rho` and `sigma`\nnp.around(fidelity(rho, sigma), decimals=2)\n</code></pre> <p>Out:</p> <pre><code>np.float64(1.0)\n</code></pre> <p>There are a number of other metrics one can compute on two density matrices including the trace norm, trace distance. These and others are also available in <code>|toqito\u27e9</code>. For a full list of distance metrics one can compute on quantum states, consult the docs.</p>"},{"location":"generated/gallery/basics/intro_tutorial/#channels","title":"Channels","text":"<p>A quantum channel can be defined as a completely positive and trace preserving linear map.</p> <p>More formally, let \\(\\mathcal{X}\\) and \\(\\mathcal{Y}\\) represent complex Euclidean spaces and let \\(\\text{L}(\\cdot)\\) represent the set of linear operators. Then a quantum channel, \\(\\Phi\\) is defined as</p> \\[ \\Phi: \\text{L}(\\mathcal{X}) \\rightarrow \\text{L}(\\mathcal{Y}) \\] <p>such that \\(\\Phi\\) is completely positive and trace preserving.</p>"},{"location":"generated/gallery/basics/intro_tutorial/#quantum-channels","title":"Quantum Channels","text":"<p>The partial trace operation is an often used in various applications of quantum information. The partial trace is defined as</p> \\[ \\left( \\text{Tr} \\otimes \\mathbb{I}_{\\mathcal{Y}} \\right) \\left(X \\otimes Y \\right) = \\text{Tr}(X)Y \\] <p>where \\(X \\in \\text{L}(\\mathcal{X})\\) and \\(Y \\in \\text{L}(\\mathcal{Y})\\) are linear operators over complex Euclidean spaces \\(\\mathcal{X}\\) and \\(\\mathcal{Y}\\).</p> <p>Consider the following matrix</p> \\[ X = \\begin{pmatrix}         1 &amp; 2 &amp; 3 &amp; 4 \\\\         5 &amp; 6 &amp; 7 &amp; 8 \\\\         9 &amp; 10 &amp; 11 &amp; 12 \\\\         13 &amp; 14 &amp; 15 &amp; 16     \\end{pmatrix}. \\] <p>Taking the partial trace over the second subsystem of \\(X\\) yields the following matrix</p> \\[ \\text{Tr}_B(X) = \\begin{pmatrix}             7 &amp; 11 \\\\             23 &amp; 27             \\end{pmatrix}. \\] <p>By default, the partial trace function in <code>|toqito\u27e9</code> takes the trace of the second subsystem.</p> <pre><code>import numpy as np\n\nfrom toqito.matrix_ops import partial_trace\n\ntest_input_mat = np.arange(1, 17).reshape(4, 4)\npartial_trace(test_input_mat)\n</code></pre> <p>Out:</p> <pre><code>array([[ 7, 11],\n       [23, 27]])\n</code></pre> <p>By specifying the <code>sys = [0]</code> argument, we can perform the partial trace over the first subsystem (instead of the default second subsystem as done above). Performing the partial trace over the first subsystem yields the following matrix</p> \\[ X_{pt, 1} = \\begin{pmatrix}                 12 &amp; 14 \\\\                 20 &amp; 22             \\end{pmatrix}. \\] <pre><code>import numpy as np\n\nfrom toqito.matrix_ops import partial_trace\n\ntest_input_mat = np.arange(1, 17).reshape(4, 4)\npartial_trace(test_input_mat, sys=[0])\n</code></pre> <p>Out:</p> <pre><code>array([[12, 14],\n       [20, 22]])\n</code></pre> <p>Another often useful channel is the partial transpose. The partial transpose is defined as</p> \\[ \\left( \\text{T} \\otimes \\mathbb{I}_{\\mathcal{Y}} \\right) \\left(X\\right) \\] <p>where \\(X \\in \\text{L}(\\mathcal{X})\\) is a linear operator over the complex Euclidean space \\(\\mathcal{X}\\) and where \\(\\text{T}\\) is the transpose mapping \\(\\text{T} \\in \\text{T}(\\mathcal{X})\\) defined as</p> \\[ \\text{T}(X) = X^{\\text{T}} \\] <p>for all \\(X \\in \\text{L}(\\mathcal{X})\\).</p> <p>Consider the following matrix</p> \\[ X = \\begin{pmatrix}         1 &amp; 2 &amp; 3 &amp; 4 \\\\         5 &amp; 6 &amp; 7 &amp; 8 \\\\         9 &amp; 10 &amp; 11 &amp; 12 \\\\         13 &amp; 14 &amp; 15 &amp; 16     \\end{pmatrix}. \\] <p>Performing the partial transpose on the matrix \\(X\\) over the second subsystem yields the following matrix</p> \\[ X^{T_B} = \\begin{pmatrix}             1 &amp; 5 &amp; 3 &amp; 7 \\\\             2 &amp; 6 &amp; 4 &amp; 8 \\\\             9 &amp; 13 &amp; 11 &amp; 15 \\\\             10 &amp; 14 &amp; 12 &amp; 16             \\end{pmatrix}. \\] <p>By default, in <code>|toqito\u27e9</code>, the partial transpose function performs the transposition on the second subsystem as follows.</p> <pre><code>import numpy as np\n\nfrom toqito.matrix_ops import partial_transpose\n\ntest_input_mat = np.arange(1, 17).reshape(4, 4)\npartial_transpose(test_input_mat)\n</code></pre> <p>Out:</p> <pre><code>array([[ 1,  5,  3,  7],\n       [ 2,  6,  4,  8],\n       [ 9, 13, 11, 15],\n       [10, 14, 12, 16]])\n</code></pre> <p>By specifying the <code>sys = [0]</code> argument, we can perform the partial transpose over the first subsystem (instead of the default second subsystem as done above). Performing the partial transpose over the first subsystem yields the following matrix</p> \\[ X_{pt, 1} = \\begin{pmatrix}                 1 &amp; 2 &amp; 9 &amp; 10 \\\\                 5 &amp; 6 &amp; 13 &amp; 14 \\\\                 3 &amp; 4 &amp; 11 &amp; 12 \\\\                 7 &amp; 8 &amp; 15 &amp; 16             \\end{pmatrix}. \\] <pre><code>import numpy as np\n\nfrom toqito.matrix_ops import partial_transpose\n\ntest_input_mat = np.arange(1, 17).reshape(4, 4)\npartial_transpose(test_input_mat, sys=[0])\n</code></pre> <p>Out:</p> <pre><code>array([[ 1,  2,  9, 10],\n       [ 5,  6, 13, 14],\n       [ 3,  4, 11, 12],\n       [ 7,  8, 15, 16]])\n</code></pre> <p>Applying Quantum Channels</p> <p>Another important operation when working with quantum channels is applying them to quantum states. <code>apply_channel</code> in <code>|toqito\u27e9</code> provides a convenient way to apply a quantum channel (represented by its Choi matrix) to a given quantum state.</p> <p>Here, we illustrate how to apply two widely used channels \u2013 the depolarizing channel and the dephasing channel \u2013 using <code>apply_channel</code>.</p> <p>Depolarizing Channel</p> <p>The depolarizing channel replaces a state with the maximally mixed state with probability \\(p\\) and leaves it unchanged with probability \\((1-p)\\). Mathematically, it is defined as</p> \\[ \\mathcal{N}(\\rho) = (1-p) \\rho + p\\,\\frac{\\mathbb{I}}{d}, \\] <p>where \\(\\mathbb{I}\\) is the identity operator and \\(d\\) is the dimension of the Hilbert space. The example below applies the depolarizing channel with \\(p=0.3\\) to the computational basis state \\(|0\\rangle\\).</p> <pre><code>import numpy as np\n\nfrom toqito.channel_ops import apply_channel\nfrom toqito.channels import depolarizing\n\n# Create a quantum state |0\u27e9\u27e80|.\nrho = np.array([[1, 0], [0, 0]])\n\n# Generate the depolarizing channel Choi matrix with noise probability p = 0.3.\nchoi = depolarizing(2, 0.3)\n\n# Apply the depolarizing channel using apply_channel.\noutput_state = apply_channel(rho, choi)\nprint(output_state)\n</code></pre> <p>Out:</p> <pre><code>[[0.65 0.  ]\n [0.   0.35]]\n</code></pre> <p>Dephasing Channel</p> <p>The dephasing channel reduces the off-diagonal elements of a density matrix without changing the diagonal entries, thereby diminishing quantum coherence. It is commonly expressed as</p> \\[ \\mathcal{N}(\\rho) = (1-p) \\rho + p\\, Z \\rho Z, \\] <p>where \\(Z\\) is the Pauli-Z operator and \\(p\\) represents the dephasing probability. The example below demonstrates how to apply the dephasing channel with \\(p=0.4\\) to the plus state \\(|+\\rangle = \\frac{1}{\\sqrt{2}}(|0\\rangle + |1\\rangle)\\).</p> <pre><code>import numpy as np\n\nfrom toqito.channel_ops import apply_channel\nfrom toqito.channels import dephasing\n\n# Create a quantum state |+\u27e9\u27e8+|.\nrho = np.array([[0.5, 0.5], [0.5, 0.5]])\n\n# Generate the dephasing channel Choi matrix with dephasing probability p = 0.4.\nchoi = dephasing(2, 0.4)\n\n# Apply the dephasing channel using apply_channel.\noutput_state = apply_channel(rho, choi)\nprint(output_state)\n</code></pre> <p>Out:</p> <pre><code>[[0.5 0.2]\n [0.2 0.5]]\n</code></pre>"},{"location":"generated/gallery/basics/intro_tutorial/#noisy-channels","title":"Noisy Channels","text":"<p>Quantum noise channels model the interaction between quantum systems and their environment, resulting in decoherence and loss of quantum information. The <code>|toqito\u27e9</code> library provides implementations of common noise models used in quantum information processing.</p> <p>Phase Damping Channel</p> <p>The phase damping channel models quantum decoherence where phase information is lost without any energy dissipation. It is characterized by a parameter \\(\\gamma\\) representing the probability of phase decoherence.</p> \\[ K_0 = \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; \\sqrt{1 - \\gamma} \\end{pmatrix}, \\quad K_1 = \\begin{pmatrix} 0 &amp; 0 \\\\ 0 &amp; \\sqrt{\\gamma} \\end{pmatrix} \\] <p>The phase damping channel can be applied to a quantum state as follows:</p> <pre><code>import numpy as np\n\nfrom toqito.channels import phase_damping\n\n# Create a density matrix with coherence.\nrho = np.array([[1, 0.5], [0.5, 1]])\n\n# Apply phase damping with \u03b3 = 0.2.\nresult = phase_damping(rho, gamma=0.2)\nprint(result)\n</code></pre> <p>Out:</p> <pre><code>[[1.       +0.j 0.4472136+0.j]\n [0.4472136+0.j 1.       +0.j]]\n</code></pre> <p>Note that the off-diagonal elements (coherences) are reduced by a factor of \\(\\sqrt{1-\\gamma}\\), while the diagonal elements (populations) remain unchanged.</p> <p>Amplitude Damping Channel</p> <p>The amplitude damping channel models energy dissipation from a quantum system to its environment, such as the spontaneous emission of a photon. It is parameterized by \\(\\gamma\\), representing the probability of losing a quantum of energy.</p> \\[ K_0 = \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; \\sqrt{1 - \\gamma} \\end{pmatrix}, \\quad K_1 = \\begin{pmatrix} 0 &amp; \\sqrt{\\gamma} \\\\ 0 &amp; 0 \\end{pmatrix} \\] <p>Here's how to use the amplitude damping channel:</p> <pre><code>import numpy as np\n\nfrom toqito.channels import amplitude_damping\n\n# Create a quantum state.\nrho = np.array([[0.5, 0.5], [0.5, 0.5]])\n\n# Apply amplitude damping with \u03b3 = 0.3.\nresult = amplitude_damping(rho, gamma=0.3)\nprint(result)\n</code></pre> <p>Out:</p> <pre><code>[[0.65      +0.j 0.41833001+0.j]\n [0.41833001+0.j 0.35      +0.j]]\n</code></pre> <p>Bit-Flip Channel</p> <p>The bit-flip channel randomly flips the state of a qubit with probability \\(p\\), analogous to the classical bit-flip error in classical information theory.</p> \\[ K_0 = \\sqrt{1 - p} \\, I = \\sqrt{1 - p} \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; 1 \\end{pmatrix}, \\quad K_1 = \\sqrt{p} \\, X = \\sqrt{p} \\begin{pmatrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\end{pmatrix} \\] <pre><code>import numpy as np\n\nfrom toqito.channels import bitflip\n\n# Create a quantum state |0\u27e9\u27e80|.\nrho = np.array([[1, 0], [0, 0]])\n\n# Apply bit-flip with probability = 0.25.\nresult = bitflip(rho, prob=0.25)\nprint(result)\n</code></pre> <p>Out:</p> <pre><code>[[0.75+0.j 0.  +0.j]\n [0.  +0.j 0.25+0.j]]\n</code></pre> <p>Observe that the result is a mixed state with 75% probability of being in state \\(|0\\rangle\\) and 25% probability of being in state \\(|1\\rangle\\), as expected for a bit flip error with probability \\(p = 0.25\\).</p> <p>Pauli Channel</p> <p>The Pauli channel is a quantum noise model that applies a probabilistic mixture of Pauli operators to a quantum state. It is defined by a probability vector \\((p_0, \\ldots, p_{4^q - 1})\\), where \\(q\\) is the number of qubits, and \\(P_i\\) are the Pauli operators acting on the system.</p> \\[ \\Phi(\\rho) = \\sum_{i=0}^{4^q - 1} p_i P_i \\rho P_i^\\dagger \\] <p>For example, when \\(q = 1\\), the Pauli operators are: \\(P_0 = I\\), \\(P_1 = X\\), \\(P_2 = Y\\), and \\(P_3 = Z\\). For multiple qubits, these operators are extended as tensor products.</p> <p>It is also worth noting that when</p> <ul> <li> <p>\\(P_2 = 0\\), and \\(P_3 = 0\\), <code>pauli_channel</code> is equivalent to a <code>bitflip</code> channel</p> </li> <li> <p>\\(P_1 = 0\\), and \\(P_2 = 0\\), <code>pauli_channel</code> is equivalent to a Phase Flip channel</p> </li> <li> <p>\\(P_1 = 0\\), and \\(P_3 = 0\\), <code>pauli_channel</code> is equivalent to a Bit and Phase Flip channel</p> </li> </ul> <p>The Pauli channel can be used to apply noise to an input quantum state or generate a Choi matrix.</p> <pre><code>import numpy as np\n\nfrom toqito.channels import pauli_channel\n\n# Define probabilities for single-qubit Pauli operators.\nprobabilities = np.array([0.5, 0.2, 0.2, 0.1])\n\n# Define an input density matrix.\nrho = np.array([[1, 0], [0, 0]])\n\n# Apply the Pauli channel.\n_, result = pauli_channel(prob=probabilities, input_mat=rho)\nprint(result)\n</code></pre> <p>Out:</p> <pre><code>[[0.6+0.j 0. +0.j]\n [0. +0.j 0.4+0.j]]\n</code></pre> <p>Here, the probabilities correspond to applying the identity (\\(I\\)), bit-flip (\\(X\\)), phase-flip (\\(Z\\)), and combined bit-phase flip (\\(Y\\)) operators.</p>"},{"location":"generated/gallery/basics/intro_tutorial/#measurements","title":"Measurements","text":"<p>A measurement can be defined as a function</p> \\[ \\mu: \\Sigma \\rightarrow \\text{Pos}(\\mathcal{X}) \\] <p>satisfying</p> \\[ \\sum_{a \\in \\Sigma} \\mu(a) = \\mathbb{I}_{\\mathcal{X}} \\] <p>where \\(\\Sigma\\) represents a set of measurement outcomes and where \\(\\mu(a)\\) represents the measurement operator associated with outcome \\(a \\in \\Sigma\\).</p>"},{"location":"generated/gallery/basics/intro_tutorial/#povm","title":"POVM","text":"<p>POVM (Positive Operator-Valued Measure) is a set of positive operators that sum up to the identity.</p> <p>Consider the following matrices:</p> \\[ M_0 = \\begin{pmatrix}     1 &amp; 0 \\\\     0 &amp; 0 \\end{pmatrix} \\quad \\text{and} \\quad M_1 = \\begin{pmatrix}     0 &amp; 0 \\\\     0 &amp; 1 \\end{pmatrix} \\] <p>Our function expects this set of operators to be a POVM because it checks if the operators sum up to the identity, ensuring that the measurement outcomes are properly normalized.</p> <pre><code>import numpy as np\n\nfrom toqito.measurement_props import is_povm\n\nmeas_1 = np.array([[1, 0], [0, 0]])\nmeas_2 = np.array([[0, 0], [0, 1]])\nmeas = [meas_1, meas_2]\nis_povm(meas)\n</code></pre> <p>Out:</p> <pre><code>True\n</code></pre>"},{"location":"generated/gallery/basics/intro_tutorial/#random-povm","title":"Random POVM","text":"<p>We may also use <code>random_povm</code> to randomly generate a POVM, and can verify that a randomly generated set satisfies the criteria for being a POVM set.</p> <pre><code>import numpy as np\n\nfrom toqito.measurement_props import is_povm\nfrom toqito.rand import random_povm\n\ndim, num_inputs, num_outputs = 2, 2, 2\nmeasurements = random_povm(dim, num_inputs, num_outputs)\nis_povm([measurements[:, :, 0, 0], measurements[:, :, 0, 1]])\n</code></pre> <p>Out:</p> <pre><code>True\n</code></pre> <p>Alternatively, the following matrices do not constitute a POVM set.</p> \\[ M_0 = \\begin{pmatrix}     1 &amp; 2 \\\\     3 &amp; 4 \\end{pmatrix} \\quad \\text{and} \\quad M_1 = \\begin{pmatrix}     5 &amp; 6 \\\\     7 &amp; 8 \\end{pmatrix}, \\] <pre><code>import numpy as np\n\nfrom toqito.measurement_props import is_povm\n\nnon_meas_1 = np.array([[1, 2], [3, 4]])\nnon_meas_2 = np.array([[5, 6], [7, 8]])\nnon_meas = [non_meas_1, non_meas_2]\nis_povm(non_meas)\n</code></pre> <p>Out:</p> <pre><code>False\n</code></pre>"},{"location":"generated/gallery/basics/intro_tutorial/#measurement-operators","title":"Measurement Operators","text":"<p>Consider the following state:</p> \\[ u = \\frac{1}{\\sqrt{3}} e_0 + \\sqrt{\\frac{2}{3}} e_1 \\] <p>where we define \\(u u^* = \\rho \\in \\text{D}(\\mathcal{X})\\) and \\(e_0\\) and \\(e_1\\) are the standard basis vectors.</p> \\[ e_0 = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} \\quad \\text{and} \\quad e_1 = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} \\] <p>The measurement operators are defined as shown below:</p> \\[ P_0 = e_0 e_0^* \\quad \\text{and} \\quad P_1 = e_1 e_1^*. \\] <pre><code>import numpy as np\n\nfrom toqito.matrices import standard_basis\nfrom toqito.measurement_ops import measure\n\ne_0, e_1 = standard_basis(2)\n\nu = (1 / np.sqrt(3)) * e_0 + (np.sqrt(2 / 3)) * e_1\nrho = u @ u.conj().T\n\nproj_0 = e_0 @ e_0.conj().T\nproj_1 = e_1 @ e_1.conj().T\n</code></pre> <p>Then the probability of obtaining outcome \\(0\\) is given by</p> \\[ \\langle P_0, \\rho \\rangle = \\frac{1}{3}. \\] <pre><code>measure(proj_0, rho)\n</code></pre> <p>Out:</p> <pre><code>np.float64(0.3333333333333334)\n</code></pre> <p>Similarly, the probability of obtaining outcome \\(1\\) is given by</p> \\[ \\langle P_1, \\rho \\rangle = \\frac{2}{3}. \\] <pre><code>measure(proj_1, rho)\n</code></pre> <p>Out:</p> <pre><code>np.float64(0.6666666666666667)\n</code></pre>"},{"location":"generated/gallery/basics/intro_tutorial/#pretty-good-measurement","title":"Pretty Good Measurement","text":"<p>Consider \"pretty good measurement\" on the set of trine states.</p> <p>The pretty good measurement (PGM), also known as the \"square root measurement\" is a set of POVMs \\((G_1, \\ldots, G_n)\\) defined as</p> \\[ G_i = P^{-1/2} \\left(p_i \\rho_i\\right) P^{-1/2} \\quad \\text{where} \\quad P = \\sum_{i=1}^n p_i \\rho_i. \\] <p>This measurement was initially defined in <sup>3</sup> and has found applications in quantum state discrimination tasks. While not always optimal, the PGM provides a reasonable measurement strategy that can be computed efficiently.</p> <p>For example, consider the following trine states:</p> \\[ u_0 = |0\\rangle, \\quad u_1 = -\\frac{1}{2}\\left(|0\\rangle + \\sqrt{3}|1\\rangle\\right), \\quad \\text{and} \\quad u_2 = -\\frac{1}{2}\\left(|0\\rangle - \\sqrt{3}|1\\rangle\\right). \\] <pre><code>from toqito.measurements import pretty_good_measurement\nfrom toqito.states import trine\n\nstates = trine()\nprobs = [1 / 3, 1 / 3, 1 / 3]\npgm = pretty_good_measurement(states, probs)\npgm\n</code></pre> <p>Out:</p> <pre><code>[array([[0.66666667, 0.        ],\n       [0.        , 0.        ]]), array([[0.16666667, 0.28867513],\n       [0.28867513, 0.5       ]]), array([[ 0.16666667, -0.28867513],\n       [-0.28867513,  0.5       ]])]\n</code></pre>"},{"location":"generated/gallery/basics/intro_tutorial/#pretty-bad-measurement","title":"Pretty Bad Measurement","text":"<p>Similarly, we can consider so-called \"pretty bad measurement\" (PBM) on the set of trine states <sup>4</sup>.</p> <p>The pretty bad measurement (PBM) is a set of POVMs \\((B_1, \\ldots, B_n)\\) defined as</p> \\[ B_i = \\left(P + (n-1)p_i \\rho_i\\right)^{-1} p_i \\rho_i \\left(P + (n-1)p_i \\rho_i\\right)^{-1} \\quad \\text{where} \\quad P = \\sum_{i=1}^n p_i \\rho_i. \\] <p>Like the PGM, the PBM provides a measurement strategy for quantum state discrimination, but with different properties that can be useful in certain contexts.</p> \\[ u_0 = |0\\rangle, \\quad u_1 = -\\frac{1}{2}\\left(|0\\rangle + \\sqrt{3}|1\\rangle\\right), \\quad \\text{and} \\quad u_2 = -\\frac{1}{2}\\left(|0\\rangle - \\sqrt{3}|1\\rangle\\right). \\] <pre><code>from toqito.measurements import pretty_bad_measurement\nfrom toqito.states import trine\n\nstates = trine()\nprobs = [1 / 3, 1 / 3, 1 / 3]\npbm = pretty_bad_measurement(states, probs)\npbm\n</code></pre> <p>Out:</p> <pre><code>[array([[0.16666667, 0.        ],\n       [0.        , 0.5       ]]), array([[ 0.41666667, -0.14433757],\n       [-0.14433757,  0.25      ]]), array([[0.41666667, 0.14433757],\n       [0.14433757, 0.25      ]])]\n</code></pre> <p>Total running time of the script: ( 0 minutes  4.761 seconds)</p> <p> Download Python source code: intro_tutorial.py</p> <p> Download Jupyter notebook: intro_tutorial.ipynb</p> <p>Gallery generated by mkdocs-gallery</p> <ol> <li> <p>Michael A. Nielsen and Isaac L. Chuang. Quantum Computation and Quantum Information: 10th Anniversary Edition. Cambridge University Press, USA, 10th edition, 2011. ISBN 1107002176.\u00a0\u21a9</p> </li> <li> <p>John Watrous. The Theory of Quantum Information. Cambridge University Press, 2018. URL: https://cs.uwaterloo.ca/~watrous/TQI/TQI.pdf, doi:10.1017/9781316848142.\u00a0\u21a9</p> </li> <li> <p>Lane P Hughston, Richard Jozsa, and William K Wootters. A complete classification of quantum ensembles having a given density matrix. Physics Letters A, 183(1):14\u201318, 1993.\u00a0\u21a9</p> </li> <li> <p>Caleb McIrvin, Ankith Mohan, and Jamie Sikora. The pretty bad measurement. 2024. arXiv:2403.17252.\u00a0\u21a9</p> </li> </ol>"},{"location":"generated/gallery/basics/mg_execution_times/","title":"Computation times","text":"<p>00:04.761 total execution time for generated_gallery_basics files:</p> <p>+-----------------------------------------------------------------------------------+-----------+--------+ | intro_tutorial (content/examples/basics/intro_tutorial.py) | 00:04.761 | 0.0 MB | +-----------------------------------------------------------------------------------+-----------+--------+</p>"},{"location":"generated/gallery/extended_nonlocal_games/bit_commitment/","title":"Modeling Bit Commitment Binding Failure","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/extended_nonlocal_games/bit_commitment/#modeling-bit-commitment-binding-failure","title":"Modeling Bit Commitment Binding Failure","text":"<p>In this tutorial, we will model a quantum bit commitment protocol as an extended nonlocal game where the \"player\" Alice attempts to cheat. Instead of calculating a cooperative winning probability, we will quantify Alice's maximum cheating probability. This allows us to provide a concrete illustration of the failure of the binding property, a key aspect of the famous Mayers-Lo-Chau (MLC) no-go theorem <sup>1</sup><sup>2</sup>.</p> <p>A bit commitment (BC) protocol is a cryptographic task involving two parties, Alice (the sender) and Bob (the receiver), which proceeds in two phases:</p> <ol> <li>Commit Phase: Alice chooses a secret bit \\(b\\) and provides Bob with     a piece of evidence (in this case, a quantum state).</li> <li>Reveal Phase: At a later time, Alice announces the value of her bit, say     \\(b'\\), and provides information that allows Bob to use his evidence     from the commit phase to verify her claim.</li> </ol> <p>For the protocol to be secure, it must satisfy two fundamental properties:</p> <ul> <li>Hiding: The evidence Bob receives during the Commit Phase must reveal   essentially no information about the value of Alice's bit \\(b\\). Bob   should not be able to distinguish the evidence for \\(b=0\\) from the   evidence for \\(b=1\\).</li> <li>Binding: Alice must be \"locked in\" to her choice after the Commit Phase.   She should not be able to change her mind and successfully convince Bob of a   different bit during the Reveal Phase. If she committed to \\(b=0\\),   she cannot successfully open the commitment as \\(b=1\\).</li> </ul> <p>The Mayers-Lo-Chau (MLC) no-go theorem <sup>1</sup><sup>2</sup> proves that no quantum protocol can be both perfectly hiding and binding. Here, we will use the <code>ExtendedNonlocalGame</code> framework not to prove the full theorem in its generality, but to illustrate the failure of the binding property. We will model a simplified, single-shot protocol to make the abstract threat of cheating concrete and quantifiable.</p> <p>The core of this impossibility proof lies in Alice's ability to use an Einstein-Podolsky-Rosen (EPR) type of attack <sup>1</sup><sup>2</sup>: she prepares an entangled state and shares one part with Bob, keeping the other. This entanglement allows her to delay her decision and \"steer\" the outcome to her advantage later on.</p> <p>The failure of binding property occurs when the protocol is hiding but not binding, allowing Alice to \"change her mind.\" We can frame this as a game where Alice wins if she can successfully respond to a challenge from the referee (playing the role of Bob).</p>"},{"location":"generated/gallery/extended_nonlocal_games/bit_commitment/#setting-up-the-bit-commitment-game","title":"Setting Up the Bit Commitment Game","text":"<ul> <li> <p>Players: The game models the two-party protocol between Alice (the     committer) and Bob (the receiver). To fit this cryptographic scenario into     our framework, we model the verifier, Bob, as the Referee who issues     the challenge. The 'player Bob' defined in the code is therefore a     simple stand-in with trivial inputs and outputs, as his active role     is handled by the Referee.</p> </li> <li> <p>The Challenge (Referee's Input): The Referee (Bob) will challenge Alice     to reveal her commitment to either bit \\(0\\) or bit \\(1\\). This is the Referee's     input, \\(y\\), which can be \\(0\\) or \\(1\\). We assume he chooses between them with     equal probability, so \\(\\pi(y=0) = \\pi(y=1) = 0.5\\).</p> </li> <li> <p>Alice's Strategy (The Quantum State): In this game, Alice's entire     strategy is encapsulated in the initial quantum state she prepares and     shares with the Referee. Because she doesn't receive a question or return     an answer in the traditional sense, her inputs \\(x\\) and outputs \\(a\\) are trivial.</p> </li> <li> <p>The Winning Condition (Referee's Measurement): Alice wins if the state she     gives the Referee passes his verification test.</p> <ul> <li>If challenged with \\(y=0\\), the Referee measures with the projector for bit   \\(0\\), \\(V(y=0) = |0\\rangle\\langle 0|\\).</li> <li>If challenged with \\(y=1\\), the Referee measures with the projector for bit   \\(1\\), \\(V(y=1) = |+\\rangle\\langle +|\\).</li> </ul> </li> </ul> <p>This choice of measurement bases is illustrative and inspired by states used in quantum key distribution. The power of the no-go theorem is that the protocol would remain insecure regardless of the specific orthogonal states Bob uses for his verification.</p> <p>Now, let's translate this game into code.</p> <pre><code>import numpy as np\n\nfrom toqito.states import basis\n\n# 1. Define Game Parameters\ndim = 2\na_in, b_in = 1, 2\na_out, b_out = 1, 1\n\n# 2. Define the Probability Matrix\nbc_prob_mat = np.array([[0.5, 0.5]])\n\n# 3. Define the Winning Condition Operators\ne_0, e_1 = basis(2, 0), basis(2, 1)\ne_p = (e_0 + e_1) / np.sqrt(2)\n\n# Verification projector for bit 0 is a projection onto |0&gt;.\nproj_0 = e_0 @ e_0.conj().T\n# Verification projector for bit 1 is a projection onto |+&gt;.\nproj_p = e_p @ e_p.conj().T\n\n# 4. Assemble the Predicate Matrix V(a,b|x,y)\nbc_pred_mat = np.zeros([dim, dim, a_out, b_out, a_in, b_in])\n\n# If Referee's challenge is y=0 (b_in=0), the winning operator is proj_0.\nbc_pred_mat[:, :, 0, 0, 0, 0] = proj_0\n\n# If Referee's challenge is y=1 (b_in=1), the winning operator is proj_p.\nbc_pred_mat[:, :, 0, 0, 0, 1] = proj_p\n</code></pre> <p>Calculating Alice's Maximum Cheating Probability</p> <pre><code>from toqito.nonlocal_games.extended_nonlocal_game import ExtendedNonlocalGame\n\nbc_binding_game = ExtendedNonlocalGame(bc_prob_mat, bc_pred_mat)\n\n# We use the NPA hierarchy (level 1) for a robust upper bound on the quantum value.\nq_val = bc_binding_game.commuting_measurement_value_upper_bound(k=1)\n\nprint(\"Upper bound on the quantum value (Alice's cheating probability): \", np.around(q_val, decimals=5))\n# mkdocs_gallery_thumbnail_path = 'figures/logo.png'\n</code></pre> <p>Out:</p> <pre><code>/home/runner/work/toqito/toqito/.venv/lib/python3.12/site-packages/scs/__init__.py:83: UserWarning: Converting A to a CSC (compressed sparse column) matrix; may take a while.\n  warn(\nUpper bound on the quantum value (Alice's cheating probability):  0.85355\n</code></pre>"},{"location":"generated/gallery/extended_nonlocal_games/bit_commitment/#interpreting-the-result","title":"Interpreting the Result","text":"<p>The value returned by the solver, \\(\\approx 0.85355\\), is not arbitrary. It represents the maximum possible success probability for Alice and can be derived from fundamental quantum mechanics.</p> <p>Alice's average winning probability is the expectation value of an operator representing the average of the two possible measurements:</p> \\[ P(\\text{win}) = \\mathbb{E}[V] = 0.5 \\cdot \\text{Tr}(V(y=0) \\rho) + 0.5 \\cdot \\text{Tr}(V(y=1) \\rho) = \\text{Tr}\\left( \\left[0.5 \\cdot (proj_0 + proj_p)\\right] \\rho \\right) \\] <p>where \\(\\rho\\) is the state of the Referee's qubit. A key principle of quantum mechanics states that the maximum expectation value of an operator is its largest eigenvalue. The operator here is \\(M = 0.5 \\cdot (proj_0 + proj_p)\\).</p> <p>The largest eigenvalue of this operator \\(M\\) is:</p> \\[ \\lambda_{\\max}(M) = \\frac{1}{2}\\left(1 + \\frac{1}{\\sqrt{2}}\\right) \\approx 0.85355. \\] <p>We found this exact value using <code>|toqito\u27e9</code>. In a secure protocol, the best Alice could hope for is a \\(50\\)%  success rate (by guessing the challenge). The fact that she can achieve over \\(85\\)% demonstrates a catastrophic failure of the binding property, confirming the no-go theorem.</p> <p>It is important to note that this value of \\(\\approx 0.85355\\) represents the maximum cheating probability for this specific, imperfectly hiding game. The full MLC no-go theorem makes an even stronger claim: for any protocol that is perfectly hiding (where Bob cannot gain any information at all about the bit before the reveal phase), Alice's cheating strategy can succeed with \\(100\\)% probability. This example demonstrates the fragility of the binding property, which worsens to a total failure in the perfectly hiding limit.</p> <p>Total running time of the script: ( 0 minutes  0.594 seconds)</p> <p> Download Python source code: bit_commitment.py</p> <p> Download Jupyter notebook: bit_commitment.ipynb</p> <p>Gallery generated by mkdocs-gallery</p> <ol> <li> <p>Dominic Mayers. Unconditionally secure quantum bit commitment is impossible. Phys. Rev. Lett., 78:3414\u20133417, Apr 1997. URL: https://link.aps.org/doi/10.1103/PhysRevLett.78.3414, doi:10.1103/PhysRevLett.78.3414.\u00a0\u21a9\u21a9\u21a9</p> </li> <li> <p>Hoi-Kwong Lo and H. F. Chau. Why quantum bit commitment and ideal quantum coin tossing are impossible. 1997. arXiv:quant-ph/9711065.\u00a0\u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"generated/gallery/extended_nonlocal_games/enlg_bb84/","title":"The BB84 extended nonlocal game","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/extended_nonlocal_games/enlg_bb84/#the-bb84-extended-nonlocal-game","title":"The BB84 extended nonlocal game","text":"<p>In our Extended nonlocal games tutorial, we introduced the framework for extended nonlocal games. Now, we will construct our first concrete example, the BB84 extended nonlocal game.</p> <p>The BB84 extended nonlocal game is defined as follows. Let \\(\\Sigma_A = \\Sigma_B = \\Gamma_A = \\Gamma_B = \\{0,1\\}\\), define</p> \\[ \\begin{equation} \\begin{aligned} V(0,0|0,0) = \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; 0 \\end{pmatrix}, &amp;\\quad V(1,1|0,0) = \\begin{pmatrix} 0 &amp; 0 \\\\ 0 &amp; 1 \\end{pmatrix}, \\\\ V(0,0|1,1) = \\frac{1}{2}\\begin{pmatrix} 1 &amp; 1 \\\\ 1 &amp; 1 \\end{pmatrix}, &amp;\\quad V(1,1|1,1) = \\frac{1}{2}\\begin{pmatrix} 1 &amp; -1 \\\\ -1 &amp; 1 \\end{pmatrix}, \\end{aligned} \\end{equation} \\] <p>define</p> \\[ V(a,b|x,y) = \\begin{pmatrix} 0 &amp; 0 \\\\ 0 &amp; 0 \\end{pmatrix} \\] <p>for all \\(a \\not= b\\) or \\(x \\not= y\\), define \\(\\pi(0,0) = \\pi(1,1) = 1/2\\), and define \\(\\pi(x,y) = 0\\) if \\(x \\not=y\\).</p> <p>We can encode the BB84 game, \\(G_{BB84} = (\\pi, V)\\), in <code>numpy</code> arrays where <code>prob_mat</code> corresponds to the probability distribution \\(\\pi\\) and where <code>pred_mat</code> corresponds to the operator \\(V\\).</p> <pre><code># Define the BB84 extended nonlocal game.\nimport numpy as np\n\nfrom toqito.states import basis\n\n# The basis: {|0&gt;, |1&gt;}:\ne_0, e_1 = basis(2, 0), basis(2, 1)\n\n# The basis: {|+&gt;, |-&gt;}:\ne_p = (e_0 + e_1) / np.sqrt(2)\ne_m = (e_0 - e_1) / np.sqrt(2)\n\n# The dimension of referee's measurement operators:\ndim = 2\n# The number of outputs for Alice and Bob:\na_out, b_out = 2, 2\n# The number of inputs for Alice and Bob:\na_in, b_in = 2, 2\n\n# Define the predicate matrix V(a,b|x,y) \\in Pos(R)\nbb84_pred_mat = np.zeros([dim, dim, a_out, b_out, a_in, b_in])\n\n# V(0,0|0,0) = |0&gt;&lt;0|\nbb84_pred_mat[:, :, 0, 0, 0, 0] = e_0 @ e_0.conj().T\n# V(1,1|0,0) = |1&gt;&lt;1|\nbb84_pred_mat[:, :, 1, 1, 0, 0] = e_1 @ e_1.conj().T\n# V(0,0|1,1) = |+&gt;&lt;+|\nbb84_pred_mat[:, :, 0, 0, 1, 1] = e_p @ e_p.conj().T\n# V(1,1|1,1) = |-&gt;&lt;-|\nbb84_pred_mat[:, :, 1, 1, 1, 1] = e_m @ e_m.conj().T\n\n# The probability matrix encode \\pi(0,0) = \\pi(1,1) = 1/2\nbb84_prob_mat = 1 / 2 * np.identity(2)\n</code></pre>"},{"location":"generated/gallery/extended_nonlocal_games/enlg_bb84/#the-unentangled-value-of-the-bb84-extended-nonlocal-game","title":"The unentangled value of the BB84 extended nonlocal game","text":"<p>It was shown in <sup>1</sup> and <sup>2</sup> that</p> \\[ \\omega(G_{BB84}) = \\cos^2(\\pi/8). \\] <p>This can be verified in <code>|toqito\u27e9</code> as follows.</p> <pre><code># Calculate the unentangled value of the BB84 extended nonlocal game.\nimport numpy as np\n\nfrom toqito.nonlocal_games.extended_nonlocal_game import ExtendedNonlocalGame\n\n# Define an ExtendedNonlocalGame object based on the BB84 game.\nbb84 = ExtendedNonlocalGame(bb84_prob_mat, bb84_pred_mat)\n\n# The unentangled value is cos(pi/8)**2 \\approx 0.85356\nprint(\"The unentangled value is \", np.around(bb84.unentangled_value(), decimals=2))\n</code></pre> <p>Out:</p> <pre><code>The unentangled value is  0.85\n</code></pre> <p>The BB84 game also exhibits strong parallel repetition. We can specify how many parallel repetitions for <code>|toqito\u27e9</code> to run. The example below provides an example of two parallel repetitions for the BB84 game.</p> <pre><code># The unentangled value of BB84 under parallel repetition.\nimport numpy as np\n\nfrom toqito.nonlocal_games.extended_nonlocal_game import ExtendedNonlocalGame\n\n# Define the bb84 game for two parallel repetitions.\nbb84_2_reps = ExtendedNonlocalGame(bb84_prob_mat, bb84_pred_mat, 2)\n\n# The unentangled value for two parallel repetitions is cos(pi/8)**4 \\approx 0.72855\nprint(\"The unentangled value for two parallel repetitions is \", np.around(bb84_2_reps.unentangled_value(), decimals=2))\n</code></pre> <p>Out:</p> <pre><code>The unentangled value for two parallel repetitions is  0.73\n</code></pre> <p>It was shown in <sup>2</sup> that the BB84 game possesses the property of strong parallel repetition. That is,</p> \\[ \\omega(G_{BB84}^r) = \\omega(G_{BB84})^r \\] <p>for any integer \\(r\\).</p>"},{"location":"generated/gallery/extended_nonlocal_games/enlg_bb84/#the-standard-quantum-value-of-the-bb84-extended-nonlocal-game","title":"The standard quantum value of the BB84 extended nonlocal game","text":"<p>We can calculate lower bounds on the standard quantum value of the BB84 game using <code>|toqito\u27e9</code> as well.</p> <pre><code># Calculate lower bounds on the standard quantum value of the BB84 extended nonlocal game.\nimport numpy as np\n\nfrom toqito.nonlocal_games.extended_nonlocal_game import ExtendedNonlocalGame\n\n# Define an ExtendedNonlocalGame object based on the BB84 game.\nbb84_lb = ExtendedNonlocalGame(bb84_prob_mat, bb84_pred_mat)\n\n# The standard quantum value is cos(pi/8)**2 \\approx 0.85356\nprint(\"The standard quantum value is \", np.around(bb84_lb.quantum_value_lower_bound(), decimals=2))\n</code></pre> <p>Out:</p> <pre><code>/home/runner/work/toqito/toqito/.venv/lib/python3.12/site-packages/scs/__init__.py:83: UserWarning: Converting A to a CSC (compressed sparse column) matrix; may take a while.\n  warn(\nThe standard quantum value is  0.85\n</code></pre> <p>From <sup>2</sup>, it is known that \\(\\omega(G_{BB84}) = \\omega^*(G_{BB84})\\), however, if we did not know this beforehand, we could attempt to calculate upper bounds on the standard quantum value.</p> <p>There are a few methods to do this, but one easy way is to simply calculate the non-signaling value of the game as this provides a natural upper bound on the standard quantum value. Typically, this bound is not tight and usually not all that useful in providing tight upper bounds on the standard quantum value, however, in this case, it will prove to be useful.</p>"},{"location":"generated/gallery/extended_nonlocal_games/enlg_bb84/#the-non-signaling-value-of-the-bb84-extended-nonlocal-game","title":"The non-signaling value of the BB84 extended nonlocal game","text":"<p>Using <code>|toqito\u27e9</code>, we can see that \\(\\omega_{ns}(G) = \\cos^2(\\pi/8)\\).</p> <pre><code># Calculate the non-signaling value of the BB84 extended nonlocal game.\nimport numpy as np\n\nfrom toqito.nonlocal_games.extended_nonlocal_game import ExtendedNonlocalGame\n\n# Define an ExtendedNonlocalGame object based on the BB84 game.\nbb84 = ExtendedNonlocalGame(bb84_prob_mat, bb84_pred_mat)\n\n# The non-signaling value is cos(pi/8)**2 \\approx 0.85356\nprint(\"The non-signaling value is \", np.around(bb84.nonsignaling_value(), decimals=2))\n</code></pre> <p>Out:</p> <pre><code>/home/runner/work/toqito/toqito/.venv/lib/python3.12/site-packages/scs/__init__.py:83: UserWarning: Converting A to a CSC (compressed sparse column) matrix; may take a while.\n  warn(\nThe non-signaling value is  0.85\n</code></pre> <p>So we have the relationship that</p> \\[ \\omega(G_{BB84}) = \\omega^*(G_{BB84}) = \\omega_{ns}(G_{BB84}) = \\cos^2(\\pi/8). \\] <p>It turns out that strong parallel repetition does not hold in the non-signaling scenario for the BB84 game. This was shown in <sup>3</sup>, and we can observe this by the following snippet.</p> <pre><code># The non-signaling value of BB84 under parallel repetition.\nimport numpy as np\n\n# mkdocs_gallery_thumbnail_path = 'figures/extended_nonlocal_game.svg'\nfrom toqito.nonlocal_games.extended_nonlocal_game import ExtendedNonlocalGame\n\n# Define the bb84 game for two parallel repetitions.\nbb84_2_reps = ExtendedNonlocalGame(bb84_prob_mat, bb84_pred_mat, 2)\n\n# The non-signaling value for two parallel repetitions is cos(pi/8)**4 \\approx 0.73825\nprint(\n    \"The non-signaling value for two parallel repetitions is \", np.around(bb84_2_reps.nonsignaling_value(), decimals=2)\n)\n</code></pre> <p>Out:</p> <pre><code>/home/runner/work/toqito/toqito/.venv/lib/python3.12/site-packages/scs/__init__.py:83: UserWarning: Converting A to a CSC (compressed sparse column) matrix; may take a while.\n  warn(\nThe non-signaling value for two parallel repetitions is  0.74\n</code></pre> <p>Note that \\(0.73825 \\geq \\cos(\\pi/8)^4 \\approx 0.72855\\) and therefore we have that</p> \\[ \\omega_{ns}(G^r_{BB84}) \\not= \\omega_{ns}(G_{BB84})^r \\] <p>for \\(r = 2\\).</p> <p>Next, we will explore another well-known example, The CHSH extended nonlocal game, and see how its properties compare.</p> <p>Total running time of the script: ( 0 minutes  8.500 seconds)</p> <p> Download Python source code: enlg_bb84.py</p> <p> Download Jupyter notebook: enlg_bb84.ipynb</p> <p>Gallery generated by mkdocs-gallery</p> <ol> <li> <p>Marco Tomamichel, Serge Fehr, J\u0119drzej Kaniewski, and Stephanie Wehner. A monogamy-of-entanglement game with applications to device-independent quantum cryptography. New Journal of Physics, 15(10):103002, oct 2013. URL: http://dx.doi.org/10.1088/1367-2630/15/10/103002, doi:10.1088/1367-2630/15/10/103002.\u00a0\u21a9</p> </li> <li> <p>Nathaniel Johnston, Rajat Mittal, Vincent Russo, and John Watrous. Extended non-local games and monogamy-of-entanglement games. Proceedings of the Royal Society A: Mathematical, Physical and Engineering Sciences, 472(2189):20160003, May 2016. URL: https://arxiv.org/abs/1510.02083.\u00a0\u21a9\u21a9\u21a9</p> </li> <li> <p>Vincent Russo. Extended nonlocal games. 2017. arXiv:1704.07375.\u00a0\u21a9</p> </li> </ol>"},{"location":"generated/gallery/extended_nonlocal_games/enlg_chsh/","title":"The CHSH extended nonlocal game","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/extended_nonlocal_games/enlg_chsh/#the-chsh-extended-nonlocal-game","title":"The CHSH extended nonlocal game","text":"<p>Following our analysis of the BB84 game, let us now define another important extended nonlocal game, \\(G_{CHSH}\\). This game is defined by a winning condition reminiscent of the standard CHSH nonlocal game.</p> <p>Let \\(\\Sigma_A = \\Sigma_B = \\Gamma_A = \\Gamma_B = \\{0,1\\}\\), define a collection of measurements \\(\\{V(a,b|x,y) : a \\in \\Gamma_A, b \\in \\Gamma_B, x \\in \\Sigma_A, y \\in \\Sigma_B\\} \\subset \\text{Pos}(\\mathcal{R})\\) such that</p> \\[ \\begin{equation} \\begin{aligned} V(0,0|0,0) = V(0,0|0,1) = V(0,0|1,0) = \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; 0 \\end{pmatrix}, \\\\ V(1,1|0,0) = V(1,1|0,1) = V(1,1|1,0) = \\begin{pmatrix} 0 &amp; 0 \\\\ 0 &amp; 1 \\end{pmatrix}, \\\\ V(0,1|1,1) = \\frac{1}{2}\\begin{pmatrix} 1 &amp; 1 \\\\ 1 &amp; 1 \\end{pmatrix}, \\\\ V(1,0|1,1) = \\frac{1}{2} \\begin{pmatrix} 1 &amp; -1 \\\\ -1 &amp; 1 \\end{pmatrix}, \\end{aligned} \\end{equation} \\] <p>define</p> \\[ V(a,b|x,y) = \\begin{pmatrix} 0 &amp; 0 \\\\ 0 &amp; 0 \\end{pmatrix} \\] <p>for all \\(a \\oplus b \\not= x \\land y\\), and define \\(\\pi(0,0) = \\pi(0,1) = \\pi(1,0) = \\pi(1,1) = 1/4\\).</p> <p>In the event that \\(a \\oplus b \\not= x \\land y\\), the referee's measurement corresponds to the zero matrix. If instead it happens that \\(a \\oplus b = x \\land y\\), the referee then proceeds to measure with respect to one of the measurement operators. This winning condition is reminiscent of the standard CHSH nonlocal game.</p> <p>We can encode \\(G_{CHSH}\\) in a similar way using <code>numpy</code> arrays as we did for \\(G_{BB84}\\).</p> <pre><code># Define the CHSH extended nonlocal game.\nimport numpy as np\n\n# The dimension of referee's measurement operators:\ndim = 2\n# The number of outputs for Alice and Bob:\na_out, b_out = 2, 2\n# The number of inputs for Alice and Bob:\na_in, b_in = 2, 2\n\n# Define the predicate matrix V(a,b|x,y) \\in Pos(R)\nchsh_pred_mat = np.zeros([dim, dim, a_out, b_out, a_in, b_in])\n\n# V(0,0|0,0) = V(0,0|0,1) = V(0,0|1,0).\nchsh_pred_mat[:, :, 0, 0, 0, 0] = np.array([[1, 0], [0, 0]])\nchsh_pred_mat[:, :, 0, 0, 0, 1] = np.array([[1, 0], [0, 0]])\nchsh_pred_mat[:, :, 0, 0, 1, 0] = np.array([[1, 0], [0, 0]])\n\n# V(1,1|0,0) = V(1,1|0,1) = V(1,1|1,0).\nchsh_pred_mat[:, :, 1, 1, 0, 0] = np.array([[0, 0], [0, 1]])\nchsh_pred_mat[:, :, 1, 1, 0, 1] = np.array([[0, 0], [0, 1]])\nchsh_pred_mat[:, :, 1, 1, 1, 0] = np.array([[0, 0], [0, 1]])\n\n# V(0,1|1,1)\nchsh_pred_mat[:, :, 0, 1, 1, 1] = 1 / 2 * np.array([[1, 1], [1, 1]])\n\n# V(1,0|1,1)\nchsh_pred_mat[:, :, 1, 0, 1, 1] = 1 / 2 * np.array([[1, -1], [-1, 1]])\n\n# The probability matrix encode \\pi(0,0) = \\pi(0,1) = \\pi(1,0) = \\pi(1,1) = 1/4.\nchsh_prob_mat = np.array([[1 / 4, 1 / 4], [1 / 4, 1 / 4]])\n</code></pre>"},{"location":"generated/gallery/extended_nonlocal_games/enlg_chsh/#example-the-unentangled-value-of-the-chsh-extended-nonlocal-game","title":"Example: The unentangled value of the CHSH extended nonlocal game","text":"<p>Similar to what we did for the BB84 extended nonlocal game, we can also compute the unentangled value of \\(G_{CHSH}\\).</p> <pre><code># Calculate the unentangled value of the CHSH extended nonlocal game\nimport numpy as np\n\nfrom toqito.nonlocal_games.extended_nonlocal_game import ExtendedNonlocalGame\n\n# Define an ExtendedNonlocalGame object based on the CHSH game.\nchsh = ExtendedNonlocalGame(chsh_prob_mat, chsh_pred_mat)\n\n# The unentangled value is 3/4 = 0.75\nprint(\"The unentangled value is \", np.around(chsh.unentangled_value(), decimals=2))\n</code></pre> <p>Out:</p> <pre><code>The unentangled value is  0.75\n</code></pre> <p>We can also run multiple repetitions of \\(G_{CHSH}\\).</p> <pre><code># The unentangled value of CHSH under parallel repetition.\nimport numpy as np\n\nfrom toqito.nonlocal_games.extended_nonlocal_game import ExtendedNonlocalGame\n\n# Define the CHSH game for two parallel repetitions.\nchsh_2_reps = ExtendedNonlocalGame(chsh_prob_mat, chsh_pred_mat, 2)\n\n# The unentangled value for two parallel repetitions is (3/4)**2 \\approx 0.5625\nprint(\"The unentangled value for two parallel repetitions is \", np.around(chsh_2_reps.unentangled_value(), decimals=2))\n</code></pre> <p>Out:</p> <pre><code>The unentangled value for two parallel repetitions is  0.56\n</code></pre> <p>Note that strong parallel repetition holds as</p> \\[ \\omega(G_{CHSH})^2 = \\omega(G_{CHSH}^2) = \\left(\\frac{3}{4}\\right)^2. \\]"},{"location":"generated/gallery/extended_nonlocal_games/enlg_chsh/#example-the-non-signaling-value-of-the-chsh-extended-nonlocal-game","title":"Example: The non-signaling value of the CHSH extended nonlocal game","text":"<p>To obtain an upper bound for \\(G_{CHSH}\\), we can calculate the non-signaling value.</p> <pre><code># Calculate the non-signaling value of the CHSH extended nonlocal game.\nimport numpy as np\n\nfrom toqito.nonlocal_games.extended_nonlocal_game import ExtendedNonlocalGame\n\n# Define an ExtendedNonlocalGame object based on the CHSH game.\nchsh = ExtendedNonlocalGame(chsh_prob_mat, chsh_pred_mat)\n\n# The non-signaling value is 3/4 = 0.75\nprint(\"The non-signaling value is \", np.around(chsh.nonsignaling_value(), decimals=2))\n# mkdocs_gallery_thumbnail_path = 'figures/logo.png'\n</code></pre> <p>Out:</p> <pre><code>/home/runner/work/toqito/toqito/.venv/lib/python3.12/site-packages/scs/__init__.py:83: UserWarning: Converting A to a CSC (compressed sparse column) matrix; may take a while.\n  warn(\nThe non-signaling value is  0.75\n</code></pre> <p>As we know that \\(\\omega(G_{CHSH}) = \\omega_{ns}(G_{CHSH}) = 3/4\\) and that</p> \\[ \\omega(G) \\leq \\omega^*(G) \\leq \\omega_{ns}(G) \\] <p>for any extended nonlocal game, \\(G\\), we may also conclude that \\(\\omega^*(G_{CHSH}) = 3/4\\).</p> <p>So far, both the BB84 and CHSH examples have demonstrated cases where the unentangled and standard quantum values are equal. In the next tutorial,  An extended nonlocal game with quantum advantage we will explore a game based on mutually unbiased bases that exhibits a strict quantum advantage, where \\(\\omega(G) &lt; \\omega^*(G)\\).</p> <p>Total running time of the script: ( 0 minutes  4.771 seconds)</p> <p> Download Python source code: enlg_chsh.py</p> <p> Download Jupyter notebook: enlg_chsh.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/extended_nonlocal_games/enlg_introduction/","title":"Extended nonlocal games","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/extended_nonlocal_games/enlg_introduction/#extended-nonlocal-games","title":"Extended nonlocal games","text":"<p>In this tutorial, we will define the concept of an extended nonlocal game. Extended nonlocal games are a more general abstraction of nonlocal games wherein the referee, who previously only provided questions and answers to the players, now share a state with the players and is able to perform a measurement on that shared state.</p> <p>Every extended nonlocal game has a value associated to it. Analogously to nonlocal games, this value is a quantity that dictates how well the players can perform a task in the extended nonlocal game model when given access to certain resources. We will be using <code>|toqito\u27e9</code> to calculate these quantities.</p> <p>We will also look at existing results in the literature on these values and be able to replicate them using <code>|toqito\u27e9</code>. Much of the written content in this tutorial will be directly taken from <sup>1</sup>.</p> <p>Extended nonlocal games have a natural physical interpretation in the setting of tripartite steering <sup>2</sup> and in device-independent quantum scenarios <sup>3</sup>. For more information on extended nonlocal games, please refer to <sup>4</sup> and <sup>1</sup>.</p>"},{"location":"generated/gallery/extended_nonlocal_games/enlg_introduction/#the-extended-nonlocal-game-model","title":"The extended nonlocal game model","text":"<p>An extended nonlocal game is similar to a nonlocal game in the sense that it is a cooperative game played between two players Alice and Bob against a referee. The game begins much like a nonlocal game, with the referee selecting and sending a pair of questions \\((x,y)\\) according to a fixed probability distribution. Once Alice and Bob receive \\(x\\) and \\(y\\), they respond with respective answers \\(a\\) and \\(b\\). Unlike a nonlocal game, the outcome of an extended nonlocal game is determined by measurements performed by the referee on its share of the state initially provided to it by Alice and Bob.</p> <p></p> <p>An extended nonlocal game. </p> <p>Specifically, Alice and Bob's winning probability is determined by collections of measurements, \\(V(a,b|x,y) \\in \\text{Pos}(\\mathcal{R})\\), where \\(\\mathcal{R} = \\mathbb{C}^m\\) is a complex Euclidean space with \\(m\\) denoting the dimension of the referee's quantum system--so if Alice and Bob's response \\((a,b)\\) to the question pair \\((x,y)\\) leaves the referee's system in the quantum state</p> \\[ \\sigma_{a,b}^{x,y} \\in \\text{D}(\\mathcal{R}), \\] <p>then their winning and losing probabilities are given by</p> \\[ \\left\\langle V(a,b|x,y), \\sigma_{a,b}^{x,y} \\right\\rangle \\quad \\text{and} \\quad \\left\\langle \\mathbb{I} - V(a,b|x,y), \\sigma_{a,b}^{x,y} \\right\\rangle. \\]"},{"location":"generated/gallery/extended_nonlocal_games/enlg_introduction/#strategies-for-extended-nonlocal-games","title":"Strategies for extended nonlocal games","text":"<p>An extended nonlocal game \\(G\\) is defined by a pair \\((\\pi, V)\\), where \\(\\pi\\) is a probability distribution of the form</p> \\[ \\pi : \\Sigma_A \\times \\Sigma_B \\rightarrow [0, 1] \\] <p>on the Cartesian product of two alphabets \\(\\Sigma_A\\) and \\(\\Sigma_B\\), and \\(V\\) is a function of the form</p> \\[ V : \\Gamma_A \\times \\Gamma_B \\times \\Sigma_A \\times \\Sigma_B \\rightarrow \\text{Pos}(\\mathcal{R}) \\] <p>for \\(\\Sigma_A\\) and \\(\\Sigma_B\\) as above, \\(\\Gamma_A\\) and \\(\\Gamma_B\\) being alphabets, and \\(\\mathcal{R}\\) refers to the referee's space. Just as in the case for nonlocal games, we shall use the convention that</p> \\[ \\Sigma = \\Sigma_A \\times \\Sigma_B \\quad \\text{and} \\quad \\Gamma = \\Gamma_A \\times \\Gamma_B \\] <p>to denote the respective sets of questions asked to Alice and Bob and the sets of answers sent from Alice and Bob to the referee.</p> <p>When analyzing a strategy for Alice and Bob, it may be convenient to define a function</p> \\[ K : \\Gamma_A \\times \\Gamma_B \\times \\Sigma_A \\times \\Sigma_B \\rightarrow \\text{Pos}(\\mathcal{R}). \\] <p>We can represent Alice and Bob's winning probability for an extended nonlocal game as</p> \\[ \\sum_{(x,y) \\in \\Sigma} \\pi(x,y) \\sum_{(a,b) \\in \\Gamma} \\left\\langle V(a,b|x,y), K(a,b|x,y) \\right\\rangle. \\]"},{"location":"generated/gallery/extended_nonlocal_games/enlg_introduction/#standard-quantum-strategies-for-extended-nonlocal-games","title":"Standard quantum strategies for extended nonlocal games","text":"<p>A standard quantum strategy for an extended nonlocal game consists of finite-dimensional complex Euclidean spaces \\(\\mathcal{U}\\) for Alice and \\(\\mathcal{V}\\) for Bob, a quantum state \\(\\sigma \\in \\text{D}(\\mathcal{U} \\otimes \\mathcal{R} \\otimes \\mathcal{V})\\), and two collections of measurements</p> \\[ \\{ A_a^x : a \\in \\Gamma_A \\} \\subset \\text{Pos}(\\mathcal{U}) \\quad \\text{and} \\quad \\{ B_b^y : b \\in \\Gamma_B \\} \\subset \\text{Pos}(\\mathcal{V}), \\] <p>for each \\(x \\in \\Sigma_A\\) and \\(y \\in \\Sigma_B\\) respectively. As usual, the measurement operators satisfy the constraint that</p> \\[ \\sum_{a \\in \\Gamma_A} A_a^x = \\mathbb{I}_{\\mathcal{U}} \\quad \\text{and} \\quad \\sum_{b \\in \\Gamma_B} B_b^y = \\mathbb{I}_{\\mathcal{V}}, \\] <p>for each \\(x \\in \\Sigma_A\\) and \\(y \\in \\Sigma_B\\).</p> <p>When the game is played, Alice and Bob present the referee with a quantum system so that the three parties share the state \\(\\sigma \\in \\text{D}(\\mathcal{U} \\otimes \\mathcal{R} \\otimes \\mathcal{V})\\). The referee selects questions \\((x,y) \\in \\Sigma\\) according to the distribution \\(\\pi\\) that is known to all participants in the game.</p> <p>The referee then sends \\(x\\) to Alice and \\(y\\) to Bob. At this point, Alice and Bob make measurements on their respective portions of the state \\(\\sigma\\) using their measurement operators to yield an outcome to send back to the referee. Specifically, Alice measures her portion of the state \\(\\sigma\\) with respect to her set of measurement operators \\(\\{A_a^x : a \\in \\Gamma_A\\}\\), and sends the result \\(a \\in \\Gamma_A\\) of this measurement to the referee. Likewise, Bob measures his portion of the state \\(\\sigma\\) with respect to his measurement operators \\(\\{B_b^y : b \\in \\Gamma_B\\}\\) to yield the outcome \\(b \\in \\Gamma_B\\), that is then sent back to the referee.</p> <p>At the end of the protocol, the referee measures its quantum system with respect to the measurement \\(\\{V(a,b|x,y), \\mathbb{I}-V(a,b|x,y)\\}\\).</p> <p>The winning probability for such a strategy in this game \\(G = (\\pi,V)\\) is given by</p> \\[ \\sum_{(x,y) \\in \\Sigma} \\pi(x,y) \\sum_{(a,b) \\in \\Gamma} \\left \\langle A_a^x \\otimes V(a,b|x,y) \\otimes B_b^y, \\sigma \\right \\rangle. \\] <p>For a given extended nonlocal game \\(G = (\\pi,V)\\), we write \\(\\omega^*(G)\\) to denote the standard quantum value of \\(G\\), which is the supremum value of Alice and Bob's winning probability over all standard quantum strategies for \\(G\\).</p>"},{"location":"generated/gallery/extended_nonlocal_games/enlg_introduction/#unentangled-strategies-for-extended-nonlocal-games","title":"Unentangled strategies for extended nonlocal games","text":"<p>An unentangled strategy for an extended nonlocal game is simply a standard quantum strategy for which the state \\(\\sigma \\in \\text{D}(\\mathcal{U} \\otimes \\mathcal{R} \\otimes \\mathcal{V})\\) initially prepared by Alice and Bob is fully separable.</p> <p>Any unentangled strategy is equivalent to a strategy where Alice and Bob store only classical information after the referee's quantum system has been provided to it.</p> <p>For a given extended nonlocal game \\(G = (\\pi, V)\\) we write \\(\\omega(G)\\) to denote the unentangled value of \\(G\\), which is the supremum value for Alice and Bob's winning probability in \\(G\\) over all unentangled strategies. The unentangled value of any extended nonlocal game, \\(G\\), may be written as</p> \\[ \\omega(G) = \\max_{f, g} \\lVert \\sum_{(x,y) \\in \\Sigma} \\pi(x,y) V(f(x), g(y)|x, y) \\rVert \\] <p>where the maximum is over all functions \\(f : \\Sigma_A \\rightarrow \\Gamma_A\\) and \\(g : \\Sigma_B \\rightarrow \\Gamma_B\\).</p>"},{"location":"generated/gallery/extended_nonlocal_games/enlg_introduction/#non-signaling-strategies-for-extended-nonlocal-games","title":"Non-signaling strategies for extended nonlocal games","text":"<p>A non-signaling strategy for an extended nonlocal game consists of a function</p> \\[ K : \\Gamma_A \\times \\Gamma_B \\times \\Sigma_A \\times \\Sigma_B \\rightarrow \\text{Pos}(\\mathcal{R}) \\] <p>such that</p> \\[ \\sum_{a \\in \\Gamma_A} K(a,b|x,y) = \\rho_b^y \\quad \\text{and} \\quad \\sum_{b \\in \\Gamma_B} K(a,b|x,y) = \\sigma_a^x, \\] <p>for all \\(x \\in \\Sigma_A\\) and \\(y \\in \\Sigma_B\\) where \\(\\{\\rho_b^y : y \\in \\Sigma_B, b \\in \\Gamma_B\\}\\) and \\(\\{\\sigma_a^x: x \\in \\Sigma_A, a \\in \\Gamma_A\\}\\) are collections of operators satisfying</p> \\[ \\sum_{a \\in \\Gamma_A} \\sigma_a^x = \\tau = \\sum_{b \\in \\Gamma_B} \\rho_b^y, \\] <p>for every choice of \\(x \\in \\Sigma_A\\) and \\(y \\in \\Sigma_B\\) and where \\(\\tau \\in \\text{D}(\\mathcal{R})\\) is a density operator.</p> <p>For any extended nonlocal game, \\(G = (\\pi, V)\\), the winning probability for a non-signaling strategy is given by</p> \\[ \\sum_{(x,y) \\in \\Sigma} \\pi(x,y) \\sum_{(a,b) \\in \\Gamma} \\left\\langle V(a,b|x,y) K(a,b|x,y) \\right\\rangle. \\] <p>We denote the non-signaling value of \\(G\\) as \\(\\omega_{ns}(G)\\) which is the supremum value of the winning probability of \\(G\\) taken over all non-signaling strategies for Alice and Bob.</p>"},{"location":"generated/gallery/extended_nonlocal_games/enlg_introduction/#relationships-between-different-strategies-and-values","title":"Relationships between different strategies and values","text":"<p>For an extended nonlocal game, \\(G\\), the values have the following relationship:</p> <p>Note</p> \\[ 0 \\leq \\omega(G) \\leq \\omega^*(G) \\leq \\omega_{ns}(G) \\leq 1. \\] <p>Now that we have established the theoretical framework for extended nonlocal games, we can explore some concrete examples. In the following tutorials, we will construct well-known games such as the BB84 and CHSH extended nonlocal games and use <code>|toqito\u27e9</code> to calculate their various values.</p> <p>%% mkdocs_gallery_thumbnail_path = 'figures/logo.png' We will start by examining the BB84 extended nonlocal game in The BB84 extended nonlocal game</p> <p>Total running time of the script: ( 0 minutes  0.000 seconds)</p> <p> Download Python source code: enlg_introduction.py</p> <p> Download Jupyter notebook: enlg_introduction.ipynb</p> <p>Gallery generated by mkdocs-gallery</p> <ol> <li> <p>Vincent Russo. Extended nonlocal games. 2017. arXiv:1704.07375.\u00a0\u21a9\u21a9</p> </li> <li> <p>D. Cavalcanti, P. Skrzypczyk, G. H. Aguilar, R. V. Nery, P.H. Souto Ribeiro, and S. P. Walborn. Detection of entanglement in asymmetric quantum networks and multipartite quantum steering. Nature Communications, aug 2015. URL: http://dx.doi.org/10.1038/ncomms8941, doi:10.1038/ncomms8941.\u00a0\u21a9</p> </li> <li> <p>Marco Tomamichel, Serge Fehr, J\u0119drzej Kaniewski, and Stephanie Wehner. A monogamy-of-entanglement game with applications to device-independent quantum cryptography. New Journal of Physics, 15(10):103002, oct 2013. URL: http://dx.doi.org/10.1088/1367-2630/15/10/103002, doi:10.1088/1367-2630/15/10/103002.\u00a0\u21a9</p> </li> <li> <p>Nathaniel Johnston, Rajat Mittal, Vincent Russo, and John Watrous. Extended non-local games and monogamy-of-entanglement games. Proceedings of the Royal Society A: Mathematical, Physical and Engineering Sciences, 472(2189):20160003, May 2016. URL: https://arxiv.org/abs/1510.02083.\u00a0\u21a9</p> </li> </ol>"},{"location":"generated/gallery/extended_nonlocal_games/enlg_mub/","title":"An extended nonlocal game with quantum advantage","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/extended_nonlocal_games/enlg_mub/#an-extended-nonlocal-game-with-quantum-advantage","title":"An extended nonlocal game with quantum advantage","text":"<p>In the previous tutorials on The BB84 extended nonlocal game and The CHSH extended nonlocal game, we saw examples where the standard quantum and unentangled values were equal (\\(\\omega(G) = \\omega^*(G)\\)). Here, we will construct an extended nonlocal game where the standard quantum value is strictly higher than the unentangled value, demonstrating a true quantum advantage.</p>"},{"location":"generated/gallery/extended_nonlocal_games/enlg_mub/#a-monogamy-of-entanglement-game-with-mutually-unbiased-bases","title":"A monogamy-of-entanglement game with mutually unbiased bases","text":"<p>Let \\(\\zeta = \\exp(\\frac{2 \\pi i}{3})\\) and consider the following four mutually unbiased bases:</p> \\[    \\begin{equation}\\label{eq:MUB43}    \\begin{aligned}      \\mathcal{B}_0 &amp;= \\left\\{ e_0,\\: e_1,\\: e_2 \\right\\}, \\\\      \\mathcal{B}_1 &amp;= \\left\\{ \\frac{e_0 + e_1 + e_2}{\\sqrt{3}},\\:      \\frac{e_0 + \\zeta^2 e_1 + \\zeta e_2}{\\sqrt{3}},\\:      \\frac{e_0 + \\zeta e_1 + \\zeta^2 e_2}{\\sqrt{3}} \\right\\}, \\\\      \\mathcal{B}_2 &amp;= \\left\\{ \\frac{e_0 + e_1 + \\zeta e_2}{\\sqrt{3}},\\:      \\frac{e_0 + \\zeta^2 e_1 + \\zeta^2 e_2}{\\sqrt{3}},\\:      \\frac{e_0 + \\zeta e_1 + e_2}{\\sqrt{3}} \\right\\}, \\\\      \\mathcal{B}_3 &amp;= \\left\\{ \\frac{e_0 + e_1 + \\zeta^2 e_2}{\\sqrt{3}},\\:      \\frac{e_0 + \\zeta^2 e_1 + e_2}{\\sqrt{3}},\\:      \\frac{e_0 + \\zeta e_1 + \\zeta e_2}{\\sqrt{3}} \\right\\}.    \\end{aligned}    \\end{equation} \\] <p>Define an extended nonlocal game \\(G_{MUB} = (\\pi,R)\\) so that</p> \\[         \\pi(0) = \\pi(1) = \\pi(2) = \\pi(3) = \\frac{1}{4} \\] <p>and \\(R\\) is such that</p> \\[         \\{ R(0|x), R(1|x), R(2|x) \\} \\] <p>represents a measurement with respect to the basis \\(\\mathcal{B}_x\\), for each \\(x \\in \\{0,1,2,3\\}\\).</p> <p>Taking the description of \\(G_{MUB}\\), we can encode this as follows.</p> <pre><code>import numpy as np\n\nfrom toqito.states import basis\n\n# The basis: {|0&gt;, |1&gt;}:\ne_0, e_1 = basis(2, 0), basis(2, 1)\n\n# Define the monogamy-of-entanglement game defined by MUBs.\nprob_mat = 1 / 4 * np.identity(4)\n\ndim = 3\ne_0, e_1, e_2 = basis(dim, 0), basis(dim, 1), basis(dim, 2)\n\neta = np.exp((2 * np.pi * 1j) / dim)\nmub_0 = [e_0, e_1, e_2]\nmub_1 = [\n    (e_0 + e_1 + e_2) / np.sqrt(3),\n    (e_0 + eta**2 * e_1 + eta * e_2) / np.sqrt(3),\n    (e_0 + eta * e_1 + eta**2 * e_2) / np.sqrt(3),\n]\nmub_2 = [\n    (e_0 + e_1 + eta * e_2) / np.sqrt(3),\n    (e_0 + eta**2 * e_1 + eta**2 * e_2) / np.sqrt(3),\n    (e_0 + eta * e_1 + e_2) / np.sqrt(3),\n]\nmub_3 = [\n    (e_0 + e_1 + eta**2 * e_2) / np.sqrt(3),\n    (e_0 + eta**2 * e_1 + e_2) / np.sqrt(3),\n    (e_0 + eta * e_1 + eta * e_2) / np.sqrt(3),\n]\n\n# List of measurements defined from mutually unbiased basis.\nmubs = [mub_0, mub_1, mub_2, mub_3]\n\nnum_in = 4\nnum_out = 3\npred_mat = np.zeros([dim, dim, num_out, num_out, num_in, num_in], dtype=complex)\n\npred_mat[:, :, 0, 0, 0, 0] = mubs[0][0] @ mubs[0][0].conj().T\npred_mat[:, :, 1, 1, 0, 0] = mubs[0][1] @ mubs[0][1].conj().T\npred_mat[:, :, 2, 2, 0, 0] = mubs[0][2] @ mubs[0][2].conj().T\n\npred_mat[:, :, 0, 0, 1, 1] = mubs[1][0] @ mubs[1][0].conj().T\npred_mat[:, :, 1, 1, 1, 1] = mubs[1][1] @ mubs[1][1].conj().T\npred_mat[:, :, 2, 2, 1, 1] = mubs[1][2] @ mubs[1][2].conj().T\n\npred_mat[:, :, 0, 0, 2, 2] = mubs[2][0] @ mubs[2][0].conj().T\npred_mat[:, :, 1, 1, 2, 2] = mubs[2][1] @ mubs[2][1].conj().T\npred_mat[:, :, 2, 2, 2, 2] = mubs[2][2] @ mubs[2][2].conj().T\n\npred_mat[:, :, 0, 0, 3, 3] = mubs[3][0] @ mubs[3][0].conj().T\npred_mat[:, :, 1, 1, 3, 3] = mubs[3][1] @ mubs[3][1].conj().T\npred_mat[:, :, 2, 2, 3, 3] = mubs[3][2] @ mubs[3][2].conj().T\n</code></pre> <p>Now that we have encoded \\(G_{MUB}\\), we can calculate the unentangled value.</p> <pre><code>import numpy as np\n\nfrom toqito.nonlocal_games.extended_nonlocal_game import ExtendedNonlocalGame\n\ng_mub = ExtendedNonlocalGame(prob_mat, pred_mat)\nunent_val = g_mub.unentangled_value()\nprint(\"The unentangled value is \", np.around(unent_val, decimals=2))\n</code></pre> <p>Out:</p> <pre><code>The unentangled value is  0.65\n</code></pre> <p>That is, we have that</p> \\[    \\omega(G_{MUB}) = \\frac{3 + \\sqrt{5}}{8} \\approx 0.65409. \\] <p>However, if we attempt to run a lower bound on the standard quantum value, we obtain.</p> <pre><code>g_mub = ExtendedNonlocalGame(prob_mat, pred_mat)\nq_val = g_mub.quantum_value_lower_bound()\nprint(\"The standard quantum value lower bound is \", np.around(q_val, decimals=2))\n# mkdocs_gallery_thumbnail_path = 'figures/logo.png'\n</code></pre> <p>Out:</p> <pre><code>/home/runner/work/toqito/toqito/.venv/lib/python3.12/site-packages/scs/__init__.py:83: UserWarning: Converting A to a CSC (compressed sparse column) matrix; may take a while.\n  warn(\nThe standard quantum value lower bound is  0.65\n</code></pre> <p>Note that as we are calculating a lower bound, it is possible that a value this high will not be obtained, or in other words, the algorithm can get stuck in a local maximum that prevents it from finding the global maximum.</p> <p>It is uncertain what the optimal standard quantum strategy is for this game, but the value of such a strategy is bounded as follows</p> \\[    2/3 \\geq \\omega^*(G) \\geq 0.6609. \\] <p>For further information on the \\(G_{MUB}\\) game, consult <sup>1</sup>.</p> <p>Total running time of the script: ( 0 minutes  1.252 seconds)</p> <p> Download Python source code: enlg_mub.py</p> <p> Download Jupyter notebook: enlg_mub.ipynb</p> <p>Gallery generated by mkdocs-gallery</p> <ol> <li> <p>Vincent Russo. Extended nonlocal games. 2017. arXiv:1704.07375.\u00a0\u21a9</p> </li> </ol>"},{"location":"generated/gallery/extended_nonlocal_games/mg_execution_times/","title":"Computation times","text":"<p>00:15.118 total execution time for generated_gallery_extended_nonlocal_games files:</p> <p>+-------------------------------------------------------------------------------------------------------------+-----------+--------+ | enlg_bb84 (content/examples/extended_nonlocal_games/enlg_bb84.py)                         | 00:08.500 | 0.0 MB | +-------------------------------------------------------------------------------------------------------------+-----------+--------+ | enlg_chsh (content/examples/extended_nonlocal_games/enlg_chsh.py)                         | 00:04.771 | 0.0 MB | +-------------------------------------------------------------------------------------------------------------+-----------+--------+ | enlg_mub (content/examples/extended_nonlocal_games/enlg_mub.py)                            | 00:01.252 | 0.0 MB | +-------------------------------------------------------------------------------------------------------------+-----------+--------+ | bit_commitment (content/examples/extended_nonlocal_games/bit_commitment.py)          | 00:00.594 | 0.0 MB | +-------------------------------------------------------------------------------------------------------------+-----------+--------+ | enlg_introduction (content/examples/extended_nonlocal_games/enlg_introduction.py) | 00:00.000 | 0.0 MB | +-------------------------------------------------------------------------------------------------------------+-----------+--------+</p>"},{"location":"generated/gallery/nonlocal_games/mg_execution_times/","title":"Computation times","text":"<p>00:21.987 total execution time for generated_gallery_nonlocal_games files:</p> <p>+----------------------------------------------------------------------------------------------------+-----------+--------+ | nonlocal_game (content/examples/nonlocal_games/nonlocal_game.py)             | 00:21.966 | 0.0 MB | +----------------------------------------------------------------------------------------------------+-----------+--------+ | xor_quantum_value (content/examples/nonlocal_games/xor_quantum_value.py) | 00:00.021 | 0.0 MB | +----------------------------------------------------------------------------------------------------+-----------+--------+</p>"},{"location":"generated/gallery/nonlocal_games/nonlocal_game/","title":"Nonlocal games","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/nonlocal_games/nonlocal_game/#nonlocal-games","title":"Nonlocal games","text":"<p>In this tutorial, we are going to cover the notion of a nonlocal game; a mathematical framework that abstractly models a physical system. The simplest instance of a nonlocal game involves two players, Alice and Bob, who are not allowed to communicate with each other once the game has started and who play cooperatively against an adversary referred to as the referee.</p> <p>A primary challenge that arises when studying these games is to determine the maximum probability with which Alice and Bob are able to achieve a winning outcome.</p> <p>This probability is highly dependent on the type of strategy that Alice and Bob use in the game. A classical strategy is one in which Alice and Bob have access to classical resources. The best that Alice and Bob can do using a classical strategy is known as the classical value of the game. Similarly, a quantum strategy is one in which Alice and Bob have access to quantum resources. The best that Alice and Bob can do using a quantum strategy is known as the quantum value of the game.</p> <p>Calculating the classical value of a game is NP-hard as we need to perform a brute-force check to see which strategy yields the classical value of the game.</p> <p>Using <code>|toqito\u27e9</code>, we will be able to specify a nonlocal game and be able to directly calculate the classical value and also place lower bounds on the quantum value.</p> <p>Further information beyond the scope of this tutorial on nonlocal games can be found in <sup>1</sup>. Further information on the lower bound technique can be found in <sup>2</sup>.</p>"},{"location":"generated/gallery/nonlocal_games/nonlocal_game/#two-player-nonlocal-games","title":"Two-player nonlocal games","text":"<p>A two-player nonlocal game consists of players that we give the names Alice and Bob:</p> <p></p> <p>The players: Alice and Bob.</p> <p>Alice and Bob are in separate locations and cannot communicate once the game begins. Prior to the game however, Alice and Bob are free to communicate with each other. In addition to the players, there is also another party in this game that is referred to as the referee.</p> <p></p> <p>The referee.</p> <p>Alice and Bob want to play in a cooperative fashion against the referee.</p> <p>Now that we have set the stage with respect to the actors and actresses we will encounter in this game, let us see how the game is actually played.</p> <p></p> <p>A two-player nonlocal game.</p> <p>A nonlocal game unfolds in the following manner.</p> <ol> <li> <p>The referee randomly generates questions denoted as \\(x\\) and \\(y\\).    The referee sends the question \\(x\\) to Alice and the question    \\(y\\) to Bob. The referee also keeps a copy of \\(x\\) and    \\(y\\) for reference.</p> </li> <li> <p>Alice and Bob each receive their respective questions. They are then each    expected to respond to their questions with answers that we denote as    \\(a\\) and \\(b\\). Alice sends \\(a\\) to the referee, and Bob    sends \\(b\\).</p> </li> <li> <p>When the referee receives \\(a\\) and \\(b\\) from Alice and Bob,    the referee evaluates a particular function that is predicated on the    questions \\(x\\) and \\(y\\) as well as the answers \\(a\\) and    \\(b\\). The outcome of this function is either \\(0\\) or    \\(1\\), where an outcome of \\(0\\) indicates a loss for Alice and    Bob and an outcome of \\(1\\) indicates a win for Alice and Bob.</p> </li> </ol> <p>Alice and Bob's goal in the above game is to get the function in Step-3 to output a \\(1\\), or equivalently, to indicate a winning outcome. This type of game is referred to as a nonlocal game.</p>"},{"location":"generated/gallery/nonlocal_games/nonlocal_game/#classical-and-quantum-strategies","title":"Classical and Quantum Strategies","text":"<p>Now that we have the framework for a nonlocal game, we can consider the player's strategy; how the players play the game given access to certain resources. There are a number of strategies that the players can use, but for simplicity, we will restrict our attention to two types of strategies.</p> <ol> <li> <p>Classical strategies: The players answer the questions in a deterministic    manner.</p> </li> <li> <p>Quantum strategies: The players make use of quantum resources in the form    of a shared quantum state and respective sets of measurements.</p> </li> </ol>"},{"location":"generated/gallery/nonlocal_games/nonlocal_game/#classical-strategies","title":"Classical strategies","text":"<p>A classical strategy for a nonlocal game is one where the players deterministically produce an output for every possible combination of inputs they may receive in the game. The classical value of a nonlocal game is the maximum probability achieved by the players over all classical strategies. For a nonlocal game, \\(G\\), we use \\(\\omega(G)\\) to represent the classical value of \\(G\\).</p> <p>One question you may have is whether a classical strategy can be improved by introducing randomness. If the players randomly select their answers, is it possible for them to do potentially better than if they had just played deterministically? As it happens, probabilistic classical strategies cannot perform any better than deterministic classical strategies.</p> <p>There is therefore no loss in generality in restricting our analysis of classical strategies to deterministic ones and it is assumed that when we use the term classical strategy that we implicitly mean a classical strategy that is played deterministically.</p>"},{"location":"generated/gallery/nonlocal_games/nonlocal_game/#quantum-strategies","title":"Quantum strategies","text":"<p>A quantum strategy for a nonlocal game is one where the players prepare a quantum state prior to the start of the game along with respective sets of measurements that they apply to their respective portions of the shared state during the game based on the questions they receive to generate their answers. The quantum value of a nonlocal game is the maximum probability achieved by the players over all quantum strategies. For a nonlocal game, \\(G\\), we use \\(\\omega^*(G)\\) to represent the quantum value of \\(G\\).</p> <p></p> <p> A two-player nonlocal game invoking a quantum strategy.</p> <p>Let us describe the high-level steps for how Alice and Bob play using a quantum strategy.</p> <ol> <li> <p>Alice and Bob prepare a state    \\(\\sigma \\in \\text{D}(\\mathcal{U} \\otimes \\mathcal{V})\\) prior to the    start of the game. We use \\(\\textsf{U}\\) and \\(\\textsf{V}\\) to    denote the respective registers of spaces \\(\\textsf{U}\\) and    \\(\\textsf{V}\\).</p> </li> <li> <p>The referee sends question \\(x \\in \\Sigma_A\\) to Alice and    \\(y \\in \\Sigma_B\\) to Bob.</p> </li> <li> <p>Alice and Bob perform a measurement on their system. The outcome of    this measurement yields their answers \\(a \\in \\Gamma_A\\) and    \\(b \\in \\Gamma_B\\). Specifically, Alice and Bob have collections of    measurements</p> </li> </ol> \\[ \\begin{aligned} \\{ A_a^x : a \\in \\Gamma_{\\text{A}} \\} \\subset \\text{Pos}(\\mathcal{U}) \\quad \\text{and} \\quad \\{ B_b^y : b \\in \\Gamma_{\\text{B}} \\} \\subset \\text{Pos}(\\mathcal{V}), \\end{aligned} \\] <p>such that the measurements satisfy</p> \\[ \\begin{aligned} \\sum_{a \\in \\Gamma_A} A_a^x = \\mathbb{I}_{\\mathcal{U}} \\quad \\text{and} \\quad \\sum_{b \\in \\Gamma_B} B_b^y = \\mathbb{I}_{\\mathcal{V}} \\end{aligned} \\] <p>4. The referee determines whether Alice and Bob win or lose, based on the    questions \\(x\\) and \\(y\\) as well as the answers \\(a\\) and    \\(b\\).</p> <p>For certain games, the probability that the players obtain a winning outcome is higher if they use a quantum strategy as opposed to a classical one. This striking separation is one primary motivation to study nonlocal games, as it provides examples of tasks that benefit from the manipulation of quantum information.</p>"},{"location":"generated/gallery/nonlocal_games/nonlocal_game/#calculating-the-classical-value","title":"Calculating the classical value","text":"<p>(Coming soon)</p>"},{"location":"generated/gallery/nonlocal_games/nonlocal_game/#calculating-the-quantum-value","title":"Calculating the quantum value","text":"<p>The ability to calculate the quantum value for an arbitrary nonlocal game is a highly non-trivial task. Indeed, the quantum value is only known in special cases for certain nonlocal games.</p> <p>For an arbitrary nonlocal game, there exist approaches that place upper and lower bounds on the quantum value. The lower bound approach is calculated using the technique of semidefinite programming <sup>2</sup>. While this method is efficient to carry out, it does not guarantee convergence to the quantum value (although in certain cases, it is attained).</p> <p>The primary idea of this approach is to note that fixing the measurements on one system yields the optimal measurements of the other system via an SDP. The algorithm proceeds in an iterative manner between two SDPs. In the first SDP, we assume that Bob's measurements are fixed, and Alice's measurements are to be optimized over. In the second SDP, we take Alice's optimized measurements from the first SDP and now optimize over Bob's measurements. This method is repeated until the quantum value reaches a desired numerical precision.</p> <p>For completeness, the first SDP where we fix Bob's measurements and optimize over Alice's measurements is given as SDP-1.</p> \\[ \\begin{equation} \\begin{aligned} \\textbf{SDP-1:} \\quad &amp; \\\\ \\text{maximize:} \\quad &amp; \\sum_{(x,y \\in \\Sigma)} \\pi(x,y) \\sum_{(a,b) \\in \\Gamma} V(a,b|x,y) \\langle B_b^y, A_a^x \\rangle \\\\ \\text{subject to:} \\quad &amp; \\sum_{a \\in \\Gamma_{\\mathsf{A}}} = \\tau, \\qquad \\qquad \\forall x \\in \\Sigma_{\\mathsf{A}}, \\\\ \\quad &amp; A_a^x \\in \\text{Pos}(\\mathcal{A}), \\qquad \\forall x \\in \\Sigma_{\\mathsf{A}}, \\ \\forall a \\in \\Gamma_{\\mathsf{A}}, \\\\ &amp; \\tau \\in \\text{D}(\\mathcal{A}). \\end{aligned} \\end{equation} \\] <p>Similarly, the second SDP where we fix Alice's measurements and optimize over Bob's measurements is given as SDP-2.</p> \\[ \\begin{equation} \\begin{aligned} \\textbf{SDP-2:} \\quad &amp; \\\\ \\text{maximize:} \\quad &amp; \\sum_{(x,y \\in \\Sigma)} \\pi(x,y) \\sum_{(a,b) \\in \\Gamma} V(a,b|x,y) \\langle B_b^y, A_a^x \\rangle \\\\ \\text{subject to:} \\quad &amp; \\sum_{b \\in \\Gamma_{\\mathsf{B}}} = \\mathbb{I}, \\qquad \\qquad \\forall y \\in \\Sigma_{\\mathsf{B}}, \\\\ \\quad &amp; B_b^y \\in \\text{Pos}(\\mathcal{B}), \\qquad \\forall y \\in \\Sigma_{\\mathsf{B}}, \\ \\forall b \\in \\Gamma_{\\mathsf{B}}. \\end{aligned} \\end{equation} \\]"},{"location":"generated/gallery/nonlocal_games/nonlocal_game/#lower-bounding-the-quantum-value-in-toqito","title":"Lower bounding the quantum value in <code>toqito</code>","text":"<p>The <code>|toqito\u27e9</code> software implements both of these optimization problems using the <code>cvxpy</code> library. We see-saw between the two SDPs until the value we obtain reaches a specific precision threshold.</p> <p>As we are not guaranteed to obtain the true quantum value of a given nonlocal game as this approach can get stuck in a local minimum, the <code>|toqito\u27e9</code> function allows the user to specify an <code>iters</code> argument that runs the see-saw approach a number of times and then returns the highest of the values obtained.</p>"},{"location":"generated/gallery/nonlocal_games/nonlocal_game/#example-lower-bounding-the-quantum-value-of-the-chsh-game","title":"Example: Lower bounding the quantum value of the CHSH game","text":"<p>Let us consider calculating the lower bound on the quantum value of the CHSH game.</p> <p>Note</p> <p>As the CHSH game is a subtype of nonlocal game referred to as an XOR game, we do not necessarily need to resort to this lower bound technique as there exists a specific SDP formulation that one can use to directly compute the quantum value of an XOR game. More information on how one defines the CHSH game as well as this method to directly calculate the quantum value of an XOR game is provided in Calculating the Quantum and Classical Value of a Two-Player XOR Game</p> <p>We will use the CHSH game here as an illustrative example as we already know what the optimal quantum value should be.</p> <p>The first step is to use <code>numpy</code> to encode a matrix that encapsulates the probabilities with which the questions are asked to Alice and Bob. As defined in the CHSH game, each of the four pairs \\(\\{(0, 0), (0, 1), (1, 0), (1, 1)\\}\\) are all equally likely. We encode this in the matrix as follows.</p> <p>Creating the probability matrix.</p> <pre><code>import numpy as np\n\nprob_mat = np.array([[1 / 4, 1 / 4], [1 / 4, 1 / 4]])\n</code></pre> <p>Next, we want to loop through all possible combinations of question and answer pairs and populate the \\((a, b, x, y)^{th}\\) entry of that matrix with a \\(1\\) in the event that the winning condition is satisfied. Otherwise, if the winning condition is not satisfied for that particular choice of \\(a, b, x,\\) and \\(y\\), we place a \\(0\\) at that position.</p> <p>The following code performs this operation and places the appropriate entries in this matrix into the <code>pred_mat</code> variable.</p> <pre><code># Creating the predicate matrix.\nimport numpy as np\n\nnum_alice_inputs, num_alice_outputs = 2, 2\nnum_bob_inputs, num_bob_outputs = 2, 2\n\npred_mat = np.zeros((num_alice_outputs, num_bob_outputs, num_alice_inputs, num_bob_inputs))\n\nfor a_alice in range(num_alice_outputs):\n    for b_bob in range(num_bob_outputs):\n        for x_alice in range(num_alice_inputs):\n            for y_bob in range(num_bob_inputs):\n                if a_alice ^ b_bob == x_alice * y_bob:\n                    pred_mat[a_alice, b_bob, x_alice, y_bob] = 1\npred_mat\n</code></pre> <p>Out:</p> <pre><code>array([[[[1., 1.],\n         [1., 0.]],\n\n        [[0., 0.],\n         [0., 1.]]],\n\n\n       [[[0., 0.],\n         [0., 1.]],\n\n        [[1., 1.],\n         [1., 0.]]]])\n</code></pre> <p>Now that we have both <code>prob_mat</code> and <code>pred_mat</code> defined, we can use <code>|toqito\u27e9</code> to determine the lower bound on the quantum value.</p> <pre><code>import numpy as np\n\nfrom toqito.nonlocal_games.nonlocal_game import NonlocalGame\n\nchsh = NonlocalGame(prob_mat, pred_mat)\n# Multiple runs to avoid trap in suboptimal quantum value.\nresults = [np.around(chsh.quantum_value_lower_bound(), decimals=2) for _ in range(5)]\nprint(f\"Maximum quantum value after multiple runs is: {max(results)}\")\n</code></pre> <p>Out:</p> <pre><code>/home/runner/work/toqito/toqito/.venv/lib/python3.12/site-packages/scs/__init__.py:83: UserWarning: Converting A to a CSC (compressed sparse column) matrix; may take a while.\n  warn(\nMaximum quantum value after multiple runs is: 0.85\n</code></pre> <p>In this case, we can see that the quantum value of the CHSH game is in fact attained as \\(\\cos^2(\\pi/8) \\approx 0.85355\\).</p>"},{"location":"generated/gallery/nonlocal_games/nonlocal_game/#the-ffl-game","title":"The FFL game","text":"<p>The FFL (Fortnow, Feige, Lovasz) game is a nonlocal game specified as follows.</p> \\[ \\begin{equation} \\begin{aligned} &amp;\\pi(0, 0) = \\frac{1}{3}, \\quad \\pi(0, 1) = \\frac{1}{3}, \\quad \\pi(1, 0) = \\frac{1}{3}, \\quad \\pi(1, 1) = 0, \\\\ &amp;(x,y) \\in \\Sigma_A \\times \\Sigma_B, \\qquad \\text{and} \\qquad (a, b) \\in \\Gamma_A \\times \\Gamma_B, \\end{aligned} \\end{equation} \\] <p>where</p> \\[ \\begin{equation} \\Sigma_A = \\{0, 1\\}, \\quad \\Sigma_B = \\{0, 1\\}, \\quad \\Gamma_A = \\{0,1\\}, \\quad \\text{and} \\quad \\Gamma_B = \\{0, 1\\}. \\end{equation} \\] <p>Alice and Bob win the FFL game if and only if the following equation is satisfied</p> \\[ \\begin{equation} a \\lor x = b \\lor y. \\end{equation} \\] <p>It is well-known that both the classical and quantum value of this nonlocal game is \\(2/3\\) <sup>1</sup>. We can verify this fact using <code>|toqito\u27e9</code>. The following example encodes the FFL game. We then calculate the classical value and calculate lower bounds on the quantum value of the FFL game.</p> <pre><code>import numpy as np\n\nfrom toqito.nonlocal_games.nonlocal_game import NonlocalGame\n\n# Specify the number of inputs, and number of outputs.\nnum_alice_in, num_alice_out = 2, 2\nnum_bob_in, num_bob_out = 2, 2\n\n# Define the probability matrix of the FFL game.\nprob_mat = np.array([[1 / 3, 1 / 3], [1 / 3, 0]])\n\n\n# Define the predicate matrix of the FFL game.\npred_mat = np.zeros((num_alice_out, num_bob_out, num_alice_in, num_bob_in))\nfor a_alice in range(num_alice_out):\n    for b_bob in range(num_bob_out):\n        for x_alice in range(num_alice_in):\n            for y_bob in range(num_bob_in):\n                if (a_alice or x_alice) != (b_bob or y_bob):\n                    pred_mat[a_alice, b_bob, x_alice, y_bob] = 1\n# Define the FFL game object.\nffl = NonlocalGame(prob_mat, pred_mat)\nprint(f\"Classical value: {np.around(ffl.classical_value(), decimals=2)}\")\nprint(f\"Quantum value (lower bound): {np.around(ffl.quantum_value_lower_bound(), decimals=2)}\")\n</code></pre> <p>Out:</p> <pre><code>Classical value: 0.67\n/home/runner/work/toqito/toqito/.venv/lib/python3.12/site-packages/scs/__init__.py:83: UserWarning: Converting A to a CSC (compressed sparse column) matrix; may take a while.\n  warn(\nQuantum value (lower bound): 0.67\n</code></pre> <p>In this case, we obtained the correct quantum value of \\(2/3\\), however, the lower bound technique is not guaranteed to converge to the true quantum value in general.</p>"},{"location":"generated/gallery/nonlocal_games/nonlocal_game/#parallel-repetitions-of-nonlocal-games","title":"Parallel repetitions of nonlocal games","text":"<p>For classical strategies, it is known that parallel repetition does not hold for the CHSH game, that is:</p> \\[ \\begin{equation} w_c(\\text{CHSH} \\land \\text{CHSH}) = 10/16 &gt; 9/16 = w_c(\\text{CHSH}) w_c(\\text{CHSH}). \\end{equation} \\]"},{"location":"generated/gallery/nonlocal_games/nonlocal_game/#binary-constraint-system-games","title":"Binary constraint system games","text":"<p>The notion of a binary constraint system game was introduced in <sup>3</sup> and the following introductory material is extracted from that work.</p> <p>A binary constraint system (BCS) (sometimes also called a linear system (LCS)) consists of \\(n\\) binary variables <code>v_1</code>, <code>v_2</code>, ..., <code>v_n</code> and \\(m\\) constraints, <code>c_1</code>, <code>c_2</code>, ..., <code>c_m</code>, where each <code>c_j</code> is a binary-valued function of a subset of the variables.</p> <p>A binary constraint system game (BCS game) is a two-player nonlocal game that is associated with a BCS. In a BCS game, the referee randomly selects a constraint <code>c_s</code> and one variable <code>x_t</code> from <code>c_s</code>. The referee sends <code>s</code> to Alice and <code>t</code> to Bob. Alice returns a truth assignment to all variables in <code>c_s</code> and bob returns a truth assignment to variable <code>x_t</code>. The verifier accepts the answer if and only if:</p> <ol> <li>Alice's truth assignment satisfies the constraint <code>c_s</code>;</li> <li>Bob's truth assignment for <code>x_t</code> is consistent with Alice's.</li> </ol> <p>As an example, the CHSH game can be described as a BCS game:</p> \\[ v_1 \\oplus v_2 = 0 \\quad \\text{and} \\quad v_1 \\oplus v_2 = 1 \\] <p>In <code>|toqito\u27e9</code>, we can encode this as a BCS game as follows</p> <pre><code>import numpy as np\n\nfrom toqito.nonlocal_games import NonlocalGame\n\n# mkdocs_gallery_thumbnail_path = 'figures/nonlocal_game.svg'\n# Define constraints c_1 and c_2.\nc_1 = np.zeros((2, 2))\nc_2 = np.zeros((2, 2))\n\n# Loop over variables and populate constraints.\nfor v_1 in range(2):\n    for v_2 in range(2):\n        if v_1 ^ v_2 == 0:\n            c_1[v_1, v_2] = 1\n        else:\n            c_2[v_1, v_2] = 1\n\n# Define the BCS game from the variables and constraints.\nchsh_bcs = NonlocalGame.from_bcs_game([c_1, c_2])\n# Classical value of CHSH is 3 / 4 = 0.75\nprint(f\"Classical value: {np.around(chsh_bcs.classical_value(), decimals=2)}\")\n# Quantum value of CHSH is cos^2(pi/8) \\approx 0.853\n# Multiple runs to avoid trap in suboptimal quantum value.\nresults = [np.around(chsh_bcs.quantum_value_lower_bound(), decimals=2) for _ in range(5)]\nprint(f\"Maximum quantum value after multiple runs is: {max(results)}\")\n</code></pre> <p>Out:</p> <pre><code>Classical value: 0.75\n/home/runner/work/toqito/toqito/.venv/lib/python3.12/site-packages/scs/__init__.py:83: UserWarning: Converting A to a CSC (compressed sparse column) matrix; may take a while.\n  warn(\nMaximum quantum value after multiple runs is: 0.85\n</code></pre> <p>Total running time of the script: ( 0 minutes  21.966 seconds)</p> <p> Download Python source code: nonlocal_game.py</p> <p> Download Jupyter notebook: nonlocal_game.ipynb</p> <p>Gallery generated by mkdocs-gallery</p> <ol> <li> <p>Richard Cleve, Peter Hoyer, Ben Toner, and John Watrous. Consequences and limits of nonlocal strategies. 2010. arXiv:quant-ph/0404076.\u00a0\u21a9\u21a9</p> </li> <li> <p>Yeong-Cherng Liang and Andrew C. Doherty. Bounds on quantum correlations in bell-inequality experiments. Physical Review A, Apr 2007. URL: http://dx.doi.org/10.1103/PhysRevA.75.042103, doi:10.1103/physreva.75.042103.\u00a0\u21a9\u21a9</p> </li> <li> <p>Richard Cleve and Rajat Mittal. Characterization of binary constraint system games. In Automata, Languages, and Programming: 41st International Colloquium, ICALP 2014, Copenhagen, Denmark, July 8-11, 2014, Proceedings, Part I 41, 320\u2013331. Springer, 2014.\u00a0\u21a9</p> </li> </ol>"},{"location":"generated/gallery/nonlocal_games/xor_quantum_value/","title":"Calculating the quantum and classical value of a two-player XOR game","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/nonlocal_games/xor_quantum_value/#calculating-the-quantum-and-classical-value-of-a-two-player-xor-game","title":"Calculating the quantum and classical value of a two-player XOR game","text":"<p>In this tutorial, we will cover the concept of an XOR game. We will also showcase how the <code>|toqito\u27e9</code> software package can be used to calculate the classical and quantum value of a given XOR game.</p> <p>For readers who are already familiar with XOR games and who simply want to see how to use <code>|toqito\u27e9</code> to study these objects, they are welcome to consult the documentation page, and more specifically the function xor_game_value.</p> <p>Further information beyond the scope of this tutorial on the notion of XOR games along with the method of computing their quantum value may be found in <sup>1</sup>.</p>"},{"location":"generated/gallery/nonlocal_games/xor_quantum_value/#two-player-xor-games","title":"Two-player XOR games","text":"<p>A two-player XOR game is a nonlocal game in which the winning condition is predicated on an XOR function. For more information on the more general class of nonlocal games along with how one defines classical and quantum strategies for these games, please refer to the example in Nonlocal games</p> <p>Note</p> <p>It is not known how to directly compute the quantum value of an arbitrary nonlocal game. For the subset of XOR games, it turns out that it is possible to directly calculate the quantum value by solving a semidefinite program. The <code>|toqito\u27e9</code> package obtains the quantum value of an XOR game in this manner.</p> <p>The rest of this tutorial is concerned with analyzing specific XOR games.</p>"},{"location":"generated/gallery/nonlocal_games/xor_quantum_value/#the-chsh-game","title":"The CHSH game","text":"<p>The CHSH game is a two-player XOR game with the following probability distribution and question and answer sets.</p> \\[ \\begin{equation} \\begin{aligned} \\pi(x,y) = \\frac{1}{4}, \\qquad (x,y) \\in \\Sigma_A \\times \\Sigma_B, \\qquad \\text{and} \\qquad (a, b) \\in \\Gamma_A \\times \\Gamma_B, \\end{aligned} \\end{equation} \\] <p>where</p> \\[ \\begin{equation} \\Sigma_A = \\{0, 1\\}, \\quad \\Sigma_B = \\{0, 1\\}, \\quad \\Gamma_A = \\{0,1\\}, \\quad \\text{and} \\quad \\Gamma_B = \\{0, 1\\}. \\end{equation} \\] <p>Alice and Bob win the CHSH game if and only if the following equation is satisfied</p> \\[ \\begin{equation} a \\oplus b = x y. \\end{equation} \\] <p>Recall that \\(\\oplus\\) refers to the XOR operation.</p> <p>For each question scenario, the following table provides what the winning condition must be equal to for each question tuple to induce a winning outcome.</p> \\(x\\) \\(y\\) \\(a \\oplus b\\) \\(0\\) \\(0\\) \\(0\\) \\(0\\) \\(1\\) \\(0\\) \\(1\\) \\(0\\) \\(0\\) \\(1\\) \\(1\\) \\(1\\) <p>In order to specify an XOR game in <code>|toqito\u27e9</code>, we will define two matrices:</p> <ul> <li> <p><code>prob_mat</code>: A matrix whose \\((x, y)^{th}\\) entry corresponds to   the probability that Alice receives question \\(x\\) and Bob receives   question \\(y\\).</p> </li> <li> <p><code>pred_mat</code>: A matrix whose \\((x, y)^{th}\\) entry corresponds to   the winning choice of \\(a\\) and \\(b\\) when Alice receives   \\(x\\) and Bob receives \\(y\\) from the referee.</p> </li> </ul> <p>For the CHSH game, the <code>prob_mat</code> and <code>pred_mat</code> variables are defined as follows.</p> <pre><code>import numpy as np\n\nprob_mat = np.array([[1 / 4, 1 / 4], [1 / 4, 1 / 4]])\npred_mat = np.array([[0, 0], [0, 1]])\n</code></pre> <p>That is, the <code>prob_mat</code> matrix encapsulates that each question pair \\(\\{(0,0), (0, 1), (1, 0), (1, 1)\\}\\) is equally likely.</p> <p>The <code>pred_mat</code> matrix indicates what the winning outcome of Alice and Bob should be. For instance, <code>pred_mat[0][0] = 0</code> describes the scenario where Alice and Bob both receive \\(0\\) as input. As we want to satisfy the winning condition \\(x \\land y = a \\oplus b\\), we must have that \\(a \\oplus b = 0\\) to satisfy the case when both \\(x\\) and \\(y\\) are equal to zero. A similar logic can be followed to populate the remaining entries of the <code>pred_mat</code> variable.</p> <p>We will use both of the <code>prob_mat</code> and <code>pred_mat</code> variables in the coming subsections to make use of the <code>|toqito\u27e9</code> package to compute both the classical and quantum value of the CHSH game.</p>"},{"location":"generated/gallery/nonlocal_games/xor_quantum_value/#a-classical-strategy-for-the-chsh-game","title":"A classical strategy for the CHSH game","text":"<p>We can begin by asking; is it possible for Alice and Bob to win for every single question pair they receive with certainty? If Alice and Bob use a classical strategy, the answer to this question is \"no\". To see why, consider the following equations:</p> \\[ \\begin{equation} \\begin{aligned} a_0 \\oplus b_0 = 0, \\quad a_0 \\oplus b_1 = 0, \\\\ a_1 \\oplus b_0 = 0, \\quad a_1 \\oplus b_1 = 1. \\end{aligned} \\end{equation} \\] <p>In the above equation, \\(a_x\\) is Alice's answer in the event that she receives question \\(x\\) from the referee for \\(x \\in \\Sigma_A\\). Similarly, \\(b_y\\) is Bob's answer when Bob receives question \\(y\\) from the referee for \\(y \\in \\Sigma_B\\). These equations express the winning conditions that Alice and Bob must satisfy in order to perfectly win the CHSH game. That is, if it's possible to satisfy all of these equations simultaneously, it's not possible for them to lose.</p> <p>One could perform a brute-force check to see that there is no possible way for Alice and Bob to simultaneously satisfy all four equations. The best they can do is satisfy three out of the four equations</p> \\[ \\begin{equation} \\begin{aligned} a_0 \\oplus b_0 = 0, \\quad a_0 \\oplus b_1 = 0, \\\\ a_1 \\oplus b_0 = 0. \\end{aligned} \\end{equation} \\] <p>They can achieve this if they either have answers \\(a_0 = b_0 = a_1 = b_1 = 0\\) or \\(a_0 = b_0 = a_1 = b_1 = 1\\).</p> <p>Since it is not possible to satisfy all four equations, but it is possible to satisfy three out of the four equations, the classical value of the CHSH game is \\(3/4\\), or stated in an equivalent way</p> \\[ \\begin{equation} \\omega(G_{CHSH}) = 3/4 = 0.75. \\end{equation} \\] <p>We can verify this by making use of <code>|toqito\u27e9</code> to compute the classical value of the CHSH game.</p> <pre><code>from toqito.nonlocal_games.xor_game import XORGame\n\nchsh = XORGame(prob_mat, pred_mat)\nprint(f\"The classical value of game is: {chsh.classical_value()}\")\n</code></pre> <p>Out:</p> <pre><code>The classical value of game is: 0.75\n</code></pre>"},{"location":"generated/gallery/nonlocal_games/xor_quantum_value/#a-quantum-strategy-for-the-chsh-game","title":"A quantum strategy for the CHSH game","text":"<p>What is very intriguing about the CHSH game is that it is an example of a nonlocal game where the players can do strictly better if they make use of a quantum strategy instead of a classical one. The quantum strategy that allows the players to do strictly better is composed of the following shared state and sets of measurements.</p> <ul> <li>State: The players prepare and share the state:</li> </ul> \\[ | \\psi \\rangle = \\frac{1}{\\sqrt{2}} \\left(| 00 \\rangle + | 11 \\rangle \\right). \\] <ul> <li>Measurements: The players measure with respect to the following basis</li> </ul> \\[ | \\phi_0 \\rangle = \\cos(\\theta)|0 \\rangle + \\sin(\\theta)|1 \\rangle, \\quad | \\phi_1 \\rangle = -\\sin(\\theta)|0 \\rangle + \\cos(\\theta)|1 \\rangle, \\] <p>such that</p> <ul> <li> <p>If \\(x = 0\\) Alice sets \\(\\theta = 0\\).     Otherwise, if \\(x = 1\\), Alice sets \\(\\theta = \\pi/4\\).</p> </li> <li> <p>If \\(y = 0\\) Bob sets \\(\\theta = \\pi/8\\).     Otherwise, if \\(y = 1\\), Bob sets \\(\\theta = -\\pi/8\\).</p> </li> </ul> <p>We can now analyze how well this particular quantum strategy performs by analyzing what occurs in each of the four possible scenarios. For brevity, we will just analyze the first case, but analyzing the remaining cases follows a similar analysis.</p> <ul> <li>Case: \\(x = 0, y = 0\\):</li> </ul> <p>In this case, Alice and Bob win if \\(a = b = 0\\) or if \\(a = b = 1\\).   Alice receives question \\(x\\) and selects her measurements constructed from   the basis as specified in the strategy.</p> \\[ A_0^0 = | \\phi_0 \\rangle \\langle \\phi_0 | \\quad \\text{and} \\quad A_1^0 = | \\phi_1 \\rangle \\langle \\phi_1 | \\] <p>where</p> \\[ \\begin{aligned} | \\phi_0 \\rangle &amp;= \\cos(0)| 0 \\rangle + \\sin(0)| 1 \\rangle, \\\\ | \\phi_1 \\rangle &amp;= -\\sin(0)| 0 \\rangle + \\cos(0)| 1 \\rangle. \\end{aligned} \\] <p>In a similar way, since Bob receives question \\(y = 0\\), he selects his   measurements from the basis</p> \\[ \\begin{aligned} | \\phi_0 \\rangle &amp;= \\cos(\\pi/8)| 0 \\rangle + \\sin(\\pi/8)| 1 \\rangle, \\\\ | \\phi_1 \\rangle &amp;= -\\sin(\\pi/8)| 0 \\rangle + \\cos(\\pi/8)| 1 \\rangle. \\end{aligned} \\] <p>where the measurement operators themselves are defined as</p> \\[ B_0^0 = | \\phi_0 \\rangle \\quad \\text{and} \\quad B_1^0 = | \\phi_1 \\rangle \\langle \\phi_1 | \\] <p>Using these measurements, we can calculate the probability that Alice and Bob   win on the inputs \\(x = 0\\) and \\(y = 0\\) as</p> \\[ p(a, b|0, 0) = \\langle \\psi | A_0^0 \\otimes B_0^0 | \\psi \\rangle + \\langle \\psi | A_1^0 \\otimes B_1^0 | \\psi \\rangle. \\] <p>Calculating the above equation and normalizing by a factor of \\(1/4\\), we obtain the value of \\(\\cos^2(\\pi/8)\\). Calculating the remaining three cases of \\((x = 0, y = 1), (x = 1, y = 0)\\), and \\((x = 1, y = 1)\\) follow a similar analysis.</p> <p>We can see that using this quantum strategy the players win the CHSH game with a probability of \\(\\cos^2(\\pi/8) \\approx 0.85355\\), which is quite a bit better than the best classical strategy yielding a probability of \\(3/4\\) to win. As it turns out, the winning probability \\(\\cos^2(\\pi/8)\\) using a quantum strategy is optimal, which we can represent as \\(\\omega^*(G_{CHSH}) = \\cos^2(\\pi/8)\\).</p> <p>We can calculate the quantum value of the CHSH game using <code>|toqito\u27e9</code> as follows:</p> <pre><code>import numpy as np\n\nprint(f\"The quantum value of game is: {np.around(chsh.quantum_value(), decimals=2)}\")\n</code></pre> <p>Out:</p> <pre><code>/home/runner/work/toqito/toqito/.venv/lib/python3.12/site-packages/scs/__init__.py:83: UserWarning: Converting A to a CSC (compressed sparse column) matrix; may take a while.\n  warn(\nThe quantum value of game is: 0.85\n</code></pre> <p>For reference, the complete code to calculate both the classical and quantum values of the CHSH game is provided below.</p> <pre><code>import numpy as np\n\nfrom toqito.nonlocal_games.xor_game import XORGame\n\nprob_mat = np.array([[1 / 4, 1 / 4], [1 / 4, 1 / 4]])\npred_mat = np.array([[0, 0], [0, 1]])\nchsh = XORGame(prob_mat, pred_mat)\nprint(f\"The classical value of games is: {chsh.classical_value()}\")\nprint(f\"The quantum value of games is: {np.around(chsh.quantum_value(), decimals=2)}\")\n</code></pre> <p>Out:</p> <pre><code>The classical value of games is: 0.75\n/home/runner/work/toqito/toqito/.venv/lib/python3.12/site-packages/scs/__init__.py:83: UserWarning: Converting A to a CSC (compressed sparse column) matrix; may take a while.\n  warn(\nThe quantum value of games is: 0.85\n</code></pre>"},{"location":"generated/gallery/nonlocal_games/xor_quantum_value/#the-odd-cycle-game","title":"The odd cycle game","text":"<p>The odd cycle game is another two-player XOR game with the following question and answer sets</p> \\[ \\begin{equation} \\begin{aligned} \\Sigma_{A} = \\Sigma_B = \\mathbb{Z}_n \\qquad \\text{and} \\qquad \\Gamma_A = \\Gamma_B = \\{0, 1\\}, \\end{aligned} \\end{equation} \\] <p>where \\(\\pi\\) is the uniform probability distribution over the question set.</p> <p>As an example, we can specify the odd cycle game for \\(n=5\\) and calculate the classical and quantum values of this game.</p> <pre><code>import numpy as np\n\nfrom toqito.nonlocal_games.xor_game import XORGame\n\n# Define the probability matrix.\nprob_mat = np.array(\n    [[0.1, 0.1, 0, 0, 0], [0, 0.1, 0.1, 0, 0], [0, 0, 0.1, 0.1, 0], [0, 0, 0, 0.1, 0.1], [0.1, 0, 0, 0, 0.1]]\n)\n\n# Define the predicate matrix.\npred_mat = np.array([[0, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 0], [0, 0, 0, 0, 1], [1, 0, 0, 0, 0]])\n\n# Compute the classical and quantum values.\nodd_cycle = XORGame(prob_mat, pred_mat)\nprint(f\"The classical value of games is: {np.around(odd_cycle.classical_value(), decimals=2)}\")\nprint(f\"The quantum value of games is: {np.around(odd_cycle.quantum_value(), decimals=2)}\")\n# mkdocs_gallery_thumbnail_path = 'figures/logo.png'\n</code></pre> <p>Out:</p> <pre><code>The classical value of games is: 0.9\n/home/runner/work/toqito/toqito/.venv/lib/python3.12/site-packages/scs/__init__.py:83: UserWarning: Converting A to a CSC (compressed sparse column) matrix; may take a while.\n  warn(\nThe quantum value of games is: 0.98\n</code></pre> <p>Note that the odd cycle game is another example of an XOR game where the players are able to win with a strictly higher probability if they adopt a quantum strategy. For a general XOR game, Alice and Bob may perform equally well whether they adopt either a quantum or classical strategy. It holds that the quantum value for any XOR game is a natural upper bound on the classical value. That is, for an XOR game, \\(G\\), it holds that</p> \\[ \\omega(G) \\leq \\omega^*(G), \\] <p>for every XOR game \\(G\\).</p> <p>Total running time of the script: ( 0 minutes  0.021 seconds)</p> <p> Download Python source code: xor_quantum_value.py</p> <p> Download Jupyter notebook: xor_quantum_value.ipynb</p> <p>Gallery generated by mkdocs-gallery</p> <ol> <li> <p>Richard Cleve, William Slofstra, Falk Unger, and Sarvagya Upadhyay. Strong parallel repetition theorem for quantum xor proof systems. 2008. arXiv:quant-ph/0608146.\u00a0\u21a9</p> </li> </ol>"},{"location":"generated/gallery/quantum_states/circulant_states/","title":"Antidistinguishability of Circulant States and the Eigenvalue Criterion","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/quantum_states/circulant_states/#antidistinguishability-of-circulant-states-and-the-eigenvalue-criterion","title":"Antidistinguishability of Circulant States and the Eigenvalue Criterion","text":"<p>In this tutorial, we investigate the antidistinguishability of a special class of quantum states known as circulant states. We will numerically verify a necessary and sufficient condition based on the eigenvalues of the states' Gram matrix, as presented in the paper by Johnston et al. <sup>1</sup>.</p> <p>This tutorial builds upon the concepts introduced in the Quantum state exclusion tutorial.</p>"},{"location":"generated/gallery/quantum_states/circulant_states/#eigenvalue-criterion-for-circulant-states","title":"Eigenvalue Criterion for Circulant States","text":"<p>A set of \\(n\\) pure states is called circulant if its Gram matrix is circulant. A matrix is circulant if each of its rows is a cyclic shift of the row above it. Such sets of states have a high degree of symmetry and appear in various quantum information contexts.</p> <p>A key result from (Theorem 5.1) <sup>1</sup> provides a simple and exact criterion for determining if a circulant set is antidistinguishable, based solely on the eigenvalues of its Gram matrix.</p> <p>The theorem states that a set of \\(n\\) states with a circulant Gram matrix \\(G\\) is antidistinguishable if and only if its eigenvalues \\(\\lambda_0 \\ge \\lambda_1 \\ge \\cdots \\ge \\lambda_{n-1}\\) satisfy the following inequality:</p> \\[ \\sqrt{\\lambda_0} \\le \\sum_{j=1}^{n-1} \\sqrt{\\lambda_j} \\] <p>This gives us a direct analytical test that is much more efficient than solving a full semidefinite program (SDP). We can use <code>|toqito\u27e9</code> to verify this equivalence. %%</p>"},{"location":"generated/gallery/quantum_states/circulant_states/#numerical-verification","title":"Numerical Verification","text":"<p>Our plan to verify this theorem is as follows:</p> <ol> <li>Generate a random circulant Gram matrix \\(G\\) using     <code>random_circulant_gram_matrix</code>.</li> <li>Compute its eigenvalues and perform the analytical check using the     inequality from the theorem.</li> <li>Generate the corresponding set of state vectors from \\(G\\) using     <code>vectors_from_gram_matrix</code>.</li> <li>Perform a numerical check by calling the high-level function     <code>is_antidistinguishable</code> to directly verify the property.</li> <li>Confirm that the analytical and numerical checks yield the same conclusion.</li> </ol> <pre><code>import numpy as np\n\nfrom toqito.matrix_ops import vectors_from_gram_matrix\nfrom toqito.rand import random_circulant_gram_matrix\nfrom toqito.state_props import is_antidistinguishable\n\n# 1. Define parameters and generate a random circulant Gram matrix.\nn = 5\n# Use a seed for reproducibility.\nseed = 42\n\nprint(f\"Generating a random {n}x{n} circulant Gram matrix (seed={seed})...\")\ngram_matrix = random_circulant_gram_matrix(n, seed=seed)\n\n# 2. Perform the analytical check based on the eigenvalue criterion.\n# Use 'eigvalsh' for Hermitian matrices; it's faster and returns real eigenvalues.\neigenvalues = np.linalg.eigvalsh(gram_matrix)\n# Sort eigenvalues in descending order.\neigenvalues = np.sort(eigenvalues)[::-1]\nlambda_0 = eigenvalues[0]\nother_lambdas = eigenvalues[1:]\n\n# The analytical check from the theorem:\nlhs = np.sqrt(lambda_0)\n# The sum of the square roots of the other eigenvalues.\n# Use np.maximum to avoid numerical precision errors leading to sqrt of tiny negative numbers.\nrhs = np.sum(np.sqrt(np.maximum(0, other_lambdas)))\nanalytical_is_ad = lhs &lt;= rhs\n\nprint(\"\\nANALYTICAL CHECK (from Theorem 5.1 of Johnston et al.):\")\nprint(f\"  sqrt(\u03bb\u2080) = {lhs:.4f}\")\nprint(f\"  \u03a3 sqrt(\u03bb\u2c7c) for j&gt;0 = {rhs:.4f}\")\nprint(f\"  Is sqrt(\u03bb\u2080) &lt;= \u03a3 sqrt(\u03bb\u2c7c)? {analytical_is_ad}\")\nprint(f\"  Conclusion: The set SHOULD BE antidistinguishable: {analytical_is_ad}\")\n\n# 3. Generate states from the Gram matrix for the numerical check.\nstates = vectors_from_gram_matrix(gram_matrix)\n\n# 4. Perform the numerical check using |toqito\u27e9's high-level function.\nnumerical_is_ad = is_antidistinguishable(states)\n\nprint(\"\\nNUMERICAL CHECK (via is_antidistinguishable function):\")\nprint(f\"  Conclusion: The set IS antidistinguishable: {numerical_is_ad}\")\n\n# 5. Verify that both methods agree.\nprint(\"\\n------------------------------------------------------\")\nprint(f\"Do the analytical and numerical results agree? {analytical_is_ad == numerical_is_ad}\")\nprint(\"------------------------------------------------------\")\n# mkdocs_gallery_thumbnail_path = 'figures/logo.png'\n</code></pre> <p>Out:</p> <pre><code>Generating a random 5x5 circulant Gram matrix (seed=42)...\n\nANALYTICAL CHECK (from Theorem 5.1 of Johnston et al.):\n  sqrt(\u03bb\u2080) = 0.8820\n  \u03a3 sqrt(\u03bb\u2c7c) for j&gt;0 = 2.7943\n  Is sqrt(\u03bb\u2080) &lt;= \u03a3 sqrt(\u03bb\u2c7c)? True\n  Conclusion: The set SHOULD BE antidistinguishable: True\n\nNUMERICAL CHECK (via is_antidistinguishable function):\n  Conclusion: The set IS antidistinguishable: True\n\n------------------------------------------------------\nDo the analytical and numerical results agree? True\n------------------------------------------------------\n</code></pre> <p>The results from both the analytical eigenvalue criterion and the numerical check using <code>|toqito\u27e9</code>'s helper function agree, providing a concrete verification of Theorem 5.1 from <sup>1</sup>. This demonstrates how a deep theoretical result can provide a powerful and efficient shortcut for a problem that would otherwise require a more computationally intensive optimization.</p> <p>Total running time of the script: ( 0 minutes  0.021 seconds)</p> <p> Download Python source code: circulant_states.py</p> <p> Download Jupyter notebook: circulant_states.ipynb</p> <p>Gallery generated by mkdocs-gallery</p> <ol> <li> <p>Nathaniel Johnston, Vincent Russo, and Jamie Sikora. Tight bounds for antidistinguishability and circulant sets of pure quantum states. Quantum, 9:1622, 2025.\u00a0\u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"generated/gallery/quantum_states/classification/","title":"Quantum classification, factor width, k-incoherence","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/quantum_states/classification/#quantum-classification-factor-width-k-incoherence","title":"Quantum classification, factor width, k-incoherence","text":"<p>This example accompanies the \"The complexity of quantum state classification\" paper <sup>1</sup>.</p> <p>In this tutorial, we will cover the concepts of the so-called \"learnability\" of quantum states along with related settings of \"factor width\" and the notion of \\(k\\)-incoherence of a matrix. More details can be found in the aforementioned paper.</p>"},{"location":"generated/gallery/quantum_states/classification/#learnability-of-quantum-states","title":"Learnability of quantum states","text":"<p>To illustrate \\(k\\)-learnability, consider the following generalization of the trine states to four states in three dimensions, called the tetrahedral states:</p> \\[ \\begin{aligned} \\ket{\\psi_1} = \\frac{1}{\\sqrt{3}} (\\ket{0} + \\ket{1} + \\ket{2}), \\quad &amp; \\ket{\\psi_2} = \\frac{1}{\\sqrt{3}} (\\ket{0} - \\ket{1} - \\ket{2}), \\\\ \\ket{\\psi_3} = \\frac{1}{\\sqrt{3}} (-\\ket{0} - \\ket{1} + \\ket{2}), \\quad &amp; \\ket{\\psi_4} = \\frac{1}{\\sqrt{3}} (-\\ket{0} + \\ket{1} - \\ket{2}). \\end{aligned} \\] <pre><code>import numpy as np\n\n\ndef tetrahedral_states() -&gt; list[np.ndarray]:\n    return [\n        np.array([1, 1, 1], dtype=np.complex128) / np.sqrt(3),\n        np.array([1, -1, -1], dtype=np.complex128) / np.sqrt(3),\n        np.array([-1, -1, 1], dtype=np.complex128) / np.sqrt(3),\n        np.array([-1, 1, -1], dtype=np.complex128) / np.sqrt(3),\n    ]\n\n\nprint(tetrahedral_states())\n</code></pre> <p>Out:</p> <pre><code>[array([0.57735027+0.j, 0.57735027+0.j, 0.57735027+0.j]), array([ 0.57735027+0.j, -0.57735027+0.j, -0.57735027+0.j]), array([-0.57735027+0.j, -0.57735027+0.j,  0.57735027+0.j]), array([-0.57735027+0.j,  0.57735027+0.j, -0.57735027+0.j])]\n</code></pre> <p>This set of states is \\(2\\)-learnable, upon receiving one of them, one can always guess two states from which it was selected without error.</p> <pre><code>from toqito.state_props import learnability\n\nstates = tetrahedral_states()\nlearnability_result = learnability(states, k=2)\nprint(f\"Average classification error (k=2): {learnability_result['value']}\")\n</code></pre> <p>Out:</p> <pre><code>Average classification error (k=2): 8.148409457769262e-06\n</code></pre> <p>Indeed, can be accomplished using the following POVM \\(M_{i,j} = \\frac{1}{2} \\ket{\\phi_{i,j}} \\bra{\\phi_{i,j}}\\), where</p> \\[ \\begin{aligned} \\ket{\\phi_{1,2}} &amp;= \\frac{1}{\\sqrt{2}}(\\ket{1} + \\ket{2}), \\quad \\ket{\\phi_{1,3}} = \\frac{1}{\\sqrt{2}}(\\ket{0} + \\ket{1}), \\quad \\ket{\\phi_{1,4}} = \\frac{1}{\\sqrt{2}}(\\ket{0} + \\ket{2}), \\\\ \\ket{\\phi_{2,3}} &amp;= \\frac{1}{\\sqrt{2}}(\\ket{0} - \\ket{2}), \\quad \\ket{\\phi_{2,4}} &amp;= \\frac{1}{\\sqrt{2}}(\\ket{0} - \\ket{1}), \\quad \\ket{\\phi_{3,4}} = \\frac{1}{\\sqrt{2}}(\\ket{1} - \\ket{2}). \\end{aligned} \\] <pre><code>def povm_residual(states: list[np.ndarray], povm: dict[tuple[int, int], np.ndarray]) -&gt; tuple[float, float]:\n    \"\"\"Return the maximum POVM reconstruction and support violations.\"\"\"\n    dim = states[0].shape[0]\n    total = sum(povm.values(), np.zeros((dim, dim), dtype=np.complex128))\n    sum_residual = np.max(np.abs(total - np.eye(dim)))\n\n    zero_residual = 0.0\n    for idx, state in enumerate(states):\n        for subset, operator in povm.items():\n            if idx not in subset:\n                zero_residual = max(zero_residual, np.abs(np.vdot(state, operator @ state)))\n    return sum_residual, zero_residual\n\n\nphi_vectors = {\n    (0, 1): np.array([0, 1, 1], dtype=np.complex128) / np.sqrt(2),\n    (0, 2): np.array([1, 1, 0], dtype=np.complex128) / np.sqrt(2),\n    (0, 3): np.array([1, 0, 1], dtype=np.complex128) / np.sqrt(2),\n    (1, 2): np.array([1, 0, -1], dtype=np.complex128) / np.sqrt(2),\n    (1, 3): np.array([1, -1, 0], dtype=np.complex128) / np.sqrt(2),\n    (2, 3): np.array([0, 1, -1], dtype=np.complex128) / np.sqrt(2),\n}\npovm_elements = {pair: 0.5 * np.outer(vec, vec.conj()) for pair, vec in phi_vectors.items()}\n\nsum_res, zero_res = povm_residual(states, povm_elements)\nprint(f\"max|\u03a3 M_S - I|             : {sum_res:.2e}\")\nprint(f\"max|\u27e8\u03c8_i|M_S|\u03c8_i\u27e9| (i\u2209S)   : {zero_res:.2e}\")\n</code></pre> <p>Out:</p> <pre><code>max|\u03a3 M_S - I|             : 2.22e-16\nmax|\u27e8\u03c8_i|M_S|\u03c8_i\u27e9| (i\u2209S)   : 0.00e+00\n</code></pre> <p>By contrast however, these states are not \\(k=1\\)-learnable:</p> <pre><code>states = tetrahedral_states()\nlearnability_result = learnability(states, k=1)\nprint(f\"Average classification error (k=1): {learnability_result['value']}\")\n</code></pre> <p>Out:</p> <pre><code>Average classification error (k=1): 0.2500001320013096\n</code></pre>"},{"location":"generated/gallery/quantum_states/classification/#k-incoherence","title":"k-Incoherence","text":"<p>The notion of \\(k\\)-incoherence comes from <sup>2</sup>. For a positive integers, \\(k\\) and \\(n\\), the matrix \\(X \\in \\text{Pos}(\\mathbb{C}^n)\\) is called \\(k\\)-incoherent if there exists a positive integer \\(m\\), a set \\(S = \\{|\\psi_0\\rangle, |\\psi_1\\rangle,\\ldots, |\\psi_{m-1}\\rangle\\} \\subset \\mathbb{C}^n\\) with the property that each \\(|\\psi_i\\rangle\\) has at most \\(k\\) non-zero entries, and real scalars \\(c_0, c_1, \\ldots, c_{m-1} \\geq 0\\) for which</p> \\[ X = \\sum_{j=0}^{m-1} c_j |\\psi_j\\rangle \\langle \\psi_j|. \\] <p>This function checks if the provided density matrix <code>mat</code> is k-incoherent. It returns True if <code>mat</code> is k-incoherent and False if <code>mat</code> is not.</p> <p>For example, the following matrix is \\(2\\)-incoherent</p> \\[ \\begin{pmatrix} 2 &amp; 1 &amp; 2 \\\\ 1 &amp; 2 &amp; -1 \\\\ 2 &amp; -1 &amp; 5 \\end{pmatrix} \\] <p>Indeed, one can verify this numerically using the <code>is_k_incoherent</code>.</p> <pre><code>from toqito.matrix_props import is_k_incoherent\n\nmat = np.array([[2, 1, 2], [1, 2, -1], [2, -1, 5]])\nprint(is_k_incoherent(mat, 2))\n</code></pre> <p>Out:</p> <pre><code>True\n</code></pre>"},{"location":"generated/gallery/quantum_states/classification/#factor-width","title":"Factor width","text":"<p>Another closely related definition to \\(k\\)-incoherence is that of factor width <sup>3</sup><sup>4</sup><sup>5</sup> below.</p> <p>Let \\(k\\) be a positive integer. The factor width of a positive semidefinite matrix \\(X\\) is the smallest \\(k\\) such that it is \\(k\\)-incoherent.</p> <p>For example, the matrix \\(\\operatorname{diag}(1, 1, 0)\\) has factor width at most \\(1\\).</p> <pre><code>from toqito.matrix_props import factor_width\n\ndiag_mat = np.diag([1, 1, 0])\nresult = factor_width(diag_mat, k=1)\nprint(result[\"feasible\"])\n</code></pre> <p>Out:</p> <pre><code>True\n</code></pre> <p>Conversely, the rank-one matrix \\(\\frac{1}{2}\\begin{pmatrix} 1 &amp; 1 \\\\ 1 &amp; 1 \\end{pmatrix}\\) is not \\(1\\)-factorable.</p> <pre><code>hadamard = np.array([[1, 1], [1, 1]], dtype=np.complex128) / 2\nresult = factor_width(hadamard, k=1)\nprint(result[\"feasible\"])\n</code></pre> <p>Out:</p> <pre><code>False\n</code></pre> <p>This example comes directly from <sup>4</sup>. Suppose we want to determine the factor width of the rank-\\(3\\) matrix</p> \\[ M = \\begin{bmatrix} 2 &amp; 1 &amp; 1 &amp; -1 \\\\ 1 &amp; 2 &amp; 0 &amp; 1 \\\\ 1 &amp; 0 &amp; 2 &amp; -1 \\\\ -1 &amp; 1 &amp; -1 &amp; 2 \\end{bmatrix}. \\] <p>We start by finding a basis for \\(S := \\text{range}(M)\\), which can be done by picking a linearly independent set of \\(r = 3\\) columns of \\(M\\): \\(S = \\operatorname{span}\\{(2,1,1,-1), (1,2,0,1), (1,0,2,-1)\\}\\). Then \\(R_0 = \\{S\\}\\) and we proceed recursively:</p> \\[ \\begin{aligned} R_1 = \\{S_1, S_2, S_3, S_3\\}, \\quad \\text{where} \\quad S_1 &amp; = \\operatorname{span}\\{(0,1,-1,1), (0,1,-3,1)\\}, \\\\ S_2 &amp; = \\operatorname{span}\\{(1,0,2,-1), (3,0,2,-3)\\}, \\\\ S_3 &amp; = \\operatorname{span}\\{(1,2,0,1), (3,2,0,-1)\\}, \\ \\ \\text{and} \\\\ S_4 &amp; = \\operatorname{span}\\{(1,1,1,0), (3,3,1,0)\\}. \\end{aligned} \\] <p>To determine whether or not \\(M\\) is \\(3\\)-incoherent, we let \\(\\Pi_1\\), \\(\\Pi_2\\), \\(\\Pi_3\\), and \\(\\Pi_4\\) be the orthogonal projections onto \\(S_1\\), \\(S_2\\), \\(S_3\\), and \\(S_4\\), respectively. We then use semidefinite programming to determine whether or not there exist matrices \\(M_1, M_2, M_3, M_4 \\in \\text{Pos}(\\mathbb{C}^4)\\) for which</p> \\[ M = M_1 + M_2 + M_3 + M_4, \\quad \\text{and} \\quad M_j = \\Pi_j M_j \\Pi_j \\quad \\text{for all} \\quad j \\in \\{1,2,3,4\\}. \\] <p>Indeed, such matrices do exist:</p> \\[ M_1 = \\begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; -1 &amp; 1 \\\\ 0 &amp; -1 &amp; 1 &amp; -1 \\\\ 0 &amp; 1 &amp; -1 &amp; 1 \\end{bmatrix}, \\ M_2 = \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; -1 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 \\\\ -1 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix}, \\ M_3 = \\begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 \\end{bmatrix}, \\ M_4 = \\begin{bmatrix} 1 &amp; 1 &amp; 1 &amp; 0 \\\\ 1 &amp; 1 &amp; 1 &amp; 0 \\\\ 1 &amp; 1 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 \\end{bmatrix}, \\] <p>so \\(M\\) is \\(3\\)-incoherent. For example, we can verify this numerically using the <code>factor_width</code>.</p> <pre><code>mat = np.array(\n    [\n        [2, 1, 1, -1],\n        [1, 2, 0, 1],\n        [1, 0, 2, -1],\n        [-1, 1, -1, 2],\n    ],\n    dtype=np.complex128,\n)\nresult = factor_width(mat, k=3)\nprint(sum(result[\"factors\"]))\n</code></pre> <p>Out:</p> <pre><code>[[ 1.99999997e+00+0.j  9.99999984e-01+0.j  9.99999985e-01+0.j\n  -9.99999983e-01+0.j]\n [ 9.99999984e-01+0.j  1.99999997e+00+0.j  2.77555756e-16+0.j\n   9.99999984e-01+0.j]\n [ 9.99999985e-01+0.j  2.77555756e-16+0.j  2.00000000e+00+0.j\n  -9.99999985e-01+0.j]\n [-9.99999983e-01+0.j  9.99999984e-01+0.j -9.99999985e-01+0.j\n   1.99999997e+00+0.j]]\n</code></pre> <p>To similarly determine whether or not \\(M\\) is \\(2\\)-incoherent, we proceed further with the recursive construction by computing</p> \\[ R_2 = \\{S_{\\{1,2\\}}, S_{\\{1,3\\}}, S_{\\{2,3\\}}, S_{\\{3,4\\}}\\}, \\quad \\text{where} \\quad S_{\\{1,2\\}} = S_{\\{1,4\\}} = S_{\\{2,4\\}} = \\operatorname{span}\\{(0,0,1,0)\\}, \\] \\[ S_{\\{1,3\\}} = \\operatorname{span}\\{(0,1,0,1)\\}, \\quad S_{\\{2,3\\}} = \\operatorname{span}\\{(1,0,0,-1)\\}, \\quad \\text{and} \\quad S_{\\{3,4\\}} = \\operatorname{span}\\{(1,1,0,0)\\}. \\] <p>It follows that the only vectors in \\(\\text{range}(M)\\) with \\(k = 2\\) or fewer non-zero entries are the scalar multiples of \\({v_1} := (0,0,1,0)\\), \\({v_2} := (0,1,0,1)\\), \\({v_3} := (1,0,0,-1)\\), and \\({v_4} := (1,1,0,0)\\), so \\(M\\) is \\(2\\)-incoherent if and only if there exist non-negative real scalars \\(c_1\\), \\(c_2\\), \\(c_3\\), and \\(c_4\\) for which</p> \\[ M = c_1 v_1 v_1^* + c_2 v_2 v_2^* + c_3 v_3 v_3^* + c_4 v_4 v_4^*. \\] <p>It is straightforward to use semidefinite programming (or even just solve by hand in this small example) to see that no such scalars exist, so \\(X\\) is not \\(2\\)-incoherent. It follows that \\(X\\) has factor width \\(3\\).</p> <pre><code>result = factor_width(mat, k=2)\nprint(result[\"feasible\"])\n# mkdocs_gallery_thumbnail_path = 'figures/logo.png'\n</code></pre> <p>Out:</p> <pre><code>False\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.219 seconds)</p> <p> Download Python source code: classification.py</p> <p> Download Jupyter notebook: classification.ipynb</p> <p>Gallery generated by mkdocs-gallery</p> <ol> <li> <p>Nathaniel Johnston, Benjamin Lovitz, Vincent Russo, and Jamie Sikora. The complexity of quantum state classification. 2025. arXiv:X.\u00a0\u21a9</p> </li> <li> <p>Nathaniel Johnston, Shirin Moein, Rajesh Pereira, and Sarah Plosker. Absolutely k-incoherent quantum states and spectral inequalities for the factor width of a matrix. Physical Review A, 106(5):052417, 2022.\u00a0\u21a9</p> </li> <li> <p>Francesco Barioli and Abraham Berman. The maximal CP-rank of rank \\(k\\) completely positive matrices. Linear Algebra and its Applications, 363:17\u201333, 2003. doi:10.1016/S0024-3795(02)00250-1.\u00a0\u21a9</p> </li> <li> <p>Nathaniel Johnston, Shirin Moein, and Sarah Plosker. The factor width rank of a matrix. Linear Algebra and its Applications, 716:32\u201359, 2025. doi:10.1016/j.laa.2025.03.016.\u00a0\u21a9\u21a9</p> </li> <li> <p>Erik G Boman, Doron Chen, Ojas Parekh, and Sivan Toledo. On factor width and symmetric H-matrices. Linear algebra and its applications, 405:239\u2013248, 2005. doi:10.1016/j.laa.2005.03.029.\u00a0\u21a9</p> </li> </ol>"},{"location":"generated/gallery/quantum_states/equiangular_threshold/","title":"Equiangular States and the Antidistinguishability Threshold","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/quantum_states/equiangular_threshold/#equiangular-states-and-the-antidistinguishability-threshold","title":"Equiangular States and the Antidistinguishability Threshold","text":"<p>In this tutorial, we explore a sharp threshold for the antidistinguishability of a special class of quantum states known as equiangular states. We will numerically verify a tight bound presented in the paper by Johnson et.al <sup>1</sup> and visualize the \"sharp cliff\" where this property changes.</p> <p>This tutorial builds upon the concepts introduced in the Quantum state exclusion tutorial.</p>"},{"location":"generated/gallery/quantum_states/equiangular_threshold/#antidistinguishability-threshold-for-equiangular-states","title":"Antidistinguishability Threshold for Equiangular States","text":"<p>A set of \\(n\\) pure states \\(\\{|\\psi_0\\rangle, \\ldots, |\\psi_{n-1}\\rangle\\}\\) is called equiangular if the absolute value of the inner product between any two distinct states is a constant, i.e., \\(|\\langle \\psi_i | \\psi_j \\rangle| = \\gamma\\) for all \\(i \\neq j\\).</p> <p>Johnston et.al <sup>1</sup> introduced a simple and powerful necessary condition for a set of states to be antidistinguishable.</p> <p>According to Corollary 4.2 from <sup>1</sup>, when \\(n \\geq 2\\), \\(S = \\{| \\psi_0\\rangle, \\ldots, |\\psi_{n-1}\\rangle\\}\\) is not anstidistinguishable if the following condition is satisfied.</p> \\[ |\\langle \\psi_i | \\psi_j \\rangle| &gt; \\frac{n-2}{n-1} \\quad \\forall \\ i \\neq j, \\] <p>Crucially, Example 3.3 in the paper demonstrates that this bound is tight. That is, a set of equiangular states with an inner product exactly equal to the threshold \\(\\gamma = \\frac{n-2}{n-1}\\) is antidistinguishable. We can use <code>|toqito\u27e9</code> to verify this sharp transition.</p>"},{"location":"generated/gallery/quantum_states/equiangular_threshold/#numerical-verification","title":"Numerical Verification","text":"<p>To demonstrate the tightness of this bound, we follow Example 3.3 from the paper <sup>1</sup>. The Gram matrix for a set of \\(n\\) equiangular states is given by</p> \\[ G = (1 - \\gamma) I + \\gamma J, \\] <p>where \\(I\\) is the identity matrix and \\(J\\) is the all-ones matrix.</p> <p>We will verify the threshold for the \\(n=4\\) case, where the critical inner product is \\(\\gamma_{\\text{crit}} = (4-2)/(4-1) = 2/3\\). Our verification plan is as follows:</p> <ol> <li>Construct the Gram matrix \\(G_{\\text{at}}\\) for \\(\\gamma = \\gamma_{\\text{crit}}\\).</li> <li>Construct a second Gram matrix \\(G_{\\text{above}}\\) for \\(\\gamma\\) slightly greater than \\(\\gamma_{\\text{crit}}\\).</li> <li>For each Gram matrix, use <code>|toqito\u27e9</code> to generate a corresponding set of state vectors.</li> <li>For each set of states, compute the minimum probability of error for state exclusion using the <code>state_exclusion</code> function.</li> <li>Confirm that the states at the threshold are antidistinguishable (error probability is \\(0\\)) and the states above it are not (error probability is &gt; \\(0\\)).</li> </ol> <pre><code>import numpy as np\n\nfrom toqito.matrix_ops import vectors_from_gram_matrix\nfrom toqito.state_opt import state_exclusion\n\n# Define parameters for n=4.\nn = 4\ngamma_crit = (n - 2) / (n - 1)\n# Use a larger epsilon to make the effect numerically obvious.\nepsilon = 0.01\n\nprint(f\"For n={n}, the critical threshold is \u03b3 = {gamma_crit:.4f}\")\n\n# 1. Construct and test the Gram matrix AT the threshold.\ngamma_at = gamma_crit\ngram_at = (1 - gamma_at) * np.identity(n) + gamma_at * np.ones((n, n))\nstates_at = vectors_from_gram_matrix(gram_at)\nopt_val_at, _ = state_exclusion(states_at)\nis_ad_at = np.isclose(opt_val_at, 0)\n\nprint(f\"\\nFor \u03b3 = {gamma_at:.4f} (at threshold):\")\nprint(f\"  - Optimal error probability is {opt_val_at:.2e}\")\nprint(f\"  - Is the set antidistinguishable? {is_ad_at} (as expected)\")\n\n# 2. Construct and test the Gram matrix slightly ABOVE the threshold.\ngamma_above = gamma_crit + epsilon\ngram_above = (1 - gamma_above) * np.identity(n) + gamma_above * np.ones((n, n))\nstates_above = vectors_from_gram_matrix(gram_above)\nopt_val_above, _ = state_exclusion(states_above)\nis_ad_above = np.isclose(opt_val_above, 0)\n\nprint(f\"\\nFor \u03b3 = {gamma_above:.4f} (above threshold):\")\nprint(f\"  - Optimal error probability is {opt_val_above:.2e}\")\nprint(f\"  - Is the set antidistinguishable? {is_ad_above} (as expected)\")\n</code></pre> <p>Out:</p> <pre><code>For n=4, the critical threshold is \u03b3 = 0.6667\n\nFor \u03b3 = 0.6667 (at threshold):\n  - Optimal error probability is 5.11e-11\n  - Is the set antidistinguishable? True (as expected)\n\nFor \u03b3 = 0.6767 (above threshold):\n  - Optimal error probability is 7.58e-05\n  - Is the set antidistinguishable? False (as expected)\n</code></pre>"},{"location":"generated/gallery/quantum_states/equiangular_threshold/#antidistinguishability-and-n-1-incoherence","title":"Antidistinguishability and (n-1)-Incoherence","text":"<p>The core theoretical result of (Theorem 3.2) <sup>1</sup> is that a set of \\(n\\) pure states is antidistinguishable if and only if its Gram matrix is \\((n-1)\\)-incoherent. Our numerical results above, obtained by solving the state exclusion SDP, implicitly verify this property for the Gram matrix as well.</p>"},{"location":"generated/gallery/quantum_states/equiangular_threshold/#visualizing-the-threshold","title":"Visualizing the Threshold","text":"<p>We can make this \"sharp cliff\" even clearer by plotting the optimal error probability of state exclusion against the inner product \\(\\gamma\\). To match the style of Figure 2 from <sup>1</sup>, we will plot this for several values of \\(n\\).</p> <p>The value returned by <code>state_exclusion</code> is the optimal probability of error. The plot should show this probability lifting off from \\(0\\) precisely at the threshold \\(\\gamma_{\\text{crit}} = (n-2)/(n-1)\\) for each respective \\(n\\).</p> <p>A Gram matrix for equiangular states is positive semidefinite (and thus physically valid) if and only if \\(-1/(n-1) \\leq \\gamma \\leq 1\\).</p> <pre><code>import matplotlib.pyplot as plt\n\nfrom toqito.matrix_props import is_positive_semidefinite\n\nfig, ax = plt.subplots(figsize=(8, 5), dpi=100)\ngamma_range = np.linspace(0, 0.999, 101)\nn_vals_to_plot = [2, 3, 4, 5, 10]\n\nfor n_val in n_vals_to_plot:\n    error_probs = []\n    gamma_crit_n = (n_val - 2) / (n_val - 1)\n\n    for gamma in gamma_range:\n        # The Gram matrix is only PSD in a specific range.\n        if gamma &lt; -1 / (n_val - 1):\n            error_probs.append(np.nan)\n            continue\n\n        gram_matrix = (1 - gamma) * np.identity(n_val) + gamma * np.ones((n_val, n_val))\n\n        if is_positive_semidefinite(gram_matrix):\n            states = vectors_from_gram_matrix(gram_matrix)\n            opt_val, _ = state_exclusion(states)\n            # The returned optimal value is the error probability.\n            error_probs.append(opt_val)\n        else:\n            # If not PSD, it's not a valid Gram matrix for a state ensemble.\n            error_probs.append(np.nan)\n\n    ax.plot(gamma_range, error_probs, label=f\"$n={n_val}$ ($\\\\gamma_{{crit}} \\\\approx {gamma_crit_n:.2f}$)\")\n\n\nax.set_xlabel(\"Inner Product $\\\\gamma = |\\\\langle \\\\psi_i | \\\\psi_j \\\\rangle|$\", fontsize=12)\nax.set_ylabel(\"Optimal Exclusion Error Probability\", fontsize=12)\nax.set_title(\"Antidistinguishability Threshold for Equiangular States\", fontsize=14)\nax.legend(fontsize=10)\nax.grid(True)\nax.set_ylim(bottom=-0.01)\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p> <p>This plot, which numerically reproduces the results from Figure 2 of <sup>1</sup>, shows that the optimal probability of error is exactly \\(0\\) for all \\(\\gamma \\leq (n-2)/(n-1)\\), indicating that the states are perfectly antidistinguishable. The moment \\(\\gamma\\) exceeds this value, the probability becomes non-zero, meaning perfect exclusion is no longer possible.</p> <p>Total running time of the script: ( 0 minutes  19.964 seconds)</p> <p> Download Python source code: equiangular_threshold.py</p> <p> Download Jupyter notebook: equiangular_threshold.ipynb</p> <p>Gallery generated by mkdocs-gallery</p> <ol> <li> <p>Nathaniel Johnston, Vincent Russo, and Jamie Sikora. Tight bounds for antidistinguishability and circulant sets of pure quantum states. Quantum, 9:1622, 2025.\u00a0\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"generated/gallery/quantum_states/mg_execution_times/","title":"Computation times","text":"<p>00:26.190 total execution time for generated_gallery_quantum_states files:</p> <p>+-------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | equiangular_threshold (content/examples/quantum_states/equiangular_threshold.py)          | 00:19.964 | 0.0 MB | +-------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | state_distinguishability (content/examples/quantum_states/state_distinguishability.py) | 00:05.516 | 0.0 MB | +-------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | classification (content/examples/quantum_states/classification.py)                               | 00:00.219 | 0.0 MB | +-------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | pgm_pbm (content/examples/quantum_states/pgm_pbm.py)                                                    | 00:00.218 | 0.0 MB | +-------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | pbr_theorem (content/examples/quantum_states/pbr_theorem.py)                                        | 00:00.203 | 0.0 MB | +-------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | state_exclusion (content/examples/quantum_states/state_exclusion.py)                            | 00:00.049 | 0.0 MB | +-------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | circulant_states (content/examples/quantum_states/circulant_states.py)                         | 00:00.021 | 0.0 MB | +-------------------------------------------------------------------------------------------------------------------------+-----------+--------+</p>"},{"location":"generated/gallery/quantum_states/pbr_theorem/","title":"The Pusey-Barrett-Rudolph (PBR) Theorem","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/quantum_states/pbr_theorem/#the-pusey-barrett-rudolph-pbr-theorem","title":"The Pusey-Barrett-Rudolph (PBR) Theorem","text":"<p>In this tutorial, we will explore the Pusey-Barrett-Rudolph (PBR) theorem, a significant no-go theorem in the foundations of quantum mechanics. We will describe the theorem's core argument and then use <code>|toqito\u27e9</code> to verify the central mathematical property that the theorem relies on.</p> <p>The PBR theorem <sup>1</sup> addresses a fundamental question: Is the quantum state (e.g., the wavefunction \\(|\\psi\\rangle\\)) a real, objective property of a single system (an ontic state), or does it merely represent our incomplete knowledge or information about some deeper underlying reality (an epistemic state)?</p>"},{"location":"generated/gallery/quantum_states/pbr_theorem/#pbr-argument","title":"PBR Argument","text":"<p>The PBR theorem <sup>1</sup> argues against a broad class of epistemic models.</p> <p>1. Epistemic Hypothesis: An epistemic model assumes there is a     \"real\" physical state of the system, often denoted by \\(\\lambda\\).     The quantum state \\(|\\psi\\rangle\\) is then just a probability     distribution over the possible values of \\(\\lambda\\). A key     implication is that the distributions for two different quantum states,     say \\(|\\psi_0\\rangle\\) and \\(|\\psi_1\\rangle\\), could overlap. This     means that for some underlying physical states \\(\\lambda\\), the system     could have been prepared in either \\(|\\psi_0\\rangle\\) or     \\(|\\psi_1\\rangle\\).</p> <p>We can visualize the overlap of these hypothetical probability distributions. To do this, we will create a simple illustrative plot. We are not assuming any specific physical model for \\(\\lambda\\); the plot is purely a visual aid to make the concept of overlapping probability distributions concrete.</p> <p>For this illustration, we represent the space of possible ontic states \\(\\lambda\\) on the x-axis. We then choose two simple, overlapping normal (Gaussian) distributions to represent the hypothetical probability densities \\(p(\\lambda | \\psi_0)\\) and \\(p(\\lambda | \\psi_1)\\). The specific choice of Gaussian distributions is arbitrary; any pair of distinct, overlapping distributions would demonstrate the same essential feature.</p> <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.stats import norm\n\nfig, ax = plt.subplots(figsize=(8, 4), dpi=100)\nlambda_space = np.linspace(-4, 4, 1000)\ndist_0 = norm(loc=-1, scale=1)\ndist_1 = norm(loc=1, scale=1)\np_lambda_0 = dist_0.pdf(lambda_space)\np_lambda_1 = dist_1.pdf(lambda_space)\nax.plot(lambda_space, p_lambda_0, label=r\"$p(\\lambda | \\psi_0)$\")\nax.plot(lambda_space, p_lambda_1, label=r\"$p(\\lambda | \\psi_1)$\")\nax.fill_between(\n    lambda_space,\n    np.minimum(p_lambda_0, p_lambda_1),\n    color=\"gray\",\n    alpha=0.5,\n    label=\"Overlap Region (\u0394)\",\n)\nax.set_xlabel(r\"Ontic State Space ($\\lambda$)\", fontsize=12)\nax.set_ylabel(r\"Probability Density\", fontsize=12)\nax.set_yticks([])\nax.legend(fontsize=12)\nax.spines[\"top\"].set_visible(False)\nax.spines[\"right\"].set_visible(False)\nax.spines[\"left\"].set_visible(False)\nplt.tight_layout()\n</code></pre> <p></p> <p>Note</p> <p>The shaded region \\(\\Delta\\) represents the set of ontic states \\(\\lambda\\) that are ambiguous\u2014the system could have been prepared as \\(|\\psi_0\\rangle\\) or \\(|\\psi_1\\rangle\\). The PBR theorem shows that the existence of any such overlap (for any pair of distinct states) leads to a contradiction with quantum theory's predictions. Figure adapted from the PBR paper <sup>1</sup>.</p> <p>2. Thought Experiment: The PBR paper <sup>1</sup> constructs a thought     experiment to show this leads to a contradiction. Consider two     non-orthogonal quantum states, for example:</p> \\[ |0\\rangle \\quad \\text{and } \\quad |+\\rangle = \\frac{1}{\\sqrt{2}}(|0\\rangle + |1\\rangle) \\] <p>If their underlying reality distributions overlap, it's possible to prepare a system where its true state \\(\\lambda\\) is consistent with both preparations. Now, imagine we prepare two such systems independently. There is a non-zero chance that the combined physical state \\((\\lambda_1, \\lambda_2)\\) is compatible with any of the four possible quantum preparations:</p> \\[ |0\\rangle \\otimes |0\\rangle, \\quad |0\\rangle \\otimes |+\\rangle, \\text{ } |+\\rangle \\otimes |0\\rangle, \\quad |+\\rangle \\otimes |+\\rangle \\] <p>3. Contradiction via Antidistinguishability: The crux of the     theorem is to show that quantum mechanics allows for a special     entangled measurement on the two systems. This measurement has a     remarkable property: each of its possible outcomes is strictly     forbidden (has zero probability) for at least one of the four     product states.</p> <p>This property is known as antidistinguishability. A set of states \\(\\{|\\Psi_i\\rangle\\}\\) is antidistinguishable if there exists a measurement with outcomes \\(\\{M_i\\}\\) such that \\(\\langle \\Psi_i | M_i | \\Psi_i \\rangle = 0\\) for all \\(i\\).</p> <p>This leads to a contradiction:</p> <ul> <li>The epistemic model predicts that sometimes the underlying         reality \\((\\lambda_1, \\lambda_2)\\) is ambiguous.</li> <li>In these cases, the measurement (which only depends on         \\(\\lambda\\)) must produce some outcome, say outcome \\(k\\).</li> <li>But what if the state was actually prepared as         \\(|\\Psi_k\\rangle\\)? Quantum mechanics says outcome \\(k\\)         is impossible for this state.</li> </ul> <p>This contradiction implies that the initial assumption\u2014that the distributions for \\(|0\\rangle\\) and \\(|+\\rangle\\) overlap\u2014must be false. The PBR theorem generalizes this to any pair of distinct quantum states. The conclusion is that, under the assumption of preparation independence, the quantum state must be ontic.</p>"},{"location":"generated/gallery/quantum_states/pbr_theorem/#verifying-antidistinguishability-with-toqito","title":"Verifying Antidistinguishability with <code>|toqito\u27e9</code>","text":"<p>We can now use <code>|toqito\u27e9</code> to verify the key requirement for the PBR theorem that the set of four states constructed from \\(|0\\rangle\\) and \\(|+\\rangle\\) are indeed antidistinguishable.</p> <pre><code>import numpy as np\n\nfrom toqito.matrices import standard_basis\nfrom toqito.matrix_ops import tensor\nfrom toqito.state_props import is_antidistinguishable\n\n# Define the single-qubit states |0&gt; and |+&gt;.\ne_0, e_1 = standard_basis(2)\nstate_0 = e_0\nstate_plus = (e_0 + e_1) / np.sqrt(2)\n\n# Construct the four 2-qubit product states from the PBR paper's simple example.\npsi_00 = tensor(state_0, state_0)\npsi_0_plus = tensor(state_0, state_plus)\npsi_plus_0 = tensor(state_plus, state_0)\npsi_plus_plus = tensor(state_plus, state_plus)\n\npbr_states = [psi_00, psi_0_plus, psi_plus_0, psi_plus_plus]\n\n# Check if this set of states is antidistinguishable.\nis_ad = is_antidistinguishable(pbr_states)\n\nprint(f\"Are the four PBR states antidistinguishable? {is_ad}\")\n</code></pre> <p>Out:</p> <pre><code>Are the four PBR states antidistinguishable? True\n</code></pre> <p>The result confirms that there exists a measurement that can perfectly exclude each of the four states, providing the necessary ingredient for the PBR no-go theorem's contradiction.</p> <p>This result, derived from a solvable semidefinite program within <code>|toqito\u27e9</code>'s  <code>state_exclusion</code> function supports the theorem's conclusion that the quantum state has a strong claim to being an objective feature of reality.</p>"},{"location":"generated/gallery/quantum_states/pbr_theorem/#general-pbr-states","title":"General PBR States","text":"<p>The theorem holds for any pair of non-orthogonal states. The <code>toqito</code> library provides a function to generate the states from the more general proof in the PBR paper <sup>1</sup>, which are defined by an angle \\(\\theta\\).</p> \\[ |\\psi_0\\rangle = \\cos(\\frac{\\theta}{2})|0\\rangle + \\sin(\\frac{\\theta}{2})|1\\rangle \\quad \\text{and } |\\psi_1\\rangle = \\cos(\\frac{\\theta}{2})|0\\rangle - \\sin(\\frac{\\theta}{2})|1\\rangle \\] <p>For instance, we can generate a set of \\(2^n\\) states for some \\(n\\) and \\(\\theta\\).</p> <pre><code>from toqito.states import pusey_barrett_rudolph\n\n# Generate states for n=2 systems and theta = pi/3\ngeneral_pbr_states = pusey_barrett_rudolph(n=2, theta=np.pi / 3)\n</code></pre> <p>The inner product of the two base states is \\(\\cos(\\theta)\\). For these to be antidistinguishable, we need to check the condition from the paper. The theorem states that if \\(2^{1/n} - 1 &lt; \\tan(\\theta/2)\\), a contradiction is obtained. For \\(n=2\\) and \\(\\theta=\\pi/3\\), we have \\(\\tan(\\theta/2) = \\tan(\\pi/6) \\approx 0.577\\). The other side of the inequality is \\(2^{1/2} - 1 \\approx 0.414\\). Since \\(0.414 &lt; 0.577\\), the theorem applies and this set should be antidistinguishable.</p> <pre><code>is_ad_general = is_antidistinguishable(general_pbr_states)\n\nprint(f\"\\nAre the four general PBR states (n=2, theta=pi/3) antidistinguishable? {is_ad_general}\")\n</code></pre> <p>Out:</p> <pre><code>Are the four general PBR states (n=2, theta=pi/3) antidistinguishable? True\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.203 seconds)</p> <p> Download Python source code: pbr_theorem.py</p> <p> Download Jupyter notebook: pbr_theorem.ipynb</p> <p>Gallery generated by mkdocs-gallery</p> <ol> <li> <p>Matthew F. Pusey, Jonathan Barrett, and Terry Rudolph. On the reality of the quantum state. Nature Physics, 8(6):475\u2013478, May 2012. URL: http://dx.doi.org/10.1038/nphys2309, doi:10.1038/nphys2309.\u00a0\u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"generated/gallery/quantum_states/pgm_pbm/","title":"The Pretty Good and Pretty Bad Measurements","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/quantum_states/pgm_pbm/#the-pretty-good-and-pretty-bad-measurements","title":"The Pretty Good and Pretty Bad Measurements","text":"<p>In this tutorial, we will explore the \"pretty good measurement\" (PGM) and its novel counterpart, the \"pretty bad measurement\" (PBM). The PGM, also known as the square-root measurement, is a widely used measurement for quantum state discrimination <sup>1</sup><sup>2</sup>. The PBM, in contrast, was recently introduced by McIrvin et. al. <sup>3</sup>. Both these measurements provide elegant, easy-to-construct tools for two opposing goals in quantum information: state discrimination and state exclusion. PGM is useful for the former while PBM is of use for the latter.</p> <p>We will verify their core properties and replicate some of the key numerical results and figures from the paper using <code>|toqito\u27e9</code>.</p>"},{"location":"generated/gallery/quantum_states/pgm_pbm/#background-discrimination-vs-exclusion","title":"Background: Discrimination vs. Exclusion","text":"<p>Bob wins the standard quantum state discrimination task, if he successfully guesses the state sent by Alice. Alice is sending Bob a quantum state \\(\\rho_i\\) chosen from an ensemble \\(\\{(p_i, \\rho_i)\\}_{i=1}^k\\) known to Bob. Bob's goal is to perform a measurement that maximizes his probability of correctly guessing the index \\(i\\). The best possible probability, \\(P_{\\text{Best}}\\), is the maximum success probability achievable over all possible measurements (POVMs) \\(\\{M_i\\}\\).</p> \\[ P_{\\text{Best}} = \\max \\sum_{i=1}^k p_i \\text{Tr}(M_i \\rho_i) \\] <p>However, finding \\(P_{\\text{Best}}\\) is often computationally very hard. The \"pretty good measurement\" (PGM) is a well-established heuristic for this task. Its measurement operators \\(G_i\\) are constructed from the ensemble as:</p> \\[ G_i = P^{-1/2} (p_i \\rho_i) P^{-1/2} \\quad \\text{where} \\quad P = \\sum_{i=1}^k p_i \\rho_i \\] <p>The success probability when using the PGM is given by the standard Born rule, averaged over the ensemble:</p> \\[ P_{\\text{PGM}} = \\sum_{i=1}^k p_i \\text{Tr}(\\rho_i G_i) \\] <p>The state exclusion task is the opposite: Bob wins if he correctly guesses a state that Alice did not send. This is equivalent to minimizing the probability of correctly guessing the state Alice did send. This minimum achievable success probability is denoted \\(P_{\\text{Worst}}\\):</p> \\[ P_{\\text{Worst}} = \\min \\sum_{i=1}^k p_i \\text{Tr}(M_i \\rho_i) \\] <p>The \"pretty bad measurement\" (PBM) is a heuristic designed to approximate this worst-case performance. The PBM is elegantly defined in terms of the PGM operators \\(G_i\\). In the formula below, \\(k\\) is the number of states in the ensemble, and \\(\\mathbb{I}\\) is the identity operator with the same dimensions as the states:</p> \\[ B_i = \\frac{1}{k-1}(\\mathbb{I} - G_i) \\] <p>The success probability for discrimination when using the PBM is, analogously:</p> \\[ P_{\\text{PBM}} = \\sum_{i=1}^k p_i \\text{Tr}(\\rho_i B_i) \\] <p>A key result from McIrvin et.al <sup>3</sup> is the tight relationship between the success probabilities of these two measurements:</p> \\[ P_{\\text{PGM}} + (k-1)P_{\\text{PBM}} = 1 \\] <p>This implies a performance hierarchy against the optimal probabilities and the blind guessing probability (\\(1/k\\)):</p> \\[ P_{\\text{Best}} \\ge P_{\\text{PGM}} \\ge \\frac{1}{k} \\ge P_{\\text{PBM}} \\ge P_{\\text{Worst}} \\] <p>We will verify this hierarchy with a concrete example.</p>"},{"location":"generated/gallery/quantum_states/pgm_pbm/#numerical-example-the-trine-states","title":"Numerical Example: The Trine States","text":"<p>Figure 3 from McIrvin et.al <sup>3</sup> analyzes the performance of these measurements for the three trine states with a uniform prior probability. The trine states are a classic example of a set that is antidistinguishable but not distinguishable, a property demonstrated in the Quantum state exclusion tutorial.</p> <p>Our plan is to:</p> <ol> <li>Generate the trine states and assume uniform prior probabilities.</li> <li>Compute the optimal win/loss probabilities, \\(P_{\\text{Best}}\\)     and \\(P_{\\text{Worst}}\\), using <code>|toqito\u27e9</code>'s SDP solvers.</li> <li>Construct the PGM and PBM measurement operators.</li> <li>Calculate the success probabilities \\(P_{\\text{PGM}}\\) and \\(P_{\\text{PBM}}\\).</li> <li>Print and compare all values, verifying the performance hierarchy and     the relationship between \\(P_{\\text{PGM}}\\) and \\(P_{\\text{PBM}}\\).</li> </ol> <pre><code>import numpy as np\n\nfrom toqito.measurements import pretty_bad_measurement, pretty_good_measurement\nfrom toqito.state_opt import state_distinguishability, state_exclusion\nfrom toqito.states import trine\n\n\ndef calculate_success_prob(\n    states: list[np.ndarray],\n    probs: list[float],\n    povm_operators: list[np.ndarray],\n) -&gt; float:\n    \"\"\"Calculate the success probability \u03a3 p\u1d62 Tr(\u03c1\u1d62 M\u1d62).\n\n    This helper is robust to `states` being either state vectors or density matrices.\n    \"\"\"\n    success_prob = 0\n    num_states = len(states)\n    for i in range(num_states):\n        state = states[i]\n        op = povm_operators[i]\n        # Check if input is a vector (pure state) or matrix (density matrix)\n        if state.ndim == 1 or (state.ndim == 2 and min(state.shape) == 1):\n            # It's a vector (or column/row vector)\n            state_vec = state.flatten()\n            prob_i = state_vec.conj().T @ op @ state_vec\n        else:\n            # It's a density matrix\n            prob_i = np.trace(op @ state)\n        success_prob += probs[i] * prob_i\n    return np.real(success_prob)\n\n\n# 1. Define the states and probabilities.\nstate_vectors = trine()\nk = len(state_vectors)\nprobs = [1 / k] * k\n\nprint(f\"Analyzing k={k} trine states with uniform probability.\")\n\n# 2. Compute the optimal benchmark values.\np_best, _ = state_distinguishability(state_vectors, probs)\np_worst, _ = state_exclusion(state_vectors, probs)\n\nprint(\"\\nOptimal Benchmarks:\")\nprint(f\"  P_Best  = {p_best:.4f} (Max discrimination probability)\")\nprint(f\"  P_Worst = {p_worst:.4f} (Min discrimination probability)\")\n</code></pre> <p>Out:</p> <pre><code>Analyzing k=3 trine states with uniform probability.\n\nOptimal Benchmarks:\n  P_Best  = 0.6667 (Max discrimination probability)\n  P_Worst = -0.0000 (Min discrimination probability)\n</code></pre> <p>The results for the optimal benchmarks show that the maximum possible success probability is \\(2/3\\), and the minimum is \\(0\\). The PGM is known to be optimal for the trine states, so we expect \\(P_{\\text{PGM}} = P_{\\text{Best}}\\).</p> <pre><code># 3. Compute the PGM and PBM operators.\npgm_operators = pretty_good_measurement(state_vectors, probs)\npbm_operators = pretty_bad_measurement(state_vectors, probs)\n\n# 4. Calculate PGM and PBM success probabilities.\np_pgm = calculate_success_prob(state_vectors, probs, pgm_operators)\np_pbm = calculate_success_prob(state_vectors, probs, pbm_operators)\n\nprint(\"\\nHeuristic Measurements:\")\nprint(f\"  P_PGM = {p_pgm:.4f}\")\nprint(f\"  P_PBM = {p_pbm:.4f}\")\n</code></pre> <p>Out:</p> <pre><code>Heuristic Measurements:\n  P_PGM = 0.6667\n  P_PBM = 0.1667\n</code></pre> <p>As expected, the PGM achieves the optimal value. Our calculated value for the PBM is \\(1/6 \\approx 0.1667\\), which is a good approximation of the true worst case of \\(0\\).</p> <p>Finally, we can verify the core relationship between these two measurements and the full performance hierarchy stated previously.</p> \\[ P_{\\text{Best}} \\ge P_{\\text{PGM}} \\ge \\frac{1}{k} \\ge P_{\\text{PBM}} \\ge P_{\\text{Worst}} \\] <ol> <li>Verify the core relationship and the hierarchy.</li> </ol> <pre><code>relation_lhs = p_pgm + (k - 1) * p_pbm\nprint(\"\\nVerifying P_PGM + (k-1)*P_PBM = 1:\")\nprint(f\"  {p_pgm:.4f} + ({k - 1})*{p_pbm:.4f} = {relation_lhs:.4f} -&gt; {np.isclose(relation_lhs, 1)}\")\n\nprint(\"\\nVerifying hierarchy (P_Best &gt;= P_PGM &gt;= 1/k &gt;= P_PBM &gt;= P_Worst):\")\nprint(f\"  P_Best &gt;= P_PGM:    {p_best:.4f} &gt;= {p_pgm:.4f}  -&gt;  {p_best &gt;= p_pgm or np.isclose(p_best, p_pgm)}\")\nprint(f\"  P_PGM &gt;= 1/k:       {p_pgm:.4f} &gt;= {1 / k:.4f}  -&gt;  {p_pgm &gt;= 1 / k or np.isclose(p_pgm, 1 / k)}\")\nprint(f\"  1/k &gt;= P_PBM:       {1 / k:.4f} &gt;= {p_pbm:.4f}  -&gt;  {1 / k &gt;= p_pbm or np.isclose(1 / k, p_pbm)}\")\nprint(f\"  P_PBM &gt;= P_Worst:   {p_pbm:.4f} &gt;= {p_worst:.4f} -&gt;  {p_pbm &gt;= p_worst or np.isclose(p_pbm, p_worst)}\")\n</code></pre> <p>Out:</p> <pre><code>Verifying P_PGM + (k-1)*P_PBM = 1:\n  0.6667 + (2)*0.1667 = 1.0000 -&gt; True\n\nVerifying hierarchy (P_Best &gt;= P_PGM &gt;= 1/k &gt;= P_PBM &gt;= P_Worst):\n  P_Best &gt;= P_PGM:    0.6667 &gt;= 0.6667  -&gt;  True\n  P_PGM &gt;= 1/k:       0.6667 &gt;= 0.3333  -&gt;  True\n  1/k &gt;= P_PBM:       0.3333 &gt;= 0.1667  -&gt;  True\n  P_PBM &gt;= P_Worst:   0.1667 &gt;= -0.0000 -&gt;  True\n</code></pre> <p>The verifications confirm that all theoretical relationships hold true for the trine states.</p> <p>Now we can move on to visualizing the performance for the more general case of random states.</p>"},{"location":"generated/gallery/quantum_states/pgm_pbm/#visualizing-performance-on-random-states","title":"Visualizing Performance on Random States","text":"<p>Figures 4 and 5 from McIrvin et. al <sup>3</sup> show that for many randomly generated states, the PGM and PBM probabilities cluster around the blind guessing baseline of \\(1/k\\). We can reproduce a similar plot.</p> <p>We will generate 100 random ensembles of \\(k=4\\) qubit states and plot the resulting \\(P_{\\text{PGM}}\\) and \\(P_{\\text{PBM}}\\) values.</p> <pre><code>import matplotlib.pyplot as plt\n\nfrom toqito.rand import random_density_matrix\n\n# Number of random ensembles to generate.\nnum_instances = 100\nk = 4  # Number of states in each ensemble.\ndim = 2  # Dimension of states (qubits).\n\npgm_results = []\npbm_results = []\n\nfor i in range(num_instances):\n    # Generate a random ensemble of k density matrices.\n    rand_states = [random_density_matrix(dim, seed=(i * k) + j) for j in range(k)]\n    # Generate random prior probabilities.\n    rand_probs = np.random.dirichlet(np.ones(k))\n\n    # Calculate PGM and PBM probabilities.\n    pgm_ops = pretty_good_measurement(rand_states, rand_probs)\n    pbm_ops = pretty_bad_measurement(rand_states, rand_probs)\n\n    pgm_prob = calculate_success_prob(rand_states, rand_probs, pgm_ops)\n    pbm_prob = calculate_success_prob(rand_states, rand_probs, pbm_ops)\n    pgm_results.append(pgm_prob)\n    pbm_results.append(pbm_prob)\n\n# Create the plot.\nfig, ax = plt.subplots(figsize=(8, 5), dpi=100)\nsample_indices = range(num_instances)\nax.scatter(sample_indices, pgm_results, alpha=0.7, label=\"$P_{PGM}$\", c=\"blue\", s=20)\nax.scatter(sample_indices, pbm_results, alpha=0.7, label=\"$P_{PBM}$\", c=\"red\", s=20)\n\n# Add blind guessing line for reference.\nblind_guess_prob = 1 / k\nax.axhline(\n    y=blind_guess_prob,\n    color=\"black\",\n    linestyle=\"--\",\n    label=f\"Blind Guessing (1/k = {blind_guess_prob:.2f})\",\n)\n\nax.set_xlabel(\"Random Instance Index\", fontsize=12)\nax.set_ylabel(\"Discrimination Success Probability\", fontsize=12)\nax.set_title(f\"PGM and PBM Performance for {num_instances} Random Ensembles (k={k})\", fontsize=14)\nax.legend()\nax.grid(True, linestyle=\":\", alpha=0.6)\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p> <p>This plot clearly illustrates the theoretical bounds. Every blue dot representing \\(P_{\\text{PGM}}\\) lies on or above the blind guessing line, and every red dot representing \\(P_{\\text{PBM}}\\) lies on or below it. This provides strong numerical evidence for the inequalities \\(P_{\\text{PGM}} \\ge 1/k \\ge P_{\\text{PBM}}\\), confirming that the PGM is always a better-than-random guess and the PBM is always a worse-than-random guess for state discrimination.</p> <p>Total running time of the script: ( 0 minutes  0.218 seconds)</p> <p> Download Python source code: pgm_pbm.py</p> <p> Download Jupyter notebook: pgm_pbm.ipynb</p> <p>Gallery generated by mkdocs-gallery</p> <ol> <li> <p>V. P. Belavkin. Optimal distinction of non-orthogonal quantum signals. Radio Engineering and Electronic Physics, 20:39\u201347, 1975.\u00a0\u21a9</p> </li> <li> <p>Lane P Hughston, Richard Jozsa, and William K Wootters. A complete classification of quantum ensembles having a given density matrix. Physics Letters A, 183(1):14\u201318, 1993.\u00a0\u21a9</p> </li> <li> <p>Caleb McIrvin, Ankith Mohan, and Jamie Sikora. The pretty bad measurement. 2024. arXiv:2403.17252.\u00a0\u21a9\u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"generated/gallery/quantum_states/state_distinguishability/","title":"Quantum state distinguishability","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/quantum_states/state_distinguishability/#quantum-state-distinguishability","title":"Quantum state distinguishability","text":"<p>In this tutorial we are going to cover the problem of quantum state distinguishability (sometimes analogously referred to as quantum state discrimination). We are going to briefly describe the problem setting and then describe how one may use <code>|toqito\u27e9</code> to calculate the optimal probability with which this problem can be solved when given access to certain measurements.</p> <p>Further information beyond the scope of this tutorial can be found in the text <sup>1</sup> as well as the course <sup>2</sup>.</p>"},{"location":"generated/gallery/quantum_states/state_distinguishability/#the-state-distinguishability-problem","title":"The state distinguishability problem","text":"<p>The quantum state distinguishability problem is phrased as follows.</p> <p>1. Alice possesses an ensemble of \\(n\\) quantum states:</p> \\[ \\eta = \\left( (p_0, \\rho_0), \\ldots, (p_n, \\rho_n)  \\right), \\] <p>where \\(p_i\\) is the probability with which state \\(\\rho_i\\) is    selected from the ensemble. Alice picks \\(\\rho_i\\) with probability    \\(p_i\\) from her ensemble and sends \\(\\rho_i\\) to Bob.</p> <p>2. Bob receives \\(\\rho_i\\). Both Alice and Bob are aware of how the    ensemble is defined but he does not know what index \\(i\\)    corresponding to the state \\(\\rho_i\\) he receives from Alice is.</p> <p>3. Bob wants to guess which of the states from the ensemble he was given. In    order to do so, he may measure \\(\\rho_i\\) to guess the index \\(i\\)    for which the state in the ensemble corresponds.</p> <p>This setting is depicted in the following figure.</p> <p></p> <p> Figure: Quantum state distinguishability setting.</p> <p>Depending on the sets of measurements that Alice and Bob are allowed to use, the optimal probability of distinguishing a given set of states is characterized by the following image.</p> <p></p> <p> Figure: Measurement hierarchy.</p> <p>That is,the probability that Alice and Bob are able to distinguish using PPT measurements is a natural upper bound on the optimal probability of distinguishing via separable measurements.</p> <p>In general:</p> <ul> <li> <p>LOCC: These are difficult objects to handle mathematically; difficult to   design protocols for and difficult to provide bounds on their power.</p> </li> <li> <p>Separable: Separable measurements have a nicer structure than LOCC.   Unfortunately, optimizing over separable measurements in NP-hard.</p> </li> <li> <p>PPT: PPT measurements offer a nice structure and there exists efficient   techniques that allow one to optimize over the set of PPT measurements via   semidefinite programming.</p> </li> </ul>"},{"location":"generated/gallery/quantum_states/state_distinguishability/#optimal-probability-of-distinguishing-a-quantum-state","title":"Optimal probability of distinguishing a quantum state","text":"<p>The optimal probability with which Bob can distinguish the state he is given may be obtained by solving the following semidefinite program (SDP).</p> \\[ \\begin{aligned} \\text{maximize:} \\quad &amp; \\sum_{i=0}^n p_i \\langle M_i, \\rho_i \\rangle \\\\ \\text{subject to:} \\quad &amp; \\sum_{i=0}^n M_i = \\mathbb{I}_{\\mathcal{X}},\\\\ &amp; M_i \\in \\text{Pos}(\\mathcal{X}). \\end{aligned} \\] <p>This optimization problem is solved in <code>|toqito\u27e9</code> to obtain the optimal probability with which Bob can distinguish state \\(\\rho_i\\).</p> <p>To illustrate how we can phrase and solve this problem in <code>|toqito\u27e9</code>, consider the following example. Assume Alice has an ensemble of quantum states</p> \\[ \\eta = \\{ (1/2, \\rho_0), (1/2, \\rho_1) \\} \\] <p>such that</p> \\[ \\rho_0 = | 0 \\rangle \\langle 0 | = \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; 0 \\end{pmatrix} \\quad \\text{and} \\quad \\rho_1 = | 1 \\rangle \\langle 1 | = \\begin{pmatrix} 0 &amp; 0 \\\\ 0 &amp; 1 \\end{pmatrix}. \\] <p>These states are completely orthogonal to each other, and it is known that Bob can optimally distinguish the state he is given perfectly, i.e. with probability \\(1\\).</p> <p>Using <code>|toqito\u27e9</code>, we can calculate this probability directly as follows:</p> <pre><code>import numpy as np\n\nfrom toqito.state_opt import state_distinguishability\nfrom toqito.states import basis\n\n# Define the standard basis |0&gt; and |1&gt;.\ne_0, e_1 = basis(2, 0), basis(2, 1)\n\n# Define the corresponding density matrices of |0&gt; and |1&gt;\n# given as |0&gt;&lt;0| and |1&gt;&lt;1|, respectively.\nE_0 = e_0 @ e_0.conj().T\nE_1 = e_1 @ e_1.conj().T\n\n# Define a list of states and a corresponding list of probabilities with which those\n# states are selected.\nstates = [E_0, E_1]\nprobs = [1 / 2, 1 / 2]\n\n# Calculate the probability with which Bob can distinguish the state he is provided.\nprint(np.around(state_distinguishability(states, probs)[0], decimals=2))\n</code></pre> <p>Out:</p> <pre><code>1.0\n</code></pre> <p>Specifying similar state distinguishability problems can be done so using this general pattern.</p>"},{"location":"generated/gallery/quantum_states/state_distinguishability/#optimal-probability-of-distinguishing-a-state-via-ppt-measurements","title":"Optimal probability of distinguishing a state via PPT measurements","text":"<p>We may consider the quantum state distinguishability scenario under somewhat different and more limited set of circumstances. Specifically, we may want to ask the same question but restrict to enforcing that in order to determine the state that Bob is provided, he is limited to using a certain class of measurement. There are a wider class of measurements with respect to the ones we considered in the previous example referred to as PPT (positive partial transpose).</p> <p>The problem of state distinguishability with respect to PPT measurements can also be framed as an SDP and was initially presented in this manner in <sup>3</sup></p> \\[ \\begin{aligned} \\text{minimize:} \\quad &amp; \\frac{1}{k} \\text{Tr}(Y) \\\\ \\text{subject to:} \\quad &amp; Y \\geq \\text{T}_{\\mathcal{A}}(\\rho_j), \\quad j = 1, \\ldots, k, \\\\ &amp; Y \\in \\text{Herm}(\\mathcal{A} \\otimes \\mathcal{B}). \\end{aligned} \\] <p>Using <code>|toqito\u27e9</code>, we can determine the optimal probability for Bob to distinguish a given state from an ensemble if he is only given access to PPT measurements. Consider the following Bell states</p> \\[ \\begin{aligned} | \\psi_0 \\rangle = \\frac{|00\\rangle + |11\\rangle}{\\sqrt{2}}, &amp;\\quad | \\psi_1 \\rangle = \\frac{|01\\rangle + |10\\rangle}{\\sqrt{2}}, \\\\ | \\psi_2 \\rangle = \\frac{|01\\rangle - |10\\rangle}{\\sqrt{2}}, &amp;\\quad | \\psi_3 \\rangle = \\frac{|00\\rangle - |11\\rangle}{\\sqrt{2}}. \\end{aligned} \\] <p>It was shown in <sup>3</sup> and later extended in <sup>4</sup> that for the following set of states</p> \\[ \\begin{aligned} \\rho_1^{(2)} &amp;= |\\psi_0 \\rangle | \\psi_0 \\rangle \\langle \\psi_0 | \\langle \\psi_0 |, \\\\ \\rho_2^{(2)} &amp;= |\\psi_1 \\rangle | \\psi_3 \\rangle \\langle \\psi_1 | \\langle \\psi_3 |, \\\\ \\rho_3^{(2)} &amp;= |\\psi_2 \\rangle | \\psi_3 \\rangle \\langle \\psi_2 | \\langle \\psi_3 |, \\\\ \\rho_4^{(2)} &amp;= |\\psi_3 \\rangle | \\psi_3 \\rangle \\langle \\psi_3 | \\langle \\psi_3 |, \\end{aligned} \\] <p>that the optimal probability of distinguishing via a PPT measurement should yield \\(7/8 \\approx 0.875\\).</p> <p>This ensemble of states and some of its properties with respect to distinguishability were initially considered in <sup>5</sup>. In <code>|toqito\u27e9</code>, we can calculate the probability with which Bob can distinguish these states via PPT measurements in the following manner.</p> <pre><code>import numpy as np\n\nfrom toqito.state_opt import ppt_distinguishability\nfrom toqito.states import bell\n\n# mkdocs_gallery_thumbnail_path = 'figures/quantum_state_distinguish.svg'\n# Bell vectors:\npsi_0 = bell(0)\npsi_1 = bell(2)\npsi_2 = bell(3)\npsi_3 = bell(1)\n\n# YDY vectors from [^Yu_2012_Four]:\nx_1 = np.kron(psi_0, psi_0)\nx_2 = np.kron(psi_1, psi_3)\nx_3 = np.kron(psi_2, psi_3)\nx_4 = np.kron(psi_3, psi_3)\n\nstates = [x_1, x_2, x_3, x_4]\n\nprobs = [1 / 4, 1 / 4, 1 / 4, 1 / 4]\n# Calculate the PPT distinguishability value.\nppt_val, _ = ppt_distinguishability(vectors=states, probs=probs, dimensions=[2, 2, 2, 2], subsystems=[0, 2])\n\n# Print the rounded result.\nprint(f\"Optimal probability with PPT measurements: {np.around(ppt_val, decimals=2)}\")\n</code></pre> <p>Out:</p> <pre><code>Optimal probability with PPT measurements: 0.87\n</code></pre>"},{"location":"generated/gallery/quantum_states/state_distinguishability/#probability-of-distinguishing-a-state-via-separable-measurements","title":"Probability of distinguishing a state via separable measurements","text":"<p>As previously mentioned, optimizing over the set of separable measurements is NP-hard. However, there does exist a hierarchy of semidefinite programs which eventually does converge to the separable value. This hierarchy is based off the notion of symmetric extensions. More information about this hierarchy of SDPs can be found here <sup>6</sup>.</p> <p>Total running time of the script: ( 0 minutes  5.516 seconds)</p> <p> Download Python source code: state_distinguishability.py</p> <p> Download Jupyter notebook: state_distinguishability.ipynb</p> <p>Gallery generated by mkdocs-gallery</p> <ol> <li> <p>John Watrous. The Theory of Quantum Information. Cambridge University Press, 2018. URL: https://cs.uwaterloo.ca/~watrous/TQI/TQI.pdf, doi:10.1017/9781316848142.\u00a0\u21a9</p> </li> <li> <p>Jamie Sikora. Semidefinite programming in quantum theory (lecture series). Lecture Series, Perimeter Institute for Theoretical Physics; Lecture 2: \"Semidefinite programs for nice problems and popular functions\", 2019. URL: https://sites.google.com/site/jamiesikora/teaching/sdps-in-quantum-theory.\u00a0\u21a9</p> </li> <li> <p>Alessandro Cosentino. Positive-partial-transpose-indistinguishable states via semidefinite programming. Physical Review A, Jan 2013. URL: http://dx.doi.org/10.1103/PhysRevA.87.012321, doi:10.1103/physreva.87.012321.\u00a0\u21a9\u21a9</p> </li> <li> <p>Alessandro Cosentino and Vincent Russo. Small sets of locally indistinguishable orthogonal maximally entangled states. 2014. arXiv:1307.3232.\u00a0\u21a9</p> </li> <li> <p>Nengkun Yu, Runyao Duan, and Mingsheng Ying. Four locally indistinguishable ququad-ququad orthogonal maximally entangled states. Physical Review Letters, Jul 2012. URL: http://dx.doi.org/10.1103/PhysRevLett.109.020506, doi:10.1103/physrevlett.109.020506.\u00a0\u21a9</p> </li> <li> <p>Miguel Navascu\u00e9s. Pure state estimation and the characterization of entanglement. Physical Review Letters, Feb 2008. URL: http://dx.doi.org/10.1103/PhysRevLett.100.070503, doi:10.1103/physrevlett.100.070503.\u00a0\u21a9</p> </li> </ol>"},{"location":"generated/gallery/quantum_states/state_exclusion/","title":"Quantum state exclusion","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/quantum_states/state_exclusion/#quantum-state-exclusion","title":"Quantum state exclusion","text":"<p>In this tutorial, we are going to cover the problem of quantum state exclusion. We are going to briefly describe the problem setting and then describe how one may use <code>|toqito\u27e9</code> to calculate the optimal probability with which this problem can be solved for a number of different scenarios.</p> <p>Quantum state exclusion is very closely related to the problem of quantum state distinguishability. It may be useful to consult the quantum state distinguishability tutorial on this topic.</p> <p>Further information beyond the scope of this tutorial can be found in the text <sup>1</sup> as well as the course <sup>2</sup>.</p>"},{"location":"generated/gallery/quantum_states/state_exclusion/#the-state-exclusion-problem","title":"The state exclusion problem","text":"<p>The quantum state exclusion problem is phrased as follows.</p> <p>1. Alice possesses an ensemble of \\(n\\) quantum states:</p> \\[ \\begin{equation} \\eta = \\left( (p_0, \\rho_0), \\ldots, (p_n, \\rho_n)  \\right), \\end{equation} \\] <p>where \\(p_i\\) is the probability with which state \\(\\rho_i\\) is    selected from the ensemble. Alice picks \\(\\rho_i\\) with probability    \\(p_i\\) from her ensemble and sends \\(\\rho_i\\) to Bob.</p> <p>2. Bob receives \\(\\rho_i\\). Both Alice and Bob are aware of how the    ensemble is defined but he does not know what index \\(i\\)    corresponding to the state \\(\\rho_i\\) he receives from Alice is.</p> <p>3. Bob wants to guess which of the states from the ensemble he was not given.    In order to do so, he may measure \\(\\rho_i\\) to guess the index    \\(i\\) for which the state in the ensemble corresponds.</p> <p>This setting is depicted in the following figure.</p> <p></p> <p> Figure: Quantum state distinguishability setting.</p> <p>Note</p> <p>The primary difference between the quantum state distinguishability scenario and the quantum state exclusion scenario is that in the former, Bob wants to guess which state he was given, and in the latter, Bob wants to guess which state he was not given.</p>"},{"location":"generated/gallery/quantum_states/state_exclusion/#perfect-state-exclusion-antidistinguishability","title":"Perfect state exclusion (antidistinguishability)","text":"<p>We say that if one is able to perfectly (without error) exclude all quantum states in a set, then the set of states is antidistinguishable.</p> <p>Definition: Let \\(n\\) and \\(d\\) be integers. A collection of quantum states \\(S = \\{|\\psi_1\\rangle, \\ldots, |\\psi_{n}\\rangle\\} \\subset \\mathbb{C}^d\\) are antidistinguishable if there exists a collection of positive operator value measurements \\(\\{M_1, \\ldots, M_{n}\\}\\) such that \\(\\langle \\psi_i | M_i | \\psi_i \\rangle = 0\\) for all \\(1 \\leq i \\leq n\\).</p> <p>Recall that a collection of POVMs are positive semidefinite operators \\(\\{M_i : 1 \\leq i \\leq n\\} \\subset \\mathbb{C}^d\\) that satisfy</p> \\[ \\begin{equation} \\sum_{i=1}^{n} M_i = \\mathbb{I}_{d}. \\end{equation} \\] <p>Properties:</p> <ul> <li> <p>If \\(S\\) is distinguishable then it is antidistinguishable.</p> </li> <li> <p>If \\(n = 2\\) then \\(S\\) is distinguishable if and only if \\(S\\) is antidistinguishable.</p> </li> <li> <p>Distinguishing one state from a pair of states is equivalent to excluding one of the states from that pair.</p> </li> <li> <p>If \\(n \\geq 3\\) then there are antidistinguishable sets that are not distinguishable.</p> </li> </ul>"},{"location":"generated/gallery/quantum_states/state_exclusion/#example-trine-states","title":"Example: Trine states","text":"<p>The so-called trine states are a set of three states, each of dimension two defined as</p> \\[ \\begin{equation} |\\psi_1\\rangle = |0\\rangle, \\quad |\\psi_2\\rangle = -\\frac{1}{2}(|0\\rangle + \\sqrt{3}|1\\rangle), \\quad |\\psi_3\\rangle = -\\frac{1}{2}(|0\\rangle - \\sqrt{3}|1\\rangle). \\end{equation} \\] <pre><code>from toqito.states import trine\n\npsi1, psi2, psi3 = trine()\nprint(f\"|\ud835\uded9_1&gt; = {psi1.reshape(1, -1)[0]}\")\nprint(f\"|\ud835\uded9_2&gt; = {psi2.reshape(1, -1)[0]}\")\nprint(f\"|\ud835\uded9_3&gt; = {psi3.reshape(1, -1)[0]}\")\n</code></pre> <p>Out:</p> <pre><code>|\ud835\uded9_1&gt; = [1 0]\n|\ud835\uded9_2&gt; = [-0.5       -0.8660254]\n|\ud835\uded9_3&gt; = [-0.5        0.8660254]\n</code></pre> <p>The trine states are three states in two dimensions. So they can't be mutually orthogonal, but they are about \"as close as you can get\" for three states in two dimensions to be mutually orthogonal.</p> <p></p> <pre><code>from toqito.state_props import is_mutually_orthogonal\nfrom toqito.states import trine\n\nprint(f\"Are states mutually orthogonal: {is_mutually_orthogonal(trine())}\")\n</code></pre> <p>Out:</p> <pre><code>Are states mutually orthogonal: False\n</code></pre> <p>An interesting property of these states is that they are antidistinguishable but not distinguishable.</p> <pre><code>from toqito.state_props import is_antidistinguishable, is_distinguishable\nfrom toqito.states import trine\n\nprint(f\"Trine antidistinguishable: {is_antidistinguishable(trine())}\")\nprint(f\"Trine distinguishable: {is_distinguishable(trine())}\")\n</code></pre> <p>Out:</p> <pre><code>Trine antidistinguishable: True\nTrine distinguishable: False\n</code></pre> <p>Here are a set of measurements that we can verify which satisfy the antidistinguishability constraints. We will see a method that we can use to obtain these directly later.</p> \\[ \\begin{equation} M_1 = \\frac{2}{3} (\\mathbb{I} - |\\psi_1\\rangle \\langle \\psi_1|), \\quad M_2 = \\frac{2}{3} (\\mathbb{I} - |\\psi_2\\rangle \\langle \\psi_2|), \\quad M_3 = \\frac{2}{3} (\\mathbb{I} - |\\psi_3\\rangle \\langle \\psi_3|). \\end{equation} \\] <pre><code>import numpy as np\n\nM1 = 2 / 3 * (np.identity(2) - psi1 @ psi1.conj().T)\nM2 = 2 / 3 * (np.identity(2) - psi2 @ psi2.conj().T)\nM3 = 2 / 3 * (np.identity(2) - psi3 @ psi3.conj().T)\n</code></pre> <p>In order for \\(M_1\\), \\(M_2\\), and \\(M_3\\) to constitute as valid POVMs, each of these matrices must be positive semidefinite and we must ensure that \\(\\sum_{i \\in \\{1,2,3\\}} M_i = \\mathbb{I}_2\\).</p> <pre><code>from toqito.matrix_props import is_positive_semidefinite\n\nprint(f\"M_1 + M_2 + M_3 is identity: {np.allclose(M1 + M2 + M3, np.identity(2))}\")\nprint(f\"Is M_1 PSD: {is_positive_semidefinite(M1)}\")\nprint(f\"Is M_2 PSD: {is_positive_semidefinite(M2)}\")\nprint(f\"Is M_3 PSD: {is_positive_semidefinite(M3)}\")\n</code></pre> <p>Out:</p> <pre><code>M_1 + M_2 + M_3 is identity: True\nIs M_1 PSD: True\nIs M_2 PSD: True\nIs M_3 PSD: True\n</code></pre> <p>Next, we must show that these measurements satisfy \\(\\langle \\psi_i | M_i | \\psi_i \\rangle = 0\\) for all \\(i \\in \\{1,2,3\\}\\).</p> <pre><code>print(f\"&lt;\ud835\uded9_1| M_1 |\ud835\uded9_1&gt;: {np.around((psi1.reshape(1, -1)[0] @ M1 @ psi1)[0], decimals=5)}\")\nprint(f\"&lt;\ud835\uded9_2| M_2 |\ud835\uded9_2&gt;: {np.around((psi2.reshape(1, -1)[0] @ M2 @ psi2)[0], decimals=5)}\")\nprint(f\"&lt;\ud835\uded9_3| M_3 |\ud835\uded9_3&gt;: {np.around((psi3.reshape(1, -1)[0] @ M3 @ psi3)[0], decimals=5)}\")\n</code></pre> <p>Out:</p> <pre><code>&lt;\ud835\uded9_1| M_1 |\ud835\uded9_1&gt;: 0.0\n&lt;\ud835\uded9_2| M_2 |\ud835\uded9_2&gt;: 0.0\n&lt;\ud835\uded9_3| M_3 |\ud835\uded9_3&gt;: 0.0\n</code></pre> <p>Since we have exhibited a set of measurements \\(\\{M_i: i \\in \\{1,2,3\\}\\} \\subset \\text{Pos}(\\mathbb{C^d})\\) that satisfy</p> \\[ \\begin{equation} \\langle \\psi_i | M_i | \\psi_i \\rangle = 0 \\quad \\text{and} \\quad \\sum_{i \\in \\{1,2,3\\}} M_i = \\mathbb{I}_2 \\end{equation} \\] <p>for all \\(i\\), we conclude that the trine states are antidistinguishable.</p>"},{"location":"generated/gallery/quantum_states/state_exclusion/#an-sdp-for-antidistinguishability","title":"An SDP for antidistinguishability","text":"<p>Whether a collection of states \\(\\{|\\psi_1 \\rangle, |\\psi_2\\rangle, \\ldots, |\\psi_{n}\\rangle \\}\\) are antidistinguishable or not can be determined by the following semidefinite program (SDP).</p> \\[ \\begin{equation} \\begin{aligned} \\text{minimize:} \\quad &amp; \\sum_{i=1}^{n} \\langle \\psi_i | M_i | \\psi_i \\rangle  \\\\ \\text{subject to:} \\quad &amp; \\sum_{i=1}^{n} M_i = \\mathbb{I}_{\\mathcal{X}}, \\\\ &amp; M_i \\succeq 0 \\quad \\forall \\ 1 \\leq i \\leq n. \\end{aligned} \\end{equation} \\] <p>Consider again the trine states from the previous example. We can determine that they are antidistinguishable by way of the antidistinguishability SDP.</p> <pre><code>from toqito.state_opt import state_exclusion\nfrom toqito.states import trine\n\nopt_value, measurements = state_exclusion(trine(), probs=[1, 1, 1], primal_dual=\"dual\")\nprint(f\"Optimal SDP value: {np.around(opt_value, decimals=2)}\")\n</code></pre> <p>Out:</p> <pre><code>Optimal SDP value: 0.0\n</code></pre> <p>The SDP not only gives us the optimal value, which is \\(0\\) in this case, indicating that the states are antidistinguishable, but we also get a set of optimal measurement operators. These should look familiar to the measurements we explicitly constructed earlier.</p>"},{"location":"generated/gallery/quantum_states/state_exclusion/#antidistinguishability-and-n-1-incoherence","title":"Antidistinguishability and (n-1)-incoherence","text":"<p>Antidistinguishability of a set of pure states is equivalent to a certain notion from the theory of quantum resources referred to as \\(k\\)-incoherence <sup>3</sup>:</p> <p>Definition: Let \\(n\\) and \\(k\\) be positive integers. Then \\(X \\in \\text{Pos}(\\mathbb{C} ^n)\\) is called \\(k\\)-incoherent* if there exists a positive integer \\(m\\), a set \\(S = \\{|\\psi_0\\rangle, |\\psi_1\\rangle,\\ldots, |\\psi_{m-1}\\rangle\\} \\subset \\mathbb{C} ^n\\) with the property that each \\(|\\psi_i\\rangle\\) has at most \\(k\\) non-zero entries, and real scalars \\(c_0, c_1, \\ldots, c_{m-1} \\geq 0\\) for which</p> \\[ X = \\sum_{j=0}^{m-1} c_j |\\psi_j\\rangle \\langle \\psi_j|. \\] <p>It turns out that antidistinguishability is equivalent to \\(k\\)-incoherence in the \\(k = n - 1\\) case. Reproducing one of the results from <sup>4</sup>, we have the following theorem.</p> <p>Theorem: Let \\(n \\geq 2\\) be an integer and let \\(S = \\{|\\phi_0\\rangle, |\\phi_1\\rangle, \\ldots, |\\phi_{n-1}\\rangle\\}\\). Then \\(S\\) is antidistinguishable if and only if the Gram matrix \\(G\\) is \\((n-1)\\)-incoherent.</p> \\[ G = \\begin{pmatrix} 1 &amp; \\langle \\phi_0 | \\phi_1 \\rangle &amp; \\cdots &amp; \\langle \\phi_0 | \\phi_{n-1}\\rangle \\\\ \\langle \\phi_1 | \\phi_0 \\rangle &amp; 1 &amp; \\cdots &amp; \\langle \\phi_1 | \\phi_{n-1}\\rangle \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ \\langle \\phi_{n-1} | \\phi_0 \\rangle &amp; \\langle \\phi_{n-1} | \\phi_1 \\rangle &amp; \\cdots &amp; 1 \\end{pmatrix} \\] <p>As an example, we can generate a random collection of quantum states, obtain the corresponding Gram matrix, and compute whether the set of states are antidistinguishable and \\((n-1)\\)-incoherent.</p> <pre><code>from toqito.matrix_ops import vectors_to_gram_matrix\nfrom toqito.matrix_props import is_k_incoherent\nfrom toqito.rand import random_states\nfrom toqito.state_props import is_antidistinguishable\n\n# mkdocs_gallery_thumbnail_path = 'figures/trine.png'\nn, d = 3, 3\nstates = random_states(n, d)\ngram = vectors_to_gram_matrix(states)\n\nprint(f\"Is Antidistinguishable: {is_antidistinguishable(states)}\")\nprint(f\"Is (n-1)-incoherent: {is_k_incoherent(gram, n - 1)}\")\n\n# As can be seen, whether the random set of states are antidistinguishable or not aligns with whether they are\n# $(n-1)$-incoherent or not as well.\n</code></pre> <p>Out:</p> <pre><code>Is Antidistinguishable: False\nIs (n-1)-incoherent: False\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.049 seconds)</p> <p> Download Python source code: state_exclusion.py</p> <p> Download Jupyter notebook: state_exclusion.ipynb</p> <p>Gallery generated by mkdocs-gallery</p> <ol> <li> <p>Matthew F. Pusey, Jonathan Barrett, and Terry Rudolph. On the reality of the quantum state. Nature Physics, 8(6):475\u2013478, May 2012. URL: http://dx.doi.org/10.1038/nphys2309, doi:10.1038/nphys2309.\u00a0\u21a9</p> </li> <li> <p>Somshubhro Bandyopadhyay, Rahul Jain, Jonathan Oppenheim, and Christopher Perry. Conclusive exclusion of quantum states. Physical Review A, Feb 2014. URL: http://dx.doi.org/10.1103/PhysRevA.89.022336, doi:10.1103/physreva.89.022336.\u00a0\u21a9</p> </li> <li> <p>Nathaniel Johnston, Shirin Moein, Rajesh Pereira, and Sarah Plosker. Absolutely k-incoherent quantum states and spectral inequalities for the factor width of a matrix. Physical Review A, 106(5):052417, 2022.\u00a0\u21a9</p> </li> <li> <p>Nathaniel Johnston, Vincent Russo, and Jamie Sikora. Tight bounds for antidistinguishability and circulant sets of pure quantum states. Quantum, 9:1622, 2025.\u00a0\u21a9</p> </li> </ol>"},{"location":"reference/toqito/","title":"toqito","text":""},{"location":"reference/toqito/#toqito","title":"toqito","text":"<p>toqito package namespace.</p>"},{"location":"reference/toqito/channel_metrics/","title":"channel_metrics","text":""},{"location":"reference/toqito/channel_metrics/#toqito.channel_metrics","title":"channel_metrics","text":"<p>Channel metrics is a set of modules used to implement the distance metrics for quantum channels.</p>"},{"location":"reference/toqito/channel_metrics/channel_distinguishability/","title":"channel_distinguishability","text":""},{"location":"reference/toqito/channel_metrics/channel_distinguishability/#toqito.channel_metrics.channel_distinguishability","title":"channel_distinguishability","text":"<p>Computes the maximum probability of distinguishing two quantum channels.</p>"},{"location":"reference/toqito/channel_metrics/channel_distinguishability/#toqito.channel_metrics.channel_distinguishability.channel_distinguishability","title":"channel_distinguishability","text":"<pre><code>channel_distinguishability(phi: ndarray | list[ndarray] | list[list[ndarray]], psi: ndarray | list[ndarray] | list[list[ndarray]], p: list[float] | None, dim: int | list[int] | ndarray | None = None, strategy: str = 'bayesian', solver: str = 'cvxopt', primal_dual: str = 'dual', **kwargs) -&gt; float | floating\n</code></pre> <p>Compute the optimal probability of distinguishing two quantum channels.</p> <p>Bayesian and minimax discrimination of two quantum channels are implemented.</p> <p>For Bayesian discrimination, channels to be distinguished should have a given a priori probability distribution. The task of discriminating channels can be connected to the completely bounded trace norm (Section 3.3.3 of <sup>1</sup>). The problem is finding POVMs for which error probability of discrimination of output states is minimized after input state is acted on by the two quantum channels. In the language of statistical decision theory, the problem is equivalent to minimizing quantum Bayes' risk.</p> <p>In the minimax problem, there are no a priori probabilities. Minimax discrimination of two channels consists of finding the optimal input state so that the two possible output states are discriminated with minimum risk. (<sup>2</sup>).</p> <p>QETLAB's functionality inspired the Bayesian option <sup>3</sup> and the minimax option is adapted from QuTIpy <sup>4</sup>.</p> <p>Examples:</p> <p>Optimal probability of distinguishing two amplitude damping channels in the Bayesian setting:</p> <pre><code>from toqito.channels import amplitude_damping\nfrom toqito.channel_ops import kraus_to_choi\nfrom toqito.channel_metrics import channel_distinguishability\n# Define two amplitude damping channels with gamma=0.25 and gamma=0.5\nchoi_ch_1 = kraus_to_choi(amplitude_damping(gamma=0.25))\nchoi_ch_2 = kraus_to_choi(amplitude_damping(gamma=0.5))\n\np = [0.5, 0.5]\n\nprint(channel_distinguishability(choi_ch_1, choi_ch_2, p))\n</code></pre> <p>0.6249999999926592</p> <p>Optimal probability of distinguishing two amplitude damping channels in the minimax setting:</p> <pre><code>from toqito.channels import amplitude_damping\nfrom toqito.channel_ops import kraus_to_choi\nfrom toqito.channel_metrics import channel_distinguishability\n# Define two amplitude damping channels with gamma=0.25 and gamma=0.5\nchoi_ch_1 = kraus_to_choi(amplitude_damping(gamma=0.25))\nchoi_ch_2 = kraus_to_choi(amplitude_damping(gamma=0.5))\n\nprint(channel_distinguishability(choi_ch_1, choi_ch_2, None, [2, 2], strategy=\"minimax\",primal_dual=\"primal\"))\n</code></pre> <p>0.6065023195679409</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If prior probabilities not provided at all for Bayesian strategy.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If strategy is neither Bayesian nor minimax.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If channels have different input or output dimensions.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If prior probabilities do not add up to 1.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If number of prior probabilities not equal to 2.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>phi</code>               (<code>ndarray | list[ndarray] | list[list[ndarray]]</code>)           \u2013            <p>A superoperator. It should be provided either as a Choi matrix,  or as a (1d or 2d) list of numpy arrays whose entries are its Kraus operators.</p> </li> <li> <code>psi</code>               (<code>ndarray | list[ndarray] | list[list[ndarray]]</code>)           \u2013            <p>A superoperator. It should be provided either as a Choi matrix,  or as a (1d or 2d) list of numpy arrays whose entries are its Kraus operators.</p> </li> <li> <code>p</code>               (<code>list[float] | None</code>)           \u2013            <p>Prior probabilities of the two channels.</p> </li> <li> <code>dim</code>               (<code>int | list[int] | ndarray | None</code>, default:                   <code>None</code> )           \u2013            <p>Input and output dimensions of the channels.</p> </li> <li> <code>strategy</code>               (<code>str</code>, default:                   <code>'bayesian'</code> )           \u2013            <p>Whether to perform Bayesian or minimax discrimination task. Possible       values are \"Bayesian\" and \"minimax\". Default option is <code>strategy=\"Bayesian\"</code>.</p> </li> <li> <code>solver</code>               (<code>str</code>, default:                   <code>'cvxopt'</code> )           \u2013            <p>Optimization option for <code>picos</code> solver. Default option is <code>solver=\"cvxopt\"</code>.</p> </li> <li> <code>primal_dual</code>               (<code>str</code>, default:                   <code>'dual'</code> )           \u2013            <p>Option for the optimization problem. Default option is <code>solver=\"cvxopt\"</code>.</p> </li> <li> <code>kwargs</code>           \u2013            <p>Additional arguments to pass to picos' solve method.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float | floating</code>           \u2013            <p>The optimal probability of discriminating two quantum channels.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Watrous, John. The Theory of Quantum Information. (2018). doi:10.1017/9781316848142. <sup>2</sup> D\u2019Ariano, G and Sacchi, Massimiliano and Kahn, Jonas. Minimax discrimination of two Pauli channels. Physical Review A\u2014Atomic, Molecular, and Optical Physics. vol. 72(5). (2005). <sup>3</sup> Johnston, Nathaniel. {{QETLAB}: {A MATLAB} toolbox for quantum entanglement}. doi:10.5281/zenodo.44637. <sup>4</sup> Khatri, Sumeet. {QuTIpy}: {Quantum Theory of Information for Python}; pronounced \" cutie pie\". A package for performing calculations with quantum states and channels.. link.</p> Source code in <code>toqito/channel_metrics/channel_distinguishability.py</code> <pre><code>def channel_distinguishability(\n    phi: np.ndarray | list[np.ndarray] | list[list[np.ndarray]],\n    psi: np.ndarray | list[np.ndarray] | list[list[np.ndarray]],\n    p: list[float] | None,\n    dim: int | list[int] | np.ndarray | None = None,\n    strategy: str = \"bayesian\",\n    solver: str = \"cvxopt\",\n    primal_dual: str = \"dual\",\n    **kwargs,\n) -&gt; float | np.floating:\n    r\"\"\"Compute the optimal probability of distinguishing two quantum channels.\n\n    Bayesian and minimax discrimination of two quantum channels are implemented.\n\n    For Bayesian discrimination, channels to be distinguished should have a given a priori probability distribution.\n    The task of discriminating channels can be connected to the completely bounded trace norm\n    (Section 3.3.3 of [@Watrous_2018_TQI]).\n    The problem is finding POVMs for which error probability of discrimination of\n    output states is minimized after input state is acted on by the two quantum channels.\n    In the language of statistical decision theory, the problem is equivalent to minimizing quantum Bayes' risk.\n\n    In the minimax problem, there are no a priori probabilities.\n    Minimax discrimination of two channels consists of finding the\n    optimal input state so that the two possible output states are discriminated\n    with minimum risk. ([@d2005minimax]).\n\n    QETLAB's functionality inspired the Bayesian option [@QETLAB_link]\n    and the minimax option is adapted from QuTIpy [@QuTIpy_link].\n\n    Examples:\n        Optimal probability of distinguishing two amplitude damping channels in the Bayesian setting:\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.channels import amplitude_damping\n        from toqito.channel_ops import kraus_to_choi\n        from toqito.channel_metrics import channel_distinguishability\n        # Define two amplitude damping channels with gamma=0.25 and gamma=0.5\n        choi_ch_1 = kraus_to_choi(amplitude_damping(gamma=0.25))\n        choi_ch_2 = kraus_to_choi(amplitude_damping(gamma=0.5))\n\n        p = [0.5, 0.5]\n\n        print(channel_distinguishability(choi_ch_1, choi_ch_2, p))\n        ```\n\n        Optimal probability of distinguishing two amplitude damping channels in the minimax setting:\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.channels import amplitude_damping\n        from toqito.channel_ops import kraus_to_choi\n        from toqito.channel_metrics import channel_distinguishability\n        # Define two amplitude damping channels with gamma=0.25 and gamma=0.5\n        choi_ch_1 = kraus_to_choi(amplitude_damping(gamma=0.25))\n        choi_ch_2 = kraus_to_choi(amplitude_damping(gamma=0.5))\n\n        print(channel_distinguishability(choi_ch_1, choi_ch_2, None, [2, 2], strategy=\"minimax\",primal_dual=\"primal\"))\n        ```\n\n    Raises:\n        ValueError: If prior probabilities not provided at all for Bayesian strategy.\n        ValueError: If strategy is neither Bayesian nor minimax.\n        ValueError: If channels have different input or output dimensions.\n        ValueError: If prior probabilities do not add up to 1.\n        ValueError: If number of prior probabilities not equal to 2.\n\n    Args:\n        phi: A superoperator. It should be provided either as a Choi matrix,\n             or as a (1d or 2d) list of numpy arrays whose entries are its Kraus operators.\n        psi: A superoperator. It should be provided either as a Choi matrix,\n             or as a (1d or 2d) list of numpy arrays whose entries are its Kraus operators.\n        p: Prior probabilities of the two channels.\n        dim: Input and output dimensions of the channels.\n        strategy: Whether to perform Bayesian or minimax discrimination task. Possible\n                  values are \"Bayesian\" and \"minimax\". Default option is `strategy=\"Bayesian\"`.\n        solver: Optimization option for `picos` solver. Default option is `solver=\"cvxopt\"`.\n        primal_dual: Option for the optimization problem. Default option is `solver=\"cvxopt\"`.\n        kwargs: Additional arguments to pass to picos' solve method.\n\n    Returns:\n        The optimal probability of discriminating two quantum channels.\n\n    \"\"\"\n    # Get the input, output and environment dimensions of phi and psi.\n    d_in_phi, d_out_phi, d_e = channel_dim(phi, dim=dim)\n    d_in_psi, d_out_psi, d_e = channel_dim(psi, dim=dim)\n\n    # If the variable `phi` and/or `psi` are provided as a list, we assume this is a list\n    # of Kraus operators. We convert to choi matrices if not provided as choi matrix.\n    if isinstance(phi, list):\n        phi = kraus_to_choi(phi)\n\n    if isinstance(psi, list):\n        psi = kraus_to_choi(psi)\n\n    dim_phi, dim_psi = np.array([d_in_phi, d_out_phi]), np.array([d_in_psi, d_out_psi])\n\n    # checking for errors.\n    if strategy.lower() not in (\"bayesian\", \"minimax\"):\n        raise ValueError(\"The strategy must either be Bayesian or Minimax.\")\n\n    if not np.array_equal(dim_phi, dim_psi):\n        raise ValueError(\"The channels must have the same dimension input and output spaces as each other.\")\n\n    if strategy.lower() == \"bayesian\":\n        if p is None:\n            raise ValueError(\"Must provide valid prior probabilities for Bayesian strategy.\")\n\n        if len(p) != 2:\n            raise ValueError(\"p must be a probability distribution with 2 entries.\")\n\n        if max(p) &gt;= 1:\n            return 1\n\n        if abs(sum(p) - 1) != 0:\n            raise ValueError(\"Sum of prior probabilities must add up to 1.\")\n\n        # optimal success probability is minimizing error probability (Bayes risk).\n        return 1 / 2 * (1 + completely_bounded_trace_norm(p[0] * phi - p[1] * psi))\n\n    if primal_dual == \"primal\":\n        return _minimax_primal(phi, psi, d_in_phi[0], d_out_phi[0], solver=solver, **kwargs)\n\n    return _minimax_dual(phi, psi, d_in_phi[0], d_out_phi[0], solver=solver, **kwargs)\n</code></pre>"},{"location":"reference/toqito/channel_metrics/channel_fidelity/","title":"channel_fidelity","text":""},{"location":"reference/toqito/channel_metrics/channel_fidelity/#toqito.channel_metrics.channel_fidelity","title":"channel_fidelity","text":"<p>Computes the channel fidelity between two quantum channels.</p>"},{"location":"reference/toqito/channel_metrics/channel_fidelity/#toqito.channel_metrics.channel_fidelity.channel_fidelity","title":"channel_fidelity","text":"<pre><code>channel_fidelity(choi_1: ndarray, choi_2: ndarray, eps: float = 1e-07) -&gt; float\n</code></pre> <p>Compute the channel fidelity between two quantum channels <sup>1</sup>.</p> <p>Let \\(\\Phi : \\text{L}(\\mathcal{Y}) \\rightarrow \\text{L}(\\mathcal{X})\\) and \\(\\Psi: \\text{L}(\\mathcal{Y}) \\rightarrow \\text{L}(\\mathcal{X})\\) be quantum channels. Then the root channel fidelity defined as</p> \\[     \\sqrt{F}(\\Phi, \\Psi) := \\text{inf}_{\\rho} \\sqrt{F}(\\Phi(\\rho), \\Psi(\\rho)) \\] <p>where \\(\\rho \\in \\text{D}(\\mathcal{Z} \\otimes \\mathcal{X})\\) can be calculated by means of the following semidefinite program (Proposition 50) in <sup>1</sup>,</p> \\[     \\begin{align*}         \\text{maximize:} \\quad &amp; \\lambda \\\\         \\text{subject to:} \\quad &amp; \\lambda \\mathbb{I}_{\\mathcal{Z}} \\leq             \\text{Re}\\left( \\text{Tr}_{\\mathcal{Y}} \\left( Q \\right) \\right),\\\\             &amp; \\begin{pmatrix}                 J(\\Phi) &amp; Q^* \\\\                 Q &amp; J(\\Psi)             \\end{pmatrix} \\geq 0     \\end{align*} \\] <p>where \\(Q \\in \\text{L}(\\mathcal{Z} \\otimes \\mathcal{X})\\).</p> <p>Examples:</p> <p>For two identical channels, we should expect that the channel fidelity should yield a value of \\(1\\).</p> <pre><code>import numpy as np\nfrom toqito.channels import dephasing\nfrom toqito.channel_metrics import channel_fidelity\n# The Choi matrices of dimension-4 for the dephasing channel\nchoi_1 = dephasing(4)\nchoi_2 = dephasing(4)\nprint(channel_fidelity(choi_1, choi_2))\n</code></pre> <p>0.9999999999309465</p> <p>We can also compute the channel fidelity between two different channels. For example, we can compute the channel fidelity between the dephasing and depolarizing channels.</p> <pre><code>import numpy as np\nfrom toqito.channels import dephasing, depolarizing\nfrom toqito.channel_metrics import channel_fidelity\n# The Choi matrices of dimension-4 for the dephasing and depolarizing channels\nchoi_1 = dephasing(4)\nchoi_2 = depolarizing(4)\nprint(channel_fidelity(choi_1, choi_2))\n</code></pre> <p>0.5003013055043918</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If matrices are not of equal dimension.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If matrices are not square.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>choi_1</code>               (<code>ndarray</code>)           \u2013            <p>The Choi matrix of the first quantum channel.</p> </li> <li> <code>choi_2</code>               (<code>ndarray</code>)           \u2013            <p>The Choi matrix of the second quantum channel.</p> </li> <li> <code>eps</code>               (<code>float</code>, default:                   <code>1e-07</code> )           \u2013            <p>The solver tolerance for convergence to feasability.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The channel fidelity between the channels specified by the quantum channels corresponding to the Choi matrices</p> </li> <li> <code>float</code>           \u2013            <p><code>choi_1</code> and <code>choi_2</code>.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Katariya, Vishal and Wilde, Mark. Geometric distinguishability measures limit quantum channel estimation and discrimination. Quantum Information Processing. vol. 20(2). (2021). doi:10.1007/s11128-021-02992-7.</p> Source code in <code>toqito/channel_metrics/channel_fidelity.py</code> <pre><code>def channel_fidelity(choi_1: np.ndarray, choi_2: np.ndarray, eps: float = 1e-7) -&gt; float:\n    r\"\"\"Compute the channel fidelity between two quantum channels [@Katariya_2021_Geometric].\n\n    Let \\(\\Phi : \\text{L}(\\mathcal{Y}) \\rightarrow \\text{L}(\\mathcal{X})\\) and\n    \\(\\Psi: \\text{L}(\\mathcal{Y}) \\rightarrow \\text{L}(\\mathcal{X})\\) be quantum channels. Then\n    the root channel fidelity defined as\n\n    \\[\n        \\sqrt{F}(\\Phi, \\Psi) := \\text{inf}_{\\rho} \\sqrt{F}(\\Phi(\\rho), \\Psi(\\rho))\n    \\]\n\n    where \\(\\rho \\in \\text{D}(\\mathcal{Z} \\otimes \\mathcal{X})\\) can be calculated by means of\n    the following semidefinite program (Proposition 50) in [@Katariya_2021_Geometric],\n\n    \\[\n        \\begin{align*}\n            \\text{maximize:} \\quad &amp; \\lambda \\\\\n            \\text{subject to:} \\quad &amp; \\lambda \\mathbb{I}_{\\mathcal{Z}} \\leq\n                \\text{Re}\\left( \\text{Tr}_{\\mathcal{Y}} \\left( Q \\right) \\right),\\\\\n                &amp; \\begin{pmatrix}\n                    J(\\Phi) &amp; Q^* \\\\\n                    Q &amp; J(\\Psi)\n                \\end{pmatrix} \\geq 0\n        \\end{align*}\n    \\]\n\n    where \\(Q \\in \\text{L}(\\mathcal{Z} \\otimes \\mathcal{X})\\).\n\n    Examples:\n        For two identical channels, we should expect that the channel fidelity should yield a value of\n        \\(1\\).\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.channels import dephasing\n        from toqito.channel_metrics import channel_fidelity\n        # The Choi matrices of dimension-4 for the dephasing channel\n        choi_1 = dephasing(4)\n        choi_2 = dephasing(4)\n        print(channel_fidelity(choi_1, choi_2))\n        ```\n\n        We can also compute the channel fidelity between two different channels. For example, we can\n        compute the channel fidelity between the dephasing and depolarizing channels.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.channels import dephasing, depolarizing\n        from toqito.channel_metrics import channel_fidelity\n        # The Choi matrices of dimension-4 for the dephasing and depolarizing channels\n        choi_1 = dephasing(4)\n        choi_2 = depolarizing(4)\n        print(channel_fidelity(choi_1, choi_2))\n        ```\n\n    Raises:\n        ValueError: If matrices are not of equal dimension.\n        ValueError: If matrices are not square.\n\n    Args:\n        choi_1: The Choi matrix of the first quantum channel.\n        choi_2: The Choi matrix of the second quantum channel.\n        eps: The solver tolerance for convergence to feasability.\n\n    Returns:\n        The channel fidelity between the channels specified by the quantum channels corresponding to the Choi matrices\n        `choi_1` and `choi_2`.\n\n    \"\"\"\n    if choi_1.shape != choi_2.shape:\n        raise ValueError(\"The Choi matrices provided should be of equal dimension.\")\n\n    choi_dim_x, choi_dim_y = choi_1.shape\n    if choi_dim_x != choi_dim_y:\n        raise ValueError(\"The Choi matrix provided must be square.\")\n\n    choi_dim = choi_dim_x\n    dim = int(np.log2(choi_dim))\n\n    lam = cvxpy.Variable(nonneg=True)\n    q_var = cvxpy.Variable((choi_dim, choi_dim), complex=True)\n\n    constraints = []\n    objective = cvxpy.Maximize(lam)\n\n    constraints.append(cvxpy.bmat([[choi_1, q_var.H], [q_var, choi_2]]) &gt;&gt; 0)\n\n    constraints.append(lam * np.identity(dim) &lt;= cvxpy.real(partial_trace(q_var, [1], [dim, dim])))\n\n    problem = cvxpy.Problem(objective, constraints)\n\n    return problem.solve(solver=cvxpy.SCS, eps=eps)\n</code></pre>"},{"location":"reference/toqito/channel_metrics/channel_measured_relative_entropy/","title":"channel_measured_relative_entropy","text":""},{"location":"reference/toqito/channel_metrics/channel_measured_relative_entropy/#toqito.channel_metrics.channel_measured_relative_entropy","title":"channel_measured_relative_entropy","text":"<p>Measured relative entropy (channel) is how well two channels can be distinguished by measuring them individually.</p>"},{"location":"reference/toqito/channel_metrics/channel_measured_relative_entropy/#toqito.channel_metrics.channel_measured_relative_entropy.channel_measured_relative_entropy","title":"channel_measured_relative_entropy","text":"<pre><code>channel_measured_relative_entropy(channel_1: ndarray, channel_2: ndarray, in_dim: int, m: int, k: int, hamiltonian: ndarray, energy: float) -&gt; float\n</code></pre> <p>Compute the measured relative entropy of two quantum channels <sup>1</sup>.</p> <p>Given a quantum channel \\(\\mathcal{N}_{A \\to B}\\), a completely positive map \\(\\mathcal{M}_{A \\to B}\\), a Hamiltonian \\(H_A\\) (Hermitian operator acting on system \\(A\\)), and an energy constraint \\(E \\in \\mathbb{R}\\), the energy-constrained measured relative entropy of channels is defined as:</p> \\[     D^{M}_{H,E}(\\mathcal{N}\\Vert\\mathcal{M}) :=     \\sup_{\\substack{d_{R'} \\in \\mathbb{N},\\\\ \\rho_{R'A} \\in \\mathcal{D}(\\mathcal{H}_{R'A})}}     \\left\\{D^{M}\\!\\left(\\mathcal{N}_{A \\to B}(\\rho_{R'A}) \\middle\\Vert \\mathcal{M}_{A \\to B}(\\rho_{R'A})\\right):     \\operatorname{Tr}[H_A \\rho_A] \\le E\\right\\}. \\] <p>When their Choi operators \\(\\Gamma^{\\mathcal{N}}\\) and \\(\\Gamma^{\\mathcal{M}}\\) are \\(d_A d_B \\times d_A d_B\\) matrices, the quantity \\(D^{M}_{H,E}(\\mathcal{N}\\Vert\\mathcal{M})\\) can be efficiently calculated by means of a semi-definite program up to an additive error \\(\\varepsilon\\), by means of \\(O(\\sqrt{\\ln(1/\\varepsilon)})\\) linear matrix inequalities, each of size \\(2d_A d_B \\times 2d_A d_B\\). Specifically, there exist \\(m, k \\in \\mathbb{N}\\) such that \\(m + k = O(\\sqrt{\\ln(1/\\varepsilon)})\\) and the following inequality holds:</p> \\[     \\left|D^{M}_{H,E}(\\mathcal{N}\\Vert\\mathcal{M})     - D^{M}_{H,E,m,k}(\\mathcal{N}\\Vert\\mathcal{M})\\right| \\le \\varepsilon, \\] <p>where</p> \\[     D_{H,E,m,k}^{M}(\\mathcal{N} \\| \\mathcal{M}) :=     \\sup\\limits_{\\substack{\\Omega, \\rho &gt; 0, \\Theta \\in \\mathbb{H}, \\\\     T_1, \\dots, T_m \\in \\mathbb{H}, \\\\ Z_0, \\dots, Z_k \\in \\mathbb{H}}}     \\left\\{ \\begin{gathered}     \\operatorname{Tr}[\\Theta \\Gamma^{\\mathcal{N}}]     - \\operatorname{Tr}[\\Omega \\Gamma^{\\mathcal{M}}] + 1 : \\\\     \\operatorname{Tr}[\\rho] = 1, \\operatorname{Tr}[H\\rho] \\leq E, \\\\     Z_0 = \\Omega, \\sum_{j=1}^m w_j T_j = 2^{-k} \\Theta, \\\\     \\left\\{ \\begin{bmatrix} Z_i &amp; Z_{i+1} \\\\ Z_{i+1} &amp; \\rho \\otimes I \\end{bmatrix}     \\geq 0 \\right\\}_{i=0}^{k-1}, \\\\     \\left\\{ \\begin{bmatrix} Z_k - \\rho \\otimes I - T_j &amp; -\\sqrt{t_j} T_j \\\\     -\\sqrt{t_j} T_j &amp; \\rho \\otimes I - t_j T_j \\end{bmatrix} \\geq 0 \\right\\}_{j=1}^m     \\end{gathered} \\right\\} \\] <p>and, for all \\(j \\in \\{1, \\dots, m\\}\\), \\(w_j\\) and \\(t_j\\) are the weights and nodes, respectively, for the \\(m\\)-point Gauss--Legendre quadrature on the interval \\([0, 1]\\).</p> <p>Examples:</p> <p>We can find the measured relative entropy between a depolarizing channel of dimension 2 and the identity channel, constrained by a Hamiltonian and energy, as follows:</p> <pre><code>from toqito.channel_metrics import channel_measured_relative_entropy\nfrom toqito.channels import depolarizing\nimport numpy as np\nchannel_1 = depolarizing(2, 0.2)\nchannel_2 = np.eye(4)\nin_dim = 2\nm = 5\nk = 5\nhamiltonian = np.zeros((2, 2))\nenergy = 100\nprint(channel_measured_relative_entropy(channel_1, channel_2, in_dim, m, k, hamiltonian, energy))\n</code></pre> <p>-0.6390152012616084</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>channel_1</code> is not a quantum channel or <code>channel_2</code> is not completely positive.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>channel_1</code>               (<code>ndarray</code>)           \u2013            <p>Choi matrix for the first channel.</p> </li> <li> <code>channel_2</code>               (<code>ndarray</code>)           \u2013            <p>Choi matrix for the second channel.</p> </li> <li> <code>in_dim</code>               (<code>int</code>)           \u2013            <p>The dimension of the input of the quantum channels.</p> </li> <li> <code>m</code>               (<code>int</code>)           \u2013            <p>One of the optimization parameters.</p> </li> <li> <code>k</code>               (<code>int</code>)           \u2013            <p>The other optimization parameter.</p> </li> <li> <code>hamiltonian</code>               (<code>ndarray</code>)           \u2013            <p>The Hamiltonian.</p> </li> <li> <code>energy</code>               (<code>float</code>)           \u2013            <p>The energy constraint.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The measured relative entropy between <code>channel_1</code> and <code>channel_2</code>.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Huang, Zixin and Wilde, Mark. Semi-definite optimization of the measured relative entropies of quantum states and channels. (2025). link.</p> Source code in <code>toqito/channel_metrics/channel_measured_relative_entropy.py</code> <pre><code>def channel_measured_relative_entropy(\n    channel_1: np.ndarray,\n    channel_2: np.ndarray,\n    in_dim: int,\n    m: int,\n    k: int,\n    hamiltonian: np.ndarray,\n    energy: float,\n) -&gt; float:\n    r\"\"\"Compute the measured relative entropy of two quantum channels [@Huang_2025_Msrd_Rel_Entr].\n\n    Given a quantum channel $\\mathcal{N}_{A \\to B}$, a completely positive map $\\mathcal{M}_{A \\to B}$,\n    a Hamiltonian $H_A$ (Hermitian operator acting on system $A$), and an energy constraint\n    $E \\in \\mathbb{R}$, the energy-constrained measured relative entropy of channels is defined as:\n\n    $$\n        D^{M}_{H,E}(\\mathcal{N}\\Vert\\mathcal{M}) :=\n        \\sup_{\\substack{d_{R'} \\in \\mathbb{N},\\\\ \\rho_{R'A} \\in \\mathcal{D}(\\mathcal{H}_{R'A})}}\n        \\left\\{D^{M}\\!\\left(\\mathcal{N}_{A \\to B}(\\rho_{R'A}) \\middle\\Vert \\mathcal{M}_{A \\to B}(\\rho_{R'A})\\right):\n        \\operatorname{Tr}[H_A \\rho_A] \\le E\\right\\}.\n    $$\n\n    When their Choi operators $\\Gamma^{\\mathcal{N}}$ and $\\Gamma^{\\mathcal{M}}$ are\n    $d_A d_B \\times d_A d_B$ matrices, the quantity $D^{M}_{H,E}(\\mathcal{N}\\Vert\\mathcal{M})$ can be\n    efficiently calculated by means of a semi-definite program up to an additive error $\\varepsilon$,\n    by means of $O(\\sqrt{\\ln(1/\\varepsilon)})$ linear matrix inequalities, each of size\n    $2d_A d_B \\times 2d_A d_B$. Specifically, there exist $m, k \\in \\mathbb{N}$ such that\n    $m + k = O(\\sqrt{\\ln(1/\\varepsilon)})$ and the following inequality holds:\n\n    $$\n        \\left|D^{M}_{H,E}(\\mathcal{N}\\Vert\\mathcal{M})\n        - D^{M}_{H,E,m,k}(\\mathcal{N}\\Vert\\mathcal{M})\\right| \\le \\varepsilon,\n    $$\n\n    where\n\n    $$\n        D_{H,E,m,k}^{M}(\\mathcal{N} \\| \\mathcal{M}) :=\n        \\sup\\limits_{\\substack{\\Omega, \\rho &gt; 0, \\Theta \\in \\mathbb{H}, \\\\\n        T_1, \\dots, T_m \\in \\mathbb{H}, \\\\ Z_0, \\dots, Z_k \\in \\mathbb{H}}}\n        \\left\\{ \\begin{gathered}\n        \\operatorname{Tr}[\\Theta \\Gamma^{\\mathcal{N}}]\n        - \\operatorname{Tr}[\\Omega \\Gamma^{\\mathcal{M}}] + 1 : \\\\\n        \\operatorname{Tr}[\\rho] = 1, \\operatorname{Tr}[H\\rho] \\leq E, \\\\\n        Z_0 = \\Omega, \\sum_{j=1}^m w_j T_j = 2^{-k} \\Theta, \\\\\n        \\left\\{ \\begin{bmatrix} Z_i &amp; Z_{i+1} \\\\ Z_{i+1} &amp; \\rho \\otimes I \\end{bmatrix}\n        \\geq 0 \\right\\}_{i=0}^{k-1}, \\\\\n        \\left\\{ \\begin{bmatrix} Z_k - \\rho \\otimes I - T_j &amp; -\\sqrt{t_j} T_j \\\\\n        -\\sqrt{t_j} T_j &amp; \\rho \\otimes I - t_j T_j \\end{bmatrix} \\geq 0 \\right\\}_{j=1}^m\n        \\end{gathered} \\right\\}\n    $$\n\n    and, for all $j \\in \\{1, \\dots, m\\}$, $w_j$ and $t_j$\n    are the weights and nodes, respectively, for the $m$-point Gauss--Legendre quadrature\n    on the interval $[0, 1]$.\n\n    Examples:\n        We can find the measured relative entropy between a depolarizing channel of dimension 2\n        and the identity channel, constrained by a Hamiltonian and energy, as follows:\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.channel_metrics import channel_measured_relative_entropy\n        from toqito.channels import depolarizing\n        import numpy as np\n        channel_1 = depolarizing(2, 0.2)\n        channel_2 = np.eye(4)\n        in_dim = 2\n        m = 5\n        k = 5\n        hamiltonian = np.zeros((2, 2))\n        energy = 100\n        print(channel_measured_relative_entropy(channel_1, channel_2, in_dim, m, k, hamiltonian, energy))\n        ```\n\n    Raises:\n        ValueError: If `channel_1` is not a quantum channel or `channel_2` is not completely positive.\n\n    Args:\n        channel_1: Choi matrix for the first channel.\n        channel_2: Choi matrix for the second channel.\n        in_dim: The dimension of the input of the quantum channels.\n        m: One of the optimization parameters.\n        k: The other optimization parameter.\n        hamiltonian: The Hamiltonian.\n        energy: The energy constraint.\n\n    Returns:\n        The measured relative entropy between `channel_1` and `channel_2`.\n\n    \"\"\"\n    if not is_quantum_channel(channel_1):\n        raise ValueError(\"Measured relative entropy is only defined if channel_1 is a quantum channel.\")\n    if not is_completely_positive(channel_2):\n        raise ValueError(\"Measured relative entropy is only defined if channel_2 is a completely positive map.\")\n    if np.array_equal(channel_1, channel_2):\n        return 0\n    n = len(channel_1)\n    out_dim = len(channel_1) // in_dim\n    omega = cvx.Variable((n, n), complex=True)\n    rho = cvx.Variable((in_dim, in_dim), complex=True)\n    theta = cvx.Variable((n, n), hermitian=True)\n    ts = [cvx.Variable((n, n), hermitian=True) for _ in range(m)]\n    zs = [cvx.Variable((n, n), hermitian=True) for _ in range(k + 1)]\n    nodes, weights = _gauss_legendre_on_01(m)\n\n    Id = cvx.Constant(np.eye(out_dim))\n    zblocks = [cvx.bmat(([zs[i], zs[i + 1]], [zs[i + 1], cvx.kron(rho, Id)])) for i in range(k)]\n    tblocks = [\n        cvx.bmat(\n            (\n                [zs[k] - cvx.kron(rho, Id) - ts[j], -np.sqrt(nodes[j]) * ts[j]],\n                [-np.sqrt(nodes[j]) * ts[j], cvx.kron(rho, Id) - nodes[j] * ts[j]],\n            )\n        )\n        for j in range(m)\n    ]\n\n    cons = (\n        [cvx.trace(rho) == 1]\n        + [zs[0] == omega]\n        + [cvx.real(cvx.trace(hamiltonian @ rho)) &lt;= energy]\n        + [rho &gt;&gt; 0, omega &gt;&gt; 0]\n        + [sum([weights[i] * ts[i] for i in range(m)]) == 2 ** (-k) * theta]\n        + [zblocks[i] &gt;&gt; 0 for i in range(k)]\n        + [tblocks[j] &gt;&gt; 0 for j in range(m)]\n    )\n\n    channel_1_cvx = cvx.Constant(channel_1)\n    channel_2_cvx = cvx.Constant(channel_2)\n    obj = cvx.Maximize(cvx.real(cvx.trace(theta @ channel_1_cvx) - cvx.trace(omega @ channel_2_cvx) + 1))\n    problem = cvx.Problem(obj, constraints=cons)\n    problem.solve(verbose=False)\n    return obj.value\n</code></pre>"},{"location":"reference/toqito/channel_metrics/completely_bounded_spectral_norm/","title":"completely_bounded_spectral_norm","text":""},{"location":"reference/toqito/channel_metrics/completely_bounded_spectral_norm/#toqito.channel_metrics.completely_bounded_spectral_norm","title":"completely_bounded_spectral_norm","text":"<p>Computes the completely bounded spectral norm of a quantum channel.</p>"},{"location":"reference/toqito/channel_metrics/completely_bounded_spectral_norm/#toqito.channel_metrics.completely_bounded_spectral_norm.completely_bounded_spectral_norm","title":"completely_bounded_spectral_norm","text":"<pre><code>completely_bounded_spectral_norm(phi: ndarray) -&gt; float | floating\n</code></pre> <p>Compute the completely bounded spectral norm of a quantum channel.</p> <p>As defined in <sup>1</sup> and <sup>2</sup>.</p> <p>Examples:</p> <p>To compute the completely bounded spectral norm of a depolarizing channel:</p> <pre><code>from toqito.channels import depolarizing\nfrom toqito.channel_metrics import completely_bounded_spectral_norm\n# Define the depolarizing channel\nchoi_depolarizing = depolarizing(dim=2, param_p=0.2)\nprint(completely_bounded_spectral_norm(choi_depolarizing))\n</code></pre> <p>1</p> <p>Parameters:</p> <ul> <li> <code>phi</code>               (<code>ndarray</code>)           \u2013            <p>superoperator</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float | floating</code>           \u2013            <p>The completely bounded spectral norm of the channel</p> </li> </ul> <p>References</p> <p><sup>1</sup> Watrous, John. Semidefinite programs for completely bounded norms. (2009). <sup>2</sup> Johnston, Nathaniel. {{QETLAB}: {A MATLAB} toolbox for quantum entanglement}. doi:10.5281/zenodo.44637.</p> Source code in <code>toqito/channel_metrics/completely_bounded_spectral_norm.py</code> <pre><code>def completely_bounded_spectral_norm(phi: np.ndarray) -&gt; float | np.floating:\n    r\"\"\"Compute the completely bounded spectral norm of a quantum channel.\n\n    As defined in [@Watrous_2009_Semidefinite] and [@QETLAB_link].\n\n    Examples:\n        To compute the completely bounded spectral norm of a depolarizing channel:\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.channels import depolarizing\n        from toqito.channel_metrics import completely_bounded_spectral_norm\n        # Define the depolarizing channel\n        choi_depolarizing = depolarizing(dim=2, param_p=0.2)\n        print(completely_bounded_spectral_norm(choi_depolarizing))\n        ```\n\n    Args:\n        phi: superoperator\n\n    Returns:\n        The completely bounded spectral norm of the channel\n\n    \"\"\"\n    return completely_bounded_trace_norm(dual_channel(phi))\n</code></pre>"},{"location":"reference/toqito/channel_metrics/completely_bounded_trace_norm/","title":"completely_bounded_trace_norm","text":""},{"location":"reference/toqito/channel_metrics/completely_bounded_trace_norm/#toqito.channel_metrics.completely_bounded_trace_norm","title":"completely_bounded_trace_norm","text":"<p>Computes the completely bounded trace norm of a quantum channel.</p>"},{"location":"reference/toqito/channel_metrics/completely_bounded_trace_norm/#toqito.channel_metrics.completely_bounded_trace_norm.completely_bounded_trace_norm","title":"completely_bounded_trace_norm","text":"<pre><code>completely_bounded_trace_norm(phi: ndarray, solver: str = 'cvxopt', **kwargs) -&gt; float | floating\n</code></pre> <p>Find the completely bounded trace norm of a quantum channel.</p> <p>Also known as the diamond norm of a quantum channel (Section 3.3.2 of <sup>1</sup>). The algorithm in p.11 of <sup>2</sup> with implementation in QETLAB <sup>3</sup> is used.</p> <p>Examples:</p> <p>To compute the completely bounded trace norm of a depolarizing channel:</p> <pre><code>from toqito.channels import depolarizing\nfrom toqito.channel_metrics import completely_bounded_trace_norm\n# Define the depolarizing channel\nchoi_depolarizing = depolarizing(dim=2, param_p=0.2)\nprint(completely_bounded_trace_norm(choi_depolarizing))\n</code></pre> <p>1</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If matrix is not square.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>phi</code>               (<code>ndarray</code>)           \u2013            <p>superoperator as choi matrix</p> </li> <li> <code>solver</code>               (<code>str</code>, default:                   <code>'cvxopt'</code> )           \u2013            <p>Optimization option for <code>picos</code> solver. Default option is <code>solver=\"cvxopt\"</code>.</p> </li> <li> <code>kwargs</code>           \u2013            <p>Additional arguments to pass to picos' solve method.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float | floating</code>           \u2013            <p>The completely bounded trace norm of the channel</p> </li> </ul> <p>References</p> <p><sup>1</sup> Watrous, John. The Theory of Quantum Information. (2018). doi:10.1017/9781316848142. <sup>2</sup> Watrous, John. Simpler semidefinite programs for completely bounded norms. (2012). <sup>3</sup> Johnston, Nathaniel. {{QETLAB}: {A MATLAB} toolbox for quantum entanglement}. doi:10.5281/zenodo.44637.</p> Source code in <code>toqito/channel_metrics/completely_bounded_trace_norm.py</code> <pre><code>def completely_bounded_trace_norm(phi: np.ndarray, solver: str = \"cvxopt\", **kwargs) -&gt; float | np.floating:\n    r\"\"\"Find the completely bounded trace norm of a quantum channel.\n\n    Also known as the diamond norm of a quantum channel (Section 3.3.2 of [@Watrous_2018_TQI]). The algorithm in p.11 of\n    [@Watrous_2012_Simpler] with implementation in QETLAB [@QETLAB_link] is used.\n\n    Examples:\n        To compute the completely bounded trace norm of a depolarizing channel:\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.channels import depolarizing\n        from toqito.channel_metrics import completely_bounded_trace_norm\n        # Define the depolarizing channel\n        choi_depolarizing = depolarizing(dim=2, param_p=0.2)\n        print(completely_bounded_trace_norm(choi_depolarizing))\n        ```\n\n    Raises:\n        ValueError: If matrix is not square.\n\n    Args:\n        phi: superoperator as choi matrix\n        solver: Optimization option for `picos` solver. Default option is `solver=\"cvxopt\"`.\n        kwargs: Additional arguments to pass to picos' solve method.\n\n    Returns:\n        The completely bounded trace norm of the channel\n\n    \"\"\"\n    dim_lx, dim_ly = phi.shape\n\n    if dim_lx != dim_ly:\n        raise ValueError(\"The input and output spaces of the superoperator phi must both be square.\")\n\n    if is_quantum_channel(phi):\n        return 1\n\n    if is_completely_positive(phi):\n        v = apply_channel(np.eye(dim_ly), dual_channel(phi))\n        return trace_norm(v)\n\n    dim = round(np.sqrt(dim_lx))\n    # SDP\n    sdp = pc.Problem()\n    y0 = pc.HermitianVariable(\"y0\", (dim_lx, dim_lx))\n    sdp.add_constraint(y0 &gt;&gt; 0)\n\n    y1 = pc.HermitianVariable(\"y1\", (dim_lx, dim_lx))\n    sdp.add_constraint(y1 &gt;&gt; 0)\n\n    a_var = pc.block([[y0, -phi], [-phi.conj().T, y1]])\n    sdp.add_constraint(a_var &gt;&gt; 0)\n    obj = pc.SpectralNorm(y0.partial_trace(1, dimensions=dim)) + pc.SpectralNorm(y1.partial_trace(1, dimensions=dim))\n    sdp.set_objective(\"min\", obj)\n    sdp.solve(solver=solver, **kwargs)\n\n    return sdp.value / 2\n</code></pre>"},{"location":"reference/toqito/channel_metrics/diamond_distance/","title":"diamond_distance","text":""},{"location":"reference/toqito/channel_metrics/diamond_distance/#toqito.channel_metrics.diamond_distance","title":"diamond_distance","text":"<p>Computes the diamond norm between two quantum channels.</p>"},{"location":"reference/toqito/channel_metrics/diamond_distance/#toqito.channel_metrics.diamond_distance.diamond_distance","title":"diamond_distance","text":"<pre><code>diamond_distance(choi_1: ndarray, choi_2: ndarray) -&gt; float | floating\n</code></pre> <p>Return the diamond norm distance between two quantum channels.</p> <p>This function is a wrapper around <code>completely_bounded_trace_norm</code>, in that it returns half of the completely bounded trace norm of the difference of its arguments.</p> <p>Note</p> <p>This calculation becomes very slow for 4 or more qubits.</p> <p>Examples:</p> <p>Consider the depolarizing and identity channels in a 2-dimensional space. The depolarizing channel parameter is set to 0.2:</p> <pre><code>import numpy as np\nfrom toqito.channels import depolarizing\nfrom toqito.channel_metrics import diamond_distance\nchoi_depolarizing = depolarizing(dim=2, param_p=0.2)\nchoi_identity = np.identity(2**2)\nprint(diamond_distance(choi_depolarizing, choi_identity))\n</code></pre> <p>1.0000000000261728</p> <p>Similarly, we can compute the diamond norm between the dephasing channel (with parameter 0.3) and the identity channel:</p> <pre><code>import numpy as np\nfrom toqito.channels import dephasing\nfrom toqito.channel_metrics import diamond_distance\nchoi_dephasing = dephasing(dim=2)\nchoi_identity = np.identity(2**2)\nprint(diamond_distance(choi_dephasing, choi_identity))\n</code></pre> <p>1.0000000000273874</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If matrices are not of equal dimension.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If matrices are not square.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>choi_1</code>               (<code>ndarray</code>)           \u2013            <p>A 4N by 4N matrix (where N is the number of qubits).</p> </li> <li> <code>choi_2</code>               (<code>ndarray</code>)           \u2013            <p>A 4N by 4N matrix (where N is the number of qubits).</p> </li> </ul> Source code in <code>toqito/channel_metrics/diamond_distance.py</code> <pre><code>def diamond_distance(choi_1: np.ndarray, choi_2: np.ndarray) -&gt; float | np.floating:\n    r\"\"\"Return the diamond norm distance between two quantum channels.\n\n    This function is a wrapper around\n    [`completely_bounded_trace_norm`]\n    [toqito.channel_metrics.completely_bounded_trace_norm.completely_bounded_trace_norm],\n    in that it returns half of the completely bounded trace norm of the difference of its arguments.\n\n    !!! note\n        This calculation becomes very slow for 4 or more qubits.\n\n\n    Examples:\n        Consider the depolarizing and identity channels in a 2-dimensional space. The depolarizing channel parameter is\n        set to 0.2:\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.channels import depolarizing\n        from toqito.channel_metrics import diamond_distance\n        choi_depolarizing = depolarizing(dim=2, param_p=0.2)\n        choi_identity = np.identity(2**2)\n        print(diamond_distance(choi_depolarizing, choi_identity))\n        ```\n\n        Similarly, we can compute the diamond norm between the dephasing channel (with parameter 0.3) and the identity\n        channel:\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.channels import dephasing\n        from toqito.channel_metrics import diamond_distance\n        choi_dephasing = dephasing(dim=2)\n        choi_identity = np.identity(2**2)\n        print(diamond_distance(choi_dephasing, choi_identity))\n        ```\n\n    Raises:\n        ValueError: If matrices are not of equal dimension.\n        ValueError: If matrices are not square.\n\n    Args:\n        choi_1: A 4**N by 4**N matrix (where N is the number of qubits).\n        choi_2: A 4**N by 4**N matrix (where N is the number of qubits).\n\n    \"\"\"\n    from toqito.channel_metrics import completely_bounded_trace_norm  # noqa\n\n    return completely_bounded_trace_norm(choi_1 - choi_2)\n</code></pre>"},{"location":"reference/toqito/channel_metrics/fidelity_of_separability/","title":"fidelity_of_separability","text":""},{"location":"reference/toqito/channel_metrics/fidelity_of_separability/#toqito.channel_metrics.fidelity_of_separability","title":"fidelity_of_separability","text":"<p>Add functions for channel fidelity of Separability as defined in <sup>1</sup>.</p> <p>The constrainsts for this function are positive partial transpose (PPT) &amp; k-extendible channels.</p> <p>References</p> <p><sup>1</sup> Philip, Aby and Rethinasamy, Soorya and Russo, Vincent and Wilde, Mark. Schr\\\"odinger as a Quantum Programmer: Estimating Entanglement via Steering. (2023).</p>"},{"location":"reference/toqito/channel_metrics/fidelity_of_separability/#toqito.channel_metrics.fidelity_of_separability.fidelity_of_separability","title":"fidelity_of_separability","text":"<pre><code>fidelity_of_separability(psi: ndarray, psi_dims: list[int], k: int = 1, verbosity_option: int = 0, solver_option: str = 'cvxopt') -&gt; float\n</code></pre> <p>Define the first benchmark introduced in Appendix I of <sup>1</sup>.</p> <p>If you would like to instead use the benchmark introduced in Appendix H, go to state_metrics.fidelity_of_separability.</p> <p>In <sup>1</sup>, a variational quantum algorithm (VQA) is introduced to test the separability of general bipartite state. The algorithm utilizes quantum steering between two separated systems such that the separability of the state is quantified.</p> <p>Due to the limitations of currently available quantum computers, two optimization semidefinite programs (SDP) benchmarks were introduced to maximize the fidelity of separability subject to some state constraints (Positive Partial Transpose (PPT), symmetric extensions (k-extendibility) <sup>2</sup>). Entangled states do not have k-symmetric extensions. If an extension exists, it cannot be assumed directly that the state is separable. This function approximates the fidelity of separability by maximizing over PPT channels &amp; k-extendible entanglement breaking channels i.e. an optimization problem over channels <sup>3</sup>.</p> <p>The following discussion (Equation (I4) from <sup>1</sup>) defines the constraints for approximating \\(\\widetilde{F}_s^2(\\rho_{AB})\\) in \\(\\frac{1}{2}(1+\\widetilde{F}_s^2(\\rho_{AB}))\\).</p> \\[ \\operatorname{Tr}[     \\Pi_{A^{\\prime}A}^{\\operatorname{sym}} \\operatorname{Tr}_{R}[         T_R(\\psi_{RAB})\\Gamma^{\\mathcal{E}^{k}}_{RA^{\\prime}_1}]] \\] <p>Above expression defines the maximization problem subject to PPT &amp; k-extendible channel constraints over \\(\\max_{\\Gamma^{\\mathcal{E}^{k}}_{RA^{\\prime k}}\\geq 0}\\).</p> <p>The constraint expressions are listed below:</p> \\[ \\operatorname{Tr}_{A^{\\prime k}}[\\Gamma^{\\mathcal{E}^{k}}_{RA^{\\prime k}}]=I_R \\] <p>\\(\\Gamma^{\\mathcal{E}^{k}}_{RA^{\\prime}}\\) is Choi operator of entanglement breaking channel \\(\\mathcal{E}^{k}\\).</p> \\[ \\Gamma^{\\mathcal{E}^{k}}_{RA^{\\prime k}}= \\mathcal{P}_{A^{\\prime k}}(\\Gamma^{\\mathcal{E}^{k}}_{RA^{\\prime k}}) \\] <p>\\(\\mathcal{P}_{A^{\\prime k}}\\) is the permutation operator over k-extensions \\(A^{\\prime k}\\).</p> \\[ T_{A^{\\prime}_{1\\cdots j}}(\\Gamma^{\\mathcal{E}^{k}_{RA^{\\prime k}}}) \\geq 0 \\quad \\forall j\\leq k \\] <p>These other constraints are due to the PPT condition <sup>4</sup>.</p> <p>Examples:</p> <p>Let's consider a density matrix of a state that we know is pure &amp; separable. \\(|000 \\rangle = |0 \\rangle \\otimes |0 \\rangle \\otimes |0 \\rangle\\).</p> <p>The expected approximation of fidelity of separability is the maximum value possible i.e. very close to 1.</p> \\[ \\rho_{AB} = |000 \\rangle \\langle 000| \\] <pre><code>import numpy as np\nfrom toqito.state_metrics import fidelity_of_separability\nfrom toqito.matrix_ops import tensor\nfrom toqito.states import basis\nstate = tensor(basis(2, 0), basis(2, 0))\nrho = state @ state.conj().T\nprint(fidelity_of_separability(rho, [2, 2]))\n</code></pre> <p>0.9999999998278968</p> <p>Raises:</p> <ul> <li> <code>AssertionError</code>             \u2013            <p>If the provided dimensions are not for a tripartite density matrix.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If the matrix is not a density matrix (square matrix that is PSD with trace 1).</p> </li> <li> <code>ValueError</code>             \u2013            <p>the input state is entangled.</p> </li> <li> <code>ValueError</code>             \u2013            <p>the input state is a mixed state.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>psi</code>               (<code>ndarray</code>)           \u2013            <p>the density matrix for the tripartite state of interest psi_{BAR}</p> </li> <li> <code>psi_dims</code>               (<code>list[int]</code>)           \u2013            <p>the dimensions of System A, B, &amp; R in the input state density matrix. It is assumed that the first</p> </li> <li> <code>k</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>value for k-extendibility.</p> </li> <li> <code>verbosity_option</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Parameter option for <code>picos</code>. Default value is <code>verbosity = 0</code>. For more info, visit https://picos-api.gitlab.io/picos/api/picos.modeling.options.html#option-verbosity.</p> </li> <li> <code>solver_option</code>               (<code>str</code>, default:                   <code>'cvxopt'</code> )           \u2013            <p>Optimization option for <code>picos</code> solver. Default option is <code>solver_option=\"cvxopt\"</code>. For more info, visit</p> </li> <li> <code>https</code>           \u2013            <p>//picos-api.gitlab.io/picos/api/picos.modeling.options.html#option-solver.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>Optimized value of the SDP when maximized over a set of linear operators subject to some constraints.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Philip, Aby and Rethinasamy, Soorya and Russo, Vincent and Wilde, Mark. Schr\\\"odinger as a Quantum Programmer: Estimating Entanglement via Steering. (2023). <sup>2</sup> Hayden, Patrick and Milner, Kevin and Wilde, Mark. Two-Message quantum interactive proofs and the quantum separability problem. 2013 IEEE Conference on Computational Complexity. (2013). doi:10.1109/ccc.2013.24. <sup>3</sup> Watrous, John. The Theory of Quantum Information. (2018). doi:10.1017/9781316848142. <sup>4</sup> Peres, Asher. Separability Criterion for Density Matrices. Physical Review Letters. vol. 77(8). (1996). doi:10.1103/physrevlett.77.1413.</p> Source code in <code>toqito/channel_metrics/fidelity_of_separability.py</code> <pre><code>def fidelity_of_separability(\n    psi: np.ndarray,\n    psi_dims: list[int],\n    k: int = 1,\n    verbosity_option: int = 0,\n    solver_option: str = \"cvxopt\",\n) -&gt; float:\n    r\"\"\"Define the first benchmark introduced in Appendix I of [@Philip_2023_Schrodinger].\n\n    If you would like to instead use the benchmark introduced in Appendix H, go to\n    [state_metrics.fidelity_of_separability][toqito.state_metrics.fidelity_of_separability].\n\n    In [@Philip_2023_Schrodinger], a variational quantum algorithm (VQA) is introduced to test the separability of\n    general bipartite state. The algorithm utilizes quantum steering between two separated systems such that the\n    separability of the state is quantified.\n\n    Due to the limitations of currently available quantum computers, two optimization semidefinite programs (SDP)\n    benchmarks were introduced to maximize the fidelity of separability subject to some state constraints\n    (Positive Partial Transpose (PPT), symmetric extensions (k-extendibility) [@Hayden_2013_TwoMessage]).\n    Entangled states do not have k-symmetric extensions. If an extension exists, it cannot be assumed directly that the\n    state is separable. This function approximates the fidelity of separability by maximizing over PPT channels &amp;\n    k-extendible entanglement breaking channels i.e. an optimization problem over channels [@Watrous_2018_TQI].\n\n    The following discussion (Equation (I4) from [@Philip_2023_Schrodinger]) defines the constraints for approximating\n    $\\widetilde{F}_s^2(\\rho_{AB})$ in $\\frac{1}{2}(1+\\widetilde{F}_s^2(\\rho_{AB}))$.\n\n    $$\n    \\operatorname{Tr}[\n        \\Pi_{A^{\\prime}A}^{\\operatorname{sym}} \\operatorname{Tr}_{R}[\n            T_R(\\psi_{RAB})\\Gamma^{\\mathcal{E}^{k}}_{RA^{\\prime}_1}]]\n    $$\n\n    Above expression defines the maximization problem subject to PPT &amp; k-extendible channel constraints over\n    $\\max_{\\Gamma^{\\mathcal{E}^{k}}_{RA^{\\prime k}}\\geq 0}$.\n\n    The constraint expressions are listed below:\n\n    $$\n    \\operatorname{Tr}_{A^{\\prime k}}[\\Gamma^{\\mathcal{E}^{k}}_{RA^{\\prime k}}]=I_R\n    $$\n\n    $\\Gamma^{\\mathcal{E}^{k}}_{RA^{\\prime}}$ is Choi operator of entanglement breaking channel $\\mathcal{E}^{k}$.\n\n    $$\n    \\Gamma^{\\mathcal{E}^{k}}_{RA^{\\prime k}}= \\mathcal{P}_{A^{\\prime k}}(\\Gamma^{\\mathcal{E}^{k}}_{RA^{\\prime k}})\n    $$\n\n    $\\mathcal{P}_{A^{\\prime k}}$ is the permutation operator over k-extensions $A^{\\prime k}$.\n\n    $$\n    T_{A^{\\prime}_{1\\cdots j}}(\\Gamma^{\\mathcal{E}^{k}_{RA^{\\prime k}}}) \\geq 0 \\quad \\forall j\\leq k\n    $$\n\n    These other constraints are due to the PPT condition [@Peres_1996_Separability].\n\n    Examples:\n        Let's consider a density matrix of a state that we know is pure &amp; separable.\n        $|000 \\rangle = |0 \\rangle \\otimes |0 \\rangle \\otimes |0 \\rangle$.\n\n        The expected approximation of fidelity of separability is the maximum\n        value possible i.e. very close to 1.\n\n        $$\n        \\rho_{AB} = |000 \\rangle \\langle 000|\n        $$\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.state_metrics import fidelity_of_separability\n        from toqito.matrix_ops import tensor\n        from toqito.states import basis\n        state = tensor(basis(2, 0), basis(2, 0))\n        rho = state @ state.conj().T\n        print(fidelity_of_separability(rho, [2, 2]))\n        ```\n\n    Raises:\n        AssertionError: If the provided dimensions are not for a tripartite density matrix.\n        ValueError: If the matrix is not a density matrix (square matrix that\n            is PSD with trace 1).\n        ValueError: the input state is entangled.\n        ValueError: the input state is a mixed state.\n\n    Args:\n        psi: the density matrix for the tripartite state of interest psi_{BAR}\n        psi_dims: the dimensions of System A, B, &amp; R in the input state density matrix. It is assumed that the first\n        quantity in this list is the dimension of System B.\n        k: value for k-extendibility.\n        verbosity_option: Parameter option for `picos`. Default value is\n            `verbosity = 0`. For more info, visit\n            https://picos-api.gitlab.io/picos/api/picos.modeling.options.html#option-verbosity.\n        solver_option: Optimization option for `picos` solver. Default option is\n            `solver_option=\"cvxopt\"`. For more info, visit\n        https://picos-api.gitlab.io/picos/api/picos.modeling.options.html#option-solver.\n\n    Returns:\n        Optimized value of the SDP when maximized over a set of linear operators subject to some constraints.\n\n    \"\"\"\n    if not is_density(psi):\n        raise ValueError(\"Provided input state is not a density matrix.\")\n    tripartite_num = 3\n    if not len(psi_dims) == tripartite_num:\n        raise AssertionError(\"For Channel SDP: require tripartite state dims.\")\n    if not is_pure(psi):\n        raise ValueError(\"This function only works for pure states.\")\n\n    # We first permure psi_{BAR} to psi_{RAB} to simplify the code.\n    psi = permute_systems(psi, [2, 1, 0], psi_dims)\n    dim_b, dim_a, dim_r = psi_dims\n    psi_dims = [dim_r, dim_a, dim_b]\n\n    # List of dimensions [R, A, B, A'] needed to define optimization function.\n    dim_list = [dim_r, dim_a, dim_b, dim_a]\n\n    # Dimension of the Choi matrix of the extended channel.\n    choi_dims = [dim_r] + [dim_a] * k\n\n    # List of extenstion systems and dimension of the Choi matrix.\n    sys_ext = list(range(2, 2 + k - 1))\n    dim_choi = dim_r * (dim_a**k)\n\n    # Projection onto symmetric subspace on AA'.\n    pi_sym = symmetric_projection(dim_a, 2)\n\n    choi = picos.HermitianVariable(\"S\", (dim_choi, dim_choi))\n    choi_partial = picos.partial_trace(choi, sys_ext, choi_dims)\n    sym_choi = symmetric_projection(dim_a, k)\n    problem = picos.Problem(verbosity=verbosity_option)\n\n    problem.set_objective(\n        \"max\",\n        np.real(\n            picos.trace(\n                pi_sym\n                * picos.partial_trace(\n                    (picos.partial_transpose(psi, [0], psi_dims) @ picos.I(dim_a))\n                    * permute_systems(choi_partial @ picos.I(dim_b * dim_a), [0, 3, 2, 1], dim_list),\n                    [0, 2],\n                    dim_list,\n                )\n            )\n        ),\n    )\n\n    problem.add_constraint(picos.partial_trace(choi, list(range(1, k + 1)), choi_dims) == picos.I(dim_r))\n    problem.add_constraint(choi &gt;&gt; 0)\n\n    # k-extendablility of Choi state\n    problem.add_constraint((picos.I(dim_r) @ sym_choi) * choi * (picos.I(dim_r) @ sym_choi) == choi)\n\n    # PPT condition on Choi state\n    sys = []\n    for i in range(1, 1 + k):\n        sys = sys + [i]\n        problem.add_constraint(picos.partial_transpose(choi, sys, choi_dims) &gt;&gt; 0)\n\n    solution = problem.solve(solver=solver_option)\n    return 2 * solution.value - 1\n</code></pre>"},{"location":"reference/toqito/channel_ops/","title":"channel_ops","text":""},{"location":"reference/toqito/channel_ops/#toqito.channel_ops","title":"channel_ops","text":"<p>Channel operations is a module used to implement a number of operations on quantum channels.</p>"},{"location":"reference/toqito/channel_ops/apply_channel/","title":"apply_channel","text":""},{"location":"reference/toqito/channel_ops/apply_channel/#toqito.channel_ops.apply_channel","title":"apply_channel","text":"<p>Applies a quantum channel to an operator.</p>"},{"location":"reference/toqito/channel_ops/apply_channel/#toqito.channel_ops.apply_channel.apply_channel","title":"apply_channel","text":"<pre><code>apply_channel(mat: ndarray, phi_op: ndarray | list[list[ndarray]]) -&gt; ndarray\n</code></pre> <p>Apply a quantum channel to an operator.</p> <p>(Section: Representations and Characterizations of Channels of <sup>1</sup>).</p> <p>Specifically, an application of the channel is defined as</p> \\[     \\Phi(X) = \\text{Tr}_{\\mathcal{X}} \\left(J(\\Phi)     \\left(\\mathbb{I}_{\\mathcal{Y}} \\otimes X^{T}\\right)\\right), \\] <p>where</p> \\[     J(\\Phi): \\text{T}(\\mathcal{X}, \\mathcal{Y}) \\rightarrow     \\text{L}(\\mathcal{Y} \\otimes \\mathcal{X}) \\] <p>is the Choi representation of \\(\\Phi\\).</p> <p>We assume the quantum channel given as <code>phi_op</code> is provided as either the Choi matrix of the channel or a set of Kraus operators that define the quantum channel.</p> <p>This function is adapted from the QETLAB package.</p> <p>Examples:</p> <p>The swap operator is the Choi matrix of the transpose map. The following is a (non-ideal, but illustrative) way of computing the transpose of a matrix.</p> <p>Consider the following matrix</p> \\[     X = \\begin{pmatrix}             1 &amp; 4 &amp; 7 \\\\             2 &amp; 5 &amp; 8 \\\\             3 &amp; 6 &amp; 9         \\end{pmatrix} \\] <p>Applying the swap operator given as</p> \\[     \\Phi =     \\begin{pmatrix}         1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\\\         0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\\\         0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1      \\end{pmatrix} \\] <p>to the matrix \\(X\\), we have the resulting matrix of</p> \\[     \\Phi(X) = \\begin{pmatrix}                     1 &amp; 2 &amp; 3 \\\\                     4 &amp; 5 &amp; 6 \\\\                     7 &amp; 8 &amp; 9                \\end{pmatrix} \\] <p>Using <code>|toqito\u27e9</code>, we can obtain the above matrices as follows.</p> <pre><code>from toqito.channel_ops import apply_channel\nfrom toqito.perms import swap_operator\nimport numpy as np\ntest_input_mat = np.array([[1, 4, 7], [2, 5, 8], [3, 6, 9]])\nprint(apply_channel(test_input_mat, swap_operator(3)))\n</code></pre> <p>[[1. 2. 3.]  [4. 5. 6.]  [7. 8. 9.]]</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If matrix is not Choi matrix.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>mat</code>               (<code>ndarray</code>)           \u2013            <p>A matrix.</p> </li> <li> <code>phi_op</code>               (<code>ndarray | list[list[ndarray]]</code>)           \u2013            <p>A superoperator. <code>phi_op</code> should be provided either as a Choi matrix, or as a list of numpy arrays with</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>The result of applying the superoperator <code>phi_op</code> to the operator <code>mat</code>.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Watrous, John. The Theory of Quantum Information. (2018). doi:10.1017/9781316848142.</p> Source code in <code>toqito/channel_ops/apply_channel.py</code> <pre><code>def apply_channel(mat: np.ndarray, phi_op: np.ndarray | list[list[np.ndarray]]) -&gt; np.ndarray:\n    r\"\"\"Apply a quantum channel to an operator.\n\n    (Section: Representations and Characterizations of Channels of [@Watrous_2018_TQI]).\n\n    Specifically, an application of the channel is defined as\n\n    \\[\n        \\Phi(X) = \\text{Tr}_{\\mathcal{X}} \\left(J(\\Phi)\n        \\left(\\mathbb{I}_{\\mathcal{Y}} \\otimes X^{T}\\right)\\right),\n    \\]\n\n    where\n\n    \\[\n        J(\\Phi): \\text{T}(\\mathcal{X}, \\mathcal{Y}) \\rightarrow\n        \\text{L}(\\mathcal{Y} \\otimes \\mathcal{X})\n    \\]\n\n    is the Choi representation of \\(\\Phi\\).\n\n    We assume the quantum channel given as `phi_op` is provided as either the Choi matrix\n    of the channel or a set of Kraus operators that define the quantum channel.\n\n    This function is adapted from the QETLAB package.\n\n    Examples:\n        The swap operator is the Choi matrix of the transpose map. The following is a (non-ideal,\n        but illustrative) way of computing the transpose of a matrix.\n\n        Consider the following matrix\n\n        \\[\n            X = \\begin{pmatrix}\n                    1 &amp; 4 &amp; 7 \\\\\n                    2 &amp; 5 &amp; 8 \\\\\n                    3 &amp; 6 &amp; 9\n                \\end{pmatrix}\n        \\]\n\n        Applying the swap operator given as\n\n        \\[\n            \\Phi =\n            \\begin{pmatrix}\n                1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\\\\n                0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\\\\n                0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\\\\n                0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1\n             \\end{pmatrix}\n        \\]\n\n        to the matrix \\(X\\), we have the resulting matrix of\n\n        \\[\n            \\Phi(X) = \\begin{pmatrix}\n                            1 &amp; 2 &amp; 3 \\\\\n                            4 &amp; 5 &amp; 6 \\\\\n                            7 &amp; 8 &amp; 9\n                       \\end{pmatrix}\n        \\]\n\n        Using `|toqito\u27e9`, we can obtain the above matrices as follows.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.channel_ops import apply_channel\n        from toqito.perms import swap_operator\n        import numpy as np\n        test_input_mat = np.array([[1, 4, 7], [2, 5, 8], [3, 6, 9]])\n        print(apply_channel(test_input_mat, swap_operator(3)))\n        ```\n\n    Raises:\n        ValueError: If matrix is not Choi matrix.\n\n    Args:\n        mat: A matrix.\n        phi_op: A superoperator. `phi_op` should be provided either as a Choi matrix, or as a list of numpy arrays with\n        either 1 or 2 columns whose entries are its Kraus operators.\n\n    Returns:\n        The result of applying the superoperator `phi_op` to the operator `mat`.\n\n    \"\"\"\n    # Both of the following methods of applying the superoperator are much faster than naively\n    # looping through the Kraus operators or constructing eigenvectors of a Choi matrix.\n\n    # The superoperator was given as a list of Kraus operators:\n    if isinstance(phi_op, list):\n        s_phi_op = [len(phi_op), len(phi_op[0])]\n\n        phi_0_list = []\n        phi_1_list = []\n\n        # Map is completely positive if input is given as:\n        # 1. [K1, K2, .. Kr]\n        # 2. [[K1], [K2], .. [Kr]]\n        # 3. [[K1, K2, .. Kr]] and r &gt; 2\n        if isinstance(phi_op[0], np.ndarray):\n            phi_0_list = phi_op\n        elif s_phi_op[1] == 1 or (s_phi_op[0] == 1 and s_phi_op[1] &gt; 2):\n            phi_0_list = list(itertools.chain(*phi_op))\n        else:\n            # Input is given as: [[A1, B1], [A2, B2], .. [Ar, Br]]\n            phi_0_list = [k_mat[0] for k_mat in phi_op]\n            phi_1_list = [k_mat[1].conj().T for k_mat in phi_op]\n\n        if not phi_1_list:\n            phi_1_list = [k_mat.conj().T for k_mat in phi_0_list]\n\n        k_1 = np.concatenate(phi_0_list, axis=1)\n        k_2 = np.concatenate(phi_1_list, axis=0)\n\n        a_mat = np.kron(np.identity(len(phi_0_list)), mat)\n        return k_1 @ a_mat @ k_2\n\n    # The superoperator was given as a Choi matrix:\n    if isinstance(phi_op, np.ndarray):\n        mat_size = np.array(list(mat.shape))\n        phi_size = np.array(list(phi_op.shape)) / mat_size\n\n        a_mat = np.kron(vec(mat).T[0], np.identity(int(phi_size[0])))\n        b_mat = np.reshape(\n            swap(\n                phi_op.T,\n                [1, 2],\n                [[mat_size[1], phi_size[1]], [mat_size[0], phi_size[0]]],\n                True,\n            ).T,\n            (int(phi_size[0] * np.prod(mat_size)), int(phi_size[1])),\n            order=\"F\",\n        )\n        return a_mat @ b_mat\n    raise ValueError(\"Invalid: The variable `phi_op` must either be a list of Kraus operators or as a Choi matrix.\")\n</code></pre>"},{"location":"reference/toqito/channel_ops/choi_to_kraus/","title":"choi_to_kraus","text":""},{"location":"reference/toqito/channel_ops/choi_to_kraus/#toqito.channel_ops.choi_to_kraus","title":"choi_to_kraus","text":"<p>Computes a list of Kraus operators from the Choi matrix.</p>"},{"location":"reference/toqito/channel_ops/choi_to_kraus/#toqito.channel_ops.choi_to_kraus.choi_to_kraus","title":"choi_to_kraus","text":"<pre><code>choi_to_kraus(choi_mat: ndarray, tol: float = 1e-09, dim: int | list[int] | ndarray | None = None) -&gt; list[ndarray] | list[list[ndarray]]\n</code></pre> <p>Compute a list of Kraus operators from the Choi matrix from <sup>1</sup>.</p> <p>Note that unlike the Choi or natural representation of operators, the Kraus representation is not unique.</p> <p>If the input channel maps \\(M_{r,c}\\) to \\(M_{x,y}\\) then <code>dim</code> should be the list <code>[[r,x], [c,y]]</code>. If it maps \\(M_m\\) to \\(M_n\\), then <code>dim</code> can simply be the vector <code>[m,n]</code>.</p> <p>For completely positive maps the output is a single flat list of numpy arrays since the left and right Kraus maps are the same.</p> <p>This function has been adapted from <sup>1</sup> and QETLAB <sup>2</sup>.</p> <p>Examples:</p> <p>Consider taking the Kraus operators of the Choi matrix that characterizes the \"swap operator\" defined as</p> \\[     \\begin{pmatrix}         1 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 1 &amp; 0 \\\\         0 &amp; 1 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 1     \\end{pmatrix} \\] <p>The corresponding Kraus operators of the swap operator are given as follows,</p> \\[     \\begin{equation}     \\big[         \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 0 &amp; 1 \\\\ -1 &amp; 0 \\end{pmatrix},         \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 0 &amp; -1 \\\\ 1 &amp; 0 \\end{pmatrix}     \\big],     \\big[         \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\end{pmatrix},         \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\end{pmatrix}     \\big],     \\big[         \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; 0 \\end{pmatrix},         \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; 0 \\end{pmatrix}     \\big],     \\big[         \\begin{pmatrix} 0 &amp; 0 \\\\ 0 &amp; 1 \\end{pmatrix},         \\begin{pmatrix} 0 &amp; 0 \\\\ 0 &amp; 1 \\end{pmatrix}     \\big]     \\end{equation} \\] <p>This can be verified in <code>|toqito\u27e9</code> as follows.</p> <pre><code>import numpy as np\nfrom toqito.channel_ops import choi_to_kraus\nchoi_mat = np.array([[1, 0, 0, 0], [0, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 1]])\nkraus_ops = choi_to_kraus(choi_mat)\nfor i, pair in enumerate(kraus_ops):\n   print(f\"\\nKraus Pair {i+1}:\")\n   for j, op in enumerate(pair):\n       print(f\"  Operator {j+1}:\\n{np.array_str(op, precision=4, suppress_small=True)}\")\n</code></pre> <p>Kraus Pair 1:   Operator 1: [[ 0.      0.7071]  [-0.7071  0.    ]]   Operator 2: [[-0.     -0.7071]  [ 0.7071 -0.    ]]</p> <p>Kraus Pair 2:   Operator 1: [[0.     0.7071]  [0.7071 0.    ]]   Operator 2: [[0.     0.7071]  [0.7071 0.    ]]</p> <p>Kraus Pair 3:   Operator 1: [[1. 0.]  [0. 0.]]   Operator 2: [[1. 0.]  [0. 0.]]</p> <p>Kraus Pair 4:   Operator 1: [[0. 0.]  [0. 1.]]   Operator 2: [[0. 0.]  [0. 1.]]</p> <p>See</p> <p>kraus_to_choi</p> <p>Parameters:</p> <ul> <li> <code>choi_mat</code>               (<code>ndarray</code>)           \u2013            <p>A Choi matrix</p> </li> <li> <code>tol</code>               (<code>float</code>, default:                   <code>1e-09</code> )           \u2013            <p>optional threshold parameter for eigenvalues/kraus ops to be discarded</p> </li> <li> <code>dim</code>               (<code>int | list[int] | ndarray | None</code>, default:                   <code>None</code> )           \u2013            <p>A scalar, vector or matrix containing the input and output dimensions of Choi matrix.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[ndarray] | list[list[ndarray]]</code>           \u2013            <p>List of Kraus operators</p> </li> </ul> <p>References</p> <p><sup>1</sup> Rigetti. Forest Benchmarking. link. <sup>2</sup> Johnston, Nathaniel. {{QETLAB}: {A MATLAB} toolbox for quantum entanglement}. doi:10.5281/zenodo.44637.</p> Source code in <code>toqito/channel_ops/choi_to_kraus.py</code> <pre><code>def choi_to_kraus(\n    choi_mat: np.ndarray, tol: float = 1e-9, dim: int | list[int] | np.ndarray | None = None\n) -&gt; list[np.ndarray] | list[list[np.ndarray]]:\n    r\"\"\"Compute a list of Kraus operators from the Choi matrix from [@Rigetti_2022_Forest].\n\n    Note that unlike the Choi or natural representation of operators, the Kraus representation is\n    *not* unique.\n\n    If the input channel maps \\(M_{r,c}\\) to \\(M_{x,y}\\) then `dim` should be the\n    list `[[r,x], [c,y]]`. If it maps \\(M_m\\) to \\(M_n\\), then `dim` can simply\n    be the vector `[m,n]`.\n\n    For completely positive maps the output is a single flat list of numpy arrays since the left and\n    right Kraus maps are the same.\n\n    This function has been adapted from [@Rigetti_2022_Forest] and QETLAB [@QETLAB_link].\n\n    Examples:\n        Consider taking the Kraus operators of the Choi matrix that characterizes the \"swap operator\"\n        defined as\n\n        \\[\n            \\begin{pmatrix}\n                1 &amp; 0 &amp; 0 &amp; 0 \\\\\n                0 &amp; 0 &amp; 1 &amp; 0 \\\\\n                0 &amp; 1 &amp; 0 &amp; 0 \\\\\n                0 &amp; 0 &amp; 0 &amp; 1\n            \\end{pmatrix}\n        \\]\n\n        The corresponding Kraus operators of the swap operator are given as follows,\n\n        \\[\n            \\begin{equation}\n            \\big[\n                \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 0 &amp; 1 \\\\ -1 &amp; 0 \\end{pmatrix},\n                \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 0 &amp; -1 \\\\ 1 &amp; 0 \\end{pmatrix}\n            \\big],\n            \\big[\n                \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\end{pmatrix},\n                \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\end{pmatrix}\n            \\big],\n            \\big[\n                \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; 0 \\end{pmatrix},\n                \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; 0 \\end{pmatrix}\n            \\big],\n            \\big[\n                \\begin{pmatrix} 0 &amp; 0 \\\\ 0 &amp; 1 \\end{pmatrix},\n                \\begin{pmatrix} 0 &amp; 0 \\\\ 0 &amp; 1 \\end{pmatrix}\n            \\big]\n            \\end{equation}\n        \\]\n\n        This can be verified in `|toqito\u27e9` as follows.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.channel_ops import choi_to_kraus\n        choi_mat = np.array([[1, 0, 0, 0], [0, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 1]])\n        kraus_ops = choi_to_kraus(choi_mat)\n        for i, pair in enumerate(kraus_ops):\n           print(f\"\\nKraus Pair {i+1}:\")\n           for j, op in enumerate(pair):\n               print(f\"  Operator {j+1}:\\n{np.array_str(op, precision=4, suppress_small=True)}\")\n        ```\n\n        !!! See Also\n            [kraus_to_choi][toqito.channel_ops.kraus_to_choi.kraus_to_choi]\n\n    Args:\n        choi_mat: A Choi matrix\n        tol: optional threshold parameter for eigenvalues/kraus ops to be discarded\n        dim: A scalar, vector or matrix containing the input and output dimensions of Choi matrix.\n\n    Returns:\n        List of Kraus operators\n\n    \"\"\"\n    d_in, d_out, _ = channel_dim(choi_mat, dim=dim, compute_env_dim=False)\n    if is_hermitian(choi_mat):\n        eigvals, v_mat = np.linalg.eigh(choi_mat)\n        kraus_0 = [\n            np.sqrt(abs(eigval)) * unvec(evec, shape=(d_out[0], d_in[0]))\n            for eigval, evec in zip(eigvals, v_mat.T)\n            if abs(eigval) &gt; tol\n        ]\n\n        if is_positive_semidefinite(choi_mat):\n            return kraus_0\n\n        kraus_1 = [\n            np.sign(eigval) * k_mat for eigval, k_mat in zip(filter(lambda eigval: abs(eigval) &gt; tol, eigvals), kraus_0)\n        ]\n    else:\n        u_mat, singular_values, vh_mat = np.linalg.svd(choi_mat, full_matrices=False)\n        kraus_0 = [\n            np.sqrt(s_val) * unvec(evec, shape=(d_out[0], d_in[0]))\n            for s_val, evec in zip(singular_values, u_mat.T)\n            if abs(s_val) &gt; tol\n        ]\n\n        kraus_1 = [\n            np.sqrt(s_val) * unvec(evec.conj(), shape=(d_out[1], d_in[1]))\n            for s_val, evec in zip(singular_values, vh_mat)\n            if abs(s_val) &gt; tol\n        ]\n\n    return [[ka, kb] for ka, kb in zip(kraus_0, kraus_1)]\n</code></pre>"},{"location":"reference/toqito/channel_ops/complementary_channel/","title":"complementary_channel","text":""},{"location":"reference/toqito/channel_ops/complementary_channel/#toqito.channel_ops.complementary_channel","title":"complementary_channel","text":"<p>Computes the complementary channel/map of a superoperator.</p>"},{"location":"reference/toqito/channel_ops/complementary_channel/#toqito.channel_ops.complementary_channel.complementary_channel","title":"complementary_channel","text":"<pre><code>complementary_channel(kraus_ops: list[ndarray]) -&gt; list[ndarray]\n</code></pre> <p>Compute the Kraus operators for the complementary map of a quantum channel.</p> <p>(Section: Representations and Characterizations of Channels from <sup>1</sup>).</p> <p>The complementary map is derived from the given quantum channel's Kraus operators by rearranging the rows of the input Kraus operators into the Kraus operators of the complementary map.</p> <p>Specifically, for each Kraus operator \\(K_i\\) in the input channel \\(\\Phi\\), we define the complementary Kraus operators \\(K_i^C\\) by stacking the rows of \\(K_i\\) from all Kraus operators vertically.</p> <p>Examples:</p> <p>Suppose the following Kraus operators define a quantum channel:</p> \\[     K_1 = \\frac{1}{\\sqrt{2}} \\begin{pmatrix}         1 &amp; 0 \\\\         0 &amp; 0     \\end{pmatrix},     K_2 = \\frac{1}{\\sqrt{2}} \\begin{pmatrix}         0 &amp; 1 \\\\         0 &amp; 0     \\end{pmatrix},     K_3 = \\frac{1}{\\sqrt{2}} \\begin{pmatrix}         0 &amp; 0 \\\\         1 &amp; 0     \\end{pmatrix},     K_4 = \\frac{1}{\\sqrt{2}} \\begin{pmatrix}         0 &amp; 0 \\\\         0 &amp; 1     \\end{pmatrix} \\] <p>To compute the Kraus operators for the complementary map, we rearrange the rows of these Kraus operators as follows:</p> <pre><code>import numpy as np\nfrom toqito.channel_ops import complementary_channel\nkraus_ops_Phi = [\n    np.sqrt(0.5) * np.array([[1, 0], [0, 0]]),\n    np.sqrt(0.5) * np.array([[0, 1], [0, 0]]),\n    np.sqrt(0.5) * np.array([[0, 0], [1, 0]]),\n    np.sqrt(0.5) * np.array([[0, 0], [0, 1]])\n]\ncomp_kraus_ops = complementary_channel(kraus_ops_Phi)\nfor i, op in enumerate(comp_kraus_ops):\n    print(f\"Kraus operator {i + 1}:\")\n    print(op)\n</code></pre> <p>Kraus operator 1: [[0.70710678 0.        ]  [0.         0.70710678]  [0.         0.        ]  [0.         0.        ]] Kraus operator 2: [[0.         0.        ]  [0.         0.        ]  [0.70710678 0.        ]  [0.         0.70710678]]</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the input is not a valid list of Kraus operators.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>kraus_ops</code>               (<code>list[ndarray]</code>)           \u2013            <p>A list of numpy arrays representing the Kraus operators of a quantum channel. Each Kraus operator is</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[ndarray]</code>           \u2013            <p>A list of numpy arrays representing the Kraus operators of the complementary map.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Watrous, John. The Theory of Quantum Information. (2018). doi:10.1017/9781316848142.</p> Source code in <code>toqito/channel_ops/complementary_channel.py</code> <pre><code>def complementary_channel(kraus_ops: list[np.ndarray]) -&gt; list[np.ndarray]:\n    r\"\"\"Compute the Kraus operators for the complementary map of a quantum channel.\n\n    (Section: Representations and Characterizations of Channels from [@Watrous_2018_TQI]).\n\n    The complementary map is derived from the given quantum channel's Kraus operators by\n    rearranging the rows of the input Kraus operators into the Kraus operators of the\n    complementary map.\n\n    Specifically, for each Kraus operator \\(K_i\\) in the input channel \\(\\Phi\\),\n    we define the complementary Kraus operators \\(K_i^C\\) by stacking the rows of\n    \\(K_i\\) from all Kraus operators vertically.\n\n    Examples:\n        Suppose the following Kraus operators define a quantum channel:\n\n        \\[\n            K_1 = \\frac{1}{\\sqrt{2}} \\begin{pmatrix}\n                1 &amp; 0 \\\\\n                0 &amp; 0\n            \\end{pmatrix},\n            K_2 = \\frac{1}{\\sqrt{2}} \\begin{pmatrix}\n                0 &amp; 1 \\\\\n                0 &amp; 0\n            \\end{pmatrix},\n            K_3 = \\frac{1}{\\sqrt{2}} \\begin{pmatrix}\n                0 &amp; 0 \\\\\n                1 &amp; 0\n            \\end{pmatrix},\n            K_4 = \\frac{1}{\\sqrt{2}} \\begin{pmatrix}\n                0 &amp; 0 \\\\\n                0 &amp; 1\n            \\end{pmatrix}\n        \\]\n\n        To compute the Kraus operators for the complementary map, we rearrange the rows of these\n        Kraus operators as follows:\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.channel_ops import complementary_channel\n        kraus_ops_Phi = [\n            np.sqrt(0.5) * np.array([[1, 0], [0, 0]]),\n            np.sqrt(0.5) * np.array([[0, 1], [0, 0]]),\n            np.sqrt(0.5) * np.array([[0, 0], [1, 0]]),\n            np.sqrt(0.5) * np.array([[0, 0], [0, 1]])\n        ]\n        comp_kraus_ops = complementary_channel(kraus_ops_Phi)\n        for i, op in enumerate(comp_kraus_ops):\n            print(f\"Kraus operator {i + 1}:\")\n            print(op)\n        ```\n\n    Raises:\n        ValueError: If the input is not a valid list of Kraus operators.\n\n    Args:\n        kraus_ops: A list of numpy arrays representing the Kraus operators of a quantum channel. Each Kraus operator is\n        assumed to be a square matrix.\n\n    Returns:\n        A list of numpy arrays representing the Kraus operators of the complementary map.\n\n    \"\"\"\n    num_kraus = len(kraus_ops)\n    if num_kraus == 0:\n        raise ValueError(\"All Kraus operators must be non-empty matrices.\")\n\n    op_dim = kraus_ops[0].shape[0]\n\n    if any(k.shape[0] != k.shape[1] for k in kraus_ops):\n        raise ValueError(\"All Kraus operators must be square matrices.\")\n\n    if any(k.shape[0] != op_dim for k in kraus_ops):\n        raise ValueError(\"All Kraus operators must be equal size matrices.\")\n\n    # Check the Kraus completeness relation: \u2211 K_i\u2020 K_i = I\n    identity = np.eye(op_dim, dtype=kraus_ops[0].dtype)\n    sum_k_dagger_k = sum(k.T.conj() @ k for k in kraus_ops)\n\n    if not np.allclose(sum_k_dagger_k, identity):\n        raise ValueError(\"The Kraus operators do not satisfy the completeness relation \u2211 K_i\u2020 K_i = I.\")\n\n    comp_kraus_ops = []\n\n    for row in range(op_dim):\n        comp_kraus_op = np.vstack([kraus_ops[i][row, :] for i in range(num_kraus)])\n        comp_kraus_ops.append(comp_kraus_op)\n\n    return comp_kraus_ops\n</code></pre>"},{"location":"reference/toqito/channel_ops/dual_channel/","title":"dual_channel","text":""},{"location":"reference/toqito/channel_ops/dual_channel/#toqito.channel_ops.dual_channel","title":"dual_channel","text":"<p>Computes the dual of a map.</p>"},{"location":"reference/toqito/channel_ops/dual_channel/#toqito.channel_ops.dual_channel.dual_channel","title":"dual_channel","text":"<pre><code>dual_channel(phi_op: ndarray | list[ndarray] | list[list[ndarray]], dims: list[int] | None = None) -&gt; ndarray | list[list[ndarray]] | list[ndarray]\n</code></pre> <p>Compute the dual of a map (quantum channel).</p> <p>(Section: Representations and Characterizations of Channels of <sup>1</sup>).</p> <p>The map can be represented as a Choi matrix, with optional specification of input and output dimensions. If the input channel maps \\(M_{r,c}\\) to \\(M_{x,y}\\) then <code>dim</code> should be the list <code>[[r,x], [c,y]]</code>. If it maps \\(M_m\\) to \\(M_n\\), then <code>dim</code> can simply be the vector <code>[m,n]</code>. In this case the Choi matrix of the dual channel is returned, obtained by swapping input and output (see <code>swap</code>), and complex conjugating all elements.</p> <p>The map can also be represented as a list of Kraus operators. A list of lists, each containing two elements, corresponds to the families of operators \\(\\{(A_a, B_a)\\}\\) representing the map</p> \\[     \\Phi(X) = \\sum_a A_a X B^*_a. \\] <p>The dual map is obtained by taking the Hermitian adjoint of each operator. If <code>phi_op</code> is given as a one-dimensional list, \\(\\{A_a\\}\\), it is interpreted as the completely positive map</p> \\[     \\Phi(X) = \\sum_a A_a X A^*_a. \\] <p>Examples:</p> <p>When a channel is represented by a 1-D list of of Kraus operators, the CPTP dual channel can be determined as shown below.</p> <pre><code>import numpy as np\nfrom toqito.channel_ops import dual_channel\nkraus_1 = np.array([[1, 0, 1j, 0]])\nkraus_2 = np.array([[0, 1, 0, 1j]])\nkraus_list = [kraus_1, kraus_2]\ndual_kraus = dual_channel(kraus_list)\nfor i, op in enumerate(dual_kraus, start=1):\n   print(f\"\\nDual Kraus operator {i}:\")\n   print(op)\n</code></pre> <p>Dual Kraus operator 1: [[1.-0.j]  [0.-0.j]  [0.-1.j]  [0.-0.j]]</p> <p>Dual Kraus operator 2: [[0.-0.j]  [1.-0.j]  [0.-0.j]  [0.-1.j]]</p> <p>If the input channel's dimensions are different from the output dual channel's dimensions,</p> <pre><code>import numpy as np\nfrom toqito.channel_ops import dual_channel\nfrom toqito.perms import swap_operator\ninput_op = swap_operator([2, 3])\noutput = dual_channel(input_op, [[3, 2], [2, 3]])\nprint(output)\n</code></pre> <p>[[1. 0. 0. 0. 0. 0.]  [0. 0. 1. 0. 0. 0.]  [0. 0. 0. 0. 1. 0.]  [0. 1. 0. 0. 0. 0.]  [0. 0. 0. 1. 0. 0.]  [0. 0. 0. 0. 0. 1.]]</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If matrices are not Choi matrix.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>phi_op</code>               (<code>ndarray | list[ndarray] | list[list[ndarray]]</code>)           \u2013            <p>A superoperator. It should be provided either as a Choi matrix, or as a (1d or 2d) list of numpy arrays</p> </li> <li> <code>dims</code>               (<code>list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>Dimension of the input and output systems, for Choi matrix representation. If <code>None</code>, try to infer them</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray | list[list[ndarray]] | list[ndarray]</code>           \u2013            <p>The map dual to <code>phi_op</code>, in the same representation.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Watrous, John. The Theory of Quantum Information. (2018). doi:10.1017/9781316848142.</p> Source code in <code>toqito/channel_ops/dual_channel.py</code> <pre><code>def dual_channel(\n    phi_op: np.ndarray | list[np.ndarray] | list[list[np.ndarray]], dims: list[int] | None = None\n) -&gt; np.ndarray | list[list[np.ndarray]] | list[np.ndarray]:\n    r\"\"\"Compute the dual of a map (quantum channel).\n\n    (Section: Representations and Characterizations of Channels of [@Watrous_2018_TQI]).\n\n    The map can be represented as a Choi matrix, with optional specification of input\n    and output dimensions. If the input channel maps \\(M_{r,c}\\) to \\(M_{x,y}\\)\n    then `dim` should be the list `[[r,x], [c,y]]`. If it maps \\(M_m\\)\n    to \\(M_n\\), then `dim` can simply be the vector `[m,n]`. In this\n    case the Choi matrix of the dual channel is returned, obtained by swapping input and\n    output (see [`swap`][toqito.perms.swap.swap]), and complex conjugating all elements.\n\n    The map can also be represented as a list of Kraus operators.\n    A list of lists, each containing two elements, corresponds to the families\n    of operators \\(\\{(A_a, B_a)\\}\\) representing the map\n\n    \\[\n        \\Phi(X) = \\sum_a A_a X B^*_a.\n    \\]\n\n    The dual map is obtained by taking the Hermitian adjoint of each operator.\n    If `phi_op` is given as a one-dimensional list, \\(\\{A_a\\}\\),\n    it is interpreted as the completely positive map\n\n    \\[\n        \\Phi(X) = \\sum_a A_a X A^*_a.\n    \\]\n\n    Examples:\n        When a channel is represented by a 1-D list of of Kraus operators, the CPTP dual channel can be determined\n        as shown below.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.channel_ops import dual_channel\n        kraus_1 = np.array([[1, 0, 1j, 0]])\n        kraus_2 = np.array([[0, 1, 0, 1j]])\n        kraus_list = [kraus_1, kraus_2]\n        dual_kraus = dual_channel(kraus_list)\n        for i, op in enumerate(dual_kraus, start=1):\n           print(f\"\\nDual Kraus operator {i}:\")\n           print(op)\n        ```\n\n\n        If the input channel's dimensions are different from the output dual channel's dimensions,\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.channel_ops import dual_channel\n        from toqito.perms import swap_operator\n        input_op = swap_operator([2, 3])\n        output = dual_channel(input_op, [[3, 2], [2, 3]])\n        print(output)\n        ```\n\n    Raises:\n        ValueError: If matrices are not Choi matrix.\n\n    Args:\n        phi_op: A superoperator. It should be provided either as a Choi matrix, or as a (1d or 2d) list of numpy arrays\n        whose entries are its Kraus operators.\n        dims: Dimension of the input and output systems, for Choi matrix representation. If `None`, try to infer them\n        from `phi_op.shape`.\n\n    Returns:\n        The map dual to `phi_op`, in the same representation.\n\n    \"\"\"\n    # If phi_op is a list, assume it contains couples of Kraus operators\n    # and take the Hermitian conjugate.\n    if isinstance(phi_op, list):\n        if isinstance(phi_op[0], list):\n            return [[a.conj().T for a in x] for x in phi_op]\n        if isinstance(phi_op[0], np.ndarray):\n            return [a.conj().T for a in phi_op]\n\n    # If phi_op is a `ndarray`, assume it is a Choi matrix.\n    if isinstance(phi_op, np.ndarray):\n        if len(phi_op.shape) == 2:\n            d_in, d_out, _ = channel_dim(phi_op, dim=dims, compute_env_dim=False)\n            return swap(phi_op.conj(), dim=[[d_in[0], d_out[0]], [d_in[1], d_out[1]]])\n    raise ValueError(\"Invalid: The variable `phi_op` must either be a list of Kraus operators or as a Choi matrix.\")\n</code></pre>"},{"location":"reference/toqito/channel_ops/kraus_to_choi/","title":"kraus_to_choi","text":""},{"location":"reference/toqito/channel_ops/kraus_to_choi/#toqito.channel_ops.kraus_to_choi","title":"kraus_to_choi","text":"<p>Computes the Choi matrix of a list of Kraus operators.</p>"},{"location":"reference/toqito/channel_ops/kraus_to_choi/#toqito.channel_ops.kraus_to_choi.kraus_to_choi","title":"kraus_to_choi","text":"<pre><code>kraus_to_choi(kraus_ops: list[ndarray] | list[list[ndarray]], sys: int = 2) -&gt; ndarray\n</code></pre> <p>Compute the Choi matrix of a list of Kraus operators.</p> <p>(Section: Kraus Representations of <sup>1</sup>).</p> <p>The Choi matrix of the list of Kraus operators, <code>kraus_ops</code>. The default convention is that the Choi matrix is the result of applying the map to the second subsystem of the standard maximally entangled (unnormalized) state. The Kraus operators are expected to be input as a list of numpy arrays (i.e. [[<code>A_1</code>, <code>B_1</code>],...,[<code>A_n</code>, <code>B_n</code>]]). In case the map is CP (completely positive), it suffices to input a flat list of operators omitting their conjugate transpose (i.e. [\\(K_1\\),..., \\(K_n\\)]).</p> <p>This function was adapted from the QETLAB package.</p> <p>Examples:</p> <p>The transpose map:</p> <p>The Choi matrix of the transpose map is the swap operator. Notice that the transpose map is not completely positive.</p> <pre><code>import numpy as np\nfrom toqito.channel_ops import kraus_to_choi\nkraus_1 = np.array([[1, 0], [0, 0]])\nkraus_2 = np.array([[1, 0], [0, 0]]).conj().T\nkraus_3 = np.array([[0, 1], [0, 0]])\nkraus_4 = np.array([[0, 1], [0, 0]]).conj().T\nkraus_5 = np.array([[0, 0], [1, 0]])\nkraus_6 = np.array([[0, 0], [1, 0]]).conj().T\nkraus_7 = np.array([[0, 0], [0, 1]])\nkraus_8 = np.array([[0, 0], [0, 1]]).conj().T\n\nkraus_ops = [[kraus_1, kraus_2], [kraus_3, kraus_4], [kraus_5, kraus_6], [kraus_7, kraus_8]]\nchoi_op = kraus_to_choi(kraus_ops)\nprint(choi_op)\n</code></pre> <p>[[1. 0. 0. 0.]  [0. 0. 1. 0.]  [0. 1. 0. 0.]  [0. 0. 0. 1.]]</p> <p>See</p> <p>choi_to_kraus</p> <p>Parameters:</p> <ul> <li> <code>kraus_ops</code>               (<code>list[ndarray] | list[list[ndarray]]</code>)           \u2013            <p>A list of Kraus operators.</p> </li> <li> <code>sys</code>               (<code>int</code>, default:                   <code>2</code> )           \u2013            <p>The subsystem on which the channel acts (default is 2).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>The corresponding Choi matrix of the provided Kraus operators.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Watrous, John. The Theory of Quantum Information. (2018). doi:10.1017/9781316848142.</p> Source code in <code>toqito/channel_ops/kraus_to_choi.py</code> <pre><code>def kraus_to_choi(kraus_ops: list[np.ndarray] | list[list[np.ndarray]], sys: int = 2) -&gt; np.ndarray:\n    r\"\"\"Compute the Choi matrix of a list of Kraus operators.\n\n    (Section: Kraus Representations of [@Watrous_2018_TQI]).\n\n    The Choi matrix of the list of Kraus operators, `kraus_ops`. The default convention is\n    that the Choi matrix is the result of applying the map to the second subsystem of the\n    standard maximally entangled (unnormalized) state. The Kraus operators are expected to be\n    input as a list of numpy arrays (i.e. [[`A_1`, `B_1`],...,[`A_n`, `B_n`]]).\n    In case the map is CP (completely positive), it suffices to input a flat list of operators omitting\n    their conjugate transpose (i.e. [\\(K_1\\),..., \\(K_n\\)]).\n\n    This function was adapted from the QETLAB package.\n\n    Examples:\n        The transpose map:\n\n        The Choi matrix of the transpose map is the swap operator. Notice that the transpose map\n        is *not* completely positive.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.channel_ops import kraus_to_choi\n        kraus_1 = np.array([[1, 0], [0, 0]])\n        kraus_2 = np.array([[1, 0], [0, 0]]).conj().T\n        kraus_3 = np.array([[0, 1], [0, 0]])\n        kraus_4 = np.array([[0, 1], [0, 0]]).conj().T\n        kraus_5 = np.array([[0, 0], [1, 0]])\n        kraus_6 = np.array([[0, 0], [1, 0]]).conj().T\n        kraus_7 = np.array([[0, 0], [0, 1]])\n        kraus_8 = np.array([[0, 0], [0, 1]]).conj().T\n\n        kraus_ops = [[kraus_1, kraus_2], [kraus_3, kraus_4], [kraus_5, kraus_6], [kraus_7, kraus_8]]\n        choi_op = kraus_to_choi(kraus_ops)\n        print(choi_op)\n        ```\n\n        !!! See Also\n            [choi_to_kraus][toqito.channel_ops.choi_to_kraus.choi_to_kraus]\n\n    Args:\n        kraus_ops: A list of Kraus operators.\n        sys: The subsystem on which the channel acts (default is 2).\n\n    Returns:\n        The corresponding Choi matrix of the provided Kraus operators.\n\n    \"\"\"\n    if sys &lt; 0:\n        raise ValueError(\"The `sys` parameter must be non-negative.\")\n\n    dim_in, _, _ = channel_dim(kraus_ops)\n    dim_op_1, dim_op_2 = dim_in\n\n    choi_mat = partial_channel(\n        max_entangled(dim_op_1, False, False) @ max_entangled(dim_op_2, False, False).conj().T,\n        kraus_ops,\n        sys,\n        np.array([[dim_op_1, dim_op_1], [dim_op_2, dim_op_2]]),\n    )\n\n    return choi_mat\n</code></pre>"},{"location":"reference/toqito/channel_ops/natural_representation/","title":"natural_representation","text":""},{"location":"reference/toqito/channel_ops/natural_representation/#toqito.channel_ops.natural_representation","title":"natural_representation","text":"<p>Kraus operators to natural representation.</p>"},{"location":"reference/toqito/channel_ops/natural_representation/#toqito.channel_ops.natural_representation.natural_representation","title":"natural_representation","text":"<pre><code>natural_representation(kraus_ops: list[ndarray]) -&gt; ndarray\n</code></pre> <p>Convert a set of Kraus operators to the natural representation of a quantum channel.</p> <p>The natural representation of a quantum channel is given by: \\(\\Phi = \\sum_i K_i \\otimes K_i^*\\) where \\(K_i^*\\) is the complex conjugate of \\(K_i\\).</p> <p>Examples:</p> <pre><code>import numpy as np\nfrom toqito.channel_ops import natural_representation\nk0 = np.sqrt(1/2) * np.array([[1, 0], [0, 1]])\nk1 = np.sqrt(1/2) * np.array([[0, 1], [1, 0]])\nprint(natural_representation([k0, k1]))\n</code></pre> <p>[[0.5 0.  0.  0.5]  [0.  0.5 0.5 0. ]  [0.  0.5 0.5 0. ]  [0.5 0.  0.  0.5]]</p> Source code in <code>toqito/channel_ops/natural_representation.py</code> <pre><code>def natural_representation(kraus_ops: list[np.ndarray]) -&gt; np.ndarray:\n    r\"\"\"Convert a set of Kraus operators to the natural representation of a quantum channel.\n\n    The natural representation of a quantum channel is given by:\n    \\(\\Phi = \\sum_i K_i \\otimes K_i^*\\)\n    where \\(K_i^*\\) is the complex conjugate of \\(K_i\\).\n\n    Examples:\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.channel_ops import natural_representation\n        k0 = np.sqrt(1/2) * np.array([[1, 0], [0, 1]])\n        k1 = np.sqrt(1/2) * np.array([[0, 1], [1, 0]])\n        print(natural_representation([k0, k1]))\n        ```\n\n    \"\"\"\n    dim = kraus_ops[0].shape\n    if not all(k.shape == dim for k in kraus_ops):\n        raise ValueError(\"All Kraus operators must have the same dimensions.\")\n\n    # Compute the natural representation.\n    return np.sum([tensor(k, np.conjugate(k)) for k in kraus_ops], axis=0)\n</code></pre>"},{"location":"reference/toqito/channel_ops/partial_channel/","title":"partial_channel","text":""},{"location":"reference/toqito/channel_ops/partial_channel/#toqito.channel_ops.partial_channel","title":"partial_channel","text":"<p>Applies a channel to a subsystem of an operator.</p>"},{"location":"reference/toqito/channel_ops/partial_channel/#toqito.channel_ops.partial_channel.partial_channel","title":"partial_channel","text":"<pre><code>partial_channel(rho: ndarray, phi_map: ndarray | list[list[ndarray]], sys: int = 2, dim: list[int] | ndarray | None = None) -&gt; ndarray\n</code></pre> <p>Apply channel to a subsystem of an operator <sup>1</sup>.</p> <p>Applies the operator</p> \\[     \\left(\\mathbb{I} \\otimes \\Phi \\right) \\left(\\rho \\right). \\] <p>In other words, it is the result of applying the channel \\(\\Phi\\) to the second subsystem of \\(\\rho\\), which is assumed to act on two subsystems of equal dimension.</p> <p>The input <code>phi_map</code> should be provided as a Choi matrix.</p> <p>This function is adapted from the QETLAB package.</p> <p>Examples:</p> <p>The following applies the completely depolarizing channel to the second subsystem of a random density matrix.</p> <pre><code>import numpy as np\nfrom toqito.channel_ops import partial_channel\nfrom toqito.channels import depolarizing\nrho = np.array([\n   [0.3101, -0.0220 - 0.0219j, -0.0671 - 0.0030j, -0.0170 - 0.0694j],\n   [-0.0220 + 0.0219j, 0.1008, -0.0775 + 0.0492j, -0.0613 + 0.0529j],\n   [-0.0671 + 0.0030j, -0.0775 - 0.0492j, 0.1361, 0.0602 + 0.0062j],\n   [-0.0170 + 0.0694j, -0.0613 - 0.0529j, 0.0602 - 0.0062j, 0.4530]\n])\n\nres = partial_channel(rho, depolarizing(2))\n\nnp.set_printoptions(linewidth=150, suppress=False)\nprint(res)\n</code></pre> <p>[[ 0.20545+0.j       0.     +0.j      -0.0642 +0.02495j  0.     +0.j     ]  [ 0.     +0.j       0.20545+0.j       0.     +0.j      -0.0642 +0.02495j]  [-0.0642 -0.02495j  0.     +0.j       0.29455+0.j       0.     +0.j     ]  [ 0.     +0.j      -0.0642 -0.02495j  0.     +0.j       0.29455+0.j     ]]</p> <p>The following applies the completely depolarizing channel to the first subsystem.</p> <pre><code>import numpy as np\nfrom toqito.channel_ops import partial_channel\nfrom toqito.channels import depolarizing\n\nrho = np.array([\n   [0.3101, -0.0220 - 0.0219j, -0.0671 - 0.0030j, -0.0170 - 0.0694j],\n   [-0.0220 + 0.0219j, 0.1008, -0.0775 + 0.0492j, -0.0613 + 0.0529j],\n   [-0.0671 + 0.0030j, -0.0775 - 0.0492j, 0.1361, 0.0602 + 0.0062j],\n   [-0.0170 + 0.0694j, -0.0613 - 0.0529j, 0.0602 - 0.0062j, 0.4530]\n])\n\nres = partial_channel(rho, depolarizing(2))\nnp.set_printoptions(linewidth=150, suppress=False)\nprint(res)\n</code></pre> <p>[[ 0.20545+0.j       0.     +0.j      -0.0642 +0.02495j  0.     +0.j     ]  [ 0.     +0.j       0.20545+0.j       0.     +0.j      -0.0642 +0.02495j]  [-0.0642 -0.02495j  0.     +0.j       0.29455+0.j       0.     +0.j     ]  [ 0.     +0.j      -0.0642 -0.02495j  0.     +0.j       0.29455+0.j     ]]</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If Phi map is not provided as a Choi matrix or Kraus operators.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>rho</code>               (<code>ndarray</code>)           \u2013            <p>A matrix.</p> </li> <li> <code>phi_map</code>               (<code>ndarray | list[list[ndarray]]</code>)           \u2013            <p>The map to partially apply.</p> </li> <li> <code>sys</code>               (<code>int</code>, default:                   <code>2</code> )           \u2013            <p>Scalar or vector specifying the size of the subsystems.</p> </li> <li> <code>dim</code>               (<code>list[int] | ndarray | None</code>, default:                   <code>None</code> )           \u2013            <p>Dimension of the subsystems. If <code>None</code>, all dimensions are assumed to be equal.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>The partial map <code>phi_map</code> applied to matrix <code>rho</code>.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Watrous, John. The Theory of Quantum Information. (2018). doi:10.1017/9781316848142.</p> Source code in <code>toqito/channel_ops/partial_channel.py</code> <pre><code>def partial_channel(\n    rho: np.ndarray,\n    phi_map: np.ndarray | list[list[np.ndarray]],\n    sys: int = 2,\n    dim: list[int] | np.ndarray | None = None,\n) -&gt; np.ndarray:\n    r\"\"\"Apply channel to a subsystem of an operator [@Watrous_2018_TQI].\n\n    Applies the operator\n\n    \\[\n        \\left(\\mathbb{I} \\otimes \\Phi \\right) \\left(\\rho \\right).\n    \\]\n\n    In other words, it is the result of applying the channel \\(\\Phi\\) to the second subsystem\n    of \\(\\rho\\), which is assumed to act on two subsystems of equal dimension.\n\n    The input `phi_map` should be provided as a Choi matrix.\n\n    This function is adapted from the QETLAB package.\n\n    Examples:\n        The following applies the completely depolarizing channel to the second\n        subsystem of a random density matrix.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.channel_ops import partial_channel\n        from toqito.channels import depolarizing\n        rho = np.array([\n           [0.3101, -0.0220 - 0.0219j, -0.0671 - 0.0030j, -0.0170 - 0.0694j],\n           [-0.0220 + 0.0219j, 0.1008, -0.0775 + 0.0492j, -0.0613 + 0.0529j],\n           [-0.0671 + 0.0030j, -0.0775 - 0.0492j, 0.1361, 0.0602 + 0.0062j],\n           [-0.0170 + 0.0694j, -0.0613 - 0.0529j, 0.0602 - 0.0062j, 0.4530]\n        ])\n\n        res = partial_channel(rho, depolarizing(2))\n\n        np.set_printoptions(linewidth=150, suppress=False)\n        print(res)\n        ```\n\n\n\n        The following applies the completely depolarizing channel to the first\n        subsystem.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.channel_ops import partial_channel\n        from toqito.channels import depolarizing\n\n        rho = np.array([\n           [0.3101, -0.0220 - 0.0219j, -0.0671 - 0.0030j, -0.0170 - 0.0694j],\n           [-0.0220 + 0.0219j, 0.1008, -0.0775 + 0.0492j, -0.0613 + 0.0529j],\n           [-0.0671 + 0.0030j, -0.0775 - 0.0492j, 0.1361, 0.0602 + 0.0062j],\n           [-0.0170 + 0.0694j, -0.0613 - 0.0529j, 0.0602 - 0.0062j, 0.4530]\n        ])\n\n        res = partial_channel(rho, depolarizing(2))\n        np.set_printoptions(linewidth=150, suppress=False)\n        print(res)\n        ```\n\n    Raises:\n        ValueError: If Phi map is not provided as a Choi matrix or Kraus operators.\n\n    Args:\n        rho: A matrix.\n        phi_map: The map to partially apply.\n        sys: Scalar or vector specifying the size of the subsystems.\n        dim: Dimension of the subsystems. If `None`, all dimensions are assumed to be equal.\n\n    Returns:\n        The partial map `phi_map` applied to matrix `rho`.\n\n    \"\"\"\n    if dim is None:\n        dim = np.round(np.sqrt(list(rho.shape))).conj().T * np.ones(2)\n    if isinstance(dim, list):\n        dim = np.array(dim)\n\n    # Force dim to be a row vector.\n    if dim.ndim == 1:\n        dim = dim.T.flatten()\n        dim = np.array([dim, dim])\n\n    prod_dim_r1 = int(np.prod(dim[0, : sys - 1]))\n    prod_dim_c1 = int(np.prod(dim[1, : sys - 1]))\n    prod_dim_r2 = int(np.prod(dim[0, sys:]))\n    prod_dim_c2 = int(np.prod(dim[1, sys:]))\n\n    if isinstance(phi_map, list):\n        # Compute the Kraus operators on the full system.\n        s_phi_1, s_phi_2 = len(phi_map), len(phi_map[0])\n        phi_list = []\n        # Map is completely positive if input is given as:\n        # 1. [K1, K2, .. Kr]\n        # 2. [[K1], [K2], .. [Kr]]\n        # 3. [[K1, K2, .. Kr]] and r &gt; 2\n        if isinstance(phi_map[0], np.ndarray):\n            phi_list = phi_map\n        elif s_phi_2 == 1 or s_phi_1 == 1 and s_phi_2 &gt; 2:\n            phi_list = list(itertools.chain(*phi_map))\n\n        if phi_list:\n            phi = []\n            for m in phi_list:\n                phi.append(\n                    np.kron(\n                        np.kron(np.identity(prod_dim_r1), m),\n                        np.identity(prod_dim_r2),\n                    )\n                )\n            phi_x = apply_channel(rho, phi)\n        else:\n            phi_1 = []\n            for m in phi_map:\n                phi_1.append(\n                    np.kron(\n                        np.kron(np.identity(prod_dim_r1), m[0]),\n                        np.identity(prod_dim_r2),\n                    )\n                )\n            phi_2 = []\n            for m in phi_map:\n                phi_2.append(\n                    np.kron(\n                        np.kron(np.identity(prod_dim_c1), m[1]),\n                        np.identity(prod_dim_c2),\n                    )\n                )\n\n            phi_x = [list(litem) for litem in zip(phi_1, phi_2)]\n            phi_x = apply_channel(rho, phi_x)\n        return phi_x\n\n    # The `phi_map` variable is provided as a Choi matrix.\n    if isinstance(phi_map, np.ndarray):\n        dim_phi = phi_map.shape\n\n        dim = np.array(\n            [\n                [\n                    prod_dim_r1,\n                    prod_dim_r1,\n                    int(dim[0, sys - 1]),\n                    int(dim_phi[0] / dim[0, sys - 1]),\n                    prod_dim_r2,\n                    prod_dim_r2,\n                ],\n                [\n                    prod_dim_c1,\n                    prod_dim_c1,\n                    int(dim[1, sys - 1]),\n                    int(dim_phi[1] / dim[1, sys - 1]),\n                    prod_dim_c2,\n                    prod_dim_c2,\n                ],\n            ]\n        )\n        psi_r1 = max_entangled(prod_dim_r1, False, False)\n        psi_c1 = max_entangled(prod_dim_c1, False, False)\n        psi_r2 = max_entangled(prod_dim_r2, False, False)\n        psi_c2 = max_entangled(prod_dim_c2, False, False)\n\n        phi_map = permute_systems(\n            np.kron(np.kron(psi_r1 @ psi_c1.conj().T, phi_map), psi_r2 @ psi_c2.conj().T),\n            [0, 2, 4, 1, 3, 5],\n            dim,\n        )\n\n        phi_x = apply_channel(rho, phi_map)\n\n        return phi_x\n\n    raise ValueError(\n        \"The `phi_map` variable is assumed to be provided as either a Choi matrix or a list of Kraus operators.\"\n    )\n</code></pre>"},{"location":"reference/toqito/channel_props/","title":"channel_props","text":""},{"location":"reference/toqito/channel_props/#toqito.channel_props","title":"channel_props","text":"<p>Channel properties module.</p>"},{"location":"reference/toqito/channel_props/channel_dim/","title":"channel_dim","text":""},{"location":"reference/toqito/channel_props/channel_dim/#toqito.channel_props.channel_dim","title":"channel_dim","text":"<p>Channel dimensions coputes and returns the input, output and environment dimensions of a channel.</p>"},{"location":"reference/toqito/channel_props/channel_dim/#toqito.channel_props.channel_dim.channel_dim","title":"channel_dim","text":"<pre><code>channel_dim(phi: ndarray | list[ndarray] | list[list[ndarray]], allow_rect: bool = True, dim: int | list[int] | ndarray | None = None, compute_env_dim: bool = True) -&gt; tuple[ndarray | int, ndarray | int, int | None]\n</code></pre> <p>Compute the input, output, and environment dimensions of a channel.</p> <p>This function returns the dimensions of the input, output, and environment spaces of input channel, in that order. Input and output dimensions are both 1-by-2 vectors containing the row and column dimensions of their spaces. The enviroment dimension is always a scalar, and it is equal to the number of Kraus operators of PHI (if PHI is provided as a Choi matrix then enviroment dimension is the minimal number of Kraus operators of any representation of PHI).</p> <p>Input DIM should provided if and only if PHI is a Choi matrix with unequal input and output dimensions (since it is impossible to determine the input and output dimensions from the Choi matrix alone). If ALLOW_RECT is false and PHI acts on non-square matrix spaces, an error will be produced. If PHI maps M_{r,c} to M_{x,y} then DIM should be the 2-by-2 matrix [[r,x], [c,y]]. If PHI maps M_m to M_n, then DIM can simply be the vector [m,n]. If ALLOW_RECT is false then returned input and output dimensions will be scalars instead of vectors. If COMPUTE_ENV_DIM is false and the PHI is a Choi matrix we avoid computing the rank of the Choi matrix.</p> <p>This functions was adapted from QETLAB <sup>1</sup>.</p> <p>Parameters:</p> <ul> <li> <code>phi</code>               (<code>ndarray | list[ndarray] | list[list[ndarray]]</code>)           \u2013            <p>A superoperator. It should be provided either as a Choi matrix, or as a (1d or 2d) list of numpy arrays</p> </li> <li> <code>allow_rect</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>A flag indicating that the input and output spaces of PHI can be non-square (default True).</p> </li> <li> <code>dim</code>               (<code>int | list[int] | ndarray | None</code>, default:                   <code>None</code> )           \u2013            <p>A scalar, vector or matrix containing the input and output dimensions of PHI.</p> </li> <li> <code>compute_env_dim</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>A flag indicating whether we compute the enviroment dimension.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[ndarray | int, ndarray | int, int | None]</code>           \u2013            <p>The input, output, and environment dimensions of a channel.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Johnston, Nathaniel. {{QETLAB}: {A MATLAB} toolbox for quantum entanglement}. doi:10.5281/zenodo.44637.</p> Source code in <code>toqito/channel_props/channel_dim.py</code> <pre><code>def channel_dim(\n    phi: np.ndarray | list[np.ndarray] | list[list[np.ndarray]],\n    allow_rect: bool = True,\n    dim: int | list[int] | np.ndarray | None = None,\n    compute_env_dim: bool = True,\n) -&gt; tuple[np.ndarray | int, np.ndarray | int, int | None]:\n    \"\"\"Compute the input, output, and environment dimensions of a channel.\n\n    This function returns the dimensions of the input, output, and environment spaces of\n    input channel, in that order. Input and output dimensions are both 1-by-2 vectors\n    containing the row and column dimensions of their spaces. The enviroment dimension\n    is always a scalar, and it is equal to the number of Kraus operators of PHI (if PHI is\n    provided as a Choi matrix then enviroment dimension is the *minimal* number of Kraus\n    operators of any representation of PHI).\n\n    Input DIM should provided if and only if PHI is a Choi matrix with unequal input and\n    output dimensions (since it is impossible to determine the input and output dimensions\n    from the Choi matrix alone). If ALLOW_RECT is false and PHI acts on non-square matrix\n    spaces, an error will be produced. If PHI maps M_{r,c} to M_{x,y} then DIM should be the\n    2-by-2 matrix [[r,x], [c,y]]. If PHI maps M_m to M_n, then DIM can simply be the vector\n    [m,n]. If ALLOW_RECT is false then returned input and output dimensions will be scalars\n    instead of vectors. If COMPUTE_ENV_DIM is false and the PHI is a Choi matrix we avoid\n    computing the rank of the Choi matrix.\n\n    This functions was adapted from QETLAB [@QETLAB_link].\n\n    Args:\n        phi: A superoperator. It should be provided either as a Choi matrix, or as a (1d or 2d) list of numpy arrays\n        whose entries are its Kraus operators.\n        allow_rect: A flag indicating that the input and output spaces of PHI can be non-square (default True).\n        dim: A scalar, vector or matrix containing the input and output dimensions of PHI.\n        compute_env_dim: A flag indicating whether we compute the enviroment dimension.\n\n    Returns:\n        The input, output, and environment dimensions of a channel.\n\n    \"\"\"\n    dim_in = np.zeros(2, dtype=int)\n    dim_out = np.zeros(2, dtype=int)\n\n    if isinstance(phi, list):\n        sz_phi_op = [len(phi), len(phi[0])]\n\n        # Map is completely positive if input is given as:\n        # 1. [K1, K2, .. Kr]\n        # 2. [[K1], [K2], .. [Kr]]\n        # 3. [[K1, K2, .. Kr]] and r &gt; 2\n        is_cpt = False\n        if isinstance(phi[0], list) and (sz_phi_op[1] == 1 or (sz_phi_op[0] == 1 and sz_phi_op[1] &gt; 2)):\n            # get a flat list of Kraus operators.\n            phi = list(itertools.chain(*phi))\n            is_cpt = True\n\n        dim_e = len(phi)\n        if isinstance(phi[0], np.ndarray):\n            dim_out[0], dim_in[0] = phi[0].shape\n            # input and output are squares.\n            dim_in[1] = dim_in[0]\n            dim_out[1] = dim_out[0]\n            is_cpt = True\n        else:\n            dim_out[0], dim_in[0] = phi[0][0].shape\n            dim_out[1], dim_in[1] = phi[0][1].shape\n\n        if dim is None:\n            dim = np.vstack([dim_in, dim_out]).T\n        dim = _expand_dim(dim)\n\n        # Now do some error checking.\n        if (dim_in[0] != dim_in[1] or dim_out[0] != dim_out[1]) and not allow_rect:\n            raise ValueError(\"The input and output spaces of PHI must be square.\")\n\n        if np.any(dim != np.vstack([dim_in, dim_out]).T):\n            raise ValueError(\"The dimensions of PHI do not match those provided in the DIM argument.\")\n\n        if (is_cpt and any(k_mat.shape != (dim[0, 1], dim[0, 0]) for k_mat in phi)) or (\n            not is_cpt\n            and any(\n                k_mat[0].shape != (dim[0, 1], dim[0, 0]) or k_mat[1].shape != (dim[1, 1], dim[1, 0]) for k_mat in phi\n            )\n        ):\n            raise ValueError(\"The Kraus operators of PHI do not all have the same size.\")\n\n    # If Phi is a Choi matrix, the dimensions are a bit more of a pain: we have\n    # to guess a bit if the input and output dimensions are different.\n    else:\n        # Try to guess input and output dims.\n        rows, cols = phi.shape\n        dim_in = np.array([int(np.round(np.sqrt(rows))), int(np.round(np.sqrt(cols)))])\n        dim_out = dim_in\n\n        if dim is None:\n            dim = np.vstack([dim_in, dim_out]).T\n        dim = _expand_dim(dim)\n\n        if dim[0, 0] * dim[0, 1] != rows or dim[1, 0] * dim[1, 1] != cols:\n            raise ValueError(\n                \"If the input and output dimensions are unequal and PHI is provided \"\n                \"as a Choi matrix, the optional argument DIM must be specified \"\n                \"(and its dimensions must agree with PHI).\"\n            )\n\n        if (dim[0, 0] != dim[1, 0] or dim[0, 1] != dim[1, 1]) and not allow_rect:\n            raise ValueError(\"The input and output spaces of PHI must be square.\")\n\n        # environment dimension is the rank of the Choi matrix\n        dim_e = None\n        if compute_env_dim:\n            dim_e = np.linalg.matrix_rank(phi)\n\n    # Finally, put `dim` back into `dim_in` and `dim_out`.\n    if allow_rect:\n        dim_in = np.array([dim[0, 0], dim[1, 0]])\n        dim_out = np.array([dim[0, 1], dim[1, 1]])\n    else:\n        dim_in = dim[0, 0]\n        dim_out = dim[0, 1]\n\n    return (dim_in, dim_out, dim_e)\n</code></pre>"},{"location":"reference/toqito/channel_props/choi_rank/","title":"choi_rank","text":""},{"location":"reference/toqito/channel_props/choi_rank/#toqito.channel_props.choi_rank","title":"choi_rank","text":"<p>Calculates the Choi rank of a channel.</p>"},{"location":"reference/toqito/channel_props/choi_rank/#toqito.channel_props.choi_rank.choi_rank","title":"choi_rank","text":"<pre><code>choi_rank(phi: ndarray | list[list[ndarray]]) -&gt; int\n</code></pre> <p>Calculate the rank of the Choi representation of a quantum channel.</p> <p>(Section 2.2: Quantum Channels from <sup>1</sup>).</p> <p>Examples:</p> <p>The transpose map can be written either in Choi representation (as a SWAP operator) or in Kraus representation. If we choose the latter, it will be given by the following matrices:</p> \\[     \\begin{equation}         \\frac{1}{\\sqrt{2}}         \\begin{pmatrix}             0 &amp; i \\\\ -i &amp; 0         \\end{pmatrix}, \\quad         \\frac{1}{\\sqrt{2}}         \\begin{pmatrix}             0 &amp; 1 \\\\             1 &amp; 0         \\end{pmatrix}, \\quad         \\begin{pmatrix}             1 &amp; 0 \\\\             0 &amp; 0         \\end{pmatrix}, \\quad         \\begin{pmatrix}             0 &amp; 0 \\\\             0 &amp; 1         \\end{pmatrix}.     \\end{equation} \\] <p>and can be generated in <code>|toqito\u27e9</code> with the following list:</p> <pre><code>import numpy as np\nfrom toqito.channel_props import choi_rank\n\nkraus_1 = np.array([[1, 0], [0, 0]])\nkraus_2 = np.array([[1, 0], [0, 0]]).conj().T\nkraus_3 = np.array([[0, 1], [0, 0]])\nkraus_4 = np.array([[0, 1], [0, 0]]).conj().T\nkraus_5 = np.array([[0, 0], [1, 0]])\nkraus_6 = np.array([[0, 0], [1, 0]]).conj().T\nkraus_7 = np.array([[0, 0], [0, 1]])\nkraus_8 = np.array([[0, 0], [0, 1]]).conj().T\nkraus_ops = [[kraus_1, kraus_2], [kraus_3, kraus_4],[kraus_5, kraus_6],[kraus_7, kraus_8]]\n\nprint(choi_rank(kraus_ops))\n</code></pre> <p>4</p> <p>We can the verify the associated Choi representation (the SWAP gate) gets the same Choi rank:</p> <pre><code>import numpy as np\nfrom toqito.channel_props import choi_rank\nchoi_matrix = np.array([[1,0,0,0],[0,0,1,0],[0,1,0,0],[0,0,0,1]])\nprint(choi_rank(choi_matrix))\n</code></pre> <p>4</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If matrix is not Choi.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>phi</code>               (<code>ndarray | list[list[ndarray]]</code>)           \u2013            <p>Either a Choi matrix or a list of Kraus operators</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The Choi rank of the provided channel representation.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Watrous, John. The Theory of Quantum Information. (2018). doi:10.1017/9781316848142.</p> Source code in <code>toqito/channel_props/choi_rank.py</code> <pre><code>def choi_rank(phi: np.ndarray | list[list[np.ndarray]]) -&gt; int:\n    r\"\"\"Calculate the rank of the Choi representation of a quantum channel.\n\n    (Section 2.2: Quantum Channels from [@Watrous_2018_TQI]).\n\n    Examples:\n        The transpose map can be written either in Choi representation (as a\n        SWAP operator) or in Kraus representation. If we choose the latter, it\n        will be given by the following matrices:\n\n        \\[\n            \\begin{equation}\n                \\frac{1}{\\sqrt{2}}\n                \\begin{pmatrix}\n                    0 &amp; i \\\\ -i &amp; 0\n                \\end{pmatrix}, \\quad\n                \\frac{1}{\\sqrt{2}}\n                \\begin{pmatrix}\n                    0 &amp; 1 \\\\\n                    1 &amp; 0\n                \\end{pmatrix}, \\quad\n                \\begin{pmatrix}\n                    1 &amp; 0 \\\\\n                    0 &amp; 0\n                \\end{pmatrix}, \\quad\n                \\begin{pmatrix}\n                    0 &amp; 0 \\\\\n                    0 &amp; 1\n                \\end{pmatrix}.\n            \\end{equation}\n        \\]\n\n        and can be generated in `|toqito\u27e9` with the following list:\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.channel_props import choi_rank\n\n        kraus_1 = np.array([[1, 0], [0, 0]])\n        kraus_2 = np.array([[1, 0], [0, 0]]).conj().T\n        kraus_3 = np.array([[0, 1], [0, 0]])\n        kraus_4 = np.array([[0, 1], [0, 0]]).conj().T\n        kraus_5 = np.array([[0, 0], [1, 0]])\n        kraus_6 = np.array([[0, 0], [1, 0]]).conj().T\n        kraus_7 = np.array([[0, 0], [0, 1]])\n        kraus_8 = np.array([[0, 0], [0, 1]]).conj().T\n        kraus_ops = [[kraus_1, kraus_2], [kraus_3, kraus_4],[kraus_5, kraus_6],[kraus_7, kraus_8]]\n\n        print(choi_rank(kraus_ops))\n        ```\n\n        We can the verify the associated Choi representation (the SWAP gate)\n        gets the same Choi rank:\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.channel_props import choi_rank\n        choi_matrix = np.array([[1,0,0,0],[0,0,1,0],[0,1,0,0],[0,0,0,1]])\n        print(choi_rank(choi_matrix))\n        ```\n\n    Raises:\n        ValueError: If matrix is not Choi.\n\n    Args:\n        phi: Either a Choi matrix or a list of Kraus operators\n\n    Returns:\n        The Choi rank of the provided channel representation.\n\n    \"\"\"\n    if isinstance(phi, list):\n        phi = kraus_to_choi(phi)\n    elif not isinstance(phi, np.ndarray):\n        raise ValueError(\"Not a valid Choi matrix.\")\n\n    return np.linalg.matrix_rank(phi)\n</code></pre>"},{"location":"reference/toqito/channel_props/is_completely_positive/","title":"is_completely_positive","text":""},{"location":"reference/toqito/channel_props/is_completely_positive/#toqito.channel_props.is_completely_positive","title":"is_completely_positive","text":"<p>Determines if a channel is completely positive.</p>"},{"location":"reference/toqito/channel_props/is_completely_positive/#toqito.channel_props.is_completely_positive.is_completely_positive","title":"is_completely_positive","text":"<pre><code>is_completely_positive(phi: ndarray | list[list[ndarray]], rtol: float = 1e-05, atol: float = 1e-08) -&gt; bool\n</code></pre> <p>Determine whether the given channel is completely positive.</p> <p>(Section: Linear Maps Of Square Operators from <sup>1</sup>).</p> <p>A map \\(\\Phi \\in \\text{T} \\left(\\mathcal{X}, \\mathcal{Y} \\right)\\) is completely positive if it holds that</p> \\[     \\Phi \\otimes \\mathbb{I}_{\\text{L}(\\mathcal{Z})} \\] <p>is a positive map for every complex Euclidean space \\(\\mathcal{Z}\\).</p> <p>Alternatively, a channel is completely positive if the corresponding Choi matrix of the channel is both Hermitian-preserving and positive semidefinite.</p> <p>Examples:</p> <p>We can specify the input as a list of Kraus operators. Consider the map \\(\\Phi\\) defined as</p> \\[     \\Phi(X) = X - U X U^* \\] <p>where</p> \\[     U = \\frac{1}{\\sqrt{2}}     \\begin{pmatrix}         1 &amp; 1 \\\\         -1 &amp; 1     \\end{pmatrix}. \\] <p>This map is not completely positive, as we can verify as follows.</p> <pre><code>import numpy as np\nfrom toqito.channel_props import is_completely_positive\n\nunitary_mat = np.array([[1, 1], [-1, 1]]) / np.sqrt(2)\nkraus_ops = [[np.identity(2), np.identity(2)], [unitary_mat, -unitary_mat]]\n\nprint(is_completely_positive(kraus_ops))\n</code></pre> <p>False</p> <p>We can also specify the input as a Choi matrix. For instance, consider the Choi matrix corresponding to the \\(2\\)-dimensional completely depolarizing channel</p> \\[     \\Omega =     \\frac{1}{2}     \\begin{pmatrix}         1 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 1 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 1 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 1     \\end{pmatrix}. \\] <p>We may verify that this channel is completely positive</p> <pre><code>from toqito.channels import depolarizing\nfrom toqito.channel_props import is_completely_positive\n\nprint(is_completely_positive(depolarizing(2)))\n</code></pre> <p>True</p> <p>Parameters:</p> <ul> <li> <code>phi</code>               (<code>ndarray | list[list[ndarray]]</code>)           \u2013            <p>The channel provided as either a Choi matrix or a list of Kraus operators.</p> </li> <li> <code>rtol</code>               (<code>float</code>, default:                   <code>1e-05</code> )           \u2013            <p>The relative tolerance parameter (default 1e-05).</p> </li> <li> <code>atol</code>               (<code>float</code>, default:                   <code>1e-08</code> )           \u2013            <p>The absolute tolerance parameter (default 1e-08).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the channel is completely positive, and False otherwise.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Watrous, John. The Theory of Quantum Information. (2018). doi:10.1017/9781316848142.</p> Source code in <code>toqito/channel_props/is_completely_positive.py</code> <pre><code>def is_completely_positive(\n    phi: np.ndarray | list[list[np.ndarray]],\n    rtol: float = 1e-05,\n    atol: float = 1e-08,\n) -&gt; bool:\n    r\"\"\"Determine whether the given channel is completely positive.\n\n    (Section: Linear Maps Of Square Operators from [@Watrous_2018_TQI]).\n\n    A map \\(\\Phi \\in \\text{T} \\left(\\mathcal{X}, \\mathcal{Y} \\right)\\) is *completely\n    positive* if it holds that\n\n    \\[\n        \\Phi \\otimes \\mathbb{I}_{\\text{L}(\\mathcal{Z})}\n    \\]\n\n    is a positive map for every complex Euclidean space \\(\\mathcal{Z}\\).\n\n    Alternatively, a channel is completely positive if the corresponding Choi matrix of the\n    channel is both Hermitian-preserving and positive semidefinite.\n\n    Examples:\n        We can specify the input as a list of Kraus operators. Consider the map \\(\\Phi\\) defined as\n\n        \\[\n            \\Phi(X) = X - U X U^*\n        \\]\n\n        where\n\n        \\[\n            U = \\frac{1}{\\sqrt{2}}\n            \\begin{pmatrix}\n                1 &amp; 1 \\\\\n                -1 &amp; 1\n            \\end{pmatrix}.\n        \\]\n\n        This map is not completely positive, as we can verify as follows.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.channel_props import is_completely_positive\n\n        unitary_mat = np.array([[1, 1], [-1, 1]]) / np.sqrt(2)\n        kraus_ops = [[np.identity(2), np.identity(2)], [unitary_mat, -unitary_mat]]\n\n        print(is_completely_positive(kraus_ops))\n        ```\n\n        We can also specify the input as a Choi matrix. For instance, consider the Choi matrix\n        corresponding to the \\(2\\)-dimensional completely depolarizing channel\n\n        \\[\n            \\Omega =\n            \\frac{1}{2}\n            \\begin{pmatrix}\n                1 &amp; 0 &amp; 0 &amp; 0 \\\\\n                0 &amp; 1 &amp; 0 &amp; 0 \\\\\n                0 &amp; 0 &amp; 1 &amp; 0 \\\\\n                0 &amp; 0 &amp; 0 &amp; 1\n            \\end{pmatrix}.\n        \\]\n\n        We may verify that this channel is completely positive\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.channels import depolarizing\n        from toqito.channel_props import is_completely_positive\n\n        print(is_completely_positive(depolarizing(2)))\n        ```\n\n    Args:\n        phi: The channel provided as either a Choi matrix or a list of Kraus operators.\n        rtol: The relative tolerance parameter (default 1e-05).\n        atol: The absolute tolerance parameter (default 1e-08).\n\n    Returns:\n        True if the channel is completely positive, and False otherwise.\n\n    \"\"\"\n    # If the variable `phi` is provided as a list, we assume this is a list\n    # of Kraus operators.\n    if isinstance(phi, list):\n        phi = kraus_to_choi(phi)\n\n    # Use Choi's theorem to determine whether `phi` is completely positive.\n    return is_herm_preserving(phi, rtol, atol) and is_positive_semidefinite(phi, rtol, atol)\n</code></pre>"},{"location":"reference/toqito/channel_props/is_extremal/","title":"is_extremal","text":""},{"location":"reference/toqito/channel_props/is_extremal/#toqito.channel_props.is_extremal","title":"is_extremal","text":"<p>Determines whether a quantum channel is extremal.</p>"},{"location":"reference/toqito/channel_props/is_extremal/#toqito.channel_props.is_extremal.is_extremal","title":"is_extremal","text":"<pre><code>is_extremal(phi: ndarray | list[ndarray | list[ndarray]], tol: float = 1e-09) -&gt; bool\n</code></pre> <p>Determine whether a quantum channel is extremal.</p> <p>(Section 2.2.4: Extremal Channels from <sup>1</sup>).</p> <p>Theorem 2.31 in <sup>1</sup> provides the characterization of extremal quantum channels as a channel \\(\\Phi\\) is an extreme point of the convex set of quantum channels if and only if the collection:</p> \\[     \\{ A_i^\\dagger A_j \\}_{i,j=1}^{r} \\] <p>is linearly independent.</p> <p>The channel can be provided in one of the following representations:</p> <ul> <li>A Choi matrix, representing the quantum channel in the Choi representation. It will   be converted internally to a set of Kraus operators.</li> <li>A list of Kraus operators, representing the channel in Kraus form.</li> <li>A nested list of Kraus operators, which will be flattened automatically.</li> </ul> <p>Examples:</p> <p>The following demonstrates an example of an extremal quantum channel from Example 2.33 in <sup>1</sup>.</p> <pre><code>import numpy as np\nfrom toqito.channel_props import is_extremal\nkraus_ops = [\n    (1 / np.sqrt(6)) * np.array([[2, 0], [0, 1], [0, 1], [0, 0]]),\n    (1 / np.sqrt(6)) * np.array([[0, 0], [1, 0], [1, 0], [0, 2]])\n]\n\nprint(is_extremal(kraus_ops))\n</code></pre> <p>True</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the input is neither a valid list of Kraus operators nor a Choi matrix.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>phi</code>               (<code>ndarray | list[ndarray | list[ndarray]]</code>)           \u2013            <p>The quantum channel, which may be given as a Choi matrix or a list of Kraus operators.</p> </li> <li> <code>tol</code>               (<code>float</code>, default:                   <code>1e-09</code> )           \u2013            <p>Tolerance value for numerical precision in rank computation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the channel is extremal; False otherwise.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Watrous, John. The Theory of Quantum Information. (2018). doi:10.1017/9781316848142.</p> Source code in <code>toqito/channel_props/is_extremal.py</code> <pre><code>def is_extremal(phi: np.ndarray | list[np.ndarray | list[np.ndarray]], tol: float = 1e-9) -&gt; bool:\n    r\"\"\"Determine whether a quantum channel is extremal.\n\n    (Section 2.2.4: Extremal Channels from [@Watrous_2018_TQI]).\n\n    Theorem 2.31 in [@Watrous_2018_TQI] provides the characterization of extremal\n    quantum channels as a channel \\(\\Phi\\) is an extreme point of the convex set\n    of quantum channels if and only if the collection:\n\n    \\[\n        \\{ A_i^\\dagger A_j \\}_{i,j=1}^{r}\n    \\]\n\n    is linearly independent.\n\n    The channel can be provided in one of the following representations:\n\n    - A Choi matrix, representing the quantum channel in the Choi representation. It will\n      be converted internally to a set of Kraus operators.\n    - A list of Kraus operators, representing the channel in Kraus form.\n    - A nested list of Kraus operators, which will be flattened automatically.\n\n    Examples:\n        The following demonstrates an example of an extremal quantum channel from Example 2.33\n        in [@Watrous_2018_TQI].\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.channel_props import is_extremal\n        kraus_ops = [\n            (1 / np.sqrt(6)) * np.array([[2, 0], [0, 1], [0, 1], [0, 0]]),\n            (1 / np.sqrt(6)) * np.array([[0, 0], [1, 0], [1, 0], [0, 2]])\n        ]\n\n        print(is_extremal(kraus_ops))\n        ```\n\n    Raises:\n        ValueError: If the input is neither a valid list of Kraus operators nor a Choi matrix.\n\n    Args:\n        phi: The quantum channel, which may be given as a Choi matrix or a list of Kraus operators.\n        tol: Tolerance value for numerical precision in rank computation.\n\n    Returns:\n        True if the channel is extremal; False otherwise.\n\n    \"\"\"\n    # If input is a Choi matrix, convert to a (flat) list of Kraus operators.\n    if isinstance(phi, np.ndarray):\n        kraus_ops = choi_to_kraus(phi)\n    elif isinstance(phi, list):\n        # If the first element is a list, assume nested list of Kraus operators.\n        if len(phi) == 0:\n            raise ValueError(\"The channel must contain at least one Kraus operator.\")\n        if isinstance(phi[0], list):\n            # Flatten the nested list.\n            kraus_ops = [op for sublist in phi for op in sublist if isinstance(op, np.ndarray)]\n        elif all(isinstance(op, np.ndarray) for op in phi):\n            kraus_ops = phi\n        else:\n            raise ValueError(\"Channel must be a list (or nested list) of Kraus operators.\")\n    else:\n        raise ValueError(\"Channel must be a list of Kraus operators or a Choi matrix.\")\n\n    # Check that we have at least one Kraus operator.\n    if not kraus_ops:\n        raise ValueError(\"The channel must contain at least one Kraus operator.\")\n\n    r = len(kraus_ops)\n\n    # A single Kraus operator (e.g., a unitary channel) is always extremal.\n    if r == 1:\n        return True\n\n    # Compute the set {A_i^\u2020 A_j} for every pair (i, j).\n    flattened_products = [np.dot(A.conj().T, B).flatten() for A in kraus_ops for B in kraus_ops]\n\n    # Form a matrix whose columns are these vectorized operators.\n    M = np.column_stack(flattened_products)\n\n    # The channel is extremal if and only if the operators {A_i^\u2020 A_j} are linearly independent,\n    # i.e. the rank of M equals r^2.\n    return bool(matrix_rank(M, tol=tol) == r * r)\n</code></pre>"},{"location":"reference/toqito/channel_props/is_herm_preserving/","title":"is_herm_preserving","text":""},{"location":"reference/toqito/channel_props/is_herm_preserving/#toqito.channel_props.is_herm_preserving","title":"is_herm_preserving","text":"<p>Determines if a channel is Hermiticity-preserving.</p>"},{"location":"reference/toqito/channel_props/is_herm_preserving/#toqito.channel_props.is_herm_preserving.is_herm_preserving","title":"is_herm_preserving","text":"<pre><code>is_herm_preserving(phi: ndarray | list[list[ndarray]], rtol: float = 1e-05, atol: float = 1e-08) -&gt; bool\n</code></pre> <p>Determine whether the given channel is Hermitian-preserving.</p> <p>(Section: Linear Maps Of Square Operators from <sup>1</sup>).</p> <p>A map \\(\\Phi \\in \\text{T} \\left(\\mathcal{X}, \\mathcal{Y} \\right)\\) is Hermitian-preserving if it holds that</p> \\[     \\Phi(H) \\in \\text{Herm}(\\mathcal{Y}) \\] <p>for every Hermitian operator \\(H \\in \\text{Herm}(\\mathcal{X})\\).</p> <p>Examples:</p> <p>The map \\(\\Phi\\) defined as</p> \\[     \\Phi(X) = X - U X U^* \\] <p>is Hermitian-preserving, where</p> \\[     U = \\frac{1}{\\sqrt{2}}     \\begin{pmatrix}         1 &amp; 1 \\\\         -1 &amp; 1     \\end{pmatrix}. \\] <pre><code>import numpy as np\nfrom toqito.channel_props import is_herm_preserving\n\nunitary_mat = np.array([[1, 1], [-1, 1]]) / np.sqrt(2)\nkraus_ops = [[np.identity(2), np.identity(2)], [unitary_mat, -unitary_mat]]\n\nprint(is_herm_preserving(kraus_ops))\n</code></pre> <p>True</p> <p>We may also verify whether the corresponding Choi matrix of a given map is Hermitian-preserving. The swap operator is the Choi matrix of the transpose map, which is Hermitian-preserving as can be seen as follows:</p> <pre><code>import numpy as np\nfrom toqito.perms import swap_operator\nfrom toqito.channel_props import is_herm_preserving\n\nunitary_mat = np.array([[1, 1], [-1, 1]]) / np.sqrt(2)\nchoi_mat = swap_operator(3)\n\nprint(is_herm_preserving(choi_mat))\n</code></pre> <p>True</p> <p>Parameters:</p> <ul> <li> <code>phi</code>               (<code>ndarray | list[list[ndarray]]</code>)           \u2013            <p>The channel provided as either a Choi matrix or a list of Kraus operators.</p> </li> <li> <code>rtol</code>               (<code>float</code>, default:                   <code>1e-05</code> )           \u2013            <p>The relative tolerance parameter (default 1e-05).</p> </li> <li> <code>atol</code>               (<code>float</code>, default:                   <code>1e-08</code> )           \u2013            <p>The absolute tolerance parameter (default 1e-08).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the channel is Hermitian-preserving, and False otherwise.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Watrous, John. The Theory of Quantum Information. (2018). doi:10.1017/9781316848142.</p> Source code in <code>toqito/channel_props/is_herm_preserving.py</code> <pre><code>def is_herm_preserving(\n    phi: np.ndarray | list[list[np.ndarray]],\n    rtol: float = 1e-05,\n    atol: float = 1e-08,\n) -&gt; bool:\n    r\"\"\"Determine whether the given channel is Hermitian-preserving.\n\n    (Section: Linear Maps Of Square Operators from [@Watrous_2018_TQI]).\n\n    A map \\(\\Phi \\in \\text{T} \\left(\\mathcal{X}, \\mathcal{Y} \\right)\\) is\n    *Hermitian-preserving* if it holds that\n\n    \\[\n        \\Phi(H) \\in \\text{Herm}(\\mathcal{Y})\n    \\]\n\n    for every Hermitian operator \\(H \\in \\text{Herm}(\\mathcal{X})\\).\n\n    Examples:\n        The map \\(\\Phi\\) defined as\n\n        \\[\n            \\Phi(X) = X - U X U^*\n        \\]\n\n        is Hermitian-preserving, where\n\n        \\[\n            U = \\frac{1}{\\sqrt{2}}\n            \\begin{pmatrix}\n                1 &amp; 1 \\\\\n                -1 &amp; 1\n            \\end{pmatrix}.\n        \\]\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.channel_props import is_herm_preserving\n\n        unitary_mat = np.array([[1, 1], [-1, 1]]) / np.sqrt(2)\n        kraus_ops = [[np.identity(2), np.identity(2)], [unitary_mat, -unitary_mat]]\n\n        print(is_herm_preserving(kraus_ops))\n        ```\n\n\n        We may also verify whether the corresponding Choi matrix of a given map is\n        Hermitian-preserving. The swap operator is the Choi matrix of the transpose map, which is\n        Hermitian-preserving as can be seen as follows:\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.perms import swap_operator\n        from toqito.channel_props import is_herm_preserving\n\n        unitary_mat = np.array([[1, 1], [-1, 1]]) / np.sqrt(2)\n        choi_mat = swap_operator(3)\n\n        print(is_herm_preserving(choi_mat))\n        ```\n\n    Args:\n        phi: The channel provided as either a Choi matrix or a list of Kraus operators.\n        rtol: The relative tolerance parameter (default 1e-05).\n        atol: The absolute tolerance parameter (default 1e-08).\n\n    Returns:\n        True if the channel is Hermitian-preserving, and False otherwise.\n\n    \"\"\"\n    # If the variable `phi` is provided as a list, we assume this is a list\n    # of Kraus operators.\n    if isinstance(phi, list):\n        phi = kraus_to_choi(phi)\n\n    # Phi is Hermiticity-preserving if and only if its Choi matrix is Hermitian.\n    if phi.shape[0] != phi.shape[1]:\n        return False\n    return is_hermitian(phi, rtol=rtol, atol=atol)\n</code></pre>"},{"location":"reference/toqito/channel_props/is_positive/","title":"is_positive","text":""},{"location":"reference/toqito/channel_props/is_positive/#toqito.channel_props.is_positive","title":"is_positive","text":"<p>Determines if a channel is positive.</p>"},{"location":"reference/toqito/channel_props/is_positive/#toqito.channel_props.is_positive.is_positive","title":"is_positive","text":"<pre><code>is_positive(phi: ndarray | list[list[ndarray]], rtol: float = 1e-05, atol: float = 1e-08) -&gt; bool\n</code></pre> <p>Determine whether the given channel is positive.</p> <p>(Section: Linear Maps Of Square Operators from <sup>1</sup>).</p> <p>A map \\(\\Phi \\in \\text{T} \\left(\\mathcal{X}, \\mathcal{Y} \\right)\\) is positive if it holds that</p> \\[     \\Phi(P) \\in \\text{Pos}(\\mathcal{Y}) \\] <p>for every positive semidefinite operator \\(P \\in \\text{Pos}(\\mathcal{X})\\).</p> <p>Alternatively, a channel is positive if the corresponding Choi matrix of the channel is both Hermitian-preserving and positive semidefinite.</p> <p>Examples:</p> <p>We can specify the input as a list of Kraus operators. Consider the map \\(\\Phi\\) defined as</p> \\[     \\Phi(X) = X - U X U^* \\] <p>where</p> \\[     U = \\frac{1}{\\sqrt{2}}     \\begin{pmatrix}         1 &amp; 1 \\\\         -1 &amp; -1     \\end{pmatrix}. \\] <p>This map is not completely positive, as we can verify as follows.</p> <pre><code>import numpy as np\nfrom toqito.channel_props import is_positive\n\nunitary_mat = np.array([[1, 1], [-1, -1]]) / np.sqrt(2)\nkraus_ops = [[np.identity(2), np.identity(2)], [unitary_mat, -unitary_mat]]\n\nprint(is_positive(kraus_ops))\n</code></pre> <p>False</p> <p>We can also specify the input as a Choi matrix. For instance, consider the Choi matrix corresponding to the \\(4\\)-dimensional completely depolarizing channel and may verify that this channel is positive.</p> <pre><code>from toqito.channels import depolarizing\nfrom toqito.channel_props import is_positive\n\nprint(is_positive(depolarizing(4)))\n</code></pre> <p>True</p> <p>Parameters:</p> <ul> <li> <code>phi</code>               (<code>ndarray | list[list[ndarray]]</code>)           \u2013            <p>The channel provided as either a Choi matrix or a list of Kraus operators.</p> </li> <li> <code>rtol</code>               (<code>float</code>, default:                   <code>1e-05</code> )           \u2013            <p>The relative tolerance parameter (default 1e-05).</p> </li> <li> <code>atol</code>               (<code>float</code>, default:                   <code>1e-08</code> )           \u2013            <p>The absolute tolerance parameter (default 1e-08).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the channel is positive, and False otherwise.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Watrous, John. The Theory of Quantum Information. (2018). doi:10.1017/9781316848142.</p> Source code in <code>toqito/channel_props/is_positive.py</code> <pre><code>def is_positive(\n    phi: np.ndarray | list[list[np.ndarray]],\n    rtol: float = 1e-05,\n    atol: float = 1e-08,\n) -&gt; bool:\n    r\"\"\"Determine whether the given channel is positive.\n\n    (Section: Linear Maps Of Square Operators from [@Watrous_2018_TQI]).\n\n    A map \\(\\Phi \\in \\text{T} \\left(\\mathcal{X}, \\mathcal{Y} \\right)\\) is *positive* if it\n    holds that\n\n    \\[\n        \\Phi(P) \\in \\text{Pos}(\\mathcal{Y})\n    \\]\n\n    for every positive semidefinite operator \\(P \\in \\text{Pos}(\\mathcal{X})\\).\n\n    Alternatively, a channel is positive if the corresponding Choi matrix of the channel is both\n    Hermitian-preserving and positive semidefinite.\n\n    Examples:\n        We can specify the input as a list of Kraus operators. Consider the map \\(\\Phi\\) defined as\n\n        \\[\n            \\Phi(X) = X - U X U^*\n        \\]\n\n        where\n\n        \\[\n            U = \\frac{1}{\\sqrt{2}}\n            \\begin{pmatrix}\n                1 &amp; 1 \\\\\n                -1 &amp; -1\n            \\end{pmatrix}.\n        \\]\n\n        This map is not completely positive, as we can verify as follows.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.channel_props import is_positive\n\n        unitary_mat = np.array([[1, 1], [-1, -1]]) / np.sqrt(2)\n        kraus_ops = [[np.identity(2), np.identity(2)], [unitary_mat, -unitary_mat]]\n\n        print(is_positive(kraus_ops))\n        ```\n\n        We can also specify the input as a Choi matrix. For instance, consider the Choi matrix\n        corresponding to the \\(4\\)-dimensional completely depolarizing channel and may verify\n        that this channel is positive.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.channels import depolarizing\n        from toqito.channel_props import is_positive\n\n        print(is_positive(depolarizing(4)))\n        ```\n\n    Args:\n        phi: The channel provided as either a Choi matrix or a list of Kraus operators.\n        rtol: The relative tolerance parameter (default 1e-05).\n        atol: The absolute tolerance parameter (default 1e-08).\n\n    Returns:\n        True if the channel is positive, and False otherwise.\n\n    \"\"\"\n    # If the variable `phi` is provided as a list, we assume this is a list\n    # of Kraus operators.\n    if isinstance(phi, list):\n        phi = kraus_to_choi(phi)\n    return is_positive_semidefinite(phi, rtol, atol)\n</code></pre>"},{"location":"reference/toqito/channel_props/is_quantum_channel/","title":"is_quantum_channel","text":""},{"location":"reference/toqito/channel_props/is_quantum_channel/#toqito.channel_props.is_quantum_channel","title":"is_quantum_channel","text":"<p>Determines if an input is a quantum channel.</p>"},{"location":"reference/toqito/channel_props/is_quantum_channel/#toqito.channel_props.is_quantum_channel.is_quantum_channel","title":"is_quantum_channel","text":"<pre><code>is_quantum_channel(phi: ndarray | list[list[ndarray]], rtol: float = 1e-05, atol: float = 1e-08) -&gt; bool\n</code></pre> <p>Determine whether the given input is a quantum channel.</p> <p>For more info, see Section 2.2.1: Definitions and Basic Notions Concerning Channels from <sup>1</sup>.</p> <p>A map \\(\\Phi \\in \\text{T} \\left(\\mathcal{X}, \\mathcal{Y} \\right)\\) is a quantum channel for some choice of complex Euclidean spaces \\(\\mathcal{X}\\) and \\(\\mathcal{Y}\\), if it holds that:</p> <ol> <li>\\(\\Phi\\) is completely positive.</li> <li>\\(\\Phi\\) is trace preserving.</li> </ol> <p>Examples:</p> <p>We can specify the input as a list of Kraus operators. Consider the map \\(\\Phi\\) defined as</p> \\[     \\Phi(X) = X - U X U^* \\] <p>where</p> \\[     U = \\frac{1}{\\sqrt{2}}     \\begin{pmatrix}         1 &amp; 1 \\\\         -1 &amp; 1     \\end{pmatrix}. \\] <p>To check if this is a valid quantum channel or not,</p> <pre><code>import numpy as np\nfrom toqito.matrices import pauli\nfrom toqito.channel_props import is_quantum_channel\n\nU = (1/np.sqrt(2))*np.array([[1, 1],[-1, 1]])\nX = pauli(\"X\")\nphi = X - np.matmul(U, np.matmul(X, np.conjugate(U)))\n\nprint(is_quantum_channel(phi))\n</code></pre> <p>False</p> <p>If we instead check for the validity of depolarizing channel being a valid quantum channel,</p> <pre><code>from toqito.channels import depolarizing\nfrom toqito.channel_props import is_quantum_channel\n\nchoi_depolarizing = depolarizing(dim=2, param_p=0.2)\n\nprint(is_quantum_channel(choi_depolarizing))\n</code></pre> <p>True</p> <p>Parameters:</p> <ul> <li> <code>phi</code>               (<code>ndarray | list[list[ndarray]]</code>)           \u2013            <p>The channel provided as either a Choi matrix or a list of Kraus operators.</p> </li> <li> <code>rtol</code>               (<code>float</code>, default:                   <code>1e-05</code> )           \u2013            <p>The relative tolerance parameter (default 1e-05).</p> </li> <li> <code>atol</code>               (<code>float</code>, default:                   <code>1e-08</code> )           \u2013            <p>The absolute tolerance parameter (default 1e-08).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if the channel is a quantum channel, and <code>False</code> otherwise.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Watrous, John. The Theory of Quantum Information. (2018). doi:10.1017/9781316848142.</p> Source code in <code>toqito/channel_props/is_quantum_channel.py</code> <pre><code>def is_quantum_channel(\n    phi: np.ndarray | list[list[np.ndarray]],\n    rtol: float = 1e-05,\n    atol: float = 1e-08,\n) -&gt; bool:\n    r\"\"\"Determine whether the given input is a quantum channel.\n\n    For more info, see Section 2.2.1: Definitions and Basic Notions Concerning Channels from\n    [@Watrous_2018_TQI].\n\n    A map \\(\\Phi \\in \\text{T} \\left(\\mathcal{X}, \\mathcal{Y} \\right)\\) is a *quantum\n    channel* for some choice of complex Euclidean spaces \\(\\mathcal{X}\\)\n    and \\(\\mathcal{Y}\\), if it holds that:\n\n    1. \\(\\Phi\\) is completely positive.\n    2. \\(\\Phi\\) is trace preserving.\n\n    Examples:\n        We can specify the input as a list of Kraus operators. Consider the map \\(\\Phi\\) defined as\n\n        \\[\n            \\Phi(X) = X - U X U^*\n        \\]\n\n        where\n\n        \\[\n            U = \\frac{1}{\\sqrt{2}}\n            \\begin{pmatrix}\n                1 &amp; 1 \\\\\n                -1 &amp; 1\n            \\end{pmatrix}.\n        \\]\n\n        To check if this is a valid quantum channel or not,\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrices import pauli\n        from toqito.channel_props import is_quantum_channel\n\n        U = (1/np.sqrt(2))*np.array([[1, 1],[-1, 1]])\n        X = pauli(\"X\")\n        phi = X - np.matmul(U, np.matmul(X, np.conjugate(U)))\n\n        print(is_quantum_channel(phi))\n        ```\n\n        If we instead check for the validity of depolarizing channel being a valid quantum channel,\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.channels import depolarizing\n        from toqito.channel_props import is_quantum_channel\n\n        choi_depolarizing = depolarizing(dim=2, param_p=0.2)\n\n        print(is_quantum_channel(choi_depolarizing))\n        ```\n\n    Args:\n        phi: The channel provided as either a Choi matrix or a list of Kraus operators.\n        rtol: The relative tolerance parameter (default 1e-05).\n        atol: The absolute tolerance parameter (default 1e-08).\n\n    Returns:\n        `True` if the channel is a quantum channel, and `False` otherwise.\n\n    \"\"\"\n    # If the variable `phi` is provided as a list, we assume this is a list\n    # of Kraus operators.\n    if not (\n        isinstance(phi, np.ndarray)\n        or (\n            isinstance(phi, list)\n            and all(isinstance(row, list) and all(isinstance(op, np.ndarray) for op in row) for row in phi)\n        )\n    ):\n        raise TypeError(\n            \"phi must be either a numpy array (Choi matrix) or a list of lists of numpy arrays (Kraus operators).\"\n        )\n    if isinstance(phi, list):\n        phi = kraus_to_choi(phi)\n\n    # A valid quantum channel is a superoperator that is both completely\n    # positive and trace-preserving.\n    try:\n        return is_completely_positive(phi, rtol, atol) and is_trace_preserving(phi, rtol, atol)\n    except Exception:\n        return False\n</code></pre>"},{"location":"reference/toqito/channel_props/is_trace_preserving/","title":"is_trace_preserving","text":""},{"location":"reference/toqito/channel_props/is_trace_preserving/#toqito.channel_props.is_trace_preserving","title":"is_trace_preserving","text":"<p>Determines if a channel is trace-preserving.</p>"},{"location":"reference/toqito/channel_props/is_trace_preserving/#toqito.channel_props.is_trace_preserving.is_trace_preserving","title":"is_trace_preserving","text":"<pre><code>is_trace_preserving(phi: ndarray | list[list[ndarray]], rtol: float = 1e-05, atol: float = 1e-08, sys: int | list[int] = 2, dim: list[int] | ndarray | None = None) -&gt; bool\n</code></pre> <p>Determine whether the given channel is trace-preserving.</p> <p>A map \\(\\Phi \\in \\text{T} \\left(\\mathcal{X}, \\mathcal{Y} \\right)\\) is trace-preserving if it holds that</p> \\[     \\text{Tr} \\left( \\Phi(X) \\right) = \\text{Tr}\\left( X \\right) \\] <p>for every operator \\(X \\in \\text{L}(\\mathcal{X})\\).</p> <p>Given the corresponding Choi matrix of the channel, a neccessary and sufficient condition is</p> \\[     \\text{Tr}_{\\mathcal{Y}} \\left( J(\\Phi) \\right) = \\mathbb{I}_{\\mathcal{X}} \\] <p>In case <code>sys</code> is not specified, the default convention is that the Choi matrix is the result of applying the map to the second subsystem of the standard maximally entangled (unnormalized) state.</p> <p>The dimensions of the subsystems are given by the vector <code>dim</code>. By default, both subsystems have equal dimension.</p> <p>Alternatively, given a list of Kraus operators, a neccessary and sufficient condition is</p> \\[     \\sum_{a \\in \\Sigma} A_a^* B_a = \\mathbb{I}_{\\mathcal{X}} \\] <p>Examples:</p> <p>The map \\(\\Phi\\) defined as</p> \\[     \\Phi(X) = X - U X U^* \\] <p>is not trace-preserving, where</p> \\[     U = \\frac{1}{\\sqrt{2}}     \\begin{pmatrix}         1 &amp; 1 \\\\         -1 &amp; 1     \\end{pmatrix}. \\] <pre><code>import numpy as np\nfrom toqito.channel_props import is_trace_preserving\n\nunitary_mat = np.array([[1, 1], [-1, 1]]) / np.sqrt(2)\nkraus_ops = [[np.identity(2), np.identity(2)], [unitary_mat, -unitary_mat]]\n\nprint(is_trace_preserving(kraus_ops))\n</code></pre> <p>False</p> <p>As another example, the depolarizing channel is trace-preserving.</p> <pre><code>from toqito.channels import depolarizing\nfrom toqito.channel_props import is_trace_preserving\n\nchoi_mat = depolarizing(2)\n\nprint(is_trace_preserving(choi_mat))\n</code></pre> <p>True</p> <p>Further information for determining the trace preserving properties of channels consult (Section: Linear Maps Of Square Operators from <sup>1</sup>).</p> <p>Parameters:</p> <ul> <li> <code>phi</code>               (<code>ndarray | list[list[ndarray]]</code>)           \u2013            <p>The channel provided as either a Choi matrix or a list of Kraus operators.</p> </li> <li> <code>rtol</code>               (<code>float</code>, default:                   <code>1e-05</code> )           \u2013            <p>The relative tolerance parameter (default 1e-05).</p> </li> <li> <code>atol</code>               (<code>float</code>, default:                   <code>1e-08</code> )           \u2013            <p>The absolute tolerance parameter (default 1e-08).</p> </li> <li> <code>sys</code>               (<code>int | list[int]</code>, default:                   <code>2</code> )           \u2013            <p>Scalar or vector specifying the size of the subsystems.</p> </li> <li> <code>dim</code>               (<code>list[int] | ndarray | None</code>, default:                   <code>None</code> )           \u2013            <p>Dimension of the subsystems. If <code>None</code>, all dimensions are assumed to be equal.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the channel is trace-preserving, and False otherwise.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Watrous, John. The Theory of Quantum Information. (2018). doi:10.1017/9781316848142.</p> Source code in <code>toqito/channel_props/is_trace_preserving.py</code> <pre><code>def is_trace_preserving(\n    phi: np.ndarray | list[list[np.ndarray]],\n    rtol: float = 1e-05,\n    atol: float = 1e-08,\n    sys: int | list[int] = 2,\n    dim: list[int] | np.ndarray | None = None,\n) -&gt; bool:\n    r\"\"\"Determine whether the given channel is trace-preserving.\n\n    A map \\(\\Phi \\in \\text{T} \\left(\\mathcal{X}, \\mathcal{Y} \\right)\\) is\n    *trace-preserving* if it holds that\n\n    \\[\n        \\text{Tr} \\left( \\Phi(X) \\right) = \\text{Tr}\\left( X \\right)\n    \\]\n\n    for every operator \\(X \\in \\text{L}(\\mathcal{X})\\).\n\n    Given the corresponding Choi matrix of the channel, a neccessary and sufficient condition is\n\n    \\[\n        \\text{Tr}_{\\mathcal{Y}} \\left( J(\\Phi) \\right) = \\mathbb{I}_{\\mathcal{X}}\n    \\]\n\n    In case `sys` is not specified, the default convention is that the Choi matrix\n    is the result of applying the map to the second subsystem of the standard maximally\n    entangled (unnormalized) state.\n\n    The dimensions of the subsystems are given by the vector `dim`. By default,\n    both subsystems have equal dimension.\n\n    Alternatively, given a list of Kraus operators, a neccessary and sufficient condition is\n\n    \\[\n        \\sum_{a \\in \\Sigma} A_a^* B_a = \\mathbb{I}_{\\mathcal{X}}\n    \\]\n\n    Examples:\n        The map \\(\\Phi\\) defined as\n\n        \\[\n            \\Phi(X) = X - U X U^*\n        \\]\n\n        is not trace-preserving, where\n\n        \\[\n            U = \\frac{1}{\\sqrt{2}}\n            \\begin{pmatrix}\n                1 &amp; 1 \\\\\n                -1 &amp; 1\n            \\end{pmatrix}.\n        \\]\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.channel_props import is_trace_preserving\n\n        unitary_mat = np.array([[1, 1], [-1, 1]]) / np.sqrt(2)\n        kraus_ops = [[np.identity(2), np.identity(2)], [unitary_mat, -unitary_mat]]\n\n        print(is_trace_preserving(kraus_ops))\n        ```\n\n        As another example, the depolarizing channel is trace-preserving.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.channels import depolarizing\n        from toqito.channel_props import is_trace_preserving\n\n        choi_mat = depolarizing(2)\n\n        print(is_trace_preserving(choi_mat))\n        ```\n\n        Further information for determining the trace preserving properties of channels consult (Section: Linear Maps Of\n        Square Operators from [@Watrous_2018_TQI]).\n\n    Args:\n        phi: The channel provided as either a Choi matrix or a list of Kraus operators.\n        rtol: The relative tolerance parameter (default 1e-05).\n        atol: The absolute tolerance parameter (default 1e-08).\n        sys: Scalar or vector specifying the size of the subsystems.\n        dim: Dimension of the subsystems. If `None`, all dimensions are assumed to be equal.\n\n    Returns:\n        True if the channel is trace-preserving, and False otherwise.\n\n    \"\"\"\n    # If the variable `phi` is provided as a list, we assume this is a list\n    # of Kraus operators.\n    if isinstance(phi, list):\n        phi_l = [A for A, _ in phi]\n        phi_r = [B for _, B in phi]\n\n        k_l = np.concatenate(phi_l, axis=0)\n        k_r = np.concatenate(phi_r, axis=0)\n\n        mat = k_l.conj().T @ k_r\n    else:\n        if dim is None:\n            n = phi.shape[0]\n            d = int(round(np.sqrt(n)))\n            if d * d != n:\n                raise ValueError(\"Cannot infer equal subsystem dimensions. Please provide `dim`.\")\n            dim = [d, d]\n        mat = partial_trace(phi, [sys - 1], dim)\n    return is_identity(np.array(mat), rtol=rtol, atol=atol)\n</code></pre>"},{"location":"reference/toqito/channel_props/is_unital/","title":"is_unital","text":""},{"location":"reference/toqito/channel_props/is_unital/#toqito.channel_props.is_unital","title":"is_unital","text":"<p>Determines if a channel is unital.</p>"},{"location":"reference/toqito/channel_props/is_unital/#toqito.channel_props.is_unital.is_unital","title":"is_unital","text":"<pre><code>is_unital(phi: ndarray | list[list[ndarray]], rtol: float = 1e-05, atol: float = 1e-08, dim: int | list[int] | ndarray | None = None) -&gt; bool\n</code></pre> <p>Determine whether the given channel is unital.</p> <p>A map \\(\\Phi \\in \\text{T} \\left(\\mathcal{X}, \\mathcal{Y} \\right)\\) is unital if it holds that:</p> \\[     \\Phi(\\mathbb{I}_{\\mathcal{X}}) = \\mathbb{I}_{\\mathcal{Y}}. \\] <p>If the input channel maps \\(M_{r,c}\\) to \\(M_{x,y}\\) then <code>dim</code> should be the list <code>[[r,x], [c,y]]</code>. If it maps \\(M_m\\) to \\(M_n\\), then <code>dim</code> can simply be the vector <code>[m,n]</code>.</p> <p>More information can be found in Chapter: Unital Channels And Majorization from <sup>1</sup>).</p> <p>Examples:</p> <p>Consider the channel whose Choi matrix is the swap operator. This channel is an example of a unital channel.</p> <pre><code>from toqito.perms import swap_operator\nfrom toqito.channel_props import is_unital\n\nchoi = swap_operator(3)\n\nprint(is_unital(choi))\n</code></pre> <p>True</p> <p>Additionally, the channel whose Choi matrix is the depolarizing channel is another example of a unital channel.</p> <pre><code>from toqito.channels import depolarizing\nfrom toqito.channel_props import is_unital\n\nchoi = depolarizing(4)\n\nprint(is_unital(choi))\n</code></pre> <p>True</p> <p>Parameters:</p> <ul> <li> <code>phi</code>               (<code>ndarray | list[list[ndarray]]</code>)           \u2013            <p>The channel provided as either a Choi matrix or a list of Kraus operators.</p> </li> <li> <code>rtol</code>               (<code>float</code>, default:                   <code>1e-05</code> )           \u2013            <p>The relative tolerance parameter (default 1e-05).</p> </li> <li> <code>atol</code>               (<code>float</code>, default:                   <code>1e-08</code> )           \u2013            <p>The absolute tolerance parameter (default 1e-08).</p> </li> <li> <code>dim</code>               (<code>int | list[int] | ndarray | None</code>, default:                   <code>None</code> )           \u2013            <p>A scalar, vector or matrix containing the input and output dimensions of PHI.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if the channel is unital, and <code>False</code> otherwise.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Watrous, John. The Theory of Quantum Information. (2018). doi:10.1017/9781316848142.</p> Source code in <code>toqito/channel_props/is_unital.py</code> <pre><code>def is_unital(\n    phi: np.ndarray | list[list[np.ndarray]],\n    rtol: float = 1e-05,\n    atol: float = 1e-08,\n    dim: int | list[int] | np.ndarray | None = None,\n) -&gt; bool:\n    r\"\"\"Determine whether the given channel is unital.\n\n    A map \\(\\Phi \\in \\text{T} \\left(\\mathcal{X}, \\mathcal{Y} \\right)\\) is *unital* if it holds that:\n\n    \\[\n        \\Phi(\\mathbb{I}_{\\mathcal{X}}) = \\mathbb{I}_{\\mathcal{Y}}.\n    \\]\n\n    If the input channel maps \\(M_{r,c}\\) to \\(M_{x,y}\\) then `dim` should be the\n    list `[[r,x], [c,y]]`. If it maps \\(M_m\\) to \\(M_n\\), then `dim` can simply\n    be the vector `[m,n]`.\n\n    More information can be found in Chapter: Unital Channels And Majorization from [@Watrous_2018_TQI]).\n\n    Examples:\n        Consider the channel whose Choi matrix is the swap operator. This channel is an example of a\n        unital channel.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.perms import swap_operator\n        from toqito.channel_props import is_unital\n\n        choi = swap_operator(3)\n\n        print(is_unital(choi))\n        ```\n\n        Additionally, the channel whose Choi matrix is the depolarizing channel is another example of\n        a unital channel.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.channels import depolarizing\n        from toqito.channel_props import is_unital\n\n        choi = depolarizing(4)\n\n        print(is_unital(choi))\n        ```\n\n    Args:\n        phi: The channel provided as either a Choi matrix or a list of Kraus operators.\n        rtol: The relative tolerance parameter (default 1e-05).\n        atol: The absolute tolerance parameter (default 1e-08).\n        dim: A scalar, vector or matrix containing the input and output dimensions of PHI.\n\n    Returns:\n        `True` if the channel is unital, and `False` otherwise.\n\n    \"\"\"\n    dim_in, _, _ = channel_dim(phi, dim=dim, allow_rect=False, compute_env_dim=False)\n\n    # Channel is unital if `mat` is the identity matrix.\n    mat = apply_channel(np.identity(dim_in), phi)\n    return is_identity(mat, rtol=rtol, atol=atol)\n</code></pre>"},{"location":"reference/toqito/channel_props/is_unitary/","title":"is_unitary","text":""},{"location":"reference/toqito/channel_props/is_unitary/#toqito.channel_props.is_unitary","title":"is_unitary","text":"<p>Determines if a channel is unitary.</p>"},{"location":"reference/toqito/channel_props/is_unitary/#toqito.channel_props.is_unitary.is_unitary","title":"is_unitary","text":"<pre><code>is_unitary(phi: ndarray | list[list[ndarray]]) -&gt; bool\n</code></pre> <p>Given a quantum channel, determine if it is unitary.</p> <p>(Section 2.2.1: Definitions and Basic Notions Concerning Channels from <sup>1</sup>).</p> <p>Let \\(\\mathcal{X}\\) be a complex Euclidean space an let \\(U \\in U(\\mathcal{X})\\) be a unitary operator. Then a unitary channel is defined as:</p> \\[     \\Phi(X) = U X U^*. \\] <p>Examples:</p> <p>The identity channel is one example of a unitary channel:</p> \\[     U =     \\begin{pmatrix}         1 &amp; 0 \\\\         0 &amp; 1     \\end{pmatrix}. \\] <p>We can verify this as follows:</p> <pre><code>import numpy as np\nfrom toqito.channel_props import is_unitary\n\nkraus_ops = [[np.identity(2), np.identity(2)]]\n\nprint(is_unitary(kraus_ops))\n</code></pre> <p>True</p> <p>We can also specify the input as a Choi matrix. For instance, consider the Choi matrix corresponding to the \\(2\\)-dimensional completely depolarizing channel.</p> \\[     \\Omega =     \\frac{1}{2}     \\begin{pmatrix}         1 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 1 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 1 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 1     \\end{pmatrix}. \\] <p>We may verify that this channel is not a unitary channel.</p> <pre><code>from toqito.channels import depolarizing\nfrom toqito.channel_props import is_unitary\n\nprint(is_unitary(depolarizing(2)))\n</code></pre> <p>False</p> <p>Parameters:</p> <ul> <li> <code>phi</code>               (<code>ndarray | list[list[ndarray]]</code>)           \u2013            <p>The channel provided as either a Choi matrix or a list of Kraus operators.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if the channel is a unitary channel, and <code>False</code> otherwise.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Watrous, John. The Theory of Quantum Information. (2018). doi:10.1017/9781316848142.</p> Source code in <code>toqito/channel_props/is_unitary.py</code> <pre><code>def is_unitary(phi: np.ndarray | list[list[np.ndarray]]) -&gt; bool:\n    r\"\"\"Given a quantum channel, determine if it is unitary.\n\n    (Section 2.2.1: Definitions and Basic Notions Concerning Channels from\n    [@Watrous_2018_TQI]).\n\n    Let \\(\\mathcal{X}\\) be a complex Euclidean space an let \\(U \\in U(\\mathcal{X})\\) be a\n    unitary operator. Then a unitary channel is defined as:\n\n    \\[\n        \\Phi(X) = U X U^*.\n    \\]\n\n    Examples:\n        The identity channel is one example of a unitary channel:\n\n        \\[\n            U =\n            \\begin{pmatrix}\n                1 &amp; 0 \\\\\n                0 &amp; 1\n            \\end{pmatrix}.\n        \\]\n\n        We can verify this as follows:\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.channel_props import is_unitary\n\n        kraus_ops = [[np.identity(2), np.identity(2)]]\n\n        print(is_unitary(kraus_ops))\n        ```\n\n        We can also specify the input as a Choi matrix. For instance, consider the Choi matrix\n        corresponding to the \\(2\\)-dimensional completely depolarizing channel.\n\n        \\[\n            \\Omega =\n            \\frac{1}{2}\n            \\begin{pmatrix}\n                1 &amp; 0 &amp; 0 &amp; 0 \\\\\n                0 &amp; 1 &amp; 0 &amp; 0 \\\\\n                0 &amp; 0 &amp; 1 &amp; 0 \\\\\n                0 &amp; 0 &amp; 0 &amp; 1\n            \\end{pmatrix}.\n        \\]\n\n        We may verify that this channel is not a unitary channel.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.channels import depolarizing\n        from toqito.channel_props import is_unitary\n\n        print(is_unitary(depolarizing(2)))\n        ```\n\n    Args:\n        phi: The channel provided as either a Choi matrix or a list of Kraus operators.\n\n    Returns:\n        `True` if the channel is a unitary channel, and `False` otherwise.\n\n    \"\"\"\n    # If the variable `phi` is provided as a ndarray, we assume this is a\n    # Choi matrix.\n    if isinstance(phi, np.ndarray):\n        try:\n            phi = choi_to_kraus(phi)\n        except ValueError:\n            # if we fail to obtain a Kraus representation then input/ouput spaces might be\n            # non squares or their dimensions are not equal. Hence the channel is not unitary.\n            return False\n\n    # If there is a unique Kraus operator and it's a unitary matrix then the channel is unitary.\n    if len(phi) != 1:\n        return False\n\n    u_mat = phi[0]\n    if isinstance(phi[0], list):\n        # we enter here if phi is specified as: [[U, U]] or [[U]]\n        u_mat = phi[0][0]\n        if len(phi[0]) &gt; 2 or (len(phi[0]) == 2 and not np.allclose(phi[0][0], phi[0][1])):\n            return False\n\n    return is_unitary_matrix(u_mat)\n</code></pre>"},{"location":"reference/toqito/channels/","title":"channels","text":""},{"location":"reference/toqito/channels/#toqito.channels","title":"channels","text":"<p>Channels is a module used to generate a number of widely-studied quantum channels.</p>"},{"location":"reference/toqito/channels/amplitude_damping/","title":"amplitude_damping","text":""},{"location":"reference/toqito/channels/amplitude_damping/#toqito.channels.amplitude_damping","title":"amplitude_damping","text":"<p>Generates the (generalized) amplitude damping channel.</p>"},{"location":"reference/toqito/channels/amplitude_damping/#toqito.channels.amplitude_damping.amplitude_damping","title":"amplitude_damping","text":"<pre><code>amplitude_damping(input_mat: ndarray | None = None, gamma: float = 0, prob: float = 1) -&gt; ndarray | list[ndarray]\n</code></pre> <p>Apply the generalized amplitude damping channel to a quantum state.</p> <p>The generalized amplitude damping channel is a quantum channel that models energy dissipation in a quantum system, where the system can lose energy to its environment with a certain probability. This channel is defined by two parameters: <code>gamma</code> (the damping rate) and <code>prob</code> (the probability of energy loss).</p> <p>To also include standard implementation of amplitude damping, we have set <code>prob = 1</code> as the default implementation.</p> <p>Note</p> <p>This channel is defined for qubit systems in the standard literature <sup>1</sup>.</p> <p>The Kraus operators for the generalized amplitude damping channel are given by:</p> \\[     K_0 = \\sqrt{p} \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; \\sqrt{1 - \\gamma} \\end{pmatrix}, \\\\     K_1 = \\sqrt{p}  \\begin{pmatrix} 0 &amp; \\sqrt{\\gamma} \\\\ 0 &amp; 0 \\end{pmatrix}, \\\\     K_2 = \\sqrt{1 - p} \\begin{pmatrix} \\sqrt{1 - \\gamma} &amp; 0 \\\\ 0 &amp; 1 \\end{pmatrix}, \\\\     K_3 = \\sqrt{1 - p}  \\begin{pmatrix} 0 &amp; 0 \\\\ \\sqrt{\\gamma} &amp; 0 \\end{pmatrix}, \\\\ \\] <p>These operators describe the evolution of a quantum state under the generalized amplitude damping process.</p> <p>Examples:</p> <p>Apply the generalized amplitude damping channel to a qubit state:</p> <pre><code>import numpy as np\nfrom toqito.channels import amplitude_damping\n\nrho = np.array([[1, 0], [0, 0]])  # |0&gt;&lt;0|\nresult = amplitude_damping(rho, gamma=0.1, prob=0.5)\n\nprint(result)\n</code></pre> <p>[[0.95+0.j 0.  +0.j]  [0.  +0.j 0.05+0.j]]</p> <p>Parameters:</p> <ul> <li> <code>input_mat</code>               (<code>ndarray | None</code>, default:                   <code>None</code> )           \u2013            <p>The input matrix to which the channel is applied. If <code>None</code>, the function returns the Kraus operators</p> </li> <li> <code>gamma</code>               (<code>float</code>, default:                   <code>0</code> )           \u2013            <p>The damping rate, a float between 0 and 1. Represents the probability of energy dissipation.</p> </li> <li> <code>prob</code>               (<code>float</code>, default:                   <code>1</code> )           \u2013            <p>The probability of energy loss, a float between 0 and 1.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray | list[ndarray]</code>           \u2013            <p>The evolved quantum state after applying the generalized amplitude damping channel. If <code>input_mat</code> is <code>None</code>, it</p> </li> <li> <code>ndarray | list[ndarray]</code>           \u2013            <p>returns the list of Kraus operators.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Khatri, Sumeet and Sharma, Kunal and Wilde, Mark. Information-theoretic aspects of the generalized amplitude-damping channel. Phys. Rev. A. vol. 102. (2020). doi:10.1103/PhysRevA.102.012401.</p> Source code in <code>toqito/channels/amplitude_damping.py</code> <pre><code>def amplitude_damping(\n    input_mat: np.ndarray | None = None,\n    gamma: float = 0,\n    prob: float = 1,\n) -&gt; np.ndarray | list[np.ndarray]:\n    r\"\"\"Apply the generalized amplitude damping channel to a quantum state.\n\n    The generalized amplitude damping channel is a quantum channel that models energy dissipation\n    in a quantum system, where the system can lose energy to its environment with a certain\n    probability. This channel is defined by two parameters: `gamma` (the damping rate) and `prob`\n    (the probability of energy loss).\n\n    To also include standard implementation of amplitude damping, we have set `prob = 1` as the default implementation.\n\n    !!! note\n        This channel is defined for qubit systems in the standard literature [@Khatri_2020_Information].\n\n\n    The Kraus operators for the generalized amplitude damping channel are given by:\n\n    \\[\n        K_0 = \\sqrt{p} \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; \\sqrt{1 - \\gamma} \\end{pmatrix}, \\\\\n        K_1 = \\sqrt{p}  \\begin{pmatrix} 0 &amp; \\sqrt{\\gamma} \\\\ 0 &amp; 0 \\end{pmatrix}, \\\\\n        K_2 = \\sqrt{1 - p} \\begin{pmatrix} \\sqrt{1 - \\gamma} &amp; 0 \\\\ 0 &amp; 1 \\end{pmatrix}, \\\\\n        K_3 = \\sqrt{1 - p}  \\begin{pmatrix} 0 &amp; 0 \\\\ \\sqrt{\\gamma} &amp; 0 \\end{pmatrix}, \\\\\n    \\]\n\n    These operators describe the evolution of a quantum state under the generalized amplitude\n    damping process.\n\n    Examples:\n        Apply the generalized amplitude damping channel to a qubit state:\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.channels import amplitude_damping\n\n        rho = np.array([[1, 0], [0, 0]])  # |0&gt;&lt;0|\n        result = amplitude_damping(rho, gamma=0.1, prob=0.5)\n\n        print(result)\n        ```\n\n    Args:\n        input_mat: The input matrix to which the channel is applied. If `None`, the function returns the Kraus operators\n        of the channel.\n        gamma: The damping rate, a float between 0 and 1. Represents the probability of energy dissipation.\n        prob: The probability of energy loss, a float between 0 and 1.\n\n    Returns:\n        The evolved quantum state after applying the generalized amplitude damping channel. If `input_mat` is `None`, it\n        returns the list of Kraus operators.\n\n    \"\"\"\n    if not (0 &lt;= prob &lt;= 1):\n        raise ValueError(\"Probability must be between 0 and 1.\")\n\n    if not (0 &lt;= gamma &lt;= 1):\n        raise ValueError(\"Gamma (damping rate) must be between 0 and 1.\")\n\n    k0 = np.sqrt(prob) * np.array([[1, 0], [0, np.sqrt(1 - gamma)]])\n    k1 = np.sqrt(prob) * np.sqrt(gamma) * np.array([[0, 1], [0, 0]])\n    k2 = np.sqrt(1 - prob) * np.array([[np.sqrt(1 - gamma), 0], [0, 1]])\n    k3 = np.sqrt(1 - prob) * np.sqrt(gamma) * np.array([[0, 0], [1, 0]])\n\n    if input_mat is not None and input_mat.shape != (2, 2):\n        raise ValueError(\"Input matrix must be 2x2 for the generalized amplitude damping channel.\")\n    elif input_mat is None:\n        return [k0, k1, k2, k3]\n\n    input_mat = np.asarray(input_mat, dtype=complex)\n\n    return (\n        k0 @ input_mat @ k0.conj().T\n        + k1 @ input_mat @ k1.conj().T\n        + k2 @ input_mat @ k2.conj().T\n        + k3 @ input_mat @ k3.conj().T\n    )\n</code></pre>"},{"location":"reference/toqito/channels/bitflip/","title":"bitflip","text":""},{"location":"reference/toqito/channels/bitflip/#toqito.channels.bitflip","title":"bitflip","text":"<p>Implements the bitflip quantum gate channel.</p>"},{"location":"reference/toqito/channels/bitflip/#toqito.channels.bitflip.bitflip","title":"bitflip","text":"<pre><code>bitflip(input_mat: ndarray | None = None, prob: float = 0) -&gt; ndarray | list[ndarray]\n</code></pre> <p>Apply the bitflip quantum channel to a state or return the Kraus operators.</p> <p>The bitflip channel is a quantum channel that flips a qubit from \\(|0\\rangle\\) to \\(|1\\rangle\\) and from \\(|1\\rangle\\) to \\(|0\\rangle\\) with probability \\(p\\). It is defined by the following operation:</p> \\[     \\mathcal{E}(\\rho) = (1-p) \\rho + p X \\rho X \\] <p>where \\(X\\) is the Pauli-X (NOT) gate given by:</p> \\[     X = \\begin{pmatrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\end{pmatrix} \\] <p>The Kraus operators for this channel are:</p> \\[     K_0 = \\sqrt{1-p} \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; 1 \\end{pmatrix}, \\quad     K_1 = \\sqrt{p} \\begin{pmatrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\end{pmatrix} \\] <p>Examples:</p> <p>We can generate the Kraus operators for the bitflip channel with probability 0.3:</p> <pre><code>from toqito.channels import bitflip\n\nprint(bitflip(prob=0.3))\n</code></pre> <p>[array([[0.83666003, 0.        ],        [0.        , 0.83666003]]), array([[0.        , 0.54772256],        [0.54772256, 0.        ]])]</p> <p>We can also apply the bitflip channel to a quantum state. For the state \\(|0\\rangle\\), the bitflip channel with probability 0.3 produces:</p> <pre><code>import numpy as np\nfrom toqito.channels import bitflip\n\nrho = np.array([[1, 0], [0, 0]])  # |0&gt;&lt;0|\nprint(bitflip(rho, prob=0.3))\n</code></pre> <p>[[0.7+0.j 0. +0.j]  [0. +0.j 0.3+0.j]]</p> <p>Parameters:</p> <ul> <li> <code>input_mat</code>               (<code>ndarray | None</code>, default:                   <code>None</code> )           \u2013            <p>A matrix or state to apply the channel to. If <code>None</code>, returns the Kraus operators.</p> </li> <li> <code>prob</code>               (<code>float</code>, default:                   <code>0</code> )           \u2013            <p>The probability of a bitflip occurring.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray | list[ndarray]</code>           \u2013            <p>Either the Kraus operators of the bitflip channel if <code>input_mat</code> is <code>None</code>, or the result of applying the</p> </li> <li> <code>ndarray | list[ndarray]</code>           \u2013            <p>channel to <code>input_mat</code>.</p> </li> </ul> Source code in <code>toqito/channels/bitflip.py</code> <pre><code>def bitflip(\n    input_mat: np.ndarray | None = None,\n    prob: float = 0,\n) -&gt; np.ndarray | list[np.ndarray]:\n    r\"\"\"Apply the bitflip quantum channel to a state or return the Kraus operators.\n\n    The *bitflip channel* is a quantum channel that flips a qubit from \\(|0\\rangle\\) to \\(|1\\rangle\\)\n    and from \\(|1\\rangle\\) to \\(|0\\rangle\\) with probability \\(p\\).\n    It is defined by the following operation:\n\n    \\[\n        \\mathcal{E}(\\rho) = (1-p) \\rho + p X \\rho X\n    \\]\n\n    where \\(X\\) is the Pauli-X (NOT) gate given by:\n\n    \\[\n        X = \\begin{pmatrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\end{pmatrix}\n    \\]\n\n    The Kraus operators for this channel are:\n\n    \\[\n        K_0 = \\sqrt{1-p} \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; 1 \\end{pmatrix}, \\quad\n        K_1 = \\sqrt{p} \\begin{pmatrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\end{pmatrix}\n    \\]\n\n    Examples:\n        We can generate the Kraus operators for the bitflip channel with probability 0.3:\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.channels import bitflip\n\n        print(bitflip(prob=0.3))\n        ```\n\n\n        We can also apply the bitflip channel to a quantum state. For the state \\(|0\\rangle\\),\n        the bitflip channel with probability 0.3 produces:\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.channels import bitflip\n\n        rho = np.array([[1, 0], [0, 0]])  # |0&gt;&lt;0|\n        print(bitflip(rho, prob=0.3))\n        ```\n\n    Args:\n        input_mat: A matrix or state to apply the channel to. If `None`, returns the Kraus operators.\n        prob: The probability of a bitflip occurring.\n\n    Returns:\n        Either the Kraus operators of the bitflip channel if `input_mat` is `None`, or the result of applying the\n        channel to `input_mat`.\n\n    \"\"\"\n    if not (0 &lt;= prob &lt;= 1):\n        raise ValueError(\"Probability must be between 0 and 1.\")\n\n    k0 = np.sqrt(1 - prob) * np.eye(2)\n    k1 = np.sqrt(prob) * np.array([[0, 1], [1, 0]])\n\n    if input_mat is not None and input_mat.shape != (2, 2):\n        raise ValueError(\"Input matrix must be 2x2 for the bitflip channel.\")\n    elif input_mat is None:\n        return [k0, k1]\n\n    input_mat = np.asarray(input_mat, dtype=complex)\n\n    return k0 @ input_mat @ k0.conj().T + k1 @ input_mat @ k1.conj().T\n</code></pre>"},{"location":"reference/toqito/channels/choi/","title":"choi","text":""},{"location":"reference/toqito/channels/choi/#toqito.channels.choi","title":"choi","text":"<p>Generates the Choi channel.</p>"},{"location":"reference/toqito/channels/choi/#toqito.channels.choi.choi","title":"choi","text":"<pre><code>choi(a_var: int = 1, b_var: int = 1, c_var: int = 0) -&gt; ndarray\n</code></pre> <p>Produce the Choi channel or one of its generalizations <sup>1</sup>.</p> <p>The Choi channel is a positive map on 3-by-3 matrices that is capable of detecting some entanglement that the transpose map is not.</p> <p>The standard Choi channel defined with <code>a=1</code>, <code>b=1</code>, and <code>c=0</code> is the Choi matrix of the positive map defined in <sup>1</sup>. Many of these maps are capable of detecting PPT entanglement.</p> <p>Examples:</p> <p>The standard Choi channel is given as</p> \\[     \\Phi_{1, 1, 0} =     \\begin{pmatrix}         1 &amp; 0 &amp; 0 &amp; 0 &amp; -1 &amp; 0 &amp; 0 &amp; 0 &amp; -1 \\\\         0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\         -1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; -1 \\\\         0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\\\         -1 &amp; 0 &amp; 0 &amp; 0 &amp; -1 &amp; 0 &amp; 0 &amp; 0 &amp; 1     \\end{pmatrix} \\] <p>We can generate the Choi channel in <code>|toqito\u27e9</code> as follows.</p> <pre><code>import numpy as np\nfrom toqito.channels import choi\n\nprint(choi())\n</code></pre> <p>[[ 1.  0.  0.  0. -1.  0.  0.  0. -1.]  [ 0.  0.  0.  0.  0.  0.  0.  0.  0.]  [ 0.  0.  1.  0.  0.  0.  0.  0.  0.]  [ 0.  0.  0.  1.  0.  0.  0.  0.  0.]  [-1.  0.  0.  0.  1.  0.  0.  0. -1.]  [ 0.  0.  0.  0.  0.  0.  0.  0.  0.]  [ 0.  0.  0.  0.  0.  0.  0.  0.  0.]  [ 0.  0.  0.  0.  0.  0.  0.  1.  0.]  [-1.  0.  0.  0. -1.  0.  0.  0.  1.]]</p> <p>The reduction channel is the map \\(R\\) defined by:</p> \\[     R(X) = \\text{Tr}(X) \\mathbb{I} - X. \\] <p>The matrix correspond to this is given as</p> \\[     \\Phi_{0, 1, 1} =     \\begin{pmatrix}         0 &amp; 0 &amp; 0 &amp; 0 &amp; -1 &amp; 0 &amp; 0 &amp; 0 &amp; -1 \\\\         0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\         -1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; -1 \\\\         0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\\\         -1 &amp; 0 &amp; 0 &amp; 0 &amp; -1 &amp; 0 &amp; 0 &amp; 0 &amp; 0     \\end{pmatrix} \\] <p>The reduction channel is the Choi channel that arises when <code>a = 0</code> and when <code>b = c = 1</code>. We can obtain this matrix using <code>|toqito\u27e9</code> as follows.</p> <pre><code>import numpy as np\nfrom toqito.channels import choi\n\nprint(choi(0, 1, 1))\n</code></pre> <p>[[ 0.  0.  0.  0. -1.  0.  0.  0. -1.]  [ 0.  1.  0.  0.  0.  0.  0.  0.  0.]  [ 0.  0.  1.  0.  0.  0.  0.  0.  0.]  [ 0.  0.  0.  1.  0.  0.  0.  0.  0.]  [-1.  0.  0.  0.  0.  0.  0.  0. -1.]  [ 0.  0.  0.  0.  0.  1.  0.  0.  0.]  [ 0.  0.  0.  0.  0.  0.  1.  0.  0.]  [ 0.  0.  0.  0.  0.  0.  0.  1.  0.]  [-1.  0.  0.  0. -1.  0.  0.  0.  0.]]</p> <p>See</p> <p>reduction</p> <p>Parameters:</p> <ul> <li> <code>a_var</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Default integer for standard Choi map.</p> </li> <li> <code>b_var</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Default integer for standard Choi map.</p> </li> <li> <code>c_var</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Default integer for standard Choi map.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>The Choi channel (or one of its  generalizations).</p> </li> </ul> <p>References</p> <p><sup>1</sup> Cho, Sung and Kye, Seung-Hyeok and Lee, Sa. Generalized Choi maps in three-dimensional matrix algebra. Linear Algebra and its Applications. vol. 171. (1992). doi:https://doi.org/10.1016/0024-3795(92)90260-H.</p> Source code in <code>toqito/channels/choi.py</code> <pre><code>def choi(a_var: int = 1, b_var: int = 1, c_var: int = 0) -&gt; np.ndarray:\n    r\"\"\"Produce the Choi channel or one of its generalizations [@Choi_1992_Generalized].\n\n    The *Choi channel* is a positive map on 3-by-3 matrices that is capable of detecting some\n    entanglement that the transpose map is not.\n\n    The standard Choi channel defined with `a=1`, `b=1`, and `c=0` is the Choi\n    matrix of the positive map defined in [@Choi_1992_Generalized]. Many of these maps are capable of detecting\n    PPT entanglement.\n\n    Examples:\n        The standard Choi channel is given as\n\n        \\[\n            \\Phi_{1, 1, 0} =\n            \\begin{pmatrix}\n                1 &amp; 0 &amp; 0 &amp; 0 &amp; -1 &amp; 0 &amp; 0 &amp; 0 &amp; -1 \\\\\n                0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                -1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; -1 \\\\\n                0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\\\\n                -1 &amp; 0 &amp; 0 &amp; 0 &amp; -1 &amp; 0 &amp; 0 &amp; 0 &amp; 1\n            \\end{pmatrix}\n        \\]\n\n        We can generate the Choi channel in `|toqito\u27e9` as follows.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.channels import choi\n\n        print(choi())\n        ```\n\n        The reduction channel is the map \\(R\\) defined by:\n\n        \\[\n            R(X) = \\text{Tr}(X) \\mathbb{I} - X.\n        \\]\n\n        The matrix correspond to this is given as\n\n        \\[\n            \\Phi_{0, 1, 1} =\n            \\begin{pmatrix}\n                0 &amp; 0 &amp; 0 &amp; 0 &amp; -1 &amp; 0 &amp; 0 &amp; 0 &amp; -1 \\\\\n                0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                -1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; -1 \\\\\n                0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\\\\n                0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\\\\n                0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\\\\n                -1 &amp; 0 &amp; 0 &amp; 0 &amp; -1 &amp; 0 &amp; 0 &amp; 0 &amp; 0\n            \\end{pmatrix}\n        \\]\n\n        The reduction channel is the Choi channel that arises when `a = 0` and when `b =\n        c = 1`. We can obtain this matrix using `|toqito\u27e9` as follows.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.channels import choi\n\n        print(choi(0, 1, 1))\n        ```\n\n        !!! See Also\n            [reduction][toqito.channels.reduction.reduction]\n\n    Args:\n        a_var: Default integer for standard Choi map.\n        b_var: Default integer for standard Choi map.\n        c_var: Default integer for standard Choi map.\n\n    Returns:\n        The Choi channel (or one of its  generalizations).\n\n    \"\"\"\n    psi = max_entangled(3, False, False)\n    return np.diag([a_var + 1, c_var, b_var, b_var, a_var + 1, c_var, c_var, b_var, a_var + 1]) - psi @ psi.conj().T\n</code></pre>"},{"location":"reference/toqito/channels/dephasing/","title":"dephasing","text":""},{"location":"reference/toqito/channels/dephasing/#toqito.channels.dephasing","title":"dephasing","text":"<p>Generates the dephasing channel.</p>"},{"location":"reference/toqito/channels/dephasing/#toqito.channels.dephasing.dephasing","title":"dephasing","text":"<pre><code>dephasing(dim: int, param_p: float = 0) -&gt; ndarray\n</code></pre> <p>Produce the partially dephasing channel.</p> <p>(Section: The Completely Dephasing Channel from <sup>1</sup>).</p> <p>The Choi matrix of the completely dephasing channel that acts on <code>dim</code>-by-<code>dim</code> matrices.</p> <p>Let \\(\\Sigma\\) be an alphabet and let \\(\\mathcal{X} = \\mathbb{C}^{\\Sigma}\\). The map \\(\\Delta \\in \\text{T}(\\mathcal{X})\\) defined as</p> \\[     \\Delta(X) = \\sum_{a \\in \\Sigma} X(a, a) E_{a,a} \\] <p>for every \\(X \\in \\text{L}(\\mathcal{X})\\) is defined as the completely dephasing channel.</p> <p>Examples:</p> <p>The completely dephasing channel maps kills everything off the diagonal. Consider the following matrix</p> \\[     \\rho = \\begin{pmatrix}                1 &amp; 2 &amp; 3 &amp; 4 \\\\                5 &amp; 6 &amp; 7 &amp; 8 \\\\                9 &amp; 10 &amp; 11 &amp; 12 \\\\                13 &amp; 14 &amp; 15 &amp; 16            \\end{pmatrix}. \\] <p>Applying the dephasing channel to \\(\\rho\\) we have that</p> \\[     \\Phi(\\rho) = \\begin{pmatrix}                      1 &amp; 0 &amp; 0 &amp; 0 \\\\                      0 &amp; 6 &amp; 0 &amp; 0 \\\\                      0 &amp; 0 &amp; 11 &amp; 0 \\\\                      0 &amp; 0 &amp; 0 &amp; 16                  \\end{pmatrix}. \\] <p>This can be observed in <code>|toqito\u27e9</code> as follows.</p> <pre><code>import numpy as np\nfrom toqito.channels import dephasing\nfrom toqito.channel_ops import apply_channel\n\ntest_input_mat = np.arange(1, 17).reshape(4, 4)\n\nprint(apply_channel(test_input_mat, dephasing(4)))\n</code></pre> <p>[[ 1.  0.  0.  0.]  [ 0.  6.  0.  0.]  [ 0.  0. 11.  0.]  [ 0.  0.  0. 16.]]</p> <p>We may also consider setting the parameter <code>p = 0.5</code>.</p> <pre><code>import numpy as np\nfrom toqito.channels import dephasing\nfrom toqito.channel_ops import apply_channel\n\ntest_input_mat = np.arange(1, 17).reshape(4, 4)\n\nprint(apply_channel(test_input_mat, dephasing(4, 0.5)))\n</code></pre> <p>[[ 1.   1.   1.5  2. ]  [ 2.5  6.   3.5  4. ]  [ 4.5  5.  11.   6. ]  [ 6.5  7.   7.5 16. ]]</p> <p>Parameters:</p> <ul> <li> <code>dim</code>               (<code>int</code>)           \u2013            <p>The dimensionality on which the channel acts.</p> </li> <li> <code>param_p</code>               (<code>float</code>, default:                   <code>0</code> )           \u2013            <p>Default is 0.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>The Choi matrix of the dephasing channel.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Watrous, John. The Theory of Quantum Information. (2018). doi:10.1017/9781316848142.</p> Source code in <code>toqito/channels/dephasing.py</code> <pre><code>def dephasing(dim: int, param_p: float = 0) -&gt; np.ndarray:\n    r\"\"\"Produce the partially dephasing channel.\n\n    (Section: The Completely Dephasing Channel from [@Watrous_2018_TQI]).\n\n    The Choi matrix of the completely dephasing channel that acts on `dim`-by-`dim`\n    matrices.\n\n    Let \\(\\Sigma\\) be an alphabet and let \\(\\mathcal{X} = \\mathbb{C}^{\\Sigma}\\). The map\n    \\(\\Delta \\in \\text{T}(\\mathcal{X})\\) defined as\n\n    \\[\n        \\Delta(X) = \\sum_{a \\in \\Sigma} X(a, a) E_{a,a}\n    \\]\n\n    for every \\(X \\in \\text{L}(\\mathcal{X})\\) is defined as the *completely dephasing channel*.\n\n    Examples:\n        The completely dephasing channel maps kills everything off the diagonal. Consider the\n        following matrix\n\n        \\[\n            \\rho = \\begin{pmatrix}\n                       1 &amp; 2 &amp; 3 &amp; 4 \\\\\n                       5 &amp; 6 &amp; 7 &amp; 8 \\\\\n                       9 &amp; 10 &amp; 11 &amp; 12 \\\\\n                       13 &amp; 14 &amp; 15 &amp; 16\n                   \\end{pmatrix}.\n        \\]\n\n        Applying the dephasing channel to \\(\\rho\\) we have that\n\n        \\[\n            \\Phi(\\rho) = \\begin{pmatrix}\n                             1 &amp; 0 &amp; 0 &amp; 0 \\\\\n                             0 &amp; 6 &amp; 0 &amp; 0 \\\\\n                             0 &amp; 0 &amp; 11 &amp; 0 \\\\\n                             0 &amp; 0 &amp; 0 &amp; 16\n                         \\end{pmatrix}.\n        \\]\n\n        This can be observed in `|toqito\u27e9` as follows.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.channels import dephasing\n        from toqito.channel_ops import apply_channel\n\n        test_input_mat = np.arange(1, 17).reshape(4, 4)\n\n        print(apply_channel(test_input_mat, dephasing(4)))\n        ```\n\n\n        We may also consider setting the parameter `p = 0.5`.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.channels import dephasing\n        from toqito.channel_ops import apply_channel\n\n        test_input_mat = np.arange(1, 17).reshape(4, 4)\n\n        print(apply_channel(test_input_mat, dephasing(4, 0.5)))\n        ```\n\n    Args:\n        dim: The dimensionality on which the channel acts.\n        param_p: Default is 0.\n\n    Returns:\n        The Choi matrix of the dephasing channel.\n\n    \"\"\"\n    # Compute the Choi matrix of the dephasing channel.\n\n    # Gives a sparse non-normalized state.\n    psi = max_entangled(dim=dim, is_sparse=False, is_normalized=False)\n    return (1 - param_p) * np.diag(np.diag(psi @ psi.conj().T)) + param_p * (psi @ psi.conj().T)\n</code></pre>"},{"location":"reference/toqito/channels/depolarizing/","title":"depolarizing","text":""},{"location":"reference/toqito/channels/depolarizing/#toqito.channels.depolarizing","title":"depolarizing","text":"<p>Generates the depolarizing channel.</p>"},{"location":"reference/toqito/channels/depolarizing/#toqito.channels.depolarizing.depolarizing","title":"depolarizing","text":"<pre><code>depolarizing(dim: int, param_p: float = 0) -&gt; ndarray\n</code></pre> <p>Produce the partially depolarizing channel.</p> <p>(Section: Replacement Channels and the Completely Depolarizing Channel from <sup>1</sup>).</p> <p>The Choi matrix of the completely depolarizing channel <sup>2</sup> that acts on <code>dim</code>-by-<code>dim</code> matrices.</p> <p>The completely depolarizing channel is defined as</p> \\[     \\Omega(X) = \\text{Tr}(X) \\omega \\] <p>for all \\(X \\in \\text{L}(\\mathcal{X})\\), where</p> \\[     \\omega = \\frac{\\mathbb{I}_{\\mathcal{X}}}{\\text{dim}(\\mathcal{X})} \\] <p>denotes the completely mixed stated defined with respect to the space \\(\\mathcal{X}\\).</p> <p>Examples:</p> <p>The completely depolarizing channel maps every density matrix to the maximally-mixed state. For example, consider the density operator</p> \\[     \\rho = \\frac{1}{2} \\begin{pmatrix}                          1 &amp; 0 &amp; 0 &amp; 1 \\\\                          0 &amp; 0 &amp; 0 &amp; 0 \\\\                          0 &amp; 0 &amp; 0 &amp; 0 \\\\                          1 &amp; 0 &amp; 0 &amp; 1                        \\end{pmatrix} \\] <p>corresponding to one of the Bell states. Applying the depolarizing channel to \\(\\rho\\) we have that</p> \\[     \\Phi(\\rho) = \\frac{1}{4} \\begin{pmatrix}                                 1 &amp; 0 &amp; 0 &amp; 0 \\\\                                 0 &amp; 1 &amp; 0 &amp; 0 \\\\                                 0 &amp; 0 &amp; 1 &amp; 0 \\\\                                 0 &amp; 0 &amp; 0 &amp; 1                              \\end{pmatrix}. \\] <p>This can be observed in <code>|toqito\u27e9</code> as follows.</p> <pre><code>import numpy as np\nfrom toqito.channels import depolarizing\nfrom toqito.channel_ops import apply_channel\n\ntest_input_mat = np.array([[1 / 2, 0, 0, 1 / 2], [0, 0, 0, 0], [0, 0, 0, 0], [1 / 2, 0, 0, 1 / 2]])\n\nprint(apply_channel(test_input_mat, depolarizing(4)))\n</code></pre> <p>[[0.25 0.   0.   0.  ]  [0.   0.25 0.   0.  ]  [0.   0.   0.25 0.  ]  [0.   0.   0.   0.25]]</p> <pre><code>import numpy as np\nfrom toqito.channels import depolarizing\nfrom toqito.channel_ops import apply_channel\n\ntest_input_mat = np.arange(1, 17).reshape(4, 4)\n\nprint(apply_channel(test_input_mat, depolarizing(4, 0.5)))\n</code></pre> <p>[[ 4.75  1.    1.5   2.  ]  [ 2.5   7.25  3.5   4.  ]  [ 4.5   5.    9.75  6.  ]  [ 6.5   7.    7.5  12.25]]</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>param_p</code> is outside the interval [0,1].</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>dim</code>               (<code>int</code>)           \u2013            <p>The dimensionality on which the channel acts.</p> </li> <li> <code>param_p</code>               (<code>float</code>, default:                   <code>0</code> )           \u2013            <p>Depolarizing probability \\(p \\) \\in [0,1] that mixes the input state with the maximally mixed state.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>The Choi matrix of the completely depolarizing channel.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Watrous, John. The Theory of Quantum Information. (2018). doi:10.1017/9781316848142. <sup>2</sup> Wikipedia. Quantum Depolarizing Channel. link.</p> Source code in <code>toqito/channels/depolarizing.py</code> <pre><code>def depolarizing(dim: int, param_p: float = 0) -&gt; np.ndarray:\n    r\"\"\"Produce the partially depolarizing channel.\n\n    (Section: Replacement Channels and the Completely Depolarizing Channel from\n    [@Watrous_2018_TQI]).\n\n    The Choi matrix of the completely depolarizing channel [@WikiDepo] that acts on\n    `dim`-by-`dim` matrices.\n\n    The *completely depolarizing channel* is defined as\n\n    \\[\n        \\Omega(X) = \\text{Tr}(X) \\omega\n    \\]\n\n    for all \\(X \\in \\text{L}(\\mathcal{X})\\), where\n\n    \\[\n        \\omega = \\frac{\\mathbb{I}_{\\mathcal{X}}}{\\text{dim}(\\mathcal{X})}\n    \\]\n\n    denotes the completely mixed stated defined with respect to the space \\(\\mathcal{X}\\).\n\n    Examples:\n        The completely depolarizing channel maps every density matrix to the maximally-mixed state.\n        For example, consider the density operator\n\n        \\[\n            \\rho = \\frac{1}{2} \\begin{pmatrix}\n                                 1 &amp; 0 &amp; 0 &amp; 1 \\\\\n                                 0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                                 0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                                 1 &amp; 0 &amp; 0 &amp; 1\n                               \\end{pmatrix}\n        \\]\n\n        corresponding to one of the Bell states. Applying the depolarizing channel to \\(\\rho\\) we\n        have that\n\n        \\[\n            \\Phi(\\rho) = \\frac{1}{4} \\begin{pmatrix}\n                                        1 &amp; 0 &amp; 0 &amp; 0 \\\\\n                                        0 &amp; 1 &amp; 0 &amp; 0 \\\\\n                                        0 &amp; 0 &amp; 1 &amp; 0 \\\\\n                                        0 &amp; 0 &amp; 0 &amp; 1\n                                     \\end{pmatrix}.\n        \\]\n\n        This can be observed in `|toqito\u27e9` as follows.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.channels import depolarizing\n        from toqito.channel_ops import apply_channel\n\n        test_input_mat = np.array([[1 / 2, 0, 0, 1 / 2], [0, 0, 0, 0], [0, 0, 0, 0], [1 / 2, 0, 0, 1 / 2]])\n\n        print(apply_channel(test_input_mat, depolarizing(4)))\n        ```\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.channels import depolarizing\n        from toqito.channel_ops import apply_channel\n\n        test_input_mat = np.arange(1, 17).reshape(4, 4)\n\n        print(apply_channel(test_input_mat, depolarizing(4, 0.5)))\n        ```\n\n    Raises:\n        ValueError: If `param_p` is outside the interval [0,1].\n\n    Args:\n        dim: The dimensionality on which the channel acts.\n        param_p: Depolarizing probability \\(p \\) \\in [0,1] that mixes the input state with the maximally mixed state.\n        Default 0.\n\n    Returns:\n        The Choi matrix of the completely depolarizing channel.\n\n    \"\"\"\n    # Compute the Choi matrix of the depolarizing channel.\n    if param_p &gt; 1 or param_p &lt; 0:\n        raise ValueError(\"The depolarizing probability must be between 0 and 1.\")\n\n    result = np.zeros((dim**2, dim**2), dtype=np.float64)\n    np.fill_diagonal(result, (1 - param_p) / dim)\n\n    if param_p != 0.0:\n        idx = np.arange(dim) * (dim + 1)\n        result[np.ix_(idx, idx)] += param_p\n\n    return result\n</code></pre>"},{"location":"reference/toqito/channels/ldot_channel/","title":"ldot_channel","text":""},{"location":"reference/toqito/channels/ldot_channel/#toqito.channels.ldot_channel","title":"ldot_channel","text":"<p>Local diagonal orthogonal twirl channel.</p>"},{"location":"reference/toqito/channels/ldot_channel/#toqito.channels.ldot_channel.ldot_channel","title":"ldot_channel","text":"<pre><code>ldot_channel(mat: ndarray, efficient: bool = True) -&gt; ndarray\n</code></pre> <p>Apply the local diagonal orthogonal twirl (LDOT) channel to a matrix.</p> <p>The LDOT channel projects a matrix onto the subspace of local diagonal orthogonal invariant (LDOI) matrices. It is defined as:</p> \\[     \\Phi_O(A) = \\frac{1}{2^n} \\sum_{O \\in \\text{DO}(\\mathcal{X})} (O \\otimes O) A (O \\otimes O) \\] <p>where \\(\\text{DO}(\\mathcal{X})\\) is the set of \\(n \\times n\\) diagonal matrices with diagonal entries equal to \\(\\pm 1\\).</p> <p>The LDOT channel has the following properties:</p> <ul> <li>It is a quantum channel (completely positive and trace-preserving)</li> <li>It is self-adjoint: \\(\\Phi_O^* = \\Phi_O\\)</li> <li>It preserves PPT and separability</li> <li>It is an orthogonal projection onto the LDOI subspace</li> </ul> <p>The efficient implementation works directly in the computational basis, zeroing out the entries that average to zero under the twirl. This keeps the complexity polynomial in \\(n\\) instead of the exponential \\(O(2^n)\\) for the brute-force approach.</p> <p>Examples:</p> <p>Apply LDOT channel to project an arbitrary matrix onto LDOI subspace:</p> <pre><code>from toqito.channels import ldot_channel\nimport numpy as np\n\n# Arbitrary 2-qubit matrix\nmat = np.array([[1, 2, 3, 4],\n                [5, 6, 7, 8],\n                [9, 10, 11, 12],\n                [13, 14, 15, 16]])\nldoi_projection = ldot_channel(mat)\nprint(ldoi_projection)\n</code></pre> <p>[[ 1.+0.j  0.+0.j  0.+0.j  4.+0.j]  [ 0.+0.j  6.+0.j  7.+0.j  0.+0.j]  [ 0.+0.j 10.+0.j 11.+0.j  0.+0.j]  [13.+0.j  0.+0.j  0.+0.j 16.+0.j]]</p> <p>The LDOT channel is idempotent (applying it twice gives the same result):</p> <pre><code>from toqito.channels import ldot_channel\nimport numpy as np\n\nmat = np.random.rand(4, 4)\nonce = ldot_channel(mat)\ntwice = ldot_channel(once)\nprint(np.allclose(once, twice))\n</code></pre> <p>True</p> <p>Parameters:</p> <ul> <li> <code>mat</code>               (<code>ndarray</code>)           \u2013            <p>A square matrix of dimension \\(n^2 \\times n^2\\) representing a bipartite     operator on \\(\\mathcal{X} \\otimes \\mathcal{Y}\\) where     \\(\\mathcal{X} = \\mathcal{Y} = \\mathbb{C}^n\\).</p> </li> <li> <code>efficient</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, use the efficient O(n\u00b2) standard basis implementation. If False,           use the brute-force O(2\u207f) implementation (useful for verification).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>The LDOI projection of the input matrix.</p> </li> </ul> Source code in <code>toqito/channels/ldot_channel.py</code> <pre><code>def ldot_channel(mat: np.ndarray, efficient: bool = True) -&gt; np.ndarray:\n    r\"\"\"Apply the local diagonal orthogonal twirl (LDOT) channel to a matrix.\n\n    The LDOT channel projects a matrix onto the subspace of local diagonal\n    orthogonal invariant (LDOI) matrices. It is defined as:\n\n    \\[\n        \\Phi_O(A) = \\frac{1}{2^n} \\sum_{O \\in \\text{DO}(\\mathcal{X})} (O \\otimes O) A (O \\otimes O)\n    \\]\n\n    where \\(\\text{DO}(\\mathcal{X})\\) is the set of \\(n \\times n\\) diagonal matrices with\n    diagonal entries equal to \\(\\pm 1\\).\n\n    The LDOT channel has the following properties:\n\n    - It is a quantum channel (completely positive and trace-preserving)\n    - It is self-adjoint: \\(\\Phi_O^* = \\Phi_O\\)\n    - It preserves PPT and separability\n    - It is an orthogonal projection onto the LDOI subspace\n\n    The efficient implementation works directly in the computational basis, zeroing out the entries\n    that average to zero under the twirl. This keeps the complexity polynomial in \\(n\\) instead\n    of the exponential \\(O(2^n)\\) for the brute-force approach.\n\n    Examples:\n        Apply LDOT channel to project an arbitrary matrix onto LDOI subspace:\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.channels import ldot_channel\n        import numpy as np\n\n        # Arbitrary 2-qubit matrix\n        mat = np.array([[1, 2, 3, 4],\n                        [5, 6, 7, 8],\n                        [9, 10, 11, 12],\n                        [13, 14, 15, 16]])\n        ldoi_projection = ldot_channel(mat)\n        print(ldoi_projection)\n        ```\n\n        The LDOT channel is idempotent (applying it twice gives the same result):\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.channels import ldot_channel\n        import numpy as np\n\n        mat = np.random.rand(4, 4)\n        once = ldot_channel(mat)\n        twice = ldot_channel(once)\n        print(np.allclose(once, twice))\n        ```\n\n    Args:\n        mat: A square matrix of dimension \\(n^2 \\times n^2\\) representing a bipartite\n                operator on \\(\\mathcal{X} \\otimes \\mathcal{Y}\\) where\n                \\(\\mathcal{X} = \\mathcal{Y} = \\mathbb{C}^n\\).\n        efficient: If True, use the efficient O(n\u00b2) standard basis implementation. If False,\n                      use the brute-force O(2\u207f) implementation (useful for verification).\n\n    Returns:\n        The LDOI projection of the input matrix.\n\n    \"\"\"\n    if mat.ndim != 2 or mat.shape[0] != mat.shape[1]:\n        raise ValueError(\"Input matrix must be square.\")\n\n    if efficient:\n        return _ldot_channel_standard_basis(mat)\n    return _ldot_channel_brute_force(mat)\n</code></pre>"},{"location":"reference/toqito/channels/pauli_channel/","title":"pauli_channel","text":""},{"location":"reference/toqito/channels/pauli_channel/#toqito.channels.pauli_channel","title":"pauli_channel","text":"<p>Generates and applies Pauli Channel to a matrix.</p>"},{"location":"reference/toqito/channels/pauli_channel/#toqito.channels.pauli_channel.pauli_channel","title":"pauli_channel","text":"<pre><code>pauli_channel(prob: int | ndarray, return_kraus_ops: bool = False, input_mat: ndarray | None = None) -&gt; ndarray | csc_matrix | tuple\n</code></pre> <p>Generate and apply a Pauli channel to a matrix.</p> <p>Generates the Choi matrix of a Pauli channel with given probabilities and optionally applies it to an input matrix. The Pauli channel is defined by the set of Pauli operators weighted by the probability vector. For a given probability vector \\((p_0, \\ldots, p_{4^q -1 })\\), the channel is defined as shown below. Where, \\(q\\) is the number of qubits.</p> \\[     \\Phi(\\rho) = \\sum_{i=0}^{4^q - 1} p_i P_i \\rho P_i^* \\] <p>where \\(P_i\\) are Pauli operators generated by a lexographically increasing sequence of pauli operators of length strictly equal to \\(q\\), and \\(p_i\\) is the corresponding probability of that operator. For example, when \\(q = 2\\),</p> <p>\\(P_{0} = I \\otimes I\\), \\(P_{1} = I \\otimes X\\), \\(P_{2} = I \\otimes Y\\), \\(P_{3} = I \\otimes Z\\), \\(P_{4} = X \\otimes I\\), \\(P_{5} = X \\otimes Y , \\ldots P_{15} = Z \\otimes Z\\)</p> <p>If <code>prob</code> is a scalar, it generates a random <code>prob</code>-qubit Pauli channel. The length of the probability vector (if provided) must be \\(4^q\\) for some integer \\(q\\) (number of qubits).</p> <p>Examples:</p> <p>Generate a random single-qubit Pauli channel:</p> <pre><code>from toqito.channels import pauli_channel\n\nprint(pauli_channel(prob=1))\n</code></pre> <p>[[0.49159921+0.j 0.        +0.j 0.        +0.j 0.15778338+0.j]  [0.        +0.j 0.50840079+0.j 0.3574095 +0.j 0.        +0.j]  [0.        +0.j 0.3574095 +0.j 0.50840079+0.j 0.        +0.j]  [0.15778338+0.j 0.        +0.j 0.        +0.j 0.49159921+0.j]]</p> <p>Apply a specific two-qubit Pauli channel to an input matrix:</p> <pre><code>import numpy as np\nfrom toqito.channels import pauli_channel\n\n_, output = pauli_channel(\n    prob=np.array([0.1, 0.2, 0.3, 0.4]), input_mat=np.eye(2)\n)\nprint(output)\n</code></pre> <p>[[1.+0.j 0.+0.j]  [0.+0.j 1.+0.j]]</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If probabilities are negative or don't sum to 1.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If length of probability vector is not <code>4^q</code> for some integer <code>q</code>.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>prob</code>               (<code>int | ndarray</code>)           \u2013            <p>Probability vector for Pauli operators. If scalar, generates random probabilities for \\(q =\\) <code>prob</code></p> </li> <li> <code>return_kraus_ops</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag to return Kraus operators. Default is <code>False</code>.</p> </li> <li> <code>input_mat</code>               (<code>ndarray | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional input matrix to apply the channel to. Default is <code>None</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray | csc_matrix | tuple</code>           \u2013            <p>The Choi matrix of the channel. If <code>input_mat</code> is provided, also returns the output matrix.</p> </li> <li> <code>ndarray | csc_matrix | tuple</code>           \u2013            <p>If <code>return_kraus_ops</code> is <code>True</code>, returns Kraus operators as well.</p> </li> </ul> Source code in <code>toqito/channels/pauli_channel.py</code> <pre><code>def pauli_channel(\n    prob: int | np.ndarray, return_kraus_ops: bool = False, input_mat: np.ndarray | None = None\n) -&gt; np.ndarray | sparse.csc_matrix | tuple:\n    r\"\"\"Generate and apply a Pauli channel to a matrix.\n\n    Generates the Choi matrix of a Pauli channel with given probabilities and optionally applies it\n    to an input matrix. The Pauli channel is defined by the set of Pauli operators weighted by\n    the probability vector. For a given probability vector \\((p_0, \\ldots, p_{4^q -1 })\\), the\n    channel is defined as shown below. Where, $q$ is the number of qubits.\n\n    \\[\n        \\Phi(\\rho) = \\sum_{i=0}^{4^q - 1} p_i P_i \\rho P_i^*\n    \\]\n\n    where \\(P_i\\) are Pauli operators generated by a lexographically increasing sequence of pauli operators of\n    length strictly equal to \\(q\\), and \\(p_i\\) is the corresponding probability of that operator.\n    For example, when \\(q = 2\\),\n\n    \\(P_{0} = I \\otimes I\\), \\(P_{1} = I \\otimes X\\), \\(P_{2} = I \\otimes Y\\), \\(P_{3} = I \\otimes Z\\),\n    \\(P_{4} = X \\otimes I\\), \\(P_{5} = X \\otimes Y , \\ldots P_{15} = Z \\otimes Z\\)\n\n    If `prob` is a scalar, it generates a random `prob`-qubit Pauli channel.\n    The length of the probability vector (if provided) must be \\(4^q\\) for some\n    integer \\(q\\) (number of qubits).\n\n    Examples:\n        Generate a random single-qubit Pauli channel:\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.channels import pauli_channel\n\n        print(pauli_channel(prob=1))\n        ```\n\n        Apply a specific two-qubit Pauli channel to an input matrix:\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.channels import pauli_channel\n\n        _, output = pauli_channel(\n            prob=np.array([0.1, 0.2, 0.3, 0.4]), input_mat=np.eye(2)\n        )\n        print(output)\n        ```\n\n    Raises:\n        ValueError: If probabilities are negative or don't sum to 1.\n        ValueError: If length of probability vector is not ``4^q`` for some integer ``q``.\n\n    Args:\n        prob: Probability vector for Pauli operators. If scalar, generates random probabilities for \\(q =\\) `prob`\n        qubits. The probabilities correspond to Pauli operators in lexographical order of length strictly equal to \\(q\\)\n            ,when `prob` is a vector.\n        return_kraus_ops: Flag to return Kraus operators. Default is ``False``.\n        input_mat: Optional input matrix to apply the channel to. Default is ``None``.\n\n    Returns:\n        The Choi matrix of the channel. If ``input_mat`` is provided, also returns the output matrix.\n        If ``return_kraus_ops`` is ``True``, returns Kraus operators as well.\n\n    \"\"\"\n    if not isinstance(prob, np.ndarray):\n        if np.isscalar(prob):\n            q = prob\n            prob = np.random.rand(4**q)\n            prob /= np.sum(prob)\n        else:\n            prob = np.array(prob)\n\n    if np.any(prob &lt; 0) or not np.isclose(np.sum(prob), 1):\n        raise ValueError(\"Probabilities must be non-negative and sum to 1.\")\n\n    q = int(np.round(np.log2(len(prob)) / 2))\n    if len(prob) != 4**q:\n        raise ValueError(\"The length of the probability vector must be 4^q for some integer q (number of qubits).\")\n\n    Phi = sparse.csc_matrix((4**q, 4**q), dtype=complex)\n\n    kraus_operators = []\n    ind = np.zeros(q, dtype=int)\n\n    for j in range(len(prob)):\n        pauli_op = pauli(ind.tolist())\n        kraus_operators.append(np.sqrt(prob[j]) * pauli_op)\n        Phi += prob[j] * kraus_to_choi([[pauli_op, pauli_op.conj().T]])\n        ind = update_odometer(ind, 4 * np.ones(q, dtype=int))\n\n    output_mat = None\n    if input_mat is not None:\n        output_mat = sum(k @ input_mat @ k.conj().T for k in kraus_operators)\n\n    if return_kraus_ops:\n        return (Phi, output_mat, kraus_operators) if input_mat is not None else (Phi, kraus_operators)\n\n    return (Phi, output_mat) if input_mat is not None else Phi\n</code></pre>"},{"location":"reference/toqito/channels/phase_damping/","title":"phase_damping","text":""},{"location":"reference/toqito/channels/phase_damping/#toqito.channels.phase_damping","title":"phase_damping","text":"<p>phase damping channel.</p>"},{"location":"reference/toqito/channels/phase_damping/#toqito.channels.phase_damping.phase_damping","title":"phase_damping","text":"<pre><code>phase_damping(input_mat: ndarray | None = None, gamma: float = 0) -&gt; ndarray | list[ndarray]\n</code></pre> <p>Apply the phase damping channel to a quantum state <sup>1</sup>.</p> <p>The phase damping channel describes how quantum information is lost due to environmental interactions, causing dephasing in the computational basis without losing energy.</p> <p>The Kraus operators for the phase damping channel are:</p> \\[     K_0 = \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; \\sqrt{1 - \\gamma} \\end{pmatrix}, \\\\     K_1 = \\begin{pmatrix} 0 &amp; 0 \\\\ 0 &amp; \\sqrt{\\gamma} \\end{pmatrix}, \\] <p>Examples:</p> <p>Applying the phase damping channel to a qubit state:</p> <pre><code>import numpy as np\nfrom toqito.channels.phase_damping import phase_damping\n\nrho = np.array([[1, 0.5], [0.5, 1]])\nresult = phase_damping(rho, gamma=0.2)\n\nprint(result)\n</code></pre> <p>[[1.       +0.j 0.4472136+0.j]  [0.4472136+0.j 1.       +0.j]]</p> <p>Parameters:</p> <ul> <li> <code>input_mat</code>               (<code>ndarray | None</code>, default:                   <code>None</code> )           \u2013            <p>The input matrix to apply the channel to. If <code>None</code>, the function returns the Kraus operators.</p> </li> <li> <code>gamma</code>               (<code>float</code>, default:                   <code>0</code> )           \u2013            <p>The dephasing rate (between 0 and 1), representing the probability of phase decoherence.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray | list[ndarray]</code>           \u2013            <p>The transformed quantum state after applying the phase damping channel. If <code>input_mat</code> is <code>None</code>, returns the</p> </li> <li> <code>ndarray | list[ndarray]</code>           \u2013            <p>list of Kraus operators.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Nielsen, Michael and Chuang, Isaac. Quantum Computation and Quantum Information: 10th Anniversary Edition. (2011).</p> Source code in <code>toqito/channels/phase_damping.py</code> <pre><code>def phase_damping(\n    input_mat: np.ndarray | None = None,\n    gamma: float = 0,\n) -&gt; np.ndarray | list[np.ndarray]:\n    r\"\"\"Apply the phase damping channel to a quantum state [@Chuang_2011_Quantum].\n\n    The phase damping channel describes how quantum information is lost due to environmental interactions,\n    causing dephasing in the computational basis without losing energy.\n\n    The Kraus operators for the phase damping channel are:\n\n    \\[\n        K_0 = \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; \\sqrt{1 - \\gamma} \\end{pmatrix}, \\\\\n        K_1 = \\begin{pmatrix} 0 &amp; 0 \\\\ 0 &amp; \\sqrt{\\gamma} \\end{pmatrix},\n    \\]\n\n    Examples:\n        Applying the phase damping channel to a qubit state:\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.channels.phase_damping import phase_damping\n\n        rho = np.array([[1, 0.5], [0.5, 1]])\n        result = phase_damping(rho, gamma=0.2)\n\n        print(result)\n        ```\n\n    Args:\n        input_mat: The input matrix to apply the channel to. If `None`, the function returns the Kraus operators.\n        gamma: The dephasing rate (between 0 and 1), representing the probability of phase decoherence.\n\n    Returns:\n        The transformed quantum state after applying the phase damping channel. If `input_mat` is `None`, returns the\n        list of Kraus operators.\n\n    \"\"\"\n    if not (0 &lt;= gamma &lt;= 1):\n        raise ValueError(\"Gamma must be between 0 and 1.\")\n\n    k0 = np.diag([1, np.sqrt(1 - gamma)])\n    k1 = np.diag([0, np.sqrt(gamma)])\n\n    if input_mat is not None and input_mat.shape != (2, 2):\n        raise ValueError(\"Input matrix must be 2x2 for the phase damping channel.\")\n    elif input_mat is None:\n        return [k0, k1]\n\n    input_mat = np.asarray(input_mat, dtype=complex)\n\n    return k0 @ input_mat @ k0.conj().T + k1 @ input_mat @ k1.conj().T\n</code></pre>"},{"location":"reference/toqito/channels/realignment/","title":"realignment","text":""},{"location":"reference/toqito/channels/realignment/#toqito.channels.realignment","title":"realignment","text":"<p>Generates the realignment channel of a matrix.</p>"},{"location":"reference/toqito/channels/realignment/#toqito.channels.realignment.realignment","title":"realignment","text":"<pre><code>realignment(input_mat: ndarray, dim: int | list[int] | ndarray | None = None) -&gt; ndarray\n</code></pre> <p>Compute the realignment of a bipartite operator <sup>1</sup>.</p> <p>Gives the realignment of the matrix <code>input_mat</code>, where it is assumed that the number of rows and columns of <code>input_mat</code> are both perfect squares and both subsystems have equal dimension. The realignment is defined by mapping the operator \\(|ij \\rangle \\langle kl |\\) to \\(|ik \\rangle \\langle jl |\\) and extending linearly.</p> <p>If <code>input_mat</code> is non-square, different row and column dimensions can be specified by putting the row dimensions in the first row of <code>dim</code> and the column dimensions in the second row of <code>dim</code>.</p> <p>Examples:</p> <p>The standard realignment map</p> <p>Using <code>|toqito\u27e9</code>, we can generate the standard realignment map as follows. When viewed as a map on block matrices, the realignment map takes each block of the original matrix and makes its vectorization the rows of the realignment matrix. This is illustrated by the following small example:</p> <pre><code>import numpy as np\nfrom toqito.channels import realignment\n\ntest_input_mat = np.arange(1, 17).reshape(4, 4)\n\nprint(realignment(test_input_mat))\n</code></pre> <p>[[ 1  2  5  6]  [ 3  4  7  8]  [ 9 10 13 14]  [11 12 15 16]]</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If dimension of matrix is invalid.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>input_mat</code>               (<code>ndarray</code>)           \u2013            <p>The input matrix.</p> </li> <li> <code>dim</code>               (<code>int | list[int] | ndarray | None</code>, default:                   <code>None</code> )           \u2013            <p>Default has all equal dimensions.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>The realignment map matrix.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Lupo, Cosmo and Aniello, Paolo and Scardicchio, Antonello. Bipartite quantum systems: on the realignment criterion and beyond. Journal of Physics A: Mathematical and Theoretical. vol. 41(41). (2008). link.</p> Source code in <code>toqito/channels/realignment.py</code> <pre><code>def realignment(input_mat: np.ndarray, dim: int | list[int] | np.ndarray | None = None) -&gt; np.ndarray:\n    r\"\"\"Compute the realignment of a bipartite operator [@Lupo_2008_Bipartite].\n\n    Gives the realignment of the matrix `input_mat`, where it is assumed that the number\n    of rows and columns of `input_mat` are both perfect squares and both subsystems have\n    equal dimension. The realignment is defined by mapping the operator \\(|ij \\rangle\n    \\langle kl |\\) to \\(|ik \\rangle \\langle jl |\\) and extending linearly.\n\n    If `input_mat` is non-square, different row and column dimensions can be specified by\n    putting the row dimensions in the first row of `dim` and the column dimensions in the\n    second row of `dim`.\n\n    Examples:\n        The standard realignment map\n\n        Using `|toqito\u27e9`, we can generate the standard realignment map as follows. When viewed as a\n        map on block matrices, the realignment map takes each block of the original matrix and makes\n        its vectorization the rows of the realignment matrix. This is illustrated by the following\n        small example:\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.channels import realignment\n\n        test_input_mat = np.arange(1, 17).reshape(4, 4)\n\n        print(realignment(test_input_mat))\n        ```\n\n    Raises:\n        ValueError: If dimension of matrix is invalid.\n\n    Args:\n        input_mat: The input matrix.\n        dim: Default has all equal dimensions.\n\n    Returns:\n        The realignment map matrix.\n\n    \"\"\"\n    dim_mat = input_mat.shape\n    round_dim = np.round(np.sqrt(dim_mat))\n    if dim is None:\n        dim_arr = np.transpose(np.array([round_dim]))\n    elif isinstance(dim, list):\n        dim_arr = np.array(dim)\n    elif isinstance(dim, int):\n        dim_arr = np.array([int(dim), int(dim_mat[0] / dim)])\n        dim_arr[1] = np.round(dim_arr[1])\n    else:\n        dim_arr = dim\n\n    # Dimension if row vector.\n    if len(dim_arr.shape) == 1:\n        dim_arr = dim_arr[:].T\n        dim_arr = np.array([dim_arr, dim_arr])\n\n    # Dimension is column vector.\n    if min(dim_arr.shape) == 1:\n        dim_arr = dim_arr[:].T[0]\n        dim_arr = np.array([dim_arr, dim_arr])\n\n    dim_x = np.array([[dim_arr[0][1], dim_arr[0][0]], [dim_arr[1][0], dim_arr[1][1]]])\n    dim_x = np.int_(dim_x)\n    dim_y = np.array([[dim_arr[1][0], dim_arr[0][0]], [dim_arr[0][1], dim_arr[1][1]]])\n\n    x_tmp = swap(input_mat, [1, 2], dim_arr, True)\n    y_tmp = partial_transpose(x_tmp, [0], dim_x)\n\n    return swap(y_tmp, [1, 2], dim_y, True)\n</code></pre>"},{"location":"reference/toqito/channels/reduction/","title":"reduction","text":""},{"location":"reference/toqito/channels/reduction/#toqito.channels.reduction","title":"reduction","text":"<p>Generates the reduction channel.</p>"},{"location":"reference/toqito/channels/reduction/#toqito.channels.reduction.reduction","title":"reduction","text":"<pre><code>reduction(dim: int, k: int = 1) -&gt; ndarray\n</code></pre> <p>Produce the reduction map or reduction channel <sup>1</sup>.</p> <p>If <code>k = 1</code>, this returns the Choi matrix of the reduction map which is a positive map on <code>dim</code>-by-<code>dim</code> matrices. For a different value of <code>k</code>, this yields the Choi matrix of the map defined by:</p> \\[     R(X) = k * \\text{Tr}(X) * \\mathbb{I} - X, \\] <p>where \\(\\mathbb{I}\\) is the identity matrix. This map is \\(k\\)-positive.</p> <p>Examples:</p> <p>Using <code>|toqito\u27e9</code>, we can generate the \\(3\\)-dimensional (or standard) reduction map as follows.</p> <pre><code>from toqito.channels import reduction\n\nprint(reduction(3))\n</code></pre> <p>[[ 0.  0.  0.  0. -1.  0.  0.  0. -1.]  [ 0.  1.  0.  0.  0.  0.  0.  0.  0.]  [ 0.  0.  1.  0.  0.  0.  0.  0.  0.]  [ 0.  0.  0.  1.  0.  0.  0.  0.  0.]  [-1.  0.  0.  0.  0.  0.  0.  0. -1.]  [ 0.  0.  0.  0.  0.  1.  0.  0.  0.]  [ 0.  0.  0.  0.  0.  0.  1.  0.  0.]  [ 0.  0.  0.  0.  0.  0.  0.  1.  0.]  [-1.  0.  0.  0. -1.  0.  0.  0.  0.]]</p> <p>Parameters:</p> <ul> <li> <code>dim</code>               (<code>int</code>)           \u2013            <p>A positive integer (the dimension of the reduction map).</p> </li> <li> <code>k</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>If this positive integer is provided, the script will instead return the Choi matrix of the following</p> </li> <li> <code>linear map</code>           \u2013            <p>Phi(X) := K * Tr(X)I - X.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>The reduction map.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Reduction Criterion. link.</p> Source code in <code>toqito/channels/reduction.py</code> <pre><code>def reduction(dim: int, k: int = 1) -&gt; np.ndarray:\n    r\"\"\"Produce the reduction map or reduction channel [@WikiReductionCrit].\n\n    If `k = 1`, this returns the Choi matrix of the reduction map which is a positive map\n    on `dim`-by-`dim` matrices. For a different value of `k`, this yields the\n    Choi matrix of the map defined by:\n\n    \\[\n        R(X) = k * \\text{Tr}(X) * \\mathbb{I} - X,\n    \\]\n\n    where \\(\\mathbb{I}\\) is the identity matrix. This map is \\(k\\)-positive.\n\n    Examples:\n        Using `|toqito\u27e9`, we can generate the \\(3\\)-dimensional (or standard) reduction map\n        as follows.\n\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.channels import reduction\n\n        print(reduction(3))\n        ```\n\n    Args:\n        dim: A positive integer (the dimension of the reduction map).\n        k: If this positive integer is provided, the script will instead return the Choi matrix of the following\n        linear map: Phi(X) := K * Tr(X)I - X.\n\n    Returns:\n        The reduction map.\n\n    \"\"\"\n    psi = max_entangled(dim, False, False)\n    identity_matrix = identity(dim**2)\n    return k * identity_matrix.toarray() - psi @ psi.conj().T\n</code></pre>"},{"location":"reference/toqito/helper/","title":"helper","text":""},{"location":"reference/toqito/helper/#toqito.helper","title":"helper","text":"<p>Helper is a set of modules that implements helper functions for dealing with cvxpy objects.</p>"},{"location":"reference/toqito/helper/expr_as_np_array/","title":"expr_as_np_array","text":""},{"location":"reference/toqito/helper/expr_as_np_array/#toqito.helper.expr_as_np_array","title":"expr_as_np_array","text":"<p>Converts a Cvxpy expression into a np.array.</p>"},{"location":"reference/toqito/helper/expr_as_np_array/#toqito.helper.expr_as_np_array.expr_as_np_array","title":"expr_as_np_array","text":"<pre><code>expr_as_np_array(cvx_expr: Expression) -&gt; ndarray\n</code></pre> <p>Convert cvxpy expression into a numpy array.</p> <p>Parameters:</p> <ul> <li> <code>cvx_expr</code>               (<code>Expression</code>)           \u2013            <p>The cvxpy expression to be converted.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>The numpy array of the cvxpy expression.</p> </li> </ul> Source code in <code>toqito/helper/expr_as_np_array.py</code> <pre><code>def expr_as_np_array(cvx_expr: Expression) -&gt; np.ndarray:\n    \"\"\"Convert cvxpy expression into a numpy array.\n\n    Args:\n        cvx_expr: The cvxpy expression to be converted.\n\n    Returns:\n        The numpy array of the cvxpy expression.\n\n    \"\"\"\n    if cvx_expr.is_scalar():\n        return np.array(cvx_expr)\n    if len(cvx_expr.shape) == 1:\n        return np.array(list(cvx_expr))\n    # Then cvx_expr is a 2-D array.\n    rows = []\n    for i in range(cvx_expr.shape[0]):\n        row = [cvx_expr[i, j] for j in range(cvx_expr.shape[1])]\n        rows.append(row)\n    arr = np.array(rows)\n    return arr\n</code></pre>"},{"location":"reference/toqito/helper/np_array_as_expr/","title":"np_array_as_expr","text":""},{"location":"reference/toqito/helper/np_array_as_expr/#toqito.helper.np_array_as_expr","title":"np_array_as_expr","text":"<p>Converts a np.array object to cvxpy expression object.</p>"},{"location":"reference/toqito/helper/np_array_as_expr/#toqito.helper.np_array_as_expr.np_array_as_expr","title":"np_array_as_expr","text":"<pre><code>np_array_as_expr(np_arr: ndarray) -&gt; Expression\n</code></pre> <p>Convert numpy array into a cvxpy expression.</p> <p>Parameters:</p> <ul> <li> <code>np_arr</code>               (<code>ndarray</code>)           \u2013            <p>The numpy array to be converted.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Expression</code>           \u2013            <p>The cvxpy expression of the numpy array.</p> </li> </ul> Source code in <code>toqito/helper/np_array_as_expr.py</code> <pre><code>def np_array_as_expr(np_arr: np.ndarray) -&gt; Expression:\n    \"\"\"Convert numpy array into a cvxpy expression.\n\n    Args:\n        np_arr: The numpy array to be converted.\n\n    Returns:\n        The cvxpy expression of the numpy array.\n\n    \"\"\"\n    as_list = np_arr.tolist()\n    expr = bmat(as_list)\n    return expr\n</code></pre>"},{"location":"reference/toqito/helper/update_odometer/","title":"update_odometer","text":""},{"location":"reference/toqito/helper/update_odometer/#toqito.helper.update_odometer","title":"update_odometer","text":"<p>Updates the odometer.</p>"},{"location":"reference/toqito/helper/update_odometer/#toqito.helper.update_odometer.update_odometer","title":"update_odometer","text":"<pre><code>update_odometer(old_ind: list[int] | ndarray, upper_lim: list[int] | ndarray) -&gt; list[int] | ndarray\n</code></pre> <p>Increase a vector as odometer.</p> <p>Increases the last entry of the vector <code>old_ind</code> by 1, unless that would make it larger than the last entry of the vector <code>upper_lim</code>. In this case, it sets the last entry to 0 and instead increases the second-last entry of <code>old_ind</code>, unless that would make it larger than the second-last entry of <code>upper_lim</code>. In this case, it sets the second-last entry to 0 and instead increases the third-last entry of <code>old_ind</code> (and so on; it works like an odometer).</p> <p>This function is useful when you want to have k nested loops, but k isn't specified beforehand. For example, instead of looping over i and j going from 1 to 3, you could loop over a single variable going from 1 to 3^2 and set [i, j] = update_odometer([i, j], [3, 3]) at each step within the loop.</p> <p>This function is adapted from QETLAB <sup>1</sup>.</p> <p>Examples:</p> <pre><code>from toqito.helper import update_odometer\nimport numpy as np\nvec = np.array([0, 0])\nupper_lim = np.array([3, 2])\nfor j in range(0, np.prod(upper_lim)-1):\n        vec = update_odometer(vec, upper_lim)\n        print(vec)\n</code></pre> <p>[0 1][1 0] [1 1][2 0] [2 1]</p> <p>Parameters:</p> <ul> <li> <code>old_ind</code>               (<code>list[int] | ndarray</code>)           \u2013            <p>The initial vector.</p> </li> <li> <code>upper_lim</code>               (<code>list[int] | ndarray</code>)           \u2013            <p>The upper limit on which to increase the odometer to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[int] | ndarray</code>           \u2013            <p>The updated vector.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Johnston, Nathaniel. {{QETLAB}: {A MATLAB} toolbox for quantum entanglement}. doi:10.5281/zenodo.44637.</p> Source code in <code>toqito/helper/update_odometer.py</code> <pre><code>def update_odometer(old_ind: list[int] | np.ndarray, upper_lim: list[int] | np.ndarray) -&gt; list[int] | np.ndarray:\n    r\"\"\"Increase a vector as odometer.\n\n    Increases the last entry of the vector `old_ind` by 1, unless that would\n    make it larger than the last entry of the vector `upper_lim`. In this case,\n    it sets the last entry to 0 and instead increases the second-last entry of\n    `old_ind`, unless that would make it larger than the second-last entry of\n    `upper_lim`. In this case, it sets the second-last entry to 0 and instead\n    increases the third-last entry of `old_ind` (and so on; it works like an\n    odometer).\n\n    This function is useful when you want to have k nested loops, but k isn't\n    specified beforehand. For example, instead of looping over i and j going\n    from 1 to 3, you could loop over a single variable going from 1 to 3^2 and\n    set [i, j] = update_odometer([i, j], [3, 3]) at each step within the loop.\n\n    This function is adapted from QETLAB [@QETLAB_link].\n\n    Examples:\n        ```python exec=\"1\" source=\"above\"\n        from toqito.helper import update_odometer\n        import numpy as np\n        vec = np.array([0, 0])\n        upper_lim = np.array([3, 2])\n        for j in range(0, np.prod(upper_lim)-1):\n                vec = update_odometer(vec, upper_lim)\n                print(vec)\n        ```\n\n    Args:\n        old_ind: The initial vector.\n        upper_lim: The upper limit on which to increase the odometer to.\n\n    Returns:\n        The updated vector.\n\n    \"\"\"\n    ind_len = len(old_ind)\n    new_ind = old_ind[:]\n\n    # Start by increasing the last index by 1.\n    if len(new_ind) &gt; 0:\n        new_ind[-1] = new_ind[-1] + 1\n\n    # Increment the \"odometer\": Repeatedly set each digit to 0 if it is too high\n    # and carry the addition to the left until we hit a digit that is not too\n    # high.\n    for j in range(ind_len, 0, -1):\n        # If we have hit the upper limit in this entry, move onto the next\n        # entry.\n        if new_ind[j - 1] &gt;= upper_lim[j - 1]:\n            new_ind[j - 1] = 0\n            if j &gt;= 2:\n                new_ind[j - 2] = new_ind[j - 2] + 1\n            else:\n                # We are at the left end of the vector, so just stop.\n                return new_ind\n        else:\n            # Always return if the odometer doesn't turn over.\n            return new_ind\n    return new_ind\n</code></pre>"},{"location":"reference/toqito/matrices/","title":"matrices","text":""},{"location":"reference/toqito/matrices/#toqito.matrices","title":"matrices","text":"<p>Matrices is a set of modules that are used to implement commonly used matrices.</p>"},{"location":"reference/toqito/matrices/cnot/","title":"cnot","text":""},{"location":"reference/toqito/matrices/cnot/#toqito.matrices.cnot","title":"cnot","text":"<p>CNOT matrix generates the CNOT operator matrix.</p>"},{"location":"reference/toqito/matrices/cnot/#toqito.matrices.cnot.cnot","title":"cnot","text":"<pre><code>cnot() -&gt; ndarray\n</code></pre> <p>Produce the CNOT matrix <sup>1</sup>.</p> <p>The CNOT matrix is defined as</p> \\[     \\text{CNOT} =     \\begin{pmatrix}         1 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 1 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 1 \\\\         0 &amp; 0 &amp; 1 &amp; 0     \\end{pmatrix}. \\] <p>Examples:</p> <pre><code>from toqito.matrices import cnot\n\nprint(cnot())\n</code></pre> <p>[[1 0 0 0]  [0 1 0 0]  [0 0 0 1]  [0 0 1 0]]</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>The CNOT matrix.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Controlled NOT gate. link.</p> Source code in <code>toqito/matrices/cnot.py</code> <pre><code>def cnot() -&gt; np.ndarray:\n    r\"\"\"Produce the CNOT matrix [@WikiCNOT].\n\n    The CNOT matrix is defined as\n\n    \\[\n        \\text{CNOT} =\n        \\begin{pmatrix}\n            1 &amp; 0 &amp; 0 &amp; 0 \\\\\n            0 &amp; 1 &amp; 0 &amp; 0 \\\\\n            0 &amp; 0 &amp; 0 &amp; 1 \\\\\n            0 &amp; 0 &amp; 1 &amp; 0\n        \\end{pmatrix}.\n    \\]\n\n    Examples:\n        ```python exec=\"1\" source=\"above\"\n        from toqito.matrices import cnot\n\n        print(cnot())\n        ```\n\n    Returns:\n        The CNOT matrix.\n\n    \"\"\"\n    return np.array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]])\n</code></pre>"},{"location":"reference/toqito/matrices/comparison/","title":"comparison","text":""},{"location":"reference/toqito/matrices/comparison/#toqito.matrices.comparison","title":"comparison","text":"<p>Computes comparison matrix.</p>"},{"location":"reference/toqito/matrices/comparison/#toqito.matrices.comparison.comparison","title":"comparison","text":"<pre><code>comparison(mat: ndarray) -&gt; ndarray\n</code></pre> <p>Compute comparison matrix of a given square matrix.</p> <p>This function computes the comparison matrix \\(M(A)\\) for a square matrix \\(A\\) as defined in <sup>1</sup>. For each entry, the diagonal entries are given by the absolute value of the original diagonal entries of \\(A\\), while the off-diagonal entries are given by minus the absolute value of the corresponding entries. In other words,</p> \\[     m_{ij} =     \\begin{cases}     |a_{ij}|, &amp; \\text{if } i = j, \\\\     -|a_{ij}|, &amp; \\text{if } i \\neq j.     \\end{cases} \\] <p>Examples:</p> <pre><code>import numpy as np\nfrom toqito.matrices import comparison\nA = np.array([[2, -1],\n            [3, 4]])\nprint(comparison(A))\n</code></pre> <p>[[ 2. -1.]  [-3.  4.]]</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the input matrix is not square.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>mat</code>               (<code>ndarray</code>)           \u2013            <p>The input square matrix.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>The comparison matrix of the input matrix.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Comparison matrix. link.</p> Source code in <code>toqito/matrices/comparison.py</code> <pre><code>def comparison(mat: np.ndarray) -&gt; np.ndarray:\n    r\"\"\"Compute comparison matrix of a given square matrix.\n\n    This function computes the comparison matrix \\(M(A)\\) for a square matrix \\(A\\) as defined in\n    [@WikiComparisonMatrix]. For each entry, the diagonal entries are given by the absolute value of the\n    original diagonal entries of \\(A\\), while the off-diagonal entries are given by minus the absolute value of the\n    corresponding entries. In other words,\n\n    \\[\n        m_{ij} =\n        \\begin{cases}\n        |a_{ij}|, &amp; \\text{if } i = j, \\\\\n        -|a_{ij}|, &amp; \\text{if } i \\neq j.\n        \\end{cases}\n    \\]\n\n    Examples:\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrices import comparison\n        A = np.array([[2, -1],\n                    [3, 4]])\n        print(comparison(A))\n        ```\n\n    Raises:\n        ValueError: If the input matrix is not square.\n\n    Args:\n        mat: The input square matrix.\n\n    Returns:\n        The comparison matrix of the input matrix.\n\n    \"\"\"\n    if len(mat.shape) != 2 or mat.shape[0] != mat.shape[1]:\n        raise ValueError(\"Input matrix must be square.\")\n\n    # Compute the matrix whose off-diagonal entries are -|a_{ij}|.\n    cmp_mat = -np.abs(mat).astype(float)\n    # Replace the diagonal with the absolute values of the original diagonal.\n    np.fill_diagonal(cmp_mat, np.abs(np.diag(mat)))\n    return cmp_mat\n</code></pre>"},{"location":"reference/toqito/matrices/cyclic_permutation_matrix/","title":"cyclic_permutation_matrix","text":""},{"location":"reference/toqito/matrices/cyclic_permutation_matrix/#toqito.matrices.cyclic_permutation_matrix","title":"cyclic_permutation_matrix","text":"<p>Generates a cyclic permutation matrix.</p>"},{"location":"reference/toqito/matrices/cyclic_permutation_matrix/#toqito.matrices.cyclic_permutation_matrix.cyclic_permutation_matrix","title":"cyclic_permutation_matrix","text":"<pre><code>cyclic_permutation_matrix(n: int, k: int = 1) -&gt; ndarray\n</code></pre> <p>Create the cyclic permutation matrix for a given dimension <code>n</code> <sup>1</sup>.</p> <p>This function creates a cyclic permutation matrix of 0's and 1's which is a special type of square matrix that represents a cyclic permutation of its rows. The function allows fixed points and successive applications.</p> <p>Examples:</p> <p>Generate fixed point.</p> <pre><code>from toqito.matrices import cyclic_permutation_matrix\n\nprint(cyclic_permutation_matrix(n=4))\n</code></pre> <p>[[0 0 0 1]  [1 0 0 0]  [0 1 0 0]  [0 0 1 0]]</p> <p>Generate successive application.</p> <pre><code>from toqito.matrices import cyclic_permutation_matrix\n\nprint(cyclic_permutation_matrix(n=4, k=3))\n</code></pre> <p>[[0 1 0 0]  [0 0 1 0]  [0 0 0 1]  [1 0 0 0]]</p> <p>Parameters:</p> <ul> <li> <code>n</code>               (<code>int</code>)           \u2013            <p>int The number of rows and columns in the cyclic permutation matrix.</p> </li> <li> <code>k</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>int The power to which the elements are raised, representing successive applications.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>A NumPy array representing a cyclic permutation matrix of dimension <code>n x n</code>. Each row of the matrix is shifted</p> </li> <li> <code>ndarray</code>           \u2013            <p>one position to the right in a cyclic manner, creating a circular permutation pattern. If <code>k</code> is specified, the</p> </li> <li> <code>ndarray</code>           \u2013            <p>function raises the matrix to the power of <code>k</code>, representing successive applications of the cyclic permutation.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Cyclic permutation. link.</p> Source code in <code>toqito/matrices/cyclic_permutation_matrix.py</code> <pre><code>def cyclic_permutation_matrix(n: int, k: int = 1) -&gt; np.ndarray:\n    r\"\"\"Create the cyclic permutation matrix for a given dimension `n` [@WikiCyclicPermutation].\n\n    This function creates a cyclic permutation matrix of 0's and 1's which is a special type of square matrix\n    that represents a cyclic permutation of its rows. The function allows fixed points and successive applications.\n\n    Examples:\n        Generate fixed point.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.matrices import cyclic_permutation_matrix\n\n        print(cyclic_permutation_matrix(n=4))\n        ```\n\n        Generate successive application.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.matrices import cyclic_permutation_matrix\n\n        print(cyclic_permutation_matrix(n=4, k=3))\n        ```\n\n\n\n    Args:\n        n: int The number of rows and columns in the cyclic permutation matrix.\n        k: int The power to which the elements are raised, representing successive applications.\n\n    Returns:\n         A NumPy array representing a cyclic permutation matrix of dimension `n x n`. Each row of the matrix is shifted\n         one position to the right in a cyclic manner, creating a circular permutation pattern. If `k` is specified, the\n         function raises the matrix to the power of `k`, representing successive applications of the cyclic permutation.\n\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"'n' must be an integer.\")\n    if n &lt;= 0:\n        raise ValueError(\"'n' must be a positive integer.\")\n    if not isinstance(k, int):\n        raise TypeError(\"'k' must be an integer.\")\n\n    p_mat = np.zeros((n, n), dtype=int)\n    np.fill_diagonal(p_mat[1:], 1)\n    p_mat[0, -1] = 1\n\n    result_mat = np.linalg.matrix_power(p_mat, k)\n    return result_mat\n</code></pre>"},{"location":"reference/toqito/matrices/fourier/","title":"fourier","text":""},{"location":"reference/toqito/matrices/fourier/#toqito.matrices.fourier","title":"fourier","text":"<p>Generates a Fourier matrix.</p>"},{"location":"reference/toqito/matrices/fourier/#toqito.matrices.fourier.fourier","title":"fourier","text":"<pre><code>fourier(dim: int) -&gt; ndarray\n</code></pre> <p>Generate the Fourier transform matrix <sup>1</sup>.</p> <p>Generates the <code>dim</code>-by-<code>dim</code> unitary matrix that implements the quantum Fourier transform.</p> <p>The Fourier matrix is defined as:</p> \\[     W_N = \\frac{1}{\\sqrt{N}}     \\begin{pmatrix}         1 &amp; 1 &amp; 1 &amp; 1 &amp; \\ldots &amp; 1 \\\\         1 &amp; \\omega &amp; \\omega^2 &amp; \\omega^3 &amp; \\ldots &amp; \\omega^{N-1} \\\\         1 &amp; \\omega^2 &amp; \\omega^4 &amp; \\omega^6 &amp; \\ldots &amp; \\omega^{2(N-1)} \\\\         1 &amp; \\omega^3 &amp; \\omega^6 &amp; \\omega^9 &amp; \\ldots &amp; \\omega^{3(N-1)} \\\\         \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\         1 &amp; \\omega^{N-1} &amp; \\omega^{2(N-1)} &amp; \\omega^{3(N-1)} &amp;         \\ldots &amp; \\omega^{(N-1)(N-1)}     \\end{pmatrix} \\] <p>Examples:</p> <p>The Fourier matrix generated from \\(d = 3\\) yields the following matrix:</p> \\[     W_3 = \\frac{1}{\\sqrt{3}}     \\begin{pmatrix}         1 &amp; 1 &amp; 1 \\\\         1 &amp; \\omega &amp; \\omega^2 \\\\         1 &amp; \\omega^2 &amp; \\omega^4     \\end{pmatrix} \\] <pre><code>from toqito.matrices import fourier\n\nprint(fourier(3))\n</code></pre> <p>[[ 0.57735027+0.j   0.57735027+0.j   0.57735027+0.j ]  [ 0.57735027+0.j  -0.28867513+0.5j -0.28867513-0.5j]  [ 0.57735027+0.j  -0.28867513-0.5j -0.28867513+0.5j]]</p> <p>Parameters:</p> <ul> <li> <code>dim</code>               (<code>int</code>)           \u2013            <p>The size of the Fourier matrix.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>The Fourier matrix of dimension <code>dim</code>.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. {DFT} matrix. link.</p> Source code in <code>toqito/matrices/fourier.py</code> <pre><code>def fourier(dim: int) -&gt; np.ndarray:\n    r\"\"\"Generate the Fourier transform matrix [@WikiDFT].\n\n    Generates the `dim`-by-`dim` unitary matrix that implements the\n    quantum Fourier transform.\n\n    The Fourier matrix is defined as:\n\n    \\[\n        W_N = \\frac{1}{\\sqrt{N}}\n        \\begin{pmatrix}\n            1 &amp; 1 &amp; 1 &amp; 1 &amp; \\ldots &amp; 1 \\\\\n            1 &amp; \\omega &amp; \\omega^2 &amp; \\omega^3 &amp; \\ldots &amp; \\omega^{N-1} \\\\\n            1 &amp; \\omega^2 &amp; \\omega^4 &amp; \\omega^6 &amp; \\ldots &amp; \\omega^{2(N-1)} \\\\\n            1 &amp; \\omega^3 &amp; \\omega^6 &amp; \\omega^9 &amp; \\ldots &amp; \\omega^{3(N-1)} \\\\\n            \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\\n            1 &amp; \\omega^{N-1} &amp; \\omega^{2(N-1)} &amp; \\omega^{3(N-1)} &amp;\n            \\ldots &amp; \\omega^{(N-1)(N-1)}\n        \\end{pmatrix}\n    \\]\n\n    Examples:\n        The Fourier matrix generated from \\(d = 3\\) yields the following matrix:\n\n        \\[\n            W_3 = \\frac{1}{\\sqrt{3}}\n            \\begin{pmatrix}\n                1 &amp; 1 &amp; 1 \\\\\n                1 &amp; \\omega &amp; \\omega^2 \\\\\n                1 &amp; \\omega^2 &amp; \\omega^4\n            \\end{pmatrix}\n        \\]\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.matrices import fourier\n\n        print(fourier(3))\n        ```\n\n    Args:\n        dim: The size of the Fourier matrix.\n\n    Returns:\n        The Fourier matrix of dimension `dim`.\n\n    \"\"\"\n    # Primitive root of unity.\n    root_unity = np.exp(2 * 1j * np.pi / dim)\n    entry_1 = np.arange(0, dim)[:, None]\n    entry_2 = np.arange(0, dim)\n    return np.power(root_unity, entry_1 * entry_2) / np.sqrt(dim)\n</code></pre>"},{"location":"reference/toqito/matrices/gell_mann/","title":"gell_mann","text":""},{"location":"reference/toqito/matrices/gell_mann/#toqito.matrices.gell_mann","title":"gell_mann","text":"<p>Generates the Gell-Mann operator matrices.</p>"},{"location":"reference/toqito/matrices/gell_mann/#toqito.matrices.gell_mann.gell_mann","title":"gell_mann","text":"<pre><code>gell_mann(ind: int, is_sparse: bool = False) -&gt; ndarray | csr_array\n</code></pre> <p>Produce a Gell-Mann operator <sup>1</sup>.</p> <p>Generates the 3-by-3 Gell-Mann matrix indicated by the value of <code>ind</code>.  When <code>ind = 0</code> gives the identity matrix, while values 1 through 8 each indicate one of the other 8 Gell-Mann matrices.</p> <p>The 9 Gell-Mann matrices are defined as follows:</p> \\[     \\begin{equation}         \\begin{aligned}             \\lambda_0 = \\begin{pmatrix}                             1 &amp; 0 &amp; 0 \\\\                             0 &amp; 1 &amp; 0 \\\\                             0 &amp; 0 &amp; 1                         \\end{pmatrix}, \\quad             \\lambda_1 = \\begin{pmatrix}                             0 &amp; 1 &amp; 0 \\\\                             1 &amp; 0 &amp; 0 \\\\                             0 &amp; 0 &amp; 0                         \\end{pmatrix}, \\quad &amp;             \\lambda_2 = \\begin{pmatrix}                             0 &amp; -i &amp; 0 \\\\                             i &amp; 0 &amp; 0 \\\\                             0 &amp; 0 &amp; 0                         \\end{pmatrix},  \\\\             \\lambda_3 = \\begin{pmatrix}                             1 &amp; 0 &amp; 0 \\\\                             0 &amp; -1 &amp; 0 \\\\                             0 &amp; 0 &amp; 0                         \\end{pmatrix}, \\quad             \\lambda_4 = \\begin{pmatrix}                             0 &amp; 0 &amp; 1 \\\\                             0 &amp; 0 &amp; 0 \\\\                             1 &amp; 0 &amp; 0                         \\end{pmatrix}, \\quad &amp;             \\lambda_5 = \\begin{pmatrix}                             0 &amp; 0 &amp; -i \\\\                             0 &amp; 0 &amp; 0 \\\\                             i &amp; 0 &amp; 0                         \\end{pmatrix},  \\\\             \\lambda_6 = \\begin{pmatrix}                             0 &amp; 0 &amp; 0 \\\\                             0 &amp; 0 &amp; 1 \\\\                             0 &amp; 1 &amp; 0                         \\end{pmatrix}, \\quad             \\lambda_7 = \\begin{pmatrix}                             0 &amp; 0 &amp; 0 \\\\                             0 &amp; 0 &amp; -i \\\\                             0 &amp; i &amp; 0                         \\end{pmatrix}, \\quad &amp;             \\lambda_8 = \\frac{1}{\\sqrt{3}} \\begin{pmatrix}                                                 1 &amp; 0 &amp; 0 \\\\                                                 0 &amp; 1 &amp; 0 \\\\                                                 0 &amp; 0 &amp; -2                                             \\end{pmatrix}.             \\end{aligned}         \\end{equation} \\] <p>Examples:</p> <p>The Gell-Mann matrix generated from <code>idx = 2</code> yields the following matrix:</p> <p>[     \\lambda_2 = \\begin{pmatrix}                         0 &amp; -i &amp; 0 \\                         i &amp; 0 &amp; 0 \\                         0 &amp; 0 &amp; 0                 \\end{pmatrix} ] <pre><code>from toqito.matrices import gell_mann\n\nprint(gell_mann(ind=2))\n</code></pre> <p>[[ 0.+0.j -0.-1.j  0.+0.j]  [ 0.+1.j  0.+0.j  0.+0.j]  [ 0.+0.j  0.+0.j  0.+0.j]]</p></p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>Indices must be integers between 0 and 8.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>ind</code>               (<code>int</code>)           \u2013            <p>An integer between 0 and 8 (inclusive).</p> </li> <li> <code>is_sparse</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Boolean to determine whether array is sparse. Default value is <code>False</code>.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Gell-{M}ann matrices. link.</p> Source code in <code>toqito/matrices/gell_mann.py</code> <pre><code>def gell_mann(ind: int, is_sparse: bool = False) -&gt; np.ndarray | csr_array:\n    r\"\"\"Produce a Gell-Mann operator [@WikiGellMann].\n\n    Generates the 3-by-3 Gell-Mann matrix indicated by the value of\n    `ind`.  When `ind = 0` gives the identity matrix, while values\n    1 through 8 each indicate one of the other 8 Gell-Mann matrices.\n\n    The 9 Gell-Mann matrices are defined as follows:\n\n    \\[\n        \\begin{equation}\n            \\begin{aligned}\n                \\lambda_0 = \\begin{pmatrix}\n                                1 &amp; 0 &amp; 0 \\\\\n                                0 &amp; 1 &amp; 0 \\\\\n                                0 &amp; 0 &amp; 1\n                            \\end{pmatrix}, \\quad\n                \\lambda_1 = \\begin{pmatrix}\n                                0 &amp; 1 &amp; 0 \\\\\n                                1 &amp; 0 &amp; 0 \\\\\n                                0 &amp; 0 &amp; 0\n                            \\end{pmatrix}, \\quad &amp;\n                \\lambda_2 = \\begin{pmatrix}\n                                0 &amp; -i &amp; 0 \\\\\n                                i &amp; 0 &amp; 0 \\\\\n                                0 &amp; 0 &amp; 0\n                            \\end{pmatrix},  \\\\\n                \\lambda_3 = \\begin{pmatrix}\n                                1 &amp; 0 &amp; 0 \\\\\n                                0 &amp; -1 &amp; 0 \\\\\n                                0 &amp; 0 &amp; 0\n                            \\end{pmatrix}, \\quad\n                \\lambda_4 = \\begin{pmatrix}\n                                0 &amp; 0 &amp; 1 \\\\\n                                0 &amp; 0 &amp; 0 \\\\\n                                1 &amp; 0 &amp; 0\n                            \\end{pmatrix}, \\quad &amp;\n                \\lambda_5 = \\begin{pmatrix}\n                                0 &amp; 0 &amp; -i \\\\\n                                0 &amp; 0 &amp; 0 \\\\\n                                i &amp; 0 &amp; 0\n                            \\end{pmatrix},  \\\\\n                \\lambda_6 = \\begin{pmatrix}\n                                0 &amp; 0 &amp; 0 \\\\\n                                0 &amp; 0 &amp; 1 \\\\\n                                0 &amp; 1 &amp; 0\n                            \\end{pmatrix}, \\quad\n                \\lambda_7 = \\begin{pmatrix}\n                                0 &amp; 0 &amp; 0 \\\\\n                                0 &amp; 0 &amp; -i \\\\\n                                0 &amp; i &amp; 0\n                            \\end{pmatrix}, \\quad &amp;\n                \\lambda_8 = \\frac{1}{\\sqrt{3}} \\begin{pmatrix}\n                                                    1 &amp; 0 &amp; 0 \\\\\n                                                    0 &amp; 1 &amp; 0 \\\\\n                                                    0 &amp; 0 &amp; -2\n                                                \\end{pmatrix}.\n                \\end{aligned}\n            \\end{equation}\n    \\]\n\n    Examples:\n        The Gell-Mann matrix generated from `idx = 2` yields the following\n        matrix:\n\n        \\[\n            \\lambda_2 = \\begin{pmatrix}\n                                0 &amp; -i &amp; 0 \\\\\n                                i &amp; 0 &amp; 0 \\\\\n                                0 &amp; 0 &amp; 0\n                        \\end{pmatrix}\n        \\]\n        ```python exec=\"1\" source=\"above\"\n        from toqito.matrices import gell_mann\n\n        print(gell_mann(ind=2))\n        ```\n\n    Raises:\n        ValueError: Indices must be integers between 0 and 8.\n\n    Args:\n        ind: An integer between 0 and 8 (inclusive).\n        is_sparse: Boolean to determine whether array is sparse. Default value is `False`.\n\n    \"\"\"\n    if ind == 0:\n        gm_op = np.identity(3)\n    elif ind == 1:\n        gm_op = np.array([[0, 1, 0], [1, 0, 0], [0, 0, 0]])\n    elif ind == 2:\n        gm_op = np.array([[0, -1j, 0], [1j, 0, 0], [0, 0, 0]])\n    elif ind == 3:\n        gm_op = np.array([[1, 0, 0], [0, -1, 0], [0, 0, 0]])\n    elif ind == 4:\n        gm_op = np.array([[0, 0, 1], [0, 0, 0], [1, 0, 0]])\n    elif ind == 5:\n        gm_op = np.array([[0, 0, -1j], [0, 0, 0], [1j, 0, 0]])\n    elif ind == 6:\n        gm_op = np.array([[0, 0, 0], [0, 0, 1], [0, 1, 0]])\n    elif ind == 7:\n        gm_op = np.array([[0, 0, 0], [0, 0, -1j], [0, 1j, 0]])\n    elif ind == 8:\n        gm_op = np.array([[1, 0, 0], [0, 1, 0], [0, 0, -2]]) / np.sqrt(3)\n    else:\n        raise ValueError(\"Gell-Mann index values can only be values from 0 to 8 (inclusive).\")\n\n    if is_sparse:\n        gm_op_out = csr_array(gm_op)\n        return gm_op_out\n\n    return gm_op\n</code></pre>"},{"location":"reference/toqito/matrices/gen_gell_mann/","title":"gen_gell_mann","text":""},{"location":"reference/toqito/matrices/gen_gell_mann/#toqito.matrices.gen_gell_mann","title":"gen_gell_mann","text":"<p>Produces the generalized Gell-Mann operator matrices.</p>"},{"location":"reference/toqito/matrices/gen_gell_mann/#toqito.matrices.gen_gell_mann.gen_gell_mann","title":"gen_gell_mann","text":"<pre><code>gen_gell_mann(ind_1: int, ind_2: int, dim: int) -&gt; ndarray\n</code></pre> <p>Produce a generalized Gell-Mann operator <sup>1</sup>.</p> <p>Construct a <code>dim</code>-by-<code>dim</code> Hermitian operator. These matrices span the entire space of <code>dim</code>-by-<code>dim</code> matrices as <code>ind_1</code> and <code>ind_2</code> range from 0 to <code>dim-1</code>, inclusive, and they generalize the Pauli operators when <code>dim = 2</code> and the Gell-Mann operators when <code>dim = 3</code>.</p> <p>Examples:</p> <p>The generalized Gell-Mann matrix for <code>ind_1 = 0</code>, <code>ind_2 = 1</code> and <code>dim = 2</code> is given as</p> \\[     G_{0, 1, 2} = \\begin{pmatrix}                      0 &amp; 1 \\\\                      1 &amp; 0                   \\end{pmatrix}. \\] <p>This can be obtained in <code>|toqito\u27e9</code> as follows.</p> <pre><code>from toqito.matrices import gen_gell_mann\n\nprint(gen_gell_mann(ind_1=0, ind_2=1, dim=2))\n</code></pre> <p>[[0. 1.]  [1. 0.]]</p> <p>The generalized Gell-Mann matrix <code>ind_1 = 2</code>, <code>ind_2 = 3</code>, and <code>dim = 4</code> is given as</p> \\[     G_{2, 3, 4} = \\begin{pmatrix}                     0 &amp; 0 &amp; 0 &amp; 0 \\\\                     0 &amp; 0 &amp; 0 &amp; 0 \\\\                     0 &amp; 0 &amp; 0 &amp; 1 \\\\                     0 &amp; 0 &amp; 1 &amp; 0                   \\end{pmatrix}. \\] <p>This can be obtained in <code>|toqito\u27e9</code> as follows.</p> <pre><code>from toqito.matrices import gen_gell_mann\n\ngen_gell_mann(ind_1=2, ind_2=3, dim=4)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>ind_1</code>               (<code>int</code>)           \u2013            <p>A non-negative integer from 0 to <code>dim-1</code> (inclusive).</p> </li> <li> <code>ind_2</code>               (<code>int</code>)           \u2013            <p>A non-negative integer from 0 to <code>dim-1</code> (inclusive).</p> </li> <li> <code>dim</code>               (<code>int</code>)           \u2013            <p>The dimension of the Gell-Mann operator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>The generalized Gell-Mann operator as an array.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Gell-{M}ann matrices. link.</p> Source code in <code>toqito/matrices/gen_gell_mann.py</code> <pre><code>def gen_gell_mann(ind_1: int, ind_2: int, dim: int) -&gt; np.ndarray:\n    r\"\"\"Produce a generalized Gell-Mann operator [@WikiGellMann].\n\n    Construct a `dim`-by-`dim` Hermitian operator. These matrices\n    span the entire space of `dim`-by-`dim` matrices as\n    `ind_1` and `ind_2` range from 0 to `dim-1`, inclusive,\n    and they generalize the Pauli operators when `dim = 2` and the\n    Gell-Mann operators when `dim = 3`.\n\n    Examples:\n        The generalized Gell-Mann matrix for `ind_1 = 0`, `ind_2 = 1`\n        and `dim = 2` is given as\n\n        \\[\n            G_{0, 1, 2} = \\begin{pmatrix}\n                             0 &amp; 1 \\\\\n                             1 &amp; 0\n                          \\end{pmatrix}.\n        \\]\n\n        This can be obtained in `|toqito\u27e9` as follows.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.matrices import gen_gell_mann\n\n        print(gen_gell_mann(ind_1=0, ind_2=1, dim=2))\n        ```\n\n        The generalized Gell-Mann matrix `ind_1 = 2`, `ind_2 = 3`, and\n        `dim = 4` is given as\n\n        \\[\n            G_{2, 3, 4} = \\begin{pmatrix}\n                            0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                            0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                            0 &amp; 0 &amp; 0 &amp; 1 \\\\\n                            0 &amp; 0 &amp; 1 &amp; 0\n                          \\end{pmatrix}.\n        \\]\n\n        This can be obtained in `|toqito\u27e9` as follows.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.matrices import gen_gell_mann\n\n        gen_gell_mann(ind_1=2, ind_2=3, dim=4)\n        ```\n\n    Args:\n        ind_1: A non-negative integer from 0 to `dim-1` (inclusive).\n        ind_2: A non-negative integer from 0 to `dim-1` (inclusive).\n        dim: The dimension of the Gell-Mann operator.\n\n    Returns:\n        The generalized Gell-Mann operator as an array.\n\n    \"\"\"\n    if ind_1 == ind_2:\n        if ind_1 == 0:\n            gm_op = np.eye(dim)\n        else:\n            scalar = np.sqrt(2 / (ind_1 * (ind_1 + 1)))\n            diag = np.ones((ind_1,))\n            diag = np.append(diag, -ind_1)\n            diag = scalar * np.append(diag, np.zeros((dim - ind_1 - 1)))\n\n            gm_op = np.diag(diag)\n\n    else:\n        e_mat = np.zeros((dim, dim))\n        e_mat[ind_1, ind_2] = 1\n        if ind_1 &lt; ind_2:\n            gm_op = e_mat + e_mat.conj().T\n        else:\n            gm_op = 1j * e_mat - 1j * e_mat.conj().T\n\n    return gm_op\n</code></pre>"},{"location":"reference/toqito/matrices/gen_pauli/","title":"gen_pauli","text":""},{"location":"reference/toqito/matrices/gen_pauli/#toqito.matrices.gen_pauli","title":"gen_pauli","text":"<p>Produces the generalized Pauli operator matrices.</p>"},{"location":"reference/toqito/matrices/gen_pauli/#toqito.matrices.gen_pauli.gen_pauli","title":"gen_pauli","text":"<pre><code>gen_pauli(k_1: int, k_2: int, dim: int) -&gt; ndarray\n</code></pre> <p>Produce generalized Pauli operator <sup>1</sup>.</p> <p>Generates a <code>dim</code>-by-<code>dim</code> unitary operator. More specifically, it is the operator \\(X^k_1 Z^k_2\\), where \\(X\\) and \\(Z\\) are the \"gen_pauli_x\" and \"gen_pauli_z\" operators that naturally generalize the Pauli X and Z operators. These matrices span the entire space of <code>dim</code>-by-<code>dim</code> matrices as <code>k_1</code> and <code>k_2</code> range from 0 to <code>dim-1</code>, inclusive.</p> <p>Note that the generalized Pauli operators are also known by the name of \"discrete Weyl operators\". (Lecture 6: Further Remarks On Measurements And Channels from <sup>2</sup>)</p> <p>Examples:</p> <p>The generalized Pauli operator for <code>k_1 = 1</code>, <code>k_2 = 0</code>, and <code>dim = 2</code> is given as the standard Pauli-X matrix</p> \\[     G_{1, 0, 2} = \\begin{pmatrix}                      0 &amp; 1 \\\\                      1 &amp; 0                   \\end{pmatrix}. \\] <p>This can be obtained in <code>|toqito\u27e9</code> as follows.</p> <pre><code>from toqito.matrices import gen_pauli\n\nprint(gen_pauli(k_1=1, k_2=0, dim=2))\n</code></pre> <p>[[0.+0.j 1.+0.j]  [1.+0.j 0.+0.j]]</p> <p>The generalized Pauli matrix <code>k_1 = 1</code>, <code>k_2 = 1</code>, and <code>dim = 2</code> is given as the standard Pauli-Y matrix</p> \\[     G_{1, 1, 2} = \\begin{pmatrix}                     0 &amp; -1 \\\\                     1 &amp; 0                   \\end{pmatrix}. \\] <p>This can be obtained in <code>|toqito\u27e9</code> as follows.</p> <pre><code>from toqito.matrices import gen_pauli\n\nprint(gen_pauli(k_1=1, k_2=1, dim=2))\n</code></pre> <p>[[ 0.+0.0000000e+00j -1.+1.2246468e-16j]  [ 1.+0.0000000e+00j  0.+0.0000000e+00j]]</p> <p>Parameters:</p> <ul> <li> <code>k_1</code>               (<code>int</code>)           \u2013            <p>(a non-negative integer from 0 to <code>dim-1</code> inclusive).</p> </li> <li> <code>k_2</code>               (<code>int</code>)           \u2013            <p>(a non-negative integer from 0 to <code>dim-1</code> inclusive).</p> </li> <li> <code>dim</code>               (<code>int</code>)           \u2013            <p>(a positive integer indicating the dimension).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>A generalized Pauli operator.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Generalizations of {P}auli matrices. link. <sup>2</sup> Watrous, John. Theory of Quantum Information Lecture Notes. (2011). link.</p> Source code in <code>toqito/matrices/gen_pauli.py</code> <pre><code>def gen_pauli(k_1: int, k_2: int, dim: int) -&gt; np.ndarray:\n    r\"\"\"Produce generalized Pauli operator [@WikiPauliGen].\n\n    Generates a `dim`-by-`dim` unitary operator. More specifically,\n    it is the operator \\(X^k_1 Z^k_2\\), where \\(X\\) and \\(Z\\) are\n    the \"gen_pauli_x\" and \"gen_pauli_z\" operators that naturally generalize the Pauli X and\n    Z operators. These matrices span the entire space of\n    `dim`-by-`dim` matrices as `k_1` and `k_2` range\n    from 0 to `dim-1`, inclusive.\n\n    Note that the generalized Pauli operators are also known by the name of\n    \"discrete Weyl operators\". (Lecture 6: Further Remarks On Measurements And Channels from\n    [@Watrous_2011_Lecture_Notes])\n\n    Examples:\n        The generalized Pauli operator for `k_1 = 1`, `k_2 = 0`, and\n        `dim = 2` is given as the standard Pauli-X matrix\n\n        \\[\n            G_{1, 0, 2} = \\begin{pmatrix}\n                             0 &amp; 1 \\\\\n                             1 &amp; 0\n                          \\end{pmatrix}.\n        \\]\n\n        This can be obtained in `|toqito\u27e9` as follows.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.matrices import gen_pauli\n\n        print(gen_pauli(k_1=1, k_2=0, dim=2))\n        ```\n\n\n        The generalized Pauli matrix `k_1 = 1`, `k_2 = 1`, and\n        `dim = 2` is given as the standard Pauli-Y matrix\n\n        \\[\n            G_{1, 1, 2} = \\begin{pmatrix}\n                            0 &amp; -1 \\\\\n                            1 &amp; 0\n                          \\end{pmatrix}.\n        \\]\n\n        This can be obtained in `|toqito\u27e9` as follows.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.matrices import gen_pauli\n\n        print(gen_pauli(k_1=1, k_2=1, dim=2))\n        ```\n\n    Args:\n        k_1: (a non-negative integer from 0 to `dim-1` inclusive).\n        k_2: (a non-negative integer from 0 to `dim-1` inclusive).\n        dim: (a positive integer indicating the dimension).\n\n    Returns:\n        A generalized Pauli operator.\n\n    \"\"\"\n    gpx_val = gen_pauli_x(dim)\n    gpz_val = gen_pauli_z(dim)\n\n    gen_pauli_w = np.linalg.matrix_power(gpx_val, k_1) @ np.linalg.matrix_power(gpz_val, k_2)\n\n    return gen_pauli_w\n</code></pre>"},{"location":"reference/toqito/matrices/gen_pauli_x/","title":"gen_pauli_x","text":""},{"location":"reference/toqito/matrices/gen_pauli_x/#toqito.matrices.gen_pauli_x","title":"gen_pauli_x","text":"<p>Produces a generalized Pauli-X operator matrix.</p>"},{"location":"reference/toqito/matrices/gen_pauli_x/#toqito.matrices.gen_pauli_x.gen_pauli_x","title":"gen_pauli_x","text":"<pre><code>gen_pauli_x(dim: int) -&gt; ndarray\n</code></pre> <p>Produce a <code>dim</code>-by-<code>dim</code> gen_pauli_x matrix <sup>1</sup>.</p> <p>Returns the gen_pauli_x matrix of dimension <code>dim</code> described in <sup>1</sup>. The gen_pauli_x matrix generates the following <code>dim</code>-by-<code>dim</code> matrix:</p> \\[     \\Sigma_{1, d} = \\begin{pmatrix}                     0 &amp; 0 &amp; 0 &amp; \\ldots &amp; 0 &amp; 1 \\\\                     1 &amp; 0 &amp; 0 &amp; \\ldots &amp; 0 &amp; 0 \\\\                     0 &amp; 1 &amp; 0 &amp; \\ldots &amp; 0 &amp; 0 \\\\                     0 &amp; 0 &amp; 1 &amp; \\ldots &amp; 0 &amp; 0 \\\\                     \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots \\\\                     0 &amp; 0 &amp; 0 &amp; \\ldots &amp; 1 &amp; 0                 \\end{pmatrix} \\] <p>The gen_pauli_x matrix is primarily used in the construction of the generalized Pauli operators.</p> <p>Examples:</p> <p>The gen_pauli_x matrix generated from \\(d = 3\\) yields the following matrix:</p> \\[     \\Sigma_{1, 3} =     \\begin{pmatrix}         0 &amp; 0 &amp; 1 \\\\         1 &amp; 0 &amp; 0 \\\\         0 &amp; 1 &amp; 0     \\end{pmatrix} \\] <pre><code>from toqito.matrices import gen_pauli_x\n\nprint(gen_pauli_x(3))\n</code></pre> <p>[[0. 0. 1.]  [1. 0. 0.]  [0. 1. 0.]]</p> <p>Parameters:</p> <ul> <li> <code>dim</code>               (<code>int</code>)           \u2013            <p>Dimension of the matrix.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p><code>dim</code>-by-<code>dim</code> gen_pauli_x matrix.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Generalizations of {P}auli matrices. link.</p> Source code in <code>toqito/matrices/gen_pauli_x.py</code> <pre><code>def gen_pauli_x(dim: int) -&gt; np.ndarray:\n    r\"\"\"Produce a `dim`-by-`dim` gen_pauli_x matrix [@WikiPauliGen].\n\n    Returns the gen_pauli_x matrix of dimension `dim` described in [@WikiPauliGen].\n    The gen_pauli_x matrix generates the following `dim`-by-`dim` matrix:\n\n    \\[\n        \\Sigma_{1, d} = \\begin{pmatrix}\n                        0 &amp; 0 &amp; 0 &amp; \\ldots &amp; 0 &amp; 1 \\\\\n                        1 &amp; 0 &amp; 0 &amp; \\ldots &amp; 0 &amp; 0 \\\\\n                        0 &amp; 1 &amp; 0 &amp; \\ldots &amp; 0 &amp; 0 \\\\\n                        0 &amp; 0 &amp; 1 &amp; \\ldots &amp; 0 &amp; 0 \\\\\n                        \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots \\\\\n                        0 &amp; 0 &amp; 0 &amp; \\ldots &amp; 1 &amp; 0\n                    \\end{pmatrix}\n    \\]\n\n    The gen_pauli_x matrix is primarily used in the construction of the generalized\n    Pauli operators.\n\n    Examples:\n        The gen_pauli_x matrix generated from \\(d = 3\\) yields the following matrix:\n\n        \\[\n            \\Sigma_{1, 3} =\n            \\begin{pmatrix}\n                0 &amp; 0 &amp; 1 \\\\\n                1 &amp; 0 &amp; 0 \\\\\n                0 &amp; 1 &amp; 0\n            \\end{pmatrix}\n        \\]\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.matrices import gen_pauli_x\n\n        print(gen_pauli_x(3))\n        ```\n\n    Args:\n        dim: Dimension of the matrix.\n\n    Returns:\n        `dim`-by-`dim` gen_pauli_x matrix.\n\n    \"\"\"\n    # First column of the identity matrix becomes the last column due to `shift = -1` and `axis=1`\n    return np.roll(np.identity(dim), -1, axis=1)\n</code></pre>"},{"location":"reference/toqito/matrices/gen_pauli_z/","title":"gen_pauli_z","text":""},{"location":"reference/toqito/matrices/gen_pauli_z/#toqito.matrices.gen_pauli_z","title":"gen_pauli_z","text":"<p>Produces a generalized Pauli-Z operator matrix.</p>"},{"location":"reference/toqito/matrices/gen_pauli_z/#toqito.matrices.gen_pauli_z.gen_pauli_z","title":"gen_pauli_z","text":"<pre><code>gen_pauli_z(dim: int) -&gt; ndarray\n</code></pre> <p>Produce gen_pauli_z matrix <sup>1</sup>.</p> <p>Returns the gen_pauli_z matrix of dimension <code>dim</code> described in <sup>1</sup>. The gen_pauli_z matrix generates the following <code>dim</code>-by-<code>dim</code> matrix</p> \\[     \\Sigma_{1, d} = \\begin{pmatrix}                     1 &amp; 0 &amp; 0 &amp; \\ldots &amp; 0 \\\\                     0 &amp; \\omega &amp; 0 &amp; \\ldots &amp; 0 \\\\                     0 &amp; 0 &amp; \\omega^2 &amp; \\ldots &amp; 0 \\\\                     \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\                     0 &amp; 0 &amp; 0 &amp; \\ldots &amp; \\omega^{d-1}                \\end{pmatrix} \\] <p>where \\(\\omega\\) is the n-th primitive root of unity.</p> <p>The gen_pauli_z matrix is primarily used in the construction of the generalized Pauli operators.</p> <p>Examples:</p> <p>The gen_pauli_z matrix generated from \\(d = 3\\) yields the following matrix:</p> \\[     \\Sigma_{1, 3} = \\begin{pmatrix}         1 &amp; 0 &amp; 0 \\\\         0 &amp; \\omega &amp; 0 \\\\         0 &amp; 0 &amp; \\omega^2     \\end{pmatrix} \\] <pre><code>from toqito.matrices import gen_pauli_z\n\nprint(gen_pauli_z(3))\n</code></pre> <p>[[ 1. +0.j         0. +0.j         0. +0.j       ]  [ 0. +0.j        -0.5+0.8660254j  0. +0.j       ]  [ 0. +0.j         0. +0.j        -0.5-0.8660254j]]</p> <p>Parameters:</p> <ul> <li> <code>dim</code>               (<code>int</code>)           \u2013            <p>Dimension of the matrix.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p><code>dim</code>-by-<code>dim</code> gen_pauli_z matrix.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Generalizations of Pauli matrices. link.</p> Source code in <code>toqito/matrices/gen_pauli_z.py</code> <pre><code>def gen_pauli_z(dim: int) -&gt; np.ndarray:\n    r\"\"\"Produce gen_pauli_z matrix [@WikiClock].\n\n    Returns the gen_pauli_z matrix of dimension `dim` described in [@WikiClock].\n    The gen_pauli_z matrix generates the following `dim`-by-`dim` matrix\n\n    \\[\n        \\Sigma_{1, d} = \\begin{pmatrix}\n                        1 &amp; 0 &amp; 0 &amp; \\ldots &amp; 0 \\\\\n                        0 &amp; \\omega &amp; 0 &amp; \\ldots &amp; 0 \\\\\n                        0 &amp; 0 &amp; \\omega^2 &amp; \\ldots &amp; 0 \\\\\n                        \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\\n                        0 &amp; 0 &amp; 0 &amp; \\ldots &amp; \\omega^{d-1}\n                   \\end{pmatrix}\n    \\]\n\n    where \\(\\omega\\) is the n-th primitive root of unity.\n\n    The gen_pauli_z matrix is primarily used in the construction of the generalized\n    Pauli operators.\n\n    Examples:\n        The gen_pauli_z matrix generated from \\(d = 3\\) yields the following matrix:\n\n        \\[\n            \\Sigma_{1, 3} = \\begin{pmatrix}\n                1 &amp; 0 &amp; 0 \\\\\n                0 &amp; \\omega &amp; 0 \\\\\n                0 &amp; 0 &amp; \\omega^2\n            \\end{pmatrix}\n        \\]\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.matrices import gen_pauli_z\n\n        print(gen_pauli_z(3))\n        ```\n\n    Args:\n        dim: Dimension of the matrix.\n\n    Returns:\n        `dim`-by-`dim` gen_pauli_z matrix.\n\n    \"\"\"\n    c_var = 2j * pi / dim\n    omega = (exp(k * c_var) for k in range(dim))\n    return np.diag(list(omega))\n</code></pre>"},{"location":"reference/toqito/matrices/hadamard/","title":"hadamard","text":""},{"location":"reference/toqito/matrices/hadamard/#toqito.matrices.hadamard","title":"hadamard","text":"<p>Generates a Hadamard matrix.</p>"},{"location":"reference/toqito/matrices/hadamard/#toqito.matrices.hadamard.hadamard","title":"hadamard","text":"<pre><code>hadamard(n_param: int = 1) -&gt; ndarray\n</code></pre> <p>Produce a <code>2^{n_param}</code> dimensional Hadamard matrix <sup>1</sup>.</p> <p>The standard Hadamard matrix that is often used in quantum information as a one-qubit quantum gate is defined as</p> \\[     H_1 = \\frac{1}{\\sqrt{2}} \\begin{pmatrix}                                 1 &amp; 1 \\\\                                 1 &amp; -1                              \\end{pmatrix} \\] <p>In general, the Hadamard matrix of dimension <code>2^{n_param}</code> may be defined as</p> \\[     \\left( H_n \\right)_{i, j} = \\frac{1}{2^{\\frac{n}{2}}}     \\left(-1\\right)^{i \\cdot j} \\] <p>Examples:</p> <p>The standard 1-qubit Hadamard matrix can be generated in <code>toqito</code> as</p> <pre><code>from toqito.matrices import hadamard\n\nprint(hadamard(1))\n</code></pre> <p>[[ 0.70710678  0.70710678]  [ 0.70710678 -0.70710678]]</p> <p>References</p> <p><sup>1</sup> Wikipedia. Hadamard transform. link.</p> Source code in <code>toqito/matrices/hadamard.py</code> <pre><code>def hadamard(n_param: int = 1) -&gt; np.ndarray:\n    r\"\"\"Produce a `2^{n_param}` dimensional Hadamard matrix [@WikiHadamard].\n\n    The standard Hadamard matrix that is often used in quantum information as a\n    one-qubit quantum gate is defined as\n\n    \\[\n        H_1 = \\frac{1}{\\sqrt{2}} \\begin{pmatrix}\n                                    1 &amp; 1 \\\\\n                                    1 &amp; -1\n                                 \\end{pmatrix}\n    \\]\n\n    In general, the Hadamard matrix of dimension `2^{n_param}` may be\n    defined as\n\n    \\[\n        \\left( H_n \\right)_{i, j} = \\frac{1}{2^{\\frac{n}{2}}}\n        \\left(-1\\right)^{i \\cdot j}\n    \\]\n\n    Examples:\n        The standard 1-qubit Hadamard matrix can be generated in `toqito` as\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.matrices import hadamard\n\n        print(hadamard(1))\n        ```\n\n    \"\"\"\n    if n_param &lt; 1:\n        raise ValueError(\"Provided parameter for matrix dimensions is invalid.\")\n\n    return 2 ** (-n_param / 2) * np.array(\n        [[(-1) ** _hamming_distance(i &amp; j) for i in range(2**n_param)] for j in range(2**n_param)]\n    )\n</code></pre>"},{"location":"reference/toqito/matrices/pauli/","title":"pauli","text":""},{"location":"reference/toqito/matrices/pauli/#toqito.matrices.pauli","title":"pauli","text":"<p>Generates the Pauli matrices.</p>"},{"location":"reference/toqito/matrices/pauli/#toqito.matrices.pauli.pauli","title":"pauli","text":"<pre><code>pauli(ind: int | str | list[int] | list[str], is_sparse: bool = False) -&gt; ndarray | csr_array | None\n</code></pre> <p>Produce a Pauli operator <sup>1</sup>.</p> <p>Produces the 2-by-2 Pauli matrix indicated by the value of <code>ind</code> or a tensor product of Pauli matrices when <code>ind</code> is provided as a list. In general, when <code>ind</code> is a list \\([i_1, i_2, \\dots, i_n]\\), the function returns the tensor product</p> \\[     P_{i_1} \\otimes P_{i_2} \\otimes \\cdots \\otimes P_{i_n} \\] <p>where each \\(i_k \\in \\{0,1,2,3\\}\\), with the correspondence: \\(P_{0} = I\\), \\(P_{1} = X\\), \\(P_{2} = Y\\), and \\(P_{3} = Z\\).</p> <p>The 2-by-2 Pauli matrices are defined as follows:</p> \\[     \\begin{equation}         \\begin{aligned}             X = \\begin{pmatrix}                     0 &amp; 1 \\\\                     1 &amp; 0                 \\end{pmatrix}, \\quad             Y = \\begin{pmatrix}                     0 &amp; -i \\\\                     i &amp; 0                 \\end{pmatrix}, \\quad             Z = \\begin{pmatrix}                     1 &amp; 0 \\\\                     0 &amp; -1                 \\end{pmatrix}, \\quad             I = \\begin{pmatrix}                     1 &amp; 0 \\\\                     0 &amp; 1                 \\end{pmatrix}.             \\end{aligned}         \\end{equation} \\] <p>Examples:</p> <p>Example for identity Pauli matrix.</p> <pre><code>from toqito.matrices import pauli\n\nprint(pauli(\"I\"))\n</code></pre> <p>[[1. 0.]  [0. 1.]]</p> <p>Example for Pauli-X matrix.</p> <pre><code>from toqito.matrices import pauli\n\nprint(pauli(\"X\"))\n</code></pre> <p>[[0 1]  [1 0]]</p> <p>Example for Pauli-Y matrix.</p> <pre><code>from toqito.matrices import pauli\n\nprint(pauli(\"Y\"))\n</code></pre> <p>[[ 0.+0.j -0.-1.j]  [ 0.+1.j  0.+0.j]]</p> <p>Example for Pauli-Z matrix.</p> <pre><code>from toqito.matrices import pauli\n\nprint(pauli(\"Z\"))\n</code></pre> <p>[[ 1  0]  [ 0 -1]]</p> <p>Example using <code>ind</code> as list.</p> <pre><code>from toqito.matrices import pauli\n\nprint(pauli([0,1]))\n</code></pre> <p>[[0. 1. 0. 0.]  [1. 0. 0. 0.]  [0. 0. 0. 1.]  [0. 0. 1. 0.]]</p> <p>Parameters:</p> <ul> <li> <code>ind</code>               (<code>int | str | list[int] | list[str]</code>)           \u2013            <p>The index to indicate which Pauli operator to generate.</p> </li> <li> <code>is_sparse</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Returns a compressed sparse row array if set to True and a non compressed sparse row array if set to</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Pauli matrices. link.</p> Source code in <code>toqito/matrices/pauli.py</code> <pre><code>def pauli(ind: int | str | list[int] | list[str], is_sparse: bool = False) -&gt; np.ndarray | csr_array | None:\n    r\"\"\"Produce a Pauli operator [@WikiPauli].\n\n    Produces the 2-by-2 Pauli matrix indicated by the value of `ind` or a tensor product\n    of Pauli matrices when `ind` is provided as a list. In general, when `ind` is a list\n    \\([i_1, i_2, \\dots, i_n]\\), the function returns the tensor product\n\n    \\[\n        P_{i_1} \\otimes P_{i_2} \\otimes \\cdots \\otimes P_{i_n}\n    \\]\n\n    where each \\(i_k \\in \\{0,1,2,3\\}\\), with the correspondence:\n    \\(P_{0} = I\\), \\(P_{1} = X\\), \\(P_{2} = Y\\), and \\(P_{3} = Z\\).\n\n    The 2-by-2 Pauli matrices are defined as follows:\n\n    \\[\n        \\begin{equation}\n            \\begin{aligned}\n                X = \\begin{pmatrix}\n                        0 &amp; 1 \\\\\n                        1 &amp; 0\n                    \\end{pmatrix}, \\quad\n                Y = \\begin{pmatrix}\n                        0 &amp; -i \\\\\n                        i &amp; 0\n                    \\end{pmatrix}, \\quad\n                Z = \\begin{pmatrix}\n                        1 &amp; 0 \\\\\n                        0 &amp; -1\n                    \\end{pmatrix}, \\quad\n                I = \\begin{pmatrix}\n                        1 &amp; 0 \\\\\n                        0 &amp; 1\n                    \\end{pmatrix}.\n                \\end{aligned}\n            \\end{equation}\n    \\]\n\n    Examples:\n        Example for identity Pauli matrix.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.matrices import pauli\n\n        print(pauli(\"I\"))\n        ```\n\n        Example for Pauli-X matrix.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.matrices import pauli\n\n        print(pauli(\"X\"))\n        ```\n\n\n        Example for Pauli-Y matrix.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.matrices import pauli\n\n        print(pauli(\"Y\"))\n        ```\n\n\n        Example for Pauli-Z matrix.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.matrices import pauli\n\n        print(pauli(\"Z\"))\n        ```\n\n        Example using `ind` as list.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.matrices import pauli\n\n        print(pauli([0,1]))\n        ```\n\n\n    Args:\n        ind: The index to indicate which Pauli operator to generate.\n        is_sparse: Returns a compressed sparse row array if set to True and a non compressed sparse row array if set to\n        False.\n\n    \"\"\"\n    if isinstance(ind, (int, str)):\n        allowed_ind_options = {\"x\", \"X\", 1, \"y\", \"Y\", 2, \"z\", \"Z\", 3, \"i\", \"I\", 0}\n        if ind not in allowed_ind_options:\n            raise ValueError(f\"Invalid Pauli operator index provided. Allowed options are {allowed_ind_options}.\")\n        if ind in {\"x\", \"X\", 1}:\n            pauli_mat = np.array([[0, 1], [1, 0]])\n        elif ind in {\"y\", \"Y\", 2}:\n            pauli_mat = np.array([[0, -1j], [1j, 0]])\n        elif ind in {\"z\", \"Z\", 3}:\n            pauli_mat = np.array([[1, 0], [0, -1]])\n        else:\n            pauli_mat = np.identity(2)\n\n        if is_sparse:\n            pauli_mat = csr_array(pauli_mat)\n\n        return pauli_mat\n\n    num_qubits = len(ind)\n    pauli_mats = []\n    for i in range(num_qubits):\n        pauli_mats.append(pauli(ind[i], is_sparse))\n    return tensor(pauli_mats)\n</code></pre>"},{"location":"reference/toqito/matrices/standard_basis/","title":"standard_basis","text":""},{"location":"reference/toqito/matrices/standard_basis/#toqito.matrices.standard_basis","title":"standard_basis","text":"<p>Constructs the standard basis.</p>"},{"location":"reference/toqito/matrices/standard_basis/#toqito.matrices.standard_basis.standard_basis","title":"standard_basis","text":"<pre><code>standard_basis(dim: int, flatten: bool = False) -&gt; list[ndarray]\n</code></pre> <p>Create standard basis of dimension <code>dim</code>.</p> <p>Create a list containing the elements of the standard basis for the given dimension:</p> \\[     |1&gt; = (1, 0, 0, ..., 0)^T     |2&gt; = (0, 1, 0, ..., 0)^T     .     .     .     |n&gt; = (0, 0, 0, ..., 1)^T \\] <p>This function was inspired by [@Seshadri_2021_Git, Seshadri_2021_Theory, Seshadri_2021_Versatile]</p> <p>Examples:</p> <pre><code>from toqito.matrices import standard_basis\n\nprint(standard_basis(2))\n</code></pre> <p>[array([[1.],        [0.]]), array([[0.],        [1.]])]</p> <p>Parameters:</p> <ul> <li> <code>dim</code>               (<code>int</code>)           \u2013            <p>The dimension of the basis.</p> </li> <li> <code>flatten</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, the basis is returned as a flattened list.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[ndarray]</code>           \u2013            <p>A list of numpy.ndarray of shape (n, 1).</p> </li> </ul> Source code in <code>toqito/matrices/standard_basis.py</code> <pre><code>def standard_basis(dim: int, flatten: bool = False) -&gt; list[np.ndarray]:\n    r\"\"\"Create standard basis of dimension `dim`.\n\n    Create a list containing the elements of the standard basis for the\n    given dimension:\n\n    \\[\n        |1&gt; = (1, 0, 0, ..., 0)^T\n        |2&gt; = (0, 1, 0, ..., 0)^T\n        .\n        .\n        .\n        |n&gt; = (0, 0, 0, ..., 1)^T\n    \\]\n\n    This function was inspired by [@Seshadri_2021_Git, Seshadri_2021_Theory, Seshadri_2021_Versatile]\n\n    Examples:\n        ```python exec=\"1\" source=\"above\"\n        from toqito.matrices import standard_basis\n\n        print(standard_basis(2))\n        ```\n\n    Args:\n        dim: The dimension of the basis.\n        flatten: If True, the basis is returned as a flattened list.\n\n    Returns:\n        A list of numpy.ndarray of shape (n, 1).\n\n    \"\"\"\n    first_basis_vector = np.zeros(dim) if flatten else np.zeros((dim, 1))\n    first_basis_vector[0] = 1.0\n\n    # The standard_basis is obtained by cyclic permutations of the first basis\n    # vector\n    return [np.array([first_basis_vector[i - j] for i in range(dim)]) for j in range(dim)]\n</code></pre>"},{"location":"reference/toqito/matrix_ops/","title":"matrix_ops","text":""},{"location":"reference/toqito/matrix_ops/#toqito.matrix_ops","title":"matrix_ops","text":"<p>Matrix operations is a set of modules that are used to implement commonly used operations on vectors and matrices.</p>"},{"location":"reference/toqito/matrix_ops/calculate_vector_matrix_dimension/","title":"calculate_vector_matrix_dimension","text":""},{"location":"reference/toqito/matrix_ops/calculate_vector_matrix_dimension/#toqito.matrix_ops.calculate_vector_matrix_dimension","title":"calculate_vector_matrix_dimension","text":"<p>Calculates the (common) dimension of a set of vectors or matrices.</p>"},{"location":"reference/toqito/matrix_ops/calculate_vector_matrix_dimension/#toqito.matrix_ops.calculate_vector_matrix_dimension.calculate_vector_matrix_dimension","title":"calculate_vector_matrix_dimension","text":"<pre><code>calculate_vector_matrix_dimension(item: ndarray) -&gt; int\n</code></pre> <p>Calculate the dimension of a vector or a square matrix, including 2D representations of vectors.</p> <p>This function determines the dimension of the provided item, treating 1D arrays as vectors, 2D arrays with one dimension being 1 as vector representations, and square 2D arrays as density matrices. The dimension is the length for vectors and the square of the side length for density matrices.</p> <p>Example: Consider the following three-dimensional vector:</p> \\[     v = \\left[ 1, 0, 0 \\right]^{\\text{T}}. \\] <p>For this case, the dimension of the vector is equal to its length</p> <pre><code>import numpy as np\nfrom toqito.matrix_ops import calculate_vector_matrix_dimension\n\nv = np.array([1, 0, 0])\n\nprint(calculate_vector_matrix_dimension(v))\n</code></pre> <p>3</p> <p>For the density matrix of some two-dimensional quantum system</p> \\[     \\rho = \\frac{1}{2}             \\begin{pmatrix}                 1 &amp; 0 \\\\                 0 &amp; 1             \\end{pmatrix} \\] <pre><code>import numpy as np\nfrom toqito.matrix_ops import calculate_vector_matrix_dimension\n\nrho = np.array([[1/2, 0],[0, 1/2]])\n\nprint(calculate_vector_matrix_dimension(rho))\n</code></pre> <p>2</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The dimension of the item. For vectors (1D or 2D representations), it's the length. For square matrices, it's</p> </li> <li> <code>int</code>           \u2013            <p>the square of the size of one side.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the input is not a numpy array, not a 1D array (vector), a 2D array representing a vector, or a</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>item</code>               (<code>ndarray</code>)           \u2013            <p>The item whose dimension is being calculated. Can be a 1D array (vector), a 2D array representing a vector</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The dimension of the vector or matrix.</p> </li> </ul> Source code in <code>toqito/matrix_ops/calculate_vector_matrix_dimension.py</code> <pre><code>def calculate_vector_matrix_dimension(item: np.ndarray) -&gt; int:\n    r\"\"\"Calculate the dimension of a vector or a square matrix, including 2D representations of vectors.\n\n    This function determines the dimension of the provided item, treating 1D arrays as vectors,\n    2D arrays with one dimension being 1 as vector representations, and square 2D arrays as density matrices.\n    The dimension is the length for vectors and the square of the side length for density matrices.\n\n    Example:\n    Consider the following three-dimensional vector:\n\n    \\[\n        v = \\left[ 1, 0, 0 \\right]^{\\text{T}}.\n    \\]\n\n    For this case, the dimension of the vector is equal to its length\n\n    ```python exec=\"1\" source=\"above\"\n    import numpy as np\n    from toqito.matrix_ops import calculate_vector_matrix_dimension\n\n    v = np.array([1, 0, 0])\n\n    print(calculate_vector_matrix_dimension(v))\n    ```\n\n    For the density matrix of some two-dimensional quantum system\n\n    \\[\n        \\rho = \\frac{1}{2}\n                \\begin{pmatrix}\n                    1 &amp; 0 \\\\\n                    0 &amp; 1\n                \\end{pmatrix}\n    \\]\n\n    ```python exec=\"1\" source=\"above\"\n    import numpy as np\n    from toqito.matrix_ops import calculate_vector_matrix_dimension\n\n    rho = np.array([[1/2, 0],[0, 1/2]])\n\n    print(calculate_vector_matrix_dimension(rho))\n    ```\n\n    Returns:\n        The dimension of the item. For vectors (1D or 2D representations), it's the length. For square matrices, it's\n        the square of the size of one side.\n\n    Raises:\n        ValueError: If the input is not a numpy array, not a 1D array (vector), a 2D array representing a vector, or a\n        square 2D\n        array (density matrix).\n\n    Args:\n        item: The item whose dimension is being calculated. Can be a 1D array (vector), a 2D array representing a vector\n        with one dimension being 1, or a square 2D array (density matrix).\n\n    Returns:\n        The dimension of the vector or matrix.\n\n    \"\"\"\n    # Check if the input is a numpy array\n    if not isinstance(item, np.ndarray):\n        raise ValueError(\"Input must be a numpy array.\")\n\n    if item.ndim == 1:\n        return item.size\n    if item.ndim == 2:\n        if item.shape[0] == 1 or item.shape[1] == 1:\n            return max(item.shape)\n        if item.shape[0] == item.shape[1]:\n            return item.shape[0]\n        raise ValueError(\"Input must be either a vector or a square matrix.\")\n    raise ValueError(\"Input must be either a vector or a square matrix.\")\n</code></pre>"},{"location":"reference/toqito/matrix_ops/null_space/","title":"null_space","text":""},{"location":"reference/toqito/matrix_ops/null_space/#toqito.matrix_ops.null_space","title":"null_space","text":"<p>Compute an orthonormal basis for the null space of a matrix.</p>"},{"location":"reference/toqito/matrix_ops/null_space/#toqito.matrix_ops.null_space.null_space","title":"null_space","text":"<pre><code>null_space(mat: ndarray, tol: float = 1e-08) -&gt; ndarray\n</code></pre> <p>Return an orthonormal basis for the kernel of <code>mat</code> <sup>1</sup>.</p> <p>The routine employs the singular value decomposition so that the columns of the returned matrix span the null space and are orthonormal with respect to the standard inner product.</p> <p>Examples:</p> <p>Consider the matrix</p> \\[     A = \\begin{pmatrix} 1 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 \\end{pmatrix}. \\] <p>Its null space is spanned by the vectors \\((1,-1,0)\\) and \\((0,0,1)\\).</p> <pre><code>import numpy as np\nfrom toqito.matrix_ops import null_space\n\nA = np.array([[1, 1, 0], [0, 0, 0]], dtype=float)\nnull_basis = null_space(A)\nprint(null_basis)\n</code></pre> <p>[[-0.70710678+0.j  0.        +0.j]  [ 0.70710678-0.j  0.        +0.j]  [ 0.        -0.j -1.        +0.j]]</p> <p>Parameters:</p> <ul> <li> <code>mat</code>               (<code>ndarray</code>)           \u2013            <p>Matrix whose null space is sought.</p> </li> <li> <code>tol</code>               (<code>float</code>, default:                   <code>1e-08</code> )           \u2013            <p>Numerical tolerance that distinguishes zero singular values.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>A matrix whose columns form an orthonormal basis for the null space.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Kernel (linear algebra). link.</p> Source code in <code>toqito/matrix_ops/null_space.py</code> <pre><code>def null_space(mat: np.ndarray, tol: float = 1e-08) -&gt; np.ndarray:\n    r\"\"\"Return an orthonormal basis for the kernel of ``mat`` [@WikiNullSpace].\n\n    The routine employs the singular value decomposition so that the columns of the\n    returned matrix span the null space and are orthonormal with respect to the\n    standard inner product.\n\n    Examples:\n        Consider the matrix\n\n        \\[\n            A = \\begin{pmatrix} 1 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 \\end{pmatrix}.\n        \\]\n\n        Its null space is spanned by the vectors \\((1,-1,0)\\) and \\((0,0,1)\\).\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_ops import null_space\n\n        A = np.array([[1, 1, 0], [0, 0, 0]], dtype=float)\n        null_basis = null_space(A)\n        print(null_basis)\n        ```\n\n\n    Args:\n        mat: Matrix whose null space is sought.\n        tol: Numerical tolerance that distinguishes zero singular values.\n\n    Returns:\n        A matrix whose columns form an orthonormal basis for the null space.\n\n    \"\"\"\n    mat = np.asarray(mat, dtype=np.complex128)\n    if mat.ndim != 2:\n        raise ValueError(\"Input must be a two-dimensional array.\")\n    if mat.size == 0:\n        return np.zeros((mat.shape[0], 0), dtype=np.complex128)\n\n    _, singular_values, vh = np.linalg.svd(mat, full_matrices=True)\n    rank = np.sum(singular_values &gt; tol)\n    kernel = vh[rank:].conj().T\n    if kernel.size == 0:\n        return np.zeros((mat.shape[1], 0), dtype=np.complex128)\n    q, _ = np.linalg.qr(kernel)\n    return q\n</code></pre>"},{"location":"reference/toqito/matrix_ops/partial_trace/","title":"partial_trace","text":""},{"location":"reference/toqito/matrix_ops/partial_trace/#toqito.matrix_ops.partial_trace","title":"partial_trace","text":"<p>Generates the partial trace of a matrix.</p>"},{"location":"reference/toqito/matrix_ops/partial_trace/#toqito.matrix_ops.partial_trace.partial_trace","title":"partial_trace","text":"<pre><code>partial_trace(input_mat: ndarray | Variable, sys: int | list[int] | None = None, dim: int | list[int] | ndarray | None = None) -&gt; ndarray | Expression\n</code></pre> <p>Compute the partial trace of a matrix <sup>1</sup>.</p> <p>The partial trace is defined as</p> \\[     \\left( \\text{Tr} \\otimes \\mathbb{I}_{\\mathcal{Y}} \\right)     \\left(X \\otimes Y \\right) = \\text{Tr}(X)Y \\] <p>where \\(X \\in \\text{L}(\\mathcal{X})\\) and \\(Y \\in \\text{L}(\\mathcal{Y})\\) are linear operators over complex Euclidean spaces \\(\\mathcal{X}\\) and \\(\\mathcal{Y}\\).</p> <p>Gives the partial trace of the matrix X, where the dimensions of the (possibly more than 2) subsystems are given by the vector <code>dim</code> and the subsystems to take the trace on are given by the scalar or vector <code>sys</code>.</p> <p>Examples:</p> <p>Consider the following matrix</p> \\[     X = \\begin{pmatrix}             1 &amp; 2 &amp; 3 &amp; 4 \\\\             5 &amp; 6 &amp; 7 &amp; 8 \\\\             9 &amp; 10 &amp; 11 &amp; 12 \\\\             13 &amp; 14 &amp; 15 &amp; 16         \\end{pmatrix}. \\] <p>Taking the partial trace over the second subsystem of \\(X\\) yields the following matrix</p> \\[     X_{pt, 2} = \\begin{pmatrix}                 7 &amp; 11 \\\\                 23 &amp; 27              \\end{pmatrix}. \\] <p>By default, the partial trace function in <code>|toqito\u27e9</code> takes the trace of the second subsystem.</p> <pre><code>import numpy as np\nfrom toqito.matrix_ops import partial_trace\n\ntest_input_mat = np.arange(1, 17).reshape(4, 4)\n\nprint(partial_trace(test_input_mat))\n</code></pre> <p>[[ 7 11]  [23 27]]</p> <p>By specifying the <code>sys = [0]</code> argument, we can perform the partial trace over the first subsystem (instead of the default second subsystem as done above). Performing the partial trace over the first subsystem yields the following matrix</p> \\[     X_{pt, 1} = \\begin{pmatrix}                     12 &amp; 14 \\\\                     20 &amp; 22                 \\end{pmatrix} \\] <pre><code>import numpy as np\nfrom toqito.matrix_ops import partial_trace\n\ntest_input_mat = np.arange(1, 17).reshape(4, 4)\n\nprint(partial_trace(test_input_mat, [0]))\n</code></pre> <p>[[12 14]  [20 22]]</p> <p>We can also specify both dimension and system size as <code>list</code> arguments. Consider the following \\(16\\)-by-\\(16\\) matrix.</p> <pre><code>import numpy as np\nfrom toqito.matrix_ops import partial_trace\n\ntest_input_mat = np.arange(1, 257).reshape(16, 16)\nprint(test_input_mat)\n</code></pre> <p>[[  1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16]  [ 17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32]  [ 33  34  35  36  37  38  39  40  41  42  43  44  45  46  47  48]  [ 49  50  51  52  53  54  55  56  57  58  59  60  61  62  63  64]  [ 65  66  67  68  69  70  71  72  73  74  75  76  77  78  79  80]  [ 81  82  83  84  85  86  87  88  89  90  91  92  93  94  95  96]  [ 97  98  99 100 101 102 103 104 105 106 107 108 109 110 111 112]  [113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128]  [129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144]  [145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160]  [161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176]  [177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192]  [193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208]  [209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224]  [225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240]  [241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256]]</p> <p>We can take the partial trace on the first and third subsystems and assume that the size of each of the 4 systems is of dimension 2.</p> <pre><code>import numpy as np\nfrom toqito.matrix_ops import partial_trace\ntest_input_mat = np.arange(1, 257).reshape(16, 16)\n\nprint(partial_trace(test_input_mat, [0, 2], [2, 2, 2, 2]))\n</code></pre> <p>[[344 348 360 364]  [408 412 424 428]  [600 604 616 620]  [664 668 680 684]]</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If matrix dimension is not equal to the number of subsystems.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>input_mat</code>               (<code>ndarray | Variable</code>)           \u2013            <p>A square matrix.</p> </li> <li> <code>sys</code>               (<code>int | list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>Scalar or vector specifying the size of the subsystems.</p> </li> <li> <code>dim</code>               (<code>int | list[int] | ndarray | None</code>, default:                   <code>None</code> )           \u2013            <p>Dimension of the subsystems. If <code>None</code>, all dimensions are assumed to be equal.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray | Expression</code>           \u2013            <p>The partial trace of matrix <code>input_mat</code>.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Partial Trace. link.</p> Source code in <code>toqito/matrix_ops/partial_trace.py</code> <pre><code>def partial_trace(\n    input_mat: np.ndarray | Variable,\n    sys: int | list[int] | None = None,\n    dim: int | list[int] | np.ndarray | None = None,\n) -&gt; np.ndarray | Expression:\n    r\"\"\"Compute the partial trace of a matrix [@WikiPartialTr].\n\n    The *partial trace* is defined as\n\n    \\[\n        \\left( \\text{Tr} \\otimes \\mathbb{I}_{\\mathcal{Y}} \\right)\n        \\left(X \\otimes Y \\right) = \\text{Tr}(X)Y\n    \\]\n\n    where \\(X \\in \\text{L}(\\mathcal{X})\\) and \\(Y \\in \\text{L}(\\mathcal{Y})\\) are linear\n    operators over complex Euclidean spaces \\(\\mathcal{X}\\) and \\(\\mathcal{Y}\\).\n\n    Gives the partial trace of the matrix X, where the dimensions of the (possibly more than 2)\n    subsystems are given by the vector `dim` and the subsystems to take the trace on are\n    given by the scalar or vector `sys`.\n\n    Examples:\n        Consider the following matrix\n\n        \\[\n            X = \\begin{pmatrix}\n                    1 &amp; 2 &amp; 3 &amp; 4 \\\\\n                    5 &amp; 6 &amp; 7 &amp; 8 \\\\\n                    9 &amp; 10 &amp; 11 &amp; 12 \\\\\n                    13 &amp; 14 &amp; 15 &amp; 16\n                \\end{pmatrix}.\n        \\]\n\n        Taking the partial trace over the second subsystem of \\(X\\) yields the following matrix\n\n        \\[\n            X_{pt, 2} = \\begin{pmatrix}\n                        7 &amp; 11 \\\\\n                        23 &amp; 27\n                     \\end{pmatrix}.\n        \\]\n\n        By default, the partial trace function in `|toqito\u27e9` takes the trace of the second\n        subsystem.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_ops import partial_trace\n\n        test_input_mat = np.arange(1, 17).reshape(4, 4)\n\n        print(partial_trace(test_input_mat))\n        ```\n\n\n        By specifying the `sys = [0]` argument, we can perform the partial trace over the first\n        subsystem (instead of the default second subsystem as done above). Performing the partial\n        trace over the first subsystem yields the following matrix\n\n        \\[\n            X_{pt, 1} = \\begin{pmatrix}\n                            12 &amp; 14 \\\\\n                            20 &amp; 22\n                        \\end{pmatrix}\n        \\]\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_ops import partial_trace\n\n        test_input_mat = np.arange(1, 17).reshape(4, 4)\n\n        print(partial_trace(test_input_mat, [0]))\n        ```\n\n        We can also specify both dimension and system size as `list` arguments. Consider the\n        following \\(16\\)-by-\\(16\\) matrix.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_ops import partial_trace\n\n        test_input_mat = np.arange(1, 257).reshape(16, 16)\n        print(test_input_mat)\n        ```\n\n\n        We can take the partial trace on the first and third subsystems and assume that the size of\n        each of the 4 systems is of dimension 2.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_ops import partial_trace\n        test_input_mat = np.arange(1, 257).reshape(16, 16)\n\n        print(partial_trace(test_input_mat, [0, 2], [2, 2, 2, 2]))\n        ```\n\n    Raises:\n        ValueError: If matrix dimension is not equal to the number of subsystems.\n\n    Args:\n        input_mat: A square matrix.\n        sys: Scalar or vector specifying the size of the subsystems.\n        dim: Dimension of the subsystems. If `None`, all dimensions are assumed to be equal.\n\n    Returns:\n        The partial trace of matrix `input_mat`.\n\n    \"\"\"\n    if not isinstance(sys, int):\n        if sys is None:\n            sys = [1]\n    # If the input matrix is a CVX variable for an SDP, we convert it to a numpy array,\n    # perform the partial trace, and convert it back to a CVX variable.\n    if isinstance(input_mat, Variable):\n        rho_np = expr_as_np_array(input_mat)\n        traced_rho = partial_trace(rho_np, sys, dim)\n        traced_rho = np_array_as_expr(traced_rho)\n        return traced_rho\n\n    n = input_mat.shape[0]\n    if dim is None:\n        d = int(round(np.sqrt(n)))\n        if d * d != n:\n            raise ValueError(\"Cannot infer subsystem dimensions directly. Please provide `dim`.\")\n        dim = np.array([d, d])\n    elif isinstance(dim, int):\n        if n % dim != 0:\n            raise ValueError(\"Invalid: If `dim` is a scalar, it must evenly divide matrix dimension.\")\n        dim = np.array([dim, n // dim])\n    elif isinstance(dim, list):\n        if len(dim) == 1:\n            d = dim[0]\n            if n % d != 0:\n                raise ValueError(\"Invalid: If `dim` is a scalar, it must evenly divide matrix dimension.\")\n            dim = np.array([d, n // d])\n        else:\n            dim = np.array(dim)\n\n    num_sys = len(dim)\n    prod_dim = np.prod(dim)\n    if isinstance(sys, int):\n        prod_dim_sys = dim[sys]\n        sys = np.array([sys])\n    elif isinstance(sys, (list, np.ndarray)):\n        prod_dim_sys = int(np.prod([dim[i] for i in sys]))\n        sys = np.array(sys)\n    else:\n        raise ValueError(\"Invalid: The variable `sys` must either be of type int or of a list of ints.\")\n\n    sub_prod = prod_dim // prod_dim_sys\n    sub_sys_size = prod_dim_sys\n\n    remaining_sys = np.setdiff1d(np.arange(num_sys), sys, assume_unique=True)\n    perm = np.concatenate([remaining_sys, sys]).astype(np.int32)\n\n    a_mat = permute_systems(input_mat, perm, dim)\n\n    ret_mat = np.reshape(\n        a_mat,\n        [sub_sys_size, sub_prod, sub_sys_size, sub_prod],\n        order=\"F\",\n    )\n    permuted_mat = ret_mat.transpose((1, 3, 0, 2))\n\n    permuted_reshaped_mat = np.reshape(\n        permuted_mat,\n        [sub_prod, sub_prod, sub_sys_size**2],\n        order=\"F\",\n    )\n\n    diag_idx = np.arange(sub_sys_size) * (sub_sys_size + 1)\n    pt_mat = permuted_reshaped_mat[:, :, diag_idx]\n    pt_mat = np.sum(pt_mat, axis=2)\n\n    return pt_mat\n</code></pre>"},{"location":"reference/toqito/matrix_ops/partial_transpose/","title":"partial_transpose","text":""},{"location":"reference/toqito/matrix_ops/partial_transpose/#toqito.matrix_ops.partial_transpose","title":"partial_transpose","text":"<p>Generates the partial transpose of a matrix.</p>"},{"location":"reference/toqito/matrix_ops/partial_transpose/#toqito.matrix_ops.partial_transpose.partial_transpose","title":"partial_transpose","text":"<pre><code>partial_transpose(rho: ndarray | Variable, sys: list[int] | ndarray | int | None = None, dim: list[int] | ndarray | None = None) -&gt; ndarray | Expression\n</code></pre> <p>Compute the partial transpose of a matrix <sup>1</sup>.</p> <p>The partial transpose is defined as</p> \\[     \\left( \\text{T} \\otimes \\mathbb{I}_{\\mathcal{Y}} \\right)     \\left(X\\right) \\] <p>where \\(X \\in \\text{L}(\\mathcal{X})\\) is a linear operator over the complex Euclidean space \\(\\mathcal{X}\\) and where \\(\\text{T}\\) is the transpose mapping \\(\\text{T} \\in \\text{T}(\\mathcal{X})\\) defined as</p> \\[     \\text{T}(X) = X^{\\text{T}} \\] <p>for all \\(X \\in \\text{L}(\\mathcal{X})\\).</p> <p>By default, the returned matrix is the partial transpose of the matrix <code>rho</code>, where it is assumed that the number of rows and columns of <code>rho</code> are both perfect squares and both subsystems have equal dimension. The transpose is applied to the second subsystem.</p> <p>In the case where <code>sys</code> amd <code>dim</code> are specified, this function gives the partial transpose of the matrix <code>rho</code> where the dimensions of the (possibly more than 2) subsystems are given by the vector <code>dim</code> and the subsystems to take the partial transpose are given by the scalar or vector <code>sys</code>. If <code>rho</code> is non-square, different row and column dimensions can be specified by putting the row dimensions in the first row of <code>dim</code> and the column dimensions in the second row of <code>dim</code>.</p> <p>Examples:</p> <p>Consider the following matrix</p> \\[     X = \\begin{pmatrix}             1 &amp; 2 &amp; 3 &amp; 4 \\\\             5 &amp; 6 &amp; 7 &amp; 8 \\\\             9 &amp; 10 &amp; 11 &amp; 12 \\\\             13 &amp; 14 &amp; 15 &amp; 16         \\end{pmatrix}. \\] <p>Performing the partial transpose on the matrix \\(X\\) over the second subsystem yields the following matrix</p> \\[     X_{pt, 2} = \\begin{pmatrix}                 1 &amp; 5 &amp; 3 &amp; 7 \\\\                 2 &amp; 6 &amp; 4 &amp; 8 \\\\                 9 &amp; 13 &amp; 11 &amp; 15 \\\\                 10 &amp; 14 &amp; 12 &amp; 16              \\end{pmatrix}. \\] <p>By default, in <code>|toqito\u27e9</code>, the partial transpose function performs the transposition on the second subsystem as follows.</p> <pre><code>import numpy as np\nfrom toqito.matrix_ops import partial_transpose\n\ntest_input_mat = np.arange(1, 17).reshape(4, 4)\n\nprint(partial_transpose(test_input_mat))\n</code></pre> <p>[[ 1  5  3  7]  [ 2  6  4  8]  [ 9 13 11 15]  [10 14 12 16]]</p> <p>By specifying the <code>sys = 1</code> argument, we can perform the partial transpose over the first subsystem (instead of the default second subsystem as done above). Performing the partial transpose over the first subsystem yields the following matrix</p> \\[     X_{pt, 1} = \\begin{pmatrix}                     1 &amp; 2 &amp; 9 &amp; 10 \\\\                     5 &amp; 6 &amp; 13 &amp; 14 \\\\                     3 &amp; 4 &amp; 11 &amp; 12 \\\\                     7 &amp; 8 &amp; 15 &amp; 16                 \\end{pmatrix}. \\] <pre><code>import numpy as np\nfrom toqito.matrix_ops import partial_transpose\n\ntest_input_mat = np.arange(1, 17).reshape(4, 4)\n\nprint(partial_transpose(test_input_mat, 1))\n</code></pre> <p>[[ 1  5  3  7]  [ 2  6  4  8]  [ 9 13 11 15]  [10 14 12 16]]</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If matrix dimensions are not square.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>rho</code>               (<code>ndarray | Variable</code>)           \u2013            <p>A matrix.</p> </li> <li> <code>sys</code>               (<code>list[int] | ndarray | int | None</code>, default:                   <code>None</code> )           \u2013            <p>Scalar or vector specifying the size of the subsystems.</p> </li> <li> <code>dim</code>               (<code>list[int] | ndarray | None</code>, default:                   <code>None</code> )           \u2013            <p>Dimension of the subsystems. If <code>None</code>, all dimensions are assumed to be equal.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray | Expression</code>           \u2013            <p>The partial transpose of matrix <code>rho</code>.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Peres-Horodecki criterion. link.</p> Source code in <code>toqito/matrix_ops/partial_transpose.py</code> <pre><code>def partial_transpose(\n    rho: np.ndarray | Variable,\n    sys: list[int] | np.ndarray | int | None = None,\n    dim: list[int] | np.ndarray | None = None,\n) -&gt; np.ndarray | Expression:\n    r\"\"\"Compute the partial transpose of a matrix [@WikiPeresHorodecki].\n\n    The *partial transpose* is defined as\n\n    \\[\n        \\left( \\text{T} \\otimes \\mathbb{I}_{\\mathcal{Y}} \\right)\n        \\left(X\\right)\n    \\]\n\n    where \\(X \\in \\text{L}(\\mathcal{X})\\) is a linear operator over the complex Euclidean\n    space \\(\\mathcal{X}\\) and where \\(\\text{T}\\) is the transpose mapping\n    \\(\\text{T} \\in \\text{T}(\\mathcal{X})\\) defined as\n\n    \\[\n        \\text{T}(X) = X^{\\text{T}}\n    \\]\n\n    for all \\(X \\in \\text{L}(\\mathcal{X})\\).\n\n    By default, the returned matrix is the partial transpose of the matrix `rho`, where it\n    is assumed that the number of rows and columns of `rho` are both perfect squares and\n    both subsystems have equal dimension. The transpose is applied to the second subsystem.\n\n    In the case where `sys` amd `dim` are specified, this function gives the partial\n    transpose of the matrix `rho` where the dimensions of the (possibly more than 2)\n    subsystems are given by the vector `dim` and the subsystems to take the partial\n    transpose are given by the scalar or vector `sys`. If `rho` is non-square,\n    different row and column dimensions can be specified by putting the row dimensions in the\n    first row of `dim` and the column dimensions in the second row of `dim`.\n\n    Examples:\n        Consider the following matrix\n\n        \\[\n            X = \\begin{pmatrix}\n                    1 &amp; 2 &amp; 3 &amp; 4 \\\\\n                    5 &amp; 6 &amp; 7 &amp; 8 \\\\\n                    9 &amp; 10 &amp; 11 &amp; 12 \\\\\n                    13 &amp; 14 &amp; 15 &amp; 16\n                \\end{pmatrix}.\n        \\]\n\n        Performing the partial transpose on the matrix \\(X\\) over the second\n        subsystem yields the following matrix\n\n        \\[\n            X_{pt, 2} = \\begin{pmatrix}\n                        1 &amp; 5 &amp; 3 &amp; 7 \\\\\n                        2 &amp; 6 &amp; 4 &amp; 8 \\\\\n                        9 &amp; 13 &amp; 11 &amp; 15 \\\\\n                        10 &amp; 14 &amp; 12 &amp; 16\n                     \\end{pmatrix}.\n        \\]\n\n        By default, in `|toqito\u27e9`, the partial transpose function performs the transposition on\n        the second subsystem as follows.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_ops import partial_transpose\n\n        test_input_mat = np.arange(1, 17).reshape(4, 4)\n\n        print(partial_transpose(test_input_mat))\n        ```\n\n        By specifying the `sys = 1` argument, we can perform the partial transpose over the\n        first subsystem (instead of the default second subsystem as done above). Performing the\n        partial transpose over the first subsystem yields the following matrix\n\n        \\[\n            X_{pt, 1} = \\begin{pmatrix}\n                            1 &amp; 2 &amp; 9 &amp; 10 \\\\\n                            5 &amp; 6 &amp; 13 &amp; 14 \\\\\n                            3 &amp; 4 &amp; 11 &amp; 12 \\\\\n                            7 &amp; 8 &amp; 15 &amp; 16\n                        \\end{pmatrix}.\n        \\]\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_ops import partial_transpose\n\n        test_input_mat = np.arange(1, 17).reshape(4, 4)\n\n        print(partial_transpose(test_input_mat, 1))\n        ```\n\n    Raises:\n        ValueError: If matrix dimensions are not square.\n\n    Args:\n        rho: A matrix.\n        sys: Scalar or vector specifying the size of the subsystems.\n        dim: Dimension of the subsystems. If `None`, all dimensions are assumed to be equal.\n\n    Returns:\n        The partial transpose of matrix `rho`.\n\n    \"\"\"\n    if not isinstance(sys, int):\n        if sys is None:\n            sys = [1]\n    # If the input matrix is a CVX variable for an SDP, we convert it to a\n    # numpy array, perform the partial transpose, and convert it back to a CVX\n    # variable.\n    if isinstance(rho, Variable):\n        rho_np = expr_as_np_array(rho)\n        transposed_rho = partial_transpose(rho_np, sys, dim)\n        transposed_rho = np_array_as_expr(transposed_rho)\n        return transposed_rho\n\n    sqrt_rho_dims = np.round(np.sqrt(list(rho.shape)))\n\n    if dim is None:\n        dim = np.array([[sqrt_rho_dims[0], sqrt_rho_dims[0]], [sqrt_rho_dims[1], sqrt_rho_dims[1]]])\n    if isinstance(dim, float):\n        dim = np.array([dim])\n    if isinstance(dim, list):\n        dim = np.array(dim)\n    if isinstance(sys, list):\n        sys = np.array(sys)\n    if isinstance(sys, int):\n        sys = np.array([sys])\n\n    # Allow the user to enter a single number for dim.\n    if (num_sys := max(dim.shape)) == 1:\n        dim = np.array([dim, list(rho.shape)[0] / dim])\n        if np.abs(dim[1] - np.round(dim[1]))[0] &gt;= 2 * list(rho.shape)[0] * np.finfo(float).eps:\n            raise ValueError(\n                \"InvalidDim: If `dim` is a scalar, `rho` must be \"\n                \"square and `dim` must evenly divide `len(rho)`; \"\n                \"please provide the `dim` array containing the \"\n                \"dimensions of the subsystems.\"\n            )\n        dim[1] = np.round(dim[1])\n        num_sys = 2\n\n    # Allow the user to enter a vector for dim if X is square.\n    if min(dim.shape) == 1 or len(dim.shape) == 1:\n        # Force dim to be a row vector.\n        dim = dim.T.flatten()\n        dim = np.array([dim, dim])\n\n    prod_dim_r = int(np.prod(dim[0, :]))\n    prod_dim_c = int(np.prod(dim[1, :]))\n\n    sub_prod_r = np.prod(dim[0, sys])\n    sub_prod_c = np.prod(dim[1, sys])\n\n    sub_sys_vec_r = prod_dim_r * np.ones(int(sub_prod_r)) / sub_prod_r\n    sub_sys_vec_c = prod_dim_c * np.ones(int(sub_prod_c)) / sub_prod_c\n\n    set_diff = list(set(list(range(num_sys))) - set(sys))\n    perm = (sys).tolist()[:]\n    perm.extend(set_diff)\n\n    # Permute the subsystems so that we just have to do the partial transpose\n    # on the first (potentially larger) subsystem.\n    rho_permuted = permute_systems(rho, perm, dim)\n\n    x_tmp = np.reshape(\n        rho_permuted,\n        [\n            int(sub_sys_vec_r[0]),\n            int(sub_prod_r),\n            int(sub_sys_vec_c[0]),\n            int(sub_prod_c),\n        ],\n        order=\"F\",\n    )\n    y_tmp = np.transpose(x_tmp, [0, 3, 2, 1])\n    z_tmp = np.reshape(\n        y_tmp,\n        [\n            int(sub_sys_vec_r[0]) * int(sub_prod_c),\n            int(sub_sys_vec_c[0]) * int(sub_prod_r),\n        ],\n        order=\"F\",\n    )\n\n    # Return the subsystems back to their original positions.\n    dim[:, sys] = np.flipud(dim[:, sys])\n\n    dim = dim[:, (np.array(perm)).tolist()]\n\n    return permute_systems(z_tmp, perm, dim, False, True)\n</code></pre>"},{"location":"reference/toqito/matrix_ops/perturb_vectors/","title":"perturb_vectors","text":""},{"location":"reference/toqito/matrix_ops/perturb_vectors/#toqito.matrix_ops.perturb_vectors","title":"perturb_vectors","text":"<p>Perturb vectors is used to add a small random number to each element of a vector.</p> <p>A random value is added sampled from a normal distribution scaled by <code>eps</code>.</p>"},{"location":"reference/toqito/matrix_ops/perturb_vectors/#toqito.matrix_ops.perturb_vectors.perturb_vectors","title":"perturb_vectors","text":"<pre><code>perturb_vectors(vectors: list[ndarray], eps: float = 0.1) -&gt; ndarray\n</code></pre> <p>Perturb the vectors by adding a small random number to each element.</p>"},{"location":"reference/toqito/matrix_ops/perturb_vectors/#toqito.matrix_ops.perturb_vectors.perturb_vectors--example","title":"Example:","text":"<pre><code>import numpy as np\nfrom toqito.matrix_ops import perturb_vectors\n\nvectors = [np.array([1.0, 2.0]), np.array([3.0, 4.0])]\n\nprint(perturb_vectors(vectors, eps=0.1))\n</code></pre> <p>[[0.42254142 0.90634361]  [0.57894365 0.81536755]]</p> <p>Parameters:</p> <ul> <li> <code>vectors</code>               (<code>list[ndarray]</code>)           \u2013            <p>List of vectors to perturb.</p> </li> <li> <code>eps</code>               (<code>float</code>, default:                   <code>0.1</code> )           \u2013            <p>Amount by which to perturb vectors.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Resulting list of perturbed vectors by a factor of epsilon.</p> </li> </ul> Source code in <code>toqito/matrix_ops/perturb_vectors.py</code> <pre><code>def perturb_vectors(vectors: list[np.ndarray], eps: float = 0.1) -&gt; np.ndarray:\n    \"\"\"Perturb the vectors by adding a small random number to each element.\n\n    Example:\n    ==========\n\n    ```python exec=\"1\" source=\"above\"\n    import numpy as np\n    from toqito.matrix_ops import perturb_vectors\n\n    vectors = [np.array([1.0, 2.0]), np.array([3.0, 4.0])]\n\n    print(perturb_vectors(vectors, eps=0.1))\n    ```\n\n    Args:\n        vectors: List of vectors to perturb.\n        eps: Amount by which to perturb vectors.\n\n    Returns:\n        Resulting list of perturbed vectors by a factor of epsilon.\n\n    \"\"\"\n    perturbed_vectors: list[np.ndarray] = []\n    for i, v in enumerate(vectors):\n        if eps == 0:\n            perturbed_vectors.append(v)\n        else:\n            perturbed_vectors.append(v + np.random.randn(v.shape[0]) * eps)\n\n            # Normalize the vectors after perturbing them.\n            perturbed_vectors[i] = perturbed_vectors[i] / np.linalg.norm(perturbed_vectors[i])\n    return np.array(perturbed_vectors)\n</code></pre>"},{"location":"reference/toqito/matrix_ops/tensor/","title":"tensor","text":""},{"location":"reference/toqito/matrix_ops/tensor/#toqito.matrix_ops.tensor","title":"tensor","text":"<p>Tensor product operation calculates the tensor product between vectors or matrices.</p>"},{"location":"reference/toqito/matrix_ops/tensor/#toqito.matrix_ops.tensor.tensor","title":"tensor","text":"<pre><code>tensor(*args) -&gt; ndarray | None\n</code></pre> <p>Compute the Kronecker tensor product <sup>1</sup>.</p> <p>Tensor two matrices or vectors together using the standard Kronecker operation provided from numpy.</p> <p>Given two matrices \\(A\\) and \\(B\\), computes \\(A \\otimes B\\). The same concept also applies to two vectors \\(v\\) and \\(w\\) which computes \\(v \\otimes w\\).</p> <p>One may also compute the tensor product one matrix \\(n\\) times with itself.</p> <p>For a matrix, \\(A\\) and an integer \\(n\\), the result of this function computes \\(A^{\\otimes n}\\).</p> <p>Similarly for a vector \\(v\\) and an integer \\(n\\), the result of of this function computes \\(v^{\\otimes n}\\).</p> <p>One may also perform the tensor product on a list of matrices.</p> <p>Given a list of \\(n\\) matrices \\(A_1, A_2, \\ldots, A_n\\) the result of this function computes</p> \\[     A_1 \\otimes A_2 \\otimes \\cdots \\otimes A_n. \\] <p>Similarly, for a list of \\(n\\) vectors \\(v_1, v_2, \\ldots, v_n\\), the result of this function computes</p> \\[     v_1 \\otimes v_2 \\otimes \\cdots \\otimes v_n. \\] <p>Examples:</p> <p>Tensor product two matrices or vectors</p> <p>Consider the following ket vector</p> \\[     e_0 = \\left[1, 0 \\right]^{\\text{T}}. \\] <p>Computing the following tensor product</p> \\[ e_0 \\otimes e_0 = [1, 0, 0, 0]^{\\text{T}}. \\] <p>This can be accomplished in <code>|toqito\u27e9</code> as follows.</p> <pre><code>from toqito.states import basis\nfrom toqito.matrix_ops import tensor\n\ne_0 = basis(2, 0)\n\nprint(tensor(e_0, e_0))\n</code></pre> <p>[[1]  [0]  [0]  [0]]</p> <p>Tensor product one matrix \\(n\\) times with itself.</p> <p>We may also tensor some element with itself some integer number of times. For instance we can compute</p> \\[     e_0^{\\otimes 3} = \\left[1, 0, 0, 0, 0, 0, 0, 0 \\right]^{\\text{T}} \\] <p>in <code>|toqito\u27e9</code> as follows.</p> <pre><code>from toqito.states import basis\nfrom toqito.matrix_ops import tensor\n\ne_0 = basis(2, 0)\n\nprint(tensor(e_0, 3))\n</code></pre> <p>[[1]  [0]  [0]  [0]  [0]  [0]  [0]  [0]]</p> <p>Perform the tensor product on a list of vectors or matrices.</p> <p>If we wish to compute the tensor product against more than two matrices or vectors, we can feed them in as a <code>list</code>. For instance, if we wish to compute \\(e_0 \\otimes e_1 \\otimes e_0\\), we can do so as follows.</p> <pre><code>from toqito.states import basis\nfrom toqito.matrix_ops import tensor\n\ne_0, e_1 = basis(2, 0), basis(2, 1)\n\nprint(tensor([e_0, e_1, e_0]))\n</code></pre> <p>[[0]  [0]  [1]  [0]  [0]  [0]  [0]  [0]]</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>Input must be a vector or matrix.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>args</code>           \u2013            <p>Input to the tensor function is expected to be either: - list[np.ndarray]: List of numpy matrices, - np.ndarray, ... , np.ndarray: An arbitrary number of numpy arrays, - np.ndarray, int: A numpy array and an integer.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray | None</code>           \u2013            <p>The computed tensor product.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Tensor product. link.</p> Source code in <code>toqito/matrix_ops/tensor.py</code> <pre><code>def tensor(*args) -&gt; np.ndarray | None:\n    r\"\"\"Compute the Kronecker tensor product [@WikiTensorProd].\n\n    Tensor two matrices or vectors together using the standard Kronecker\n    operation provided from numpy.\n\n    Given two matrices \\(A\\) and \\(B\\), computes \\(A \\otimes B\\).\n    The same concept also applies to two vectors \\(v\\) and \\(w\\) which\n    computes \\(v \\otimes w\\).\n\n    One may also compute the tensor product one matrix \\(n\\) times with itself.\n\n    For a matrix, \\(A\\) and an integer \\(n\\), the result of this\n    function computes \\(A^{\\otimes n}\\).\n\n    Similarly for a vector \\(v\\) and an integer \\(n\\), the result of\n    of this function computes \\(v^{\\otimes n}\\).\n\n    One may also perform the tensor product on a list of matrices.\n\n    Given a list of \\(n\\) matrices \\(A_1, A_2, \\ldots, A_n\\) the result\n    of this function computes\n\n    \\[\n        A_1 \\otimes A_2 \\otimes \\cdots \\otimes A_n.\n    \\]\n\n    Similarly, for a list of \\(n\\) vectors \\(v_1, v_2, \\ldots, v_n\\),\n    the result of this function computes\n\n    \\[\n        v_1 \\otimes v_2 \\otimes \\cdots \\otimes v_n.\n    \\]\n\n    Examples:\n        Tensor product two matrices or vectors\n\n        Consider the following ket vector\n\n        \\[\n            e_0 = \\left[1, 0 \\right]^{\\text{T}}.\n        \\]\n\n        Computing the following tensor product\n\n        \\[\n        e_0 \\otimes e_0 = [1, 0, 0, 0]^{\\text{T}}.\n        \\]\n\n        This can be accomplished in `|toqito\u27e9` as follows.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import basis\n        from toqito.matrix_ops import tensor\n\n        e_0 = basis(2, 0)\n\n        print(tensor(e_0, e_0))\n        ```\n\n\n        Tensor product one matrix \\(n\\) times with itself.\n\n        We may also tensor some element with itself some integer number of times.\n        For instance we can compute\n\n        \\[\n            e_0^{\\otimes 3} = \\left[1, 0, 0, 0, 0, 0, 0, 0 \\right]^{\\text{T}}\n        \\]\n\n        in `|toqito\u27e9` as follows.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import basis\n        from toqito.matrix_ops import tensor\n\n        e_0 = basis(2, 0)\n\n        print(tensor(e_0, 3))\n        ```\n\n        Perform the tensor product on a list of vectors or matrices.\n\n        If we wish to compute the tensor product against more than two matrices or\n        vectors, we can feed them in as a `list`. For instance, if we wish to\n        compute \\(e_0 \\otimes e_1 \\otimes e_0\\), we can do\n        so as follows.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import basis\n        from toqito.matrix_ops import tensor\n\n        e_0, e_1 = basis(2, 0), basis(2, 1)\n\n        print(tensor([e_0, e_1, e_0]))\n        ```\n\n    Raises:\n        ValueError: Input must be a vector or matrix.\n\n    Args:\n        args: Input to the tensor function is expected to be either:\n            - list[np.ndarray]: List of numpy matrices,\n            - np.ndarray, ... , np.ndarray: An arbitrary number of numpy arrays,\n            - np.ndarray, int: A numpy array and an integer.\n\n    Returns:\n        The computed tensor product.\n\n    \"\"\"\n\n    def fast_exp(matrix, q):\n        \"\"\"Efficient exponentiation by squaring.\"\"\"\n        if q == 1:\n            return matrix\n        tmp = fast_exp(matrix, q &gt;&gt; 1)\n        tmp = np.kron(tmp, tmp)\n        if q &amp; 1:  # If q is odd\n            tmp = np.kron(matrix, tmp)\n        return tmp\n\n    result = None\n\n    # Input is provided as a list of numpy matrices.\n    if (len(args) == 1 and isinstance(args[0], list)) or (len(args) == 1 and isinstance(args[0], np.ndarray)):\n        if len(args[0]) == 1:\n            return args[0][0]\n        if len(args[0]) == 2:\n            return np.kron(args[0][0], args[0][1])\n        if len(args[0]) &gt;= 3:\n            result = args[0][0]\n            for i in range(1, len(args[0])):\n                result = np.kron(result, args[0][i])\n        return result\n\n    # Tensor product one matrix `n` times with itself.\n    if len(args) == 2 and isinstance(args[1], int):\n        num_tensor = args[1]\n        if num_tensor == 0:\n            return np.eye(1, dtype=args[0].dtype)\n        if num_tensor == 1:\n            return args[0]\n        return fast_exp(args[0], num_tensor)\n\n    # Tensor product between two or more matrices.\n    if len(args) == 2:\n        return np.kron(args[0], args[1])\n    if len(args) &gt;= 3:\n        result = args[0]\n        for i in range(1, len(args)):\n            result = np.kron(result, args[i])\n        return result\n\n    raise ValueError(\"The `tensor` function must take either a matrix or vector.\")\n</code></pre>"},{"location":"reference/toqito/matrix_ops/tensor_comb/","title":"tensor_comb","text":""},{"location":"reference/toqito/matrix_ops/tensor_comb/#toqito.matrix_ops.tensor_comb","title":"tensor_comb","text":"<p>Compute tensor combination of list of vectors.</p>"},{"location":"reference/toqito/matrix_ops/tensor_comb/#toqito.matrix_ops.tensor_comb.tensor_comb","title":"tensor_comb","text":"<pre><code>tensor_comb(states: list[ndarray], k: int, mode: str = 'injective', density_matrix: bool = True) -&gt; dict[tuple[int, ...], ndarray]\n</code></pre> <p>Generate all possible tensor product combinations of quantum states (vectors).</p> <p>This function creates a tensor product of quantum state vectors by generating all possible sequences of length <code>k</code> from a given list of quantum states, and computing the tensor product for each sequence.</p> <p>Given <code>n</code> quantum states, this function generates \\(n^k\\) combinations of sequences of length <code>k</code>, computes the tensor product for each sequence, and converts each tensor product to its corresponding density matrix.</p> <p>For one definition and usage of a quantum sequence, refer to <sup>1</sup>.</p> <p>Examples:</p> <p>Consider the following basis vectors for a 2-dimensional quantum system.</p> \\[     e_0 = \\left[1, 0 \\right]^{\\text{T}}, e_1 = \\left[0, 1 \\right]^{\\text{T}}. \\] <p>We can generate all possible tensor products for sequences of length 2.</p> <pre><code>from toqito.matrix_ops import tensor_comb\nimport numpy as np\n\ne_0 = np.array([1, 0])\ne_1 = np.array([0, 1])\n\nresult = tensor_comb([e_0, e_1], 2, mode=\"injective\", density_matrix=True)\n\nfor key, mat in result.items():\n    print(f\"tensor_comb{key} =\\n{mat}\\n\")\n</code></pre> <p>tensor_comb(0, 1) = [[0 0 0 0]  [0 1 0 0]  [0 0 0 0]  [0 0 0 0]]</p> <p>tensor_comb(1, 0) = [[0 0 0 0]  [0 0 0 0]  [0 0 1 0]  [0 0 0 0]]</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the input list of states is empty.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>states</code>               (<code>list[ndarray]</code>)           \u2013            <p>A list of state vectors.</p> </li> <li> <code>k</code>               (<code>int</code>)           \u2013            <p>The length of the sequence.</p> </li> <li> <code>mode</code>               (<code>str</code>, default:                   <code>'injective'</code> )           \u2013            <p>Determines the type of sequences. Default is <code>\"injective\"</code>. <code>non-injective</code> will allow repetitions in</p> </li> <li> <code>density_matrix</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Determines whether the return is a density matrix or a ket. Default is <code>True</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[tuple[int, ...], ndarray]</code>           \u2013            <p>A dictionary where keys are tuples representing sequences of state indices, and values are density matrices of</p> </li> <li> <code>dict[tuple[int, ...], ndarray]</code>           \u2013            <p>the tensor products of the corresponding state vectors or tensor products of the corresponding state vectors</p> </li> <li> <code>dict[tuple[int, ...], ndarray]</code>           \u2013            <p>based on input <code>density_matrix</code> being either <code>True</code> or <code>False</code>.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Gupta, Tathagata and Murshid, Shayeef and Russo, Vincent and Bandyopadhyay, Somshubhro. Optimal discrimination of quantum sequences. arXiv preprint arXiv:2409.08705. (2024).</p> Source code in <code>toqito/matrix_ops/tensor_comb.py</code> <pre><code>def tensor_comb(\n    states: list[np.ndarray],\n    k: int,\n    mode: str = \"injective\",\n    density_matrix: bool = True,\n) -&gt; dict[tuple[int, ...], np.ndarray]:\n    r\"\"\"Generate all possible tensor product combinations of quantum states (vectors).\n\n    This function creates a tensor product of quantum state vectors by generating all possible sequences of length `k`\n    from a given list of quantum states, and computing the tensor product for each sequence.\n\n    Given ``n`` quantum states, this function generates \\(n^k\\) combinations of sequences of length ``k``, computes\n    the tensor product for each sequence, and converts each tensor product to its corresponding density matrix.\n\n    For one definition and usage of a quantum sequence, refer to [@Gupta_2024_Optimal].\n\n    Examples:\n        Consider the following basis vectors for a 2-dimensional quantum system.\n\n        \\[\n            e_0 = \\left[1, 0 \\right]^{\\text{T}}, e_1 = \\left[0, 1 \\right]^{\\text{T}}.\n        \\]\n\n        We can generate all possible tensor products for sequences of length 2.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.matrix_ops import tensor_comb\n        import numpy as np\n\n        e_0 = np.array([1, 0])\n        e_1 = np.array([0, 1])\n\n        result = tensor_comb([e_0, e_1], 2, mode=\"injective\", density_matrix=True)\n\n        for key, mat in result.items():\n            print(f\"tensor_comb{key} =\\n{mat}\\n\")\n        ```\n\n\n    Raises:\n        ValueError: If the input list of states is empty.\n\n    Args:\n        states: A list of state vectors.\n        k: The length of the sequence.\n        mode: Determines the type of sequences. Default is `\"injective\"`. ``non-injective`` will allow repetitions in\n        sequences, ``injective`` will ensures sequences are injective (no repetitions) and ``diagonal`` will allow\n        sequences with repeated indices (diagonal elements).\n        density_matrix: Determines whether the return is a density matrix or a ket. Default is ``True``.\n\n    Returns:\n        A dictionary where keys are tuples representing sequences of state indices, and values are density matrices of\n        the tensor products of the corresponding state vectors or tensor products of the corresponding state vectors\n        based on input `density_matrix` being either ``True`` or ``False``.\n\n    \"\"\"\n    if not states:\n        raise ValueError(\"Input list of states cannot be empty.\")\n\n    if mode not in (\"injective\", \"non-injective\", \"diagonal\"):\n        raise ValueError(\"mode must be injective, non-injective, or diagonal.\")\n\n    if mode == \"injective\" and k &gt; len(states):\n        raise ValueError(\"k must be less than or equal to the number of states for injective sequences.\")\n\n    # Generate sequences based on the selected mode.\n    if mode == \"injective\":\n        sequences = list(itertools.permutations(range(len(states)), k))\n    elif mode == \"non-injective\":\n        sequences = list(itertools.product(range(len(states)), repeat=k))\n    else:  # mode == \"diagonal\"\n        sequences = [(i,) * k for i in range(len(states))]\n\n    sequences_of_states = {}\n    for seq in sequences:\n        state_sequence = [states[i] for i in seq]\n        sequence_tensor_product = np.array(state_sequence[0])\n        for state in state_sequence[1:]:\n            sequence_tensor_product = np.kron(sequence_tensor_product, state)\n\n        if density_matrix:\n            sequences_of_states[seq] = to_density_matrix(sequence_tensor_product)\n        else:\n            sequences_of_states[seq] = sequence_tensor_product\n\n    return sequences_of_states\n</code></pre>"},{"location":"reference/toqito/matrix_ops/tensor_unravel/","title":"tensor_unravel","text":""},{"location":"reference/toqito/matrix_ops/tensor_unravel/#toqito.matrix_ops.tensor_unravel","title":"tensor_unravel","text":"<p>Generate the 1D contraint.</p>"},{"location":"reference/toqito/matrix_ops/tensor_unravel/#toqito.matrix_ops.tensor_unravel.tensor_unravel","title":"tensor_unravel","text":"<pre><code>tensor_unravel(constraint_tensor: ndarray) -&gt; ndarray\n</code></pre> <p>Decode a clause tensor (indicator tensor) into its raw 1D representation.</p> <p>In binary constraint system (BCS) games, parity constraints can be encoded as clause tensors \u2014 n-dimensional NumPy arrays of shape <code>(2, 2, ..., 2)</code>, filled with a constant background value (e.g., <code>(-1)**b[i]</code>) except for a single unique entry that marks the satisfying assignment.</p> <p>This function unravels such a tensor by:</p> <ol> <li>Locating the unique element (the one appearing exactly once).</li> <li>Extracting its multi-dimensional index <code>(i1, i2, ..., in)</code>.</li> <li>Returning a 1D NumPy array <code>[i1, i2, ..., in, value]</code>, where the first <code>n</code>       entries are the coordinates and the last entry is the unique value (\u00b11).</li> </ol> <p>Conceptually, this is a form of structured tensor decoding, closely related to:</p> <ul> <li>Indicator (Kronecker delta) tensors in multilinear algebra refer to <sup>1</sup>.</li> <li>The matrix <code>vec</code>-operator for flattening matrices refer to <sup>2</sup>.</li> <li>Parity-projector encodings in linear-system games refer to <sup>3</sup>.</li> </ul> <p>The tensor-form constraint representation is commonly used in implementations of binary constraint system (BCS) games. For background on BCS games, refer to <sup>4</sup>.</p> <p>Examples:</p> <pre><code>import numpy as np\nfrom toqito.matrix_ops import tensor_unravel\n\ntensor_constraint = np.array([[-1, -1], [-1, 1]])\nprint(tensor_unravel(tensor_constraint))\n</code></pre> <p>[1 1 1]</p> <p>Parameters:</p> <ul> <li> <code>constraint_tensor</code>               (<code>ndarray</code>)           \u2013            <p>An n-dimensional tensor with shape <code>(2,)*n</code>, where each element is either -1 or +1.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>A 1D <code>numpy</code> array of length \\(n+1\\) where the first \\(n\\) elements are the coordinates (indices), and the last</p> </li> <li> <code>ndarray</code>           \u2013            <p>element is the unique constant (rhs).</p> </li> </ul> <p>References</p> <p><sup>1</sup> Kolda, Tamara and Bader, Brett. Tensor Decompositions and Applications. SIAM Review. vol. 51(3). (2009). doi:10.1137/07070111X. <sup>2</sup> Horn, Roger and Johnson, Charles. Matrix Analysis. (1985). doi:10.1017/CBO9780511810817. <sup>3</sup> Cleve, Richard and Liu, Li and Slofstra, William. Perfect commuting-operator strategies for linear system games. Journal of Mathematical Physics. vol. 58. (2016). doi:10.1063/1.4973422. <sup>4</sup> Cleve, Richard and Mittal, Rajat. Characterization of binary constraint system games. Automata, Languages, and Programming: 41st International Colloquium, ICALP 2014, Copenhagen, Denmark, July 8-11, 2014, Proceedings, Part I 41. (2014).</p> Source code in <code>toqito/matrix_ops/tensor_unravel.py</code> <pre><code>def tensor_unravel(constraint_tensor: np.ndarray) -&gt; np.ndarray:\n    r\"\"\"Decode a clause tensor (indicator tensor) into its raw 1D representation.\n\n    In binary constraint system (BCS) games, parity constraints can be encoded as\n    **clause tensors** \u2014 n-dimensional NumPy arrays of shape `(2, 2, ..., 2)`,\n    filled with a constant background value (e.g., `(-1)**b[i]`) except for a\n    single unique entry that marks the satisfying assignment.\n\n    This function unravels such a tensor by:\n\n       1. Locating the unique element (the one appearing exactly once).\n       2. Extracting its multi-dimensional index `(i1, i2, ..., in)`.\n       3. Returning a 1D NumPy array `[i1, i2, ..., in, value]`, where the first `n`\n          entries are the coordinates and the last entry is the unique value (\u00b11).\n\n    Conceptually, this is a form of structured tensor decoding, closely related to:\n\n    - Indicator (Kronecker delta) tensors in multilinear algebra refer to [@Kolda_2009_Tensor].\n    - The matrix ``vec``-operator for flattening matrices refer to [@Horn_1985_Matrix].\n    - Parity-projector encodings in linear-system games refer to [@Cleve_2016_Perfect].\n\n    The tensor-form constraint representation is commonly used in implementations of\n    binary constraint system (BCS) games. For background on BCS games, refer to [@Cleve_2014_Characterization].\n\n    Examples:\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_ops import tensor_unravel\n\n        tensor_constraint = np.array([[-1, -1], [-1, 1]])\n        print(tensor_unravel(tensor_constraint))\n        ```\n\n    Args:\n        constraint_tensor: An n-dimensional tensor with shape `(2,)*n`, where each element is either -1 or +1.\n        All entries should be equal except for one unique position that marks the satisfying assignment.\n\n    Returns:\n        A 1D `numpy` array of length \\(n+1\\) where the first \\(n\\) elements are the coordinates (indices), and the last\n        element is the unique constant (rhs).\n\n    \"\"\"\n    values, counts = np.unique(constraint_tensor, return_counts=True)\n    if len(values) != 2:\n        raise ValueError(\"Constraint tensor does not have exactly two distinct values.\")\n    if counts[0] == 1:\n        unique_value = values[0]\n    elif counts[1] == 1:\n        unique_value = values[1]\n    else:\n        raise ValueError(\"Constraint tensor does not have a unique element that appears exactly once.\")\n    unique_idx = np.argwhere(constraint_tensor == unique_value)\n    if unique_idx.shape[0] != 1:\n        raise ValueError(\"Expected exactly one occurrence of the unique value in the constraint tensor.\")\n    return np.array(list(unique_idx[0]) + [unique_value])\n</code></pre>"},{"location":"reference/toqito/matrix_ops/to_density_matrix/","title":"to_density_matrix","text":""},{"location":"reference/toqito/matrix_ops/to_density_matrix/#toqito.matrix_ops.to_density_matrix","title":"to_density_matrix","text":"<p>Converts a row or a column vector to a density matrix.</p>"},{"location":"reference/toqito/matrix_ops/to_density_matrix/#toqito.matrix_ops.to_density_matrix.to_density_matrix","title":"to_density_matrix","text":"<pre><code>to_density_matrix(input_array: ndarray) -&gt; ndarray\n</code></pre> <p>Convert a given vector to a density matrix or return the density matrix if already given.</p> <p>If the input is a vector, this function computes the outer product to form a density matrix. If the input is already a density matrix (square matrix), it returns the matrix as is.</p> <p>Examples:</p> <p>As an example, consider one of the Bell states.</p> <pre><code>from toqito.states import bell\nfrom toqito.matrix_ops import to_density_matrix\n\nprint(to_density_matrix(bell(0)))\n</code></pre> <p>[[0.5 0.  0.  0.5]  [0.  0.  0.  0. ]  [0.  0.  0.  0. ]  [0.5 0.  0.  0.5]]</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the input is not a vector or a square matrix.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>input_array</code>               (<code>ndarray</code>)           \u2013            <p>Input array which could be a vector or a density matrix.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>The computed or provided density matrix.</p> </li> </ul> Source code in <code>toqito/matrix_ops/to_density_matrix.py</code> <pre><code>def to_density_matrix(input_array: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Convert a given vector to a density matrix or return the density matrix if already given.\n\n    If the input is a vector, this function computes the outer product to form a density matrix.\n    If the input is already a density matrix (square matrix), it returns the matrix as is.\n\n    Examples:\n        As an example, consider one of the Bell states.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import bell\n        from toqito.matrix_ops import to_density_matrix\n\n        print(to_density_matrix(bell(0)))\n        ```\n\n\n    Raises:\n        ValueError: If the input is not a vector or a square matrix.\n\n    Args:\n        input_array: Input array which could be a vector or a density matrix.\n\n    Returns:\n        The computed or provided density matrix.\n\n    \"\"\"\n    # Check if the input is a vector (1D array) or a 2D array\n    if input_array.ndim == 1:\n        # Input is a vector, compute the density matrix\n        density_matrix = np.outer(input_array, np.conjugate(input_array))\n    elif input_array.ndim == 2:\n        # Flatten the array if it's a column vector (n, 1) or a row vector (1, n)\n        if input_array.shape[0] == 1 or input_array.shape[1] == 1:\n            vector = input_array.flatten()\n            density_matrix = np.outer(vector, np.conjugate(vector))\n        elif input_array.shape[0] == input_array.shape[1]:\n            # Input is a square matrix, assumed to be a density matrix, return as is\n            density_matrix = input_array\n        else:\n            raise ValueError(\"Input must be either a vector or a square density matrix.\")\n    else:\n        raise ValueError(\"Input must be either a vector or a square density matrix.\")\n\n    return density_matrix\n</code></pre>"},{"location":"reference/toqito/matrix_ops/unvec/","title":"unvec","text":""},{"location":"reference/toqito/matrix_ops/unvec/#toqito.matrix_ops.unvec","title":"unvec","text":"<p>Unvec operation is used to perform the unvec operation on a vector.</p>"},{"location":"reference/toqito/matrix_ops/unvec/#toqito.matrix_ops.unvec.unvec","title":"unvec","text":"<pre><code>unvec(vector: ndarray, shape: list[int] | None = None) -&gt; ndarray\n</code></pre> <p>Perform the unvec operation on a vector to obtain a matrix <sup>1</sup>.</p> <p>Takes a column vector and transforms it into a <code>shape[0]</code>-by-<code>shape[1]</code> matrix. This operation is the inverse of <code>vec</code> operation in <code>|toqito\u27e9</code>.</p> <p>For instance, for the following column vector</p> \\[     u = \\begin{pmatrix} 1 \\\\ 3 \\\\ 2 \\\\ 4 \\end{pmatrix}, \\] <p>it holds that</p> \\[     \\text{unvec}(u) =     \\begin{pmatrix}         1 &amp; 2 \\\\         3 &amp; 4     \\end{pmatrix} \\] <p>More formally, the vec operation is defined by</p> \\[     \\text{unvec}(e_a \\otimes e_b) = E_{a,b} \\] <p>for all \\(a\\) and \\(b\\) where</p> \\[     E_{a,b}(c,d) = \\begin{cases}                       1 &amp; \\text{if} \\ (c,d) = (a,b) \\\\                       0 &amp; \\text{otherwise}                     \\end{cases} \\] <p>for all \\(c\\) and \\(d\\) and where</p> \\[     e_a(b) = \\begin{cases}                  1 &amp; \\text{if} \\ a = b \\\\                  0 &amp; \\text{if} \\ a \\not= b              \\end{cases} \\] <p>for all \\(a\\) and \\(b\\).</p> <p>This function has been adapted from <sup>1</sup>.</p> <p>Examples:</p> <p>Consider the following vector</p> \\[     u = \\begin{pmatrix} 1 \\\\ 3 \\\\ 2 \\\\ 4 \\end{pmatrix} \\] <p>Performing the \\(\\text{unvec}\\) operation on \\(u\\) yields</p> \\[     \\text{unvec}(u) = \\begin{pmatrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\end{pmatrix} \\] <pre><code>import numpy as np\nfrom toqito.matrix_ops import unvec\n\nu = np.array([1, 2, 3, 4])\n\nprint(unvec(u))\n</code></pre> <p>[[1 3]  [2 4]]</p> <p>See</p> <p>[vec][toqito.matrix_ops.vec.vec]</p> <p>Parameters:</p> <ul> <li> <code>vector</code>               (<code>ndarray</code>)           \u2013            <p>A (<code>shape[0] * shape[1]</code>)-by-1 numpy array.</p> </li> <li> <code>shape</code>               (<code>list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The shape of the output matrix; by default, the matrix is assumed to be square.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Returns a <code>shape[0]</code>-by-<code>shape[1]</code> matrix.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Rigetti. Forest Benchmarking. link.</p> Source code in <code>toqito/matrix_ops/unvec.py</code> <pre><code>def unvec(vector: np.ndarray, shape: list[int] | None = None) -&gt; np.ndarray:\n    r\"\"\"Perform the unvec operation on a vector to obtain a matrix [@Rigetti_2022_Forest].\n\n    Takes a column vector and transforms it into a `shape[0]`-by-`shape[1]` matrix.\n    This operation is the inverse of `vec` operation in `|toqito\u27e9`.\n\n    For instance, for the following column vector\n\n    \\[\n        u = \\begin{pmatrix} 1 \\\\ 3 \\\\ 2 \\\\ 4 \\end{pmatrix},\n    \\]\n\n    it holds that\n\n    \\[\n        \\text{unvec}(u) =\n        \\begin{pmatrix}\n            1 &amp; 2 \\\\\n            3 &amp; 4\n        \\end{pmatrix}\n    \\]\n\n    More formally, the vec operation is defined by\n\n    \\[\n        \\text{unvec}(e_a \\otimes e_b) = E_{a,b}\n    \\]\n\n    for all \\(a\\) and \\(b\\) where\n\n    \\[\n        E_{a,b}(c,d) = \\begin{cases}\n                          1 &amp; \\text{if} \\ (c,d) = (a,b) \\\\\n                          0 &amp; \\text{otherwise}\n                        \\end{cases}\n    \\]\n\n    for all \\(c\\) and \\(d\\) and where\n\n    \\[\n        e_a(b) = \\begin{cases}\n                     1 &amp; \\text{if} \\ a = b \\\\\n                     0 &amp; \\text{if} \\ a \\not= b\n                 \\end{cases}\n    \\]\n\n    for all \\(a\\) and \\(b\\).\n\n    This function has been adapted from [@Rigetti_2022_Forest].\n\n    Examples:\n        Consider the following vector\n\n        \\[\n            u = \\begin{pmatrix} 1 \\\\ 3 \\\\ 2 \\\\ 4 \\end{pmatrix}\n        \\]\n\n        Performing the \\(\\text{unvec}\\) operation on \\(u\\) yields\n\n        \\[\n            \\text{unvec}(u) = \\begin{pmatrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\end{pmatrix}\n        \\]\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_ops import unvec\n\n        u = np.array([1, 2, 3, 4])\n\n        print(unvec(u))\n        ```\n\n        !!! See Also\n            [vec][toqito.matrix_ops.vec.vec]\n\n    Args:\n        vector: A (`shape[0] * shape[1]`)-by-1 numpy array.\n        shape: The shape of the output matrix; by default, the matrix is assumed to be square.\n\n    Returns:\n        Returns a `shape[0]`-by-`shape[1]` matrix.\n\n    \"\"\"\n    vector = np.asarray(vector)\n    if shape is None:\n        dim = int(np.sqrt(vector.size))\n        shape = dim, dim\n    mat = vector.reshape(*shape, order=\"F\")\n    return mat\n</code></pre>"},{"location":"reference/toqito/matrix_ops/vectors_from_gram_matrix/","title":"vectors_from_gram_matrix","text":""},{"location":"reference/toqito/matrix_ops/vectors_from_gram_matrix/#toqito.matrix_ops.vectors_from_gram_matrix","title":"vectors_from_gram_matrix","text":"<p>Calculates the vectors associated to a Gram matrix.</p>"},{"location":"reference/toqito/matrix_ops/vectors_from_gram_matrix/#toqito.matrix_ops.vectors_from_gram_matrix.vectors_from_gram_matrix","title":"vectors_from_gram_matrix","text":"<pre><code>vectors_from_gram_matrix(gram: ndarray) -&gt; list[ndarray]\n</code></pre> <p>Obtain the corresponding ensemble of states from the Gram matrix <sup>1</sup>.</p> <p>The function attempts to compute the Cholesky decomposition of the given Gram matrix. If the matrix is positive definite, the Cholesky decomposition is returned. If the matrix is not positive definite, the function falls back to eigendecomposition.</p> <p>Examples:</p> <p>Example of a positive definite matrix:</p> <pre><code>import numpy as np\nfrom toqito.matrix_ops import vectors_from_gram_matrix\n\ngram_matrix = np.array([[2, -1], [-1, 2]])\nvectors = vectors_from_gram_matrix(gram_matrix)\n\nprint(vectors)\n</code></pre> <p>[array([1.41421356, 0.        ]), array([-0.70710678,  1.22474487])]</p> <p>Example of a matrix that is not positive definite:</p> <pre><code>import numpy as np\nfrom toqito.matrix_ops import vectors_from_gram_matrix\ngram_matrix = np.array([[0, 1], [1, 0]])\nvectors = vectors_from_gram_matrix(gram_matrix)\n\nprint(vectors)  # Matrix is not positive semidefinite. Using eigendecomposition as alternative.\n</code></pre> <p>[array([0.70710678+0.j        , 0.        -0.70710678j]), array([0.70710678+0.j        , 0.        +0.70710678j])]</p> <p>Raises:</p> <ul> <li> <code>LinAlgError</code>             \u2013            <p>If the Gram matrix is not square.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>gram</code>               (<code>ndarray</code>)           \u2013            <p>A square, symmetric matrix representing the Gram matrix.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[ndarray]</code>           \u2013            <p>A list of vectors (np.ndarray) corresponding to the ensemble of states.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Gram Matrix. link.</p> Source code in <code>toqito/matrix_ops/vectors_from_gram_matrix.py</code> <pre><code>def vectors_from_gram_matrix(gram: np.ndarray) -&gt; list[np.ndarray]:\n    r\"\"\"Obtain the corresponding ensemble of states from the Gram matrix [@WikiGram].\n\n    The function attempts to compute the Cholesky decomposition of the given Gram matrix. If the matrix is positive\n    definite, the Cholesky decomposition is returned. If the matrix is not positive definite, the function falls back to\n    eigendecomposition.\n\n    Examples:\n        Example of a positive definite matrix:\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_ops import vectors_from_gram_matrix\n\n        gram_matrix = np.array([[2, -1], [-1, 2]])\n        vectors = vectors_from_gram_matrix(gram_matrix)\n\n        print(vectors)\n        ```\n\n        Example of a matrix that is not positive definite:\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_ops import vectors_from_gram_matrix\n        gram_matrix = np.array([[0, 1], [1, 0]])\n        vectors = vectors_from_gram_matrix(gram_matrix)\n\n        print(vectors)  # Matrix is not positive semidefinite. Using eigendecomposition as alternative.\n        ```\n\n    Raises:\n        LinAlgError: If the Gram matrix is not square.\n\n    Args:\n        gram: A square, symmetric matrix representing the Gram matrix.\n\n    Returns:\n        A list of vectors (np.ndarray) corresponding to the ensemble of states.\n\n    \"\"\"\n    dim = gram.shape[0]\n    if gram.shape[0] != gram.shape[1]:\n        raise np.linalg.LinAlgError(\"The Gram matrix must be square.\")\n\n    # If matrix is PD, can do Cholesky decomposition:\n    try:\n        decomp = np.linalg.cholesky(gram)\n        return [decomp[i][:] for i in range(dim)]\n    # Otherwise, need to do eigendecomposition:\n    except np.linalg.LinAlgError:\n        print(\"Matrix is not positive semidefinite. Using eigendecomposition as alternative.\")\n        d, v = np.linalg.eig(gram)\n        return [scipy.linalg.sqrtm(np.diag(d)) @ v[i].conj().T for i in range(dim)]\n</code></pre>"},{"location":"reference/toqito/matrix_ops/vectors_to_gram_matrix/","title":"vectors_to_gram_matrix","text":""},{"location":"reference/toqito/matrix_ops/vectors_to_gram_matrix/#toqito.matrix_ops.vectors_to_gram_matrix","title":"vectors_to_gram_matrix","text":"<p>Calculates the Gram matrix from a list of vectors.</p>"},{"location":"reference/toqito/matrix_ops/vectors_to_gram_matrix/#toqito.matrix_ops.vectors_to_gram_matrix.vectors_to_gram_matrix","title":"vectors_to_gram_matrix","text":"<pre><code>vectors_to_gram_matrix(vectors: list[ndarray]) -&gt; ndarray\n</code></pre> <p>Construct the Gram matrix from a list of vectors or density matrices <sup>1</sup>.</p> <p>The Gram matrix is a matrix of inner products. This function automatically detects whether the inputs are vectors (pure states) or density matrices (mixed states) and computes the appropriate Gram matrix.</p> <p>For vectors |\u03c8\u1d62\u27e9: G[i, j] = \u27e8\u03c8\u1d62|\u03c8\u2c7c\u27e9 For density matrices \u03c1\u1d62: G[i, j] = Tr(\u03c1\u1d62 \u03c1\u2c7c)</p> <p>Examples:</p> <p>Example with real vectors:</p> <pre><code>import numpy as np\nfrom toqito.matrix_ops import vectors_to_gram_matrix\n\nvectors = [np.array([1, 2]), np.array([3, 4])]\ngram_matrix = vectors_to_gram_matrix(vectors)\n\nprint(gram_matrix)\n</code></pre> <p>[[ 5 11]  [11 25]]</p> <p>Example with complex vectors:</p> <pre><code>import numpy as np\nfrom toqito.matrix_ops import vectors_to_gram_matrix\n\nvectors = [np.array([1+1j, 2+2j]), np.array([3+3j, 4+4j])]\ngram_matrix = vectors_to_gram_matrix(vectors)\n\nprint(gram_matrix)\n</code></pre> <p>[[10.+0.j 22.+0.j]  [22.+0.j 50.+0.j]]</p> <p>Example with density matrices (mixed states):</p> <pre><code>import numpy as np\nfrom toqito.matrix_ops import vectors_to_gram_matrix\n\n# Two mixed states\nrho1 = 0.7 * np.array([[1., 0.], [0., 0.]]) + 0.3 * np.eye(2) / 2\nrho2 = 0.7 * np.array([[0., 0.], [0., 1.]]) + 0.3 * np.eye(2) / 2\nstates = [rho1, rho2]\n\ngram_matrix = vectors_to_gram_matrix(states)\nprint(gram_matrix)\n</code></pre> <p>[[0.745+0.j 0.255+0.j]  [0.255+0.j 0.745+0.j]]</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the vectors are not all of the same shape.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>vectors</code>               (<code>list[ndarray]</code>)           \u2013            <p>A list of vectors (1D/column arrays for pure states) or density matrices (2D arrays for mixed states).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>The Gram matrix with entries G[i,j] = \u27e8v\u1d62|v\u2c7c\u27e9 for vectors or Tr(\u03c1\u1d62\u03c1\u2c7c) for density matrices.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Gram Matrix. link.</p> Source code in <code>toqito/matrix_ops/vectors_to_gram_matrix.py</code> <pre><code>def vectors_to_gram_matrix(vectors: list[np.ndarray]) -&gt; np.ndarray:\n    r\"\"\"Construct the Gram matrix from a list of vectors or density matrices [@WikiGram].\n\n    The Gram matrix is a matrix of inner products. This function automatically detects whether the inputs\n    are vectors (pure states) or density matrices (mixed states) and computes the appropriate Gram matrix.\n\n    For vectors |\u03c8\u1d62\u27e9: G[i, j] = \u27e8\u03c8\u1d62|\u03c8\u2c7c\u27e9\n    For density matrices \u03c1\u1d62: G[i, j] = Tr(\u03c1\u1d62 \u03c1\u2c7c)\n\n    Examples:\n        Example with real vectors:\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_ops import vectors_to_gram_matrix\n\n        vectors = [np.array([1, 2]), np.array([3, 4])]\n        gram_matrix = vectors_to_gram_matrix(vectors)\n\n        print(gram_matrix)\n        ```\n\n        Example with complex vectors:\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_ops import vectors_to_gram_matrix\n\n        vectors = [np.array([1+1j, 2+2j]), np.array([3+3j, 4+4j])]\n        gram_matrix = vectors_to_gram_matrix(vectors)\n\n        print(gram_matrix)\n        ```\n\n        Example with density matrices (mixed states):\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_ops import vectors_to_gram_matrix\n\n        # Two mixed states\n        rho1 = 0.7 * np.array([[1., 0.], [0., 0.]]) + 0.3 * np.eye(2) / 2\n        rho2 = 0.7 * np.array([[0., 0.], [0., 1.]]) + 0.3 * np.eye(2) / 2\n        states = [rho1, rho2]\n\n        gram_matrix = vectors_to_gram_matrix(states)\n        print(gram_matrix)\n        ```\n\n    Raises:\n        ValueError: If the vectors are not all of the same shape.\n\n    Args:\n        vectors: A list of vectors (1D/column arrays for pure states) or density matrices (2D arrays for mixed states).\n\n    Returns:\n        The Gram matrix with entries G[i,j] = \u27e8v\u1d62|v\u2c7c\u27e9 for vectors or Tr(\u03c1\u1d62\u03c1\u2c7c) for density matrices.\n\n    \"\"\"\n    # Check that all vectors are of the same shape\n    if not all(v.shape == vectors[0].shape for v in vectors):\n        raise ValueError(\"All vectors must be of the same shape.\")\n\n    first_input = vectors[0]\n\n    # Check if inputs are vectors (1D or column vectors) or density matrices (2D with d &gt; 1)\n    if first_input.ndim == 1 or (first_input.ndim == 2 and first_input.shape[1] == 1):\n        # Pure states: use standard Gram matrix construction\n        # Stack vectors into a matrix\n        stacked_vectors = np.column_stack(vectors)\n        # Compute Gram matrix using vectorized operations\n        return np.dot(stacked_vectors.conj().T, stacked_vectors)\n    else:\n        # Mixed states: compute Tr(\u03c1\u1d62 \u03c1\u2c7c)\n        n = len(vectors)\n        gram = np.zeros((n, n), dtype=complex)\n        for i in range(n):\n            for j in range(n):\n                gram[i, j] = np.trace(vectors[i] @ vectors[j])\n        return gram\n</code></pre>"},{"location":"reference/toqito/matrix_props/","title":"matrix_props","text":""},{"location":"reference/toqito/matrix_props/#toqito.matrix_props","title":"matrix_props","text":"<p>Matrix operations is a set of modules that implements various properties of matrices and vectors.</p>"},{"location":"reference/toqito/matrix_props/commutant/","title":"commutant","text":""},{"location":"reference/toqito/matrix_props/commutant/#toqito.matrix_props.commutant","title":"commutant","text":"<p>Module for computing the commutant of a set of matrices.</p>"},{"location":"reference/toqito/matrix_props/commutant/#toqito.matrix_props.commutant.commutant","title":"commutant","text":"<pre><code>commutant(A: ndarray | list[ndarray]) -&gt; list[ndarray]\n</code></pre> <p>Compute an orthonormal basis for the commutant algebra <sup>1</sup>.</p> <p>Given a matrix \\(A\\) or a set of matrices \\(\\mathcal{A} = \\{A_1, A_2, \\dots\\}\\), this function determines an orthonormal basis (with respect to the Hilbert-Schmidt inner product) for the algebra of matrices that commute with every matrix in \\(\\mathcal{A}\\).</p> <p>The commutant of a single matrix \\(A \\in \\mathbb{C}^{n \\times n}\\) consists of all matrices \\(X \\in \\mathbb{C}^{n \\times n}\\) satisfying:</p> \\[     A X = X A. \\] <p>More generally, for a set of matrices \\(\\mathcal{A} = \\{A_1, A_2, \\dots\\}\\), the commutant consists of all matrices \\(X\\) satisfying:</p> \\[     A_i X = X A_i \\quad \\forall A_i \\in \\mathcal{A}. \\] <p>This condition can be rewritten in vectorized form as:</p> \\[     (A_i \\otimes I - I \\otimes A_i^T) \\text{vec}(X) = 0, \\quad \\forall A_i \\in \\mathcal{A}. \\] <p>where \\(\\text{vec}(X)\\) denotes the column-wise vectorization of \\(X\\). The null space of this equation provides a basis for the commutant.</p> <p>This implementation is based on <sup>2</sup>.</p> <p>Examples:</p> <p>Consider the following set of matrices:</p> \\[     A_1 = \\begin{pmatrix}             1 &amp; 0 \\\\             0 &amp; -1         \\end{pmatrix}, \\quad     A_2 = \\begin{pmatrix}             0 &amp; 1 \\\\             1 &amp; 0         \\end{pmatrix} \\] <p>The commutant consists of matrices that commute with both \\(A_1\\) and \\(A_2\\).</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import commutant\n\nA1 = np.array([[1, 0], [0, -1]])\nA2 = np.array([[0, 1], [1, 0]])\n\nbasis = commutant([A1, A2])\n\nprint(basis)\n</code></pre> <p>[array([[0.70710678, 0.        ],        [0.        , 0.70710678]])]</p> <p>Now, consider a single matrix:</p> \\[     A = \\begin{pmatrix}             1 &amp; 1 \\\\             0 &amp; 1         \\end{pmatrix} \\] <pre><code>import numpy as np\nfrom toqito.matrix_props import commutant\n\nA = np.array([[1, 1], [0, 1]])\n\nbasis = commutant(A)\n\nfor i, basis_ in enumerate(basis):\n   print(f\"basis{ i} :\\n{basis_} \\n\")\n</code></pre> <p>basis0 : [[0.70710678 0.        ]  [0.         0.70710678]] </p> <p>basis1 : [[ 0. -1.]  [ 0.  0.]] </p> <p>Parameters:</p> <ul> <li> <code>A</code>               (<code>ndarray | list[ndarray]</code>)           \u2013            <p>A single matrix of the form np.ndarray or a list of square matrices of the same dimension.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[ndarray]</code>           \u2013            <p>A list of matrices forming an orthonormal basis for the commutant.</p> </li> </ul> <p>References</p> <p><sup>1</sup> {PlanetMath}. Commutant. link. <sup>2</sup> Johnston, Nathaniel. {{QETLAB}: {A MATLAB} toolbox for quantum entanglement}. doi:10.5281/zenodo.44637.</p> Source code in <code>toqito/matrix_props/commutant.py</code> <pre><code>def commutant(A: np.ndarray | list[np.ndarray]) -&gt; list[np.ndarray]:\n    r\"\"\"Compute an orthonormal basis for the commutant algebra [@PlanetMathCommutant].\n\n    Given a matrix \\(A\\) or a set of matrices \\(\\mathcal{A} = \\{A_1, A_2, \\dots\\}\\),\n    this function determines an orthonormal basis (with respect to the Hilbert-Schmidt inner product)\n    for the algebra of matrices that commute with every matrix in \\(\\mathcal{A}\\).\n\n    The commutant of a single matrix \\(A \\in \\mathbb{C}^{n \\times n}\\) consists of all matrices\n    \\(X \\in \\mathbb{C}^{n \\times n}\\) satisfying:\n\n    \\[\n        A X = X A.\n    \\]\n\n    More generally, for a set of matrices \\(\\mathcal{A} = \\{A_1, A_2, \\dots\\}\\), the commutant\n    consists of all matrices \\(X\\) satisfying:\n\n    \\[\n        A_i X = X A_i \\quad \\forall A_i \\in \\mathcal{A}.\n    \\]\n\n    This condition can be rewritten in vectorized form as:\n\n    \\[\n        (A_i \\otimes I - I \\otimes A_i^T) \\text{vec}(X) = 0, \\quad \\forall A_i \\in \\mathcal{A}.\n    \\]\n\n    where \\(\\text{vec}(X)\\) denotes the column-wise vectorization of \\(X\\).\n    The null space of this equation provides a basis for the commutant.\n\n    This implementation is based on [@QETLAB_link].\n\n    Examples:\n        Consider the following set of matrices:\n\n        \\[\n            A_1 = \\begin{pmatrix}\n                    1 &amp; 0 \\\\\n                    0 &amp; -1\n                \\end{pmatrix}, \\quad\n            A_2 = \\begin{pmatrix}\n                    0 &amp; 1 \\\\\n                    1 &amp; 0\n                \\end{pmatrix}\n        \\]\n\n        The commutant consists of matrices that commute with both \\(A_1\\) and \\(A_2\\).\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import commutant\n\n        A1 = np.array([[1, 0], [0, -1]])\n        A2 = np.array([[0, 1], [1, 0]])\n\n        basis = commutant([A1, A2])\n\n        print(basis)\n        ```\n\n\n        Now, consider a single matrix:\n\n        \\[\n            A = \\begin{pmatrix}\n                    1 &amp; 1 \\\\\n                    0 &amp; 1\n                \\end{pmatrix}\n        \\]\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import commutant\n\n        A = np.array([[1, 1], [0, 1]])\n\n        basis = commutant(A)\n\n        for i, basis_ in enumerate(basis):\n           print(f\"basis{ i} :\\n{basis_} \\n\")\n        ```\n\n    Args:\n        A: A single matrix of the form np.ndarray or a list of square matrices of the same dimension.\n\n    Returns:\n        A list of matrices forming an orthonormal basis for the commutant.\n\n    \"\"\"\n    # Handle list of matrices.\n    if isinstance(A, list):\n        # Convert to 3D array.\n        A = np.stack(A, axis=0)\n    else:\n        # Ensure it's a 3D array.\n        A = np.expand_dims(A, axis=0)\n    # Extract number of operators and dimension.\n    num_ops, dim, _ = A.shape\n\n    # Construct the commutant condition (A \u2297 I - I \u2297 A^T) vec(X) = 0.\n    comm_matrices = [np.kron(A[i], np.eye(dim)) - np.kron(np.eye(dim), A[i].T) for i in range(num_ops)]\n\n    # Stack into a 2D matrix for null_space computation.\n    comm_matrix = np.vstack(comm_matrices) if len(comm_matrices) &gt; 1 else comm_matrices[0]\n\n    # Compute null space.\n    null_basis = null_space(comm_matrix)  # Basis vectors for commuting matrices\n\n    # Reshape each basis vector into a matrix of size (dim x dim).\n    return [null_basis[:, i].reshape((dim, dim)) for i in range(null_basis.shape[1])]\n</code></pre>"},{"location":"reference/toqito/matrix_props/factor_width/","title":"factor_width","text":""},{"location":"reference/toqito/matrix_props/factor_width/#toqito.matrix_props.factor_width","title":"factor_width","text":"<p>Determine the factor width of a positive semidefinite matrix.</p>"},{"location":"reference/toqito/matrix_props/factor_width/#toqito.matrix_props.factor_width.factor_width","title":"factor_width","text":"<pre><code>factor_width(mat: ndarray, k: int, *, solver: str | None = 'SCS', solver_kwargs: dict | None = None, tol: float = 1e-08) -&gt; dict\n</code></pre> <p>Decide whether a positive semidefinite matrix has factor width at most \\(k\\).</p> <p>The factor width of a matrix is the minimal value of \\(k\\) for which it admits a decomposition \\(M = \\sum_j v_j v_j^*\\) with each \\(v_j\\) supported on at most \\(k\\) coordinates.  This routine implements the low-rank algorithm in <sup>1</sup>.</p> <p>Examples:</p> <p>The matrix \\(\\operatorname{diag}(1, 1, 0)\\) has factor width at most \\(1\\).</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import factor_width\n\ndiag_mat = np.diag([1, 1, 0])\nresult = factor_width(diag_mat, k=1)\nprint(result[\"feasible\"])\n</code></pre> <p>True</p> <p>Conversely, the rank-one matrix \\(\\begin{pmatrix} 1 &amp; 1 \\\\ 1 &amp; 1 \\end{pmatrix}/2\\) is not \\(1\\)-factorable.</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import factor_width\n\nhadamard = np.array([[1, 1], [1, 1]], dtype=np.complex128) / 2\nresult = factor_width(hadamard, k=1)\nprint(result[\"feasible\"])\n</code></pre> <p>False</p> <p>Parameters:</p> <ul> <li> <code>mat</code>               (<code>ndarray</code>)           \u2013            <p>Positive semidefinite matrix to test.</p> </li> <li> <code>k</code>               (<code>int</code>)           \u2013            <p>Target factor width bound.</p> </li> <li> <code>solver</code>               (<code>str | None</code>, default:                   <code>'SCS'</code> )           \u2013            <p>CVXPY solver name (defaults to <code>\"SCS\"</code>).</p> </li> <li> <code>solver_kwargs</code>               (<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional keyword arguments forwarded to <code>cvxpy.Problem.solve</code>.</p> </li> <li> <code>tol</code>               (<code>float</code>, default:                   <code>1e-08</code> )           \u2013            <p>Numerical tolerance used for rank computations and duplicate detection.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>Dictionary with keys</p> </li> <li> <code>dict</code>           \u2013            <p><code>feasible</code> (boolean flag),</p> </li> <li> <code>dict</code>           \u2013            <p><code>status</code> (solver status string),</p> </li> <li> <code>dict</code>           \u2013            <p><code>factors</code> (list of PSD matrices whose sum equals <code>mat</code> when feasible), and</p> </li> <li> <code>dict</code>           \u2013            <p><code>subspaces</code> (orthonormal bases spanning the subspaces used in the decomposition).</p> </li> </ul> <p>References</p> <p><sup>1</sup> Johnston, Nathaniel and Lovitz, Benjamin and Russo, Vincent and Sikora, Jamie. The complexity of quantum state classification. (2025).</p> Source code in <code>toqito/matrix_props/factor_width.py</code> <pre><code>def factor_width(\n    mat: np.ndarray,\n    k: int,\n    *,\n    solver: str | None = \"SCS\",\n    solver_kwargs: dict | None = None,\n    tol: float = 1e-8,\n) -&gt; dict:\n    r\"\"\"Decide whether a positive semidefinite matrix has factor width at most \\(k\\).\n\n    The factor width of a matrix is the minimal value of \\(k\\) for which it\n    admits a decomposition \\(M = \\sum_j v_j v_j^*\\) with each \\(v_j\\)\n    supported on at most \\(k\\) coordinates.  This routine implements the\n    low-rank algorithm in [@Johnston_2025_Complexity].\n\n    Examples:\n        The matrix \\(\\operatorname{diag}(1, 1, 0)\\) has factor width at most \\(1\\).\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import factor_width\n\n        diag_mat = np.diag([1, 1, 0])\n        result = factor_width(diag_mat, k=1)\n        print(result[\"feasible\"])\n        ```\n\n        Conversely, the rank-one matrix \\(\\begin{pmatrix} 1 &amp; 1 \\\\ 1 &amp; 1 \\end{pmatrix}/2\\) is not\n        \\(1\\)-factorable.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import factor_width\n\n        hadamard = np.array([[1, 1], [1, 1]], dtype=np.complex128) / 2\n        result = factor_width(hadamard, k=1)\n        print(result[\"feasible\"])\n        ```\n\n    Args:\n        mat: Positive semidefinite matrix to test.\n        k: Target factor width bound.\n        solver: CVXPY solver name (defaults to `\"SCS\"`).\n        solver_kwargs: Additional keyword arguments forwarded to `cvxpy.Problem.solve`.\n        tol: Numerical tolerance used for rank computations and duplicate detection.\n\n    Returns:\n        Dictionary with keys\n        ``feasible`` (boolean flag),\n        ``status`` (solver status string),\n        ``factors`` (list of PSD matrices whose sum equals ``mat`` when feasible), and\n        ``subspaces`` (orthonormal bases spanning the subspaces used in the decomposition).\n\n    \"\"\"\n    mat = np.asarray(mat, dtype=np.complex128)\n    if mat.ndim != 2 or mat.shape[0] != mat.shape[1]:\n        raise ValueError(\"Input matrix must be square.\")\n\n    d = mat.shape[0]\n    if k &lt; 1 or k &gt; d:\n        raise ValueError(\"The factor width parameter k must satisfy 1 &lt;= k &lt;= d.\")\n\n    if not is_positive_semidefinite(mat, atol=tol):\n        raise ValueError(\"Input matrix must be positive semidefinite.\")\n\n    if k == d:\n        return {\n            \"feasible\": True,\n            \"status\": \"trivial\",\n            \"factors\": [mat],\n            \"subspaces\": [np.eye(d, dtype=np.complex128)],\n        }\n\n    # Obtain an orthonormal basis for the range of mat.\n    eig_vals, eig_vecs = np.linalg.eigh((mat + mat.conj().T) / 2)\n    support = eig_vals &gt; tol\n    if not np.any(support):\n        return {\n            \"feasible\": True,\n            \"status\": \"trivial\",\n            \"factors\": [np.zeros_like(mat)],\n            \"subspaces\": [np.zeros((d, 0), dtype=np.complex128)],\n        }\n    range_basis = eig_vecs[:, support]\n\n    max_zero_count = d - k\n    subspaces = _enumerate_support_subspaces(range_basis, max_zero_count, tol)\n    if not subspaces:\n        return {\n            \"feasible\": False,\n            \"status\": \"no_support_subspace\",\n            \"factors\": None,\n            \"subspaces\": [],\n        }\n\n    # Build the SDP: variables live in the reduced coordinates of each subspace.\n    mat_block = _complex_to_real_block(mat)\n\n    variables: list[tuple[np.ndarray, cp.Variable]] = []\n    components = []\n    constraints = []\n\n    for basis in subspaces:\n        dim = basis.shape[1]\n        if dim == 0:\n            continue\n        basis_block = _complex_to_real_block(basis)\n        var = cp.Variable((2 * dim, 2 * dim), PSD=True)\n        lift_block = basis_block @ var @ basis_block.T\n        variables.append((basis, var))\n        components.append(lift_block)\n\n    if not components:\n        return {\n            \"feasible\": False,\n            \"status\": \"no_support_subspace\",\n            \"factors\": None,\n            \"subspaces\": [],\n        }\n\n    total = components[0]\n    for comp in components[1:]:\n        total += comp\n    constraints.append(total == mat_block)\n    problem = cp.Problem(cp.Minimize(cp.Constant(0)), constraints)\n\n    status = _solve_problem(problem, solver, solver_kwargs)\n\n    feasible = status in {cp.OPTIMAL, cp.OPTIMAL_INACCURATE}\n    factor_matrices = None\n    if feasible:\n        factor_matrices = []\n        for basis, var in variables:\n            if var.value is None:\n                return {\n                    \"feasible\": False,\n                    \"status\": status,\n                    \"factors\": None,\n                    \"subspaces\": subspaces,\n                }\n            local_factor = _real_block_to_complex(var.value)\n            factor_matrices.append(basis @ local_factor @ basis.conj().T)\n\n    return {\n        \"feasible\": feasible,\n        \"status\": status,\n        \"factors\": factor_matrices,\n        \"subspaces\": subspaces,\n    }\n</code></pre>"},{"location":"reference/toqito/matrix_props/has_same_dimension/","title":"has_same_dimension","text":""},{"location":"reference/toqito/matrix_props/has_same_dimension/#toqito.matrix_props.has_same_dimension","title":"has_same_dimension","text":"<p>Checks if the dimensions of list of vectors or matrices are equal.</p>"},{"location":"reference/toqito/matrix_props/has_same_dimension/#toqito.matrix_props.has_same_dimension.has_same_dimension","title":"has_same_dimension","text":"<pre><code>has_same_dimension(items: list[ndarray]) -&gt; bool\n</code></pre> <p>Check if all vectors or matrices in a list have the same dimension.</p> <p>For a vector (1D array), the dimension is its length. For a matrix, the dimension can be considered as the total number of elements (rows x columns) for non-square matrices, or simply the number of rows (or columns) for square matrices. The function iterates through the provided list and ensures that every item has the same dimension.</p> <p>Examples:</p> <p>Check a list of vectors with the same dimension:</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import has_same_dimension\n\nvectors = [np.array([1, 2, 3]), np.array([4, 5, 6]), np.array([7, 8, 9])]\n\nprint(has_same_dimension(vectors))\n</code></pre> <p>True</p> <p>Check a list of matrices with the same dimension:</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import has_same_dimension\n\nmatrices = [np.array([[1, 0], [0, 1]]), np.array([[2, 3], [4, 5]]), np.array([[6, 7], [8, 9]])]\n\nprint(has_same_dimension(matrices))\n</code></pre> <p>True</p> <p>Check a list containing items of different dimensions:</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import has_same_dimension\n\nmixed = [np.array([1, 2, 3]), np.array([[1, 0], [0, 1]])]\n\nprint(has_same_dimension(mixed))\n</code></pre> <p>False</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the input list is empty.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>items</code>               (<code>list[ndarray]</code>)           \u2013            <p>A list containing vectors or matrices. Vectors are represented as 1D numpy arrays, and matrices are</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Returns <code>True</code> if all items in the list have the same dimension, <code>False</code> otherwise.</p> </li> </ul> Source code in <code>toqito/matrix_props/has_same_dimension.py</code> <pre><code>def has_same_dimension(items: list[np.ndarray]) -&gt; bool:\n    \"\"\"Check if all vectors or matrices in a list have the same dimension.\n\n    For a vector (1D array), the dimension is its length. For a matrix, the dimension can be considered as the total\n    number of elements (rows x columns) for non-square matrices, or simply the number of rows (or columns) for square\n    matrices. The function iterates through the provided list and ensures that every item has the same dimension.\n\n    Examples:\n        Check a list of vectors with the same dimension:\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import has_same_dimension\n\n        vectors = [np.array([1, 2, 3]), np.array([4, 5, 6]), np.array([7, 8, 9])]\n\n        print(has_same_dimension(vectors))\n        ```\n\n\n        Check a list of matrices with the same dimension:\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import has_same_dimension\n\n        matrices = [np.array([[1, 0], [0, 1]]), np.array([[2, 3], [4, 5]]), np.array([[6, 7], [8, 9]])]\n\n        print(has_same_dimension(matrices))\n        ```\n\n        Check a list containing items of different dimensions:\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import has_same_dimension\n\n        mixed = [np.array([1, 2, 3]), np.array([[1, 0], [0, 1]])]\n\n        print(has_same_dimension(mixed))\n        ```\n\n    Raises:\n        ValueError: If the input list is empty.\n\n    Args:\n        items: A list containing vectors or matrices. Vectors are represented as 1D numpy arrays, and matrices are\n        represented as 2D numpy arrays.\n\n    Returns:\n        Returns `True` if all items in the list have the same dimension, `False` otherwise.\n\n    \"\"\"\n    if len(items) == 0:\n        raise ValueError(\"The list is empty.\")\n\n    first_item = items[0]\n    # Checking for numpy array to handle matrix case\n    if isinstance(first_item[0], np.ndarray):\n        expected_dim = len(first_item) * len(first_item[0])\n    else:\n        expected_dim = len(first_item)\n\n    for item in items[1:]:\n        if isinstance(item[0], np.ndarray):\n            dim = len(item) * len(item[0])\n        else:\n            dim = len(item)\n\n        if dim != expected_dim:\n            return False\n    return True\n</code></pre>"},{"location":"reference/toqito/matrix_props/is_absolutely_k_incoherent/","title":"is_absolutely_k_incoherent","text":""},{"location":"reference/toqito/matrix_props/is_absolutely_k_incoherent/#toqito.matrix_props.is_absolutely_k_incoherent","title":"is_absolutely_k_incoherent","text":"<p>Checks if the matrix is absolutely \\(k\\)-incoherent.</p>"},{"location":"reference/toqito/matrix_props/is_absolutely_k_incoherent/#toqito.matrix_props.is_absolutely_k_incoherent.is_absolutely_k_incoherent","title":"is_absolutely_k_incoherent","text":"<pre><code>is_absolutely_k_incoherent(mat: ndarray, k: int, tol: float = 1e-15) -&gt; bool\n</code></pre> <p>Determine whether a quantum state is absolutely k-incoherent <sup>1</sup>.</p> <p>Formally, for positive integers \\(n\\) and \\(k\\), a mixed quantum state is said to be absolutely k-incoherent if \\(U \\rho U^* \\in \\mathbb{I}_{k, n}\\) for all unitary matrices \\(U \\in \\text{U}(\\mathbb{C}^n)\\).</p> <p>This function checks if the provided density matrix is absolutely k-incoherent based on the criteria introduced in <sup>1</sup> and the corresponding QETLAB functionality <sup>2</sup>. When necessary, an SDP is set up via <code>cvxpy</code>.</p> <p>The notion of absolute k-incoherence is connected to the notion of quantum state antidistinguishability as discussed in <sup>3</sup>.</p> <p>Examples:</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import is_absolutely_k_incoherent\nmat = np.array([[2, 1, 2],\n            [1, 2, -1],\n            [2, -1, 5]])\nprint(is_absolutely_k_incoherent(mat, 4))\n</code></pre> <p>True</p> <p>See</p> <p>is_antidistinguishable(), is_k_incoherent()</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the input matrix is not square.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>mat</code>               (<code>ndarray</code>)           \u2013            <p>Matrix to check for absolute k-incoherence.</p> </li> <li> <code>k</code>               (<code>int</code>)           \u2013            <p>The positive integer indicating the absolute coherence level.</p> </li> <li> <code>tol</code>               (<code>float</code>, default:                   <code>1e-15</code> )           \u2013            <p>Tolerance for numerical comparisons (default is 1e-15).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the quantum state is absolutely k-incoherent, False otherwise.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Johnston, Nathaniel and Moein, Shirin and Pereira, Rajesh and Plosker, Sarah. Absolutely k-incoherent quantum states and spectral inequalities for the factor width of a matrix. Physical Review A. vol. 106(5). (2022). <sup>2</sup> Johnston, Nathaniel. {{QETLAB}: {A MATLAB} toolbox for quantum entanglement}. doi:10.5281/zenodo.44637. <sup>3</sup> Johnston, Nathaniel and Russo, Vincent and Sikora, Jamie. Tight bounds for antidistinguishability and circulant sets of pure quantum states. Quantum. vol. 9. (2025).</p> Source code in <code>toqito/matrix_props/is_absolutely_k_incoherent.py</code> <pre><code>def is_absolutely_k_incoherent(mat: np.ndarray, k: int, tol: float = 1e-15) -&gt; bool:\n    r\"\"\"Determine whether a quantum state is absolutely k-incoherent [@Johnston_2022_Absolutely].\n\n    Formally, for positive integers \\(n\\) and \\(k\\), a mixed quantum state is said to be absolutely k-incoherent\n    if \\(U \\rho U^* \\in \\mathbb{I}_{k, n}\\) for all unitary matrices \\(U \\in \\text{U}(\\mathbb{C}^n)\\).\n\n    This function checks if the provided density matrix is absolutely k-incoherent based on the criteria introduced in\n    [@Johnston_2022_Absolutely] and the corresponding QETLAB functionality [@QETLAB_link]. When\n    necessary, an SDP is set up via ``cvxpy``.\n\n    The notion of absolute k-incoherence is connected to the notion of quantum state antidistinguishability as discussed\n    in [@Johnston_2025_Tight].\n\n    Examples:\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import is_absolutely_k_incoherent\n        mat = np.array([[2, 1, 2],\n                    [1, 2, -1],\n                    [2, -1, 5]])\n        print(is_absolutely_k_incoherent(mat, 4))\n        ```\n\n        !!! See\n            [is_antidistinguishable()][toqito.state_props.is_antidistinguishable.is_antidistinguishable],\n            [is_k_incoherent()][toqito.matrix_props.is_k_incoherent.is_k_incoherent]\n\n    Raises:\n        ValueError: If the input matrix is not square.\n\n    Args:\n        mat: Matrix to check for absolute k-incoherence.\n        k: The positive integer indicating the absolute coherence level.\n        tol: Tolerance for numerical comparisons (default is 1e-15).\n\n    Returns:\n        True if the quantum state is absolutely k-incoherent, False otherwise.\n\n    \"\"\"\n    if k &lt;= 0:\n        raise ValueError(\"k must be a positive integer.\")\n    if not is_square(mat):\n        raise ValueError(\"Input matrix must be square.\")\n\n    n = mat.shape[0]\n\n    # Trivial: every matrix is absolutely k-incoherent for k &gt;= n.\n    if k &gt;= n:\n        return True\n\n    # Check that the input matrix is a valid density matrix.\n    if not (is_positive_semidefinite(mat) and np.isclose(np.trace(mat), 1, atol=tol)):\n        return False\n\n    # Compute eigenvalues and rank.\n    eigvals = np.linalg.eigvalsh(mat)\n    rankX = np.linalg.matrix_rank(mat, tol=tol)\n    lmax = np.max(eigvals)\n\n    # Trivial: only the maximally mixed state is absolutely 1-incoherent.\n    if k == 1:\n        if np.all(np.abs(eigvals - (1 / n)) &lt;= tol):\n            return True\n        else:\n            return False\n\n    # [1] Theorem 4: Check rank conditions.\n    if rankX &lt;= n - k:\n        return False\n    elif rankX == n - k + 1:\n        # Check if all nonzero eigenvalues are approximately equal.\n        nonzero = eigvals[np.abs(eigvals) &gt; tol]\n        if len(nonzero) &gt; 0 and np.all(np.abs(nonzero - nonzero[0]) &lt;= tol):\n            return True\n\n    # [1] Theorem 5: Check if the largest eigenvalue meets the condition.\n    if lmax &lt;= 1 / (n - k + 1):\n        return True\n\n    if k == 2:\n        # [1] Theorem 7: Use the Frobenius norm condition.\n        frob_norm_sq = np.linalg.norm(mat, \"fro\") ** 2\n        if frob_norm_sq &lt;= 1 / (n - 1):\n            return True\n        elif n &lt;= 3:\n            return False\n    elif k == n - 1:\n        # [1] Corollary 1: Check maximum eigenvalue condition.\n        if lmax &gt; 1 - 1 / n:\n            return False\n        else:\n            # [1] Theorem 8: Solve an SDP to decide absolute (n-1)-incoherence.\n            lam = np.sort(np.real(eigvals))[::-1]\n            n_eig = len(lam)\n            L = cp.Variable((n_eig, n_eig), symmetric=True)\n            constraints = []\n            # Constraint: L[0, 0] == -lam[0] - sum(L[0, 1:]) - sum(L[1:, 0])\n            constraints.append(L[0, 0] == -lam[0] - cp.sum(L[0, 1:]) - cp.sum(L[1:, 0]))\n            # For indices j = 1 to n_eig-1, enforce L[j, j] == lam[j]\n            for j in range(1, n_eig):\n                constraints.append(L[j, j] == lam[j])\n            # L must be positive semidefinite.\n            constraints.append(L &gt;&gt; 0)\n            # Dummy objective function.\n            objective = cp.Minimize(1)\n            prob = cp.Problem(objective, constraints)\n            opt_val = prob.solve(solver=cp.SCS, verbose=False)\n            if np.isclose(opt_val, 1.0):\n                return True\n    return False\n</code></pre>"},{"location":"reference/toqito/matrix_props/is_anti_hermitian/","title":"is_anti_hermitian","text":""},{"location":"reference/toqito/matrix_props/is_anti_hermitian/#toqito.matrix_props.is_anti_hermitian","title":"is_anti_hermitian","text":"<p>Checks if the matrix is an anti-Hermitian matrix.</p>"},{"location":"reference/toqito/matrix_props/is_anti_hermitian/#toqito.matrix_props.is_anti_hermitian.is_anti_hermitian","title":"is_anti_hermitian","text":"<pre><code>is_anti_hermitian(mat: ndarray, rtol: float = 1e-05, atol: float = 1e-08) -&gt; bool\n</code></pre> <p>Check if matrix is anti-Hermitian (a.k.a. skew-Hermitian) <sup>1</sup>.</p> <p>An anti-Hermitian matrix is a complex square matrix that is equal to the negative of its own conjugate transpose.</p> <p>Examples:</p> <p>Consider the following matrix:</p> \\[     A = \\begin{pmatrix}             2j &amp; -1 + 2j &amp; 4j \\\\             1 + 2j &amp; 3j &amp; -1 \\\\             4j &amp; 1 &amp; 1j         \\end{pmatrix} \\] <p>our function indicates that this is indeed an anti-Hermitian matrix as it holds that</p> \\[     A = -A^*. \\] <pre><code>import numpy as np\nfrom toqito.matrix_props import is_anti_hermitian\n\nmat = np.array([[2j, -1 + 2j, 4j], [1 + 2j, 3j, -1], [4j, 1, 1j]])\n\nprint(is_anti_hermitian(mat))\n</code></pre> <p>True</p> <p>Alternatively, the following example matrix \\(B\\) defined as</p> \\[     B = \\begin{pmatrix}             1 &amp; 2 &amp; 3 \\\\             4 &amp; 5 &amp; 6 \\\\             7 &amp; 8 &amp; 9         \\end{pmatrix} \\] <p>is not anti-Hermitian.</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import is_anti_hermitian\n\nmat = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n\nprint(is_anti_hermitian(mat))\n</code></pre> <p>False</p> <p>Parameters:</p> <ul> <li> <code>mat</code>               (<code>ndarray</code>)           \u2013            <p>Matrix to check.</p> </li> <li> <code>rtol</code>               (<code>float</code>, default:                   <code>1e-05</code> )           \u2013            <p>The relative tolerance parameter (default 1e-05).</p> </li> <li> <code>atol</code>               (<code>float</code>, default:                   <code>1e-08</code> )           \u2013            <p>The absolute tolerance parameter (default 1e-08).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Return True if matrix is anti-Hermitian, and False otherwise.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Skew-Hermitian matrix. link.</p> Source code in <code>toqito/matrix_props/is_anti_hermitian.py</code> <pre><code>def is_anti_hermitian(mat: np.ndarray, rtol: float = 1e-05, atol: float = 1e-08) -&gt; bool:\n    r\"\"\"Check if matrix is anti-Hermitian (a.k.a. skew-Hermitian) [@WikiAntiHerm].\n\n    An anti-Hermitian matrix is a complex square matrix that is equal to the negative of its own\n    conjugate transpose.\n\n    Examples:\n        Consider the following matrix:\n\n        \\[\n            A = \\begin{pmatrix}\n                    2j &amp; -1 + 2j &amp; 4j \\\\\n                    1 + 2j &amp; 3j &amp; -1 \\\\\n                    4j &amp; 1 &amp; 1j\n                \\end{pmatrix}\n        \\]\n\n        our function indicates that this is indeed an anti-Hermitian matrix as it holds that\n\n        \\[\n            A = -A^*.\n        \\]\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import is_anti_hermitian\n\n        mat = np.array([[2j, -1 + 2j, 4j], [1 + 2j, 3j, -1], [4j, 1, 1j]])\n\n        print(is_anti_hermitian(mat))\n        ```\n\n\n        Alternatively, the following example matrix \\(B\\) defined as\n\n        \\[\n            B = \\begin{pmatrix}\n                    1 &amp; 2 &amp; 3 \\\\\n                    4 &amp; 5 &amp; 6 \\\\\n                    7 &amp; 8 &amp; 9\n                \\end{pmatrix}\n        \\]\n\n        is not anti-Hermitian.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import is_anti_hermitian\n\n        mat = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n\n        print(is_anti_hermitian(mat))\n        ```\n\n    Args:\n        mat: Matrix to check.\n        rtol: The relative tolerance parameter (default 1e-05).\n        atol: The absolute tolerance parameter (default 1e-08).\n\n    Returns:\n        Return True if matrix is anti-Hermitian, and False otherwise.\n\n    \"\"\"\n    return is_hermitian(mat * 1j, rtol, atol)\n</code></pre>"},{"location":"reference/toqito/matrix_props/is_block_positive/","title":"is_block_positive","text":""},{"location":"reference/toqito/matrix_props/is_block_positive/#toqito.matrix_props.is_block_positive","title":"is_block_positive","text":"<p>Checks if the matrix is block positive.</p>"},{"location":"reference/toqito/matrix_props/is_block_positive/#toqito.matrix_props.is_block_positive.is_block_positive","title":"is_block_positive","text":"<pre><code>is_block_positive(mat: ndarray, k: int = 1, dim: int | list[int] | None = None, effort: int = 2, rtol: float = 1e-05) -&gt; bool | RuntimeError\n</code></pre> <p>Check if matrix is block positive <sup>1</sup>.</p> <p>Examples:</p> <p>The swap operator is always block positive, since it is the Choi matrix of the transpose map.</p> <pre><code>from toqito.perms.swap_operator import swap_operator\nfrom toqito.matrix_props.is_block_positive import is_block_positive\n\nmat = swap_operator(3)\n\nprint(is_block_positive(mat=mat))\n</code></pre> <p>True</p> <p>However, it's not 2 - block positive.</p> <pre><code>from toqito.perms.swap_operator import swap_operator\nfrom toqito.matrix_props.is_block_positive import is_block_positive\n\nmat = swap_operator(3)\n\nprint(is_block_positive(mat=mat, k=2))\n</code></pre> <p>False</p> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>Unable to determine k-block positivity. Please consider increasing the relative tolerance or the</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>mat</code>               (<code>ndarray</code>)           \u2013            <p>A bipartite Hermitian operator.</p> </li> <li> <code>k</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>A positive integer indicating that the function should determine whether or not the input operator is k-block</p> </li> <li> <code>dim</code>               (<code>int | list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The dimension of the two sub-systems. By default it's assumed to be equal.</p> </li> <li> <code>effort</code>               (<code>int</code>, default:                   <code>2</code> )           \u2013            <p>An integer value indicating the amount of computation you want to devote to determine block positivity</p> </li> <li> <code>rtol</code>               (<code>float</code>, default:                   <code>1e-05</code> )           \u2013            <p>The relative tolerance parameter (default 1e-05).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool | RuntimeError</code>           \u2013            <p>Return <code>True</code> if matrix is k-block positive definite, <code>False</code> if not, or raise a runtime error if we are unable</p> </li> <li> <code>bool | RuntimeError</code>           \u2013            <p>to determine whether or not the operator is block positive.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Johnston, Nathaniel. Norms and Cones in the Theory of Quantum Entanglement. (2012).</p> Source code in <code>toqito/matrix_props/is_block_positive.py</code> <pre><code>def is_block_positive(\n    mat: np.ndarray,\n    k: int = 1,\n    dim: int | list[int] | None = None,\n    effort: int = 2,\n    rtol: float = 1e-5,\n) -&gt; bool | RuntimeError:\n    r\"\"\"Check if matrix is block positive [@Johnston_2012_Norms].\n\n    Examples:\n        The swap operator is always block positive, since it is the Choi\n        matrix of the transpose map.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.perms.swap_operator import swap_operator\n        from toqito.matrix_props.is_block_positive import is_block_positive\n\n        mat = swap_operator(3)\n\n        print(is_block_positive(mat=mat))\n        ```\n\n\n        However, it's not 2 - block positive.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.perms.swap_operator import swap_operator\n        from toqito.matrix_props.is_block_positive import is_block_positive\n\n        mat = swap_operator(3)\n\n        print(is_block_positive(mat=mat, k=2))\n        ```\n\n    Raises:\n        RuntimeError: Unable to determine k-block positivity. Please consider increasing the relative tolerance or the\n        effort level.\n\n    Args:\n        mat: A bipartite Hermitian operator.\n        k: A positive integer indicating that the function should determine whether or not the input operator is k-block\n        positive, i.e., whether or not it remains nonnegative under left and right multiplication by vectors with\n        Schmidt rank &lt;= k (default 1).\n        dim: The dimension of the two sub-systems. By default it's assumed to be equal.\n        effort: An integer value indicating the amount of computation you want to devote to determine block positivity\n        before giving up.\n        rtol: The relative tolerance parameter (default 1e-05).\n\n    Returns:\n        Return `True` if matrix is k-block positive definite, `False` if not, or raise a runtime error if we are unable\n        to determine whether or not the operator is block positive.\n\n    \"\"\"\n    if not is_hermitian(mat):\n        return False\n\n    dim_xy = mat.shape[0]\n    # Set default dimension if none was provided.\n    if dim is None:\n        dim_val = int(np.round(np.sqrt(dim_xy)))\n    elif isinstance(dim, int):\n        dim_val = dim\n    else:\n        dim_val = None\n\n    # Allow the user to enter in a single integer for dimension.\n    if dim_val is not None:\n        dim_arr = np.array([dim_val, dim_xy / dim_val])\n        dim_arr[1] = int(np.round(dim_arr[1]))\n    else:\n        dim_arr = np.array(dim)\n\n    dim_arr = np.array(dim_arr, dtype=int)\n\n    # When a local dimension is small, block positivity is trivial.\n    if min(dim_arr) &lt;= k:\n        return is_positive_semidefinite(mat)\n\n    op_norm = np.linalg.norm(mat, ord=2)\n    # We compute the S(k)-norm of this operator since\n    # X k-block positive iff:\n    #   c &gt;= S(k)-norm of(c*I - X)\n    # See Corollary 4.2.9. of `[@Johnston_2012_Norms].\n    c_mat = op_norm * np.eye(dim_xy) - mat\n    lower_bound, upper_bound = sk_operator_norm(c_mat, k, dim_arr, op_norm, effort)\n\n    # block positive\n    # Note that QETLAB is more conservative here and multiplies\n    # by (1 - rtol). After some experiments though, I found out\n    # that probably due to numerical inaccuracies of CVXPY the check\n    #     upper_bound &lt;= op_norm * (1 - rtol)\n    # would fail even for k - block positive matrices. So, we choose to\n    # relax this inequality by increasing RHS. Additionally, the check\n    #     upper_bound &lt;= op_norm * (1 - rtol)\n    # has the \"undesired\" property that increasing tolerance makes the\n    # inequality more difficult to satisfy but usually the reverse holds,\n    # i.e increased tolerance parameter relaxes the problem.\n    if upper_bound &lt;= op_norm * (1 + rtol):\n        return True\n    # not block positive\n    if lower_bound &gt;= op_norm * (1 - rtol):\n        return False\n\n    return RuntimeError(\n        \"Unable to determine k-block positivity. Please consider increasing the relative tolerance or the effort level.\"\n    )\n</code></pre>"},{"location":"reference/toqito/matrix_props/is_circulant/","title":"is_circulant","text":""},{"location":"reference/toqito/matrix_props/is_circulant/#toqito.matrix_props.is_circulant","title":"is_circulant","text":"<p>Checks if the matrix is circulant.</p>"},{"location":"reference/toqito/matrix_props/is_circulant/#toqito.matrix_props.is_circulant.is_circulant","title":"is_circulant","text":"<pre><code>is_circulant(mat: ndarray) -&gt; bool\n</code></pre> <p>Determine if matrix is circulant <sup>1</sup>.</p> <p>A circulant matrix is a square matrix in which all row vectors are composed of the same elements and each row vector is rotated one element to the right relative to the preceding row vector.</p> <p>Examples:</p> <p>Consider the following matrix:</p> \\[     C = \\begin{pmatrix}             4 &amp; 1 &amp; 2 &amp; 3 \\\\             3 &amp; 4 &amp; 1 &amp; 2 \\\\             2 &amp; 3 &amp; 4 &amp; 1 \\\\             1 &amp; 2 &amp; 3 &amp; 4         \\end{pmatrix} \\] <p>As can be seen, this matrix is circulant. We can verify this in <code>|toqito\u27e9</code> as</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import is_circulant\n\nmat = np.array([[4, 1, 2, 3], [3, 4, 1, 2], [2, 3, 4, 1], [1, 2, 3, 4]])\n\nprint(is_circulant(mat))\n</code></pre> <p>True</p> <p>Parameters:</p> <ul> <li> <code>mat</code>               (<code>ndarray</code>)           \u2013            <p>Matrix to check the circulancy of.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Return <code>True</code> if <code>mat</code> is circulant; <code>False</code> otherwise.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Circulant matrix. link.</p> Source code in <code>toqito/matrix_props/is_circulant.py</code> <pre><code>def is_circulant(mat: np.ndarray) -&gt; bool:\n    r\"\"\"Determine if matrix is circulant [@WikiCirc].\n\n    A circulant matrix is a square matrix in which all row vectors are composed\n    of the same elements and each row vector is rotated one element to the right\n    relative to the preceding row vector.\n\n    Examples:\n        Consider the following matrix:\n\n        \\[\n            C = \\begin{pmatrix}\n                    4 &amp; 1 &amp; 2 &amp; 3 \\\\\n                    3 &amp; 4 &amp; 1 &amp; 2 \\\\\n                    2 &amp; 3 &amp; 4 &amp; 1 \\\\\n                    1 &amp; 2 &amp; 3 &amp; 4\n                \\end{pmatrix}\n        \\]\n\n        As can be seen, this matrix is circulant. We can verify this in\n        `|toqito\u27e9` as\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import is_circulant\n\n        mat = np.array([[4, 1, 2, 3], [3, 4, 1, 2], [2, 3, 4, 1], [1, 2, 3, 4]])\n\n        print(is_circulant(mat))\n        ```\n\n    Args:\n        mat: Matrix to check the circulancy of.\n\n    Returns:\n        Return `True` if `mat` is circulant; `False` otherwise.\n\n    \"\"\"\n    n, m = mat.shape\n    if n != m:\n        return False\n\n    for i in range(n - 1):\n        row = mat[i + 1]\n        shifted = np.roll(mat[i], 1)\n        if not np.allclose(row, shifted):\n            return False\n    return True\n</code></pre>"},{"location":"reference/toqito/matrix_props/is_commuting/","title":"is_commuting","text":""},{"location":"reference/toqito/matrix_props/is_commuting/#toqito.matrix_props.is_commuting","title":"is_commuting","text":"<p>Checks if the matrix is commuting.</p>"},{"location":"reference/toqito/matrix_props/is_commuting/#toqito.matrix_props.is_commuting.is_commuting","title":"is_commuting","text":"<pre><code>is_commuting(mat_1: ndarray, mat_2: ndarray) -&gt; bool\n</code></pre> <p>Determine if two linear operators commute with each other <sup>1</sup>.</p> <p>For any pair of operators \\(X, Y \\in \\text{L}(\\mathcal{X})\\), the Lie bracket \\(\\left[X, Y\\right] \\in \\text{L}(\\mathcal{X})\\) is defined as</p> \\[     \\left[X, Y\\right] = XY - YX. \\] <p>It holds that \\(\\left[X,Y\\right]=0\\) if and only if \\(X\\) and \\(Y\\) commute (Section: Lie Brackets And Commutants from <sup>2</sup>).</p> <p>Examples:</p> <p>Consider the following matrices:</p> \\[     A = \\begin{pmatrix} 0 &amp; 1 \\\\ 0 &amp; 0 \\end{pmatrix},     \\quad \\text{and} \\quad     B = \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; 0 \\end{pmatrix}. \\] <p>It holds that \\(AB=0\\), however</p> \\[     BA = \\begin{pmatrix} 0 &amp; 1 \\\\ 0 &amp; 0 \\end{pmatrix} = A, \\] <p>and hence, do not commute.</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import is_commuting\n\nmat_1 = np.array([[0, 1], [0, 0]])\nmat_2 = np.array([[1, 0], [0, 0]])\n\nprint(is_commuting(mat_1, mat_2))\n</code></pre> <p>False</p> <p>Consider the following pair of matrices:</p> \\[     A = \\begin{pmatrix}         1 &amp; 0 &amp; 0 \\\\         0 &amp; 1 &amp; 0 \\\\         1 &amp; 0 &amp; 2         \\end{pmatrix} \\quad \\text{and} \\quad     B = \\begin{pmatrix}         2 &amp; 4 &amp; 0 \\\\         3 &amp; 1 &amp; 0 \\\\         -1 &amp; -4 &amp; 1         \\end{pmatrix}. \\] <p>It may be verified that \\(AB = BA = 0\\), and therefore \\(A\\) and \\(B\\) commute.</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import is_commuting\n\nmat_1 = np.array([[1, 0, 0], [0, 1, 0], [1, 0, 2]])\nmat_2 = np.array([[2, 4, 0], [3, 1, 0], [-1, -4, 1]])\n\nprint(is_commuting(mat_1, mat_2))\n</code></pre> <p>True</p> <p>Parameters:</p> <ul> <li> <code>mat_1</code>               (<code>ndarray</code>)           \u2013            <p>First matrix to check.</p> </li> <li> <code>mat_2</code>               (<code>ndarray</code>)           \u2013            <p>Second matrix to check.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Return <code>True</code> if <code>mat_1</code> commutes with <code>mat_2</code> and False otherwise.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Commuting matrices. link. <sup>2</sup> Watrous, John. The Theory of Quantum Information. (2018). doi:10.1017/9781316848142.</p> Source code in <code>toqito/matrix_props/is_commuting.py</code> <pre><code>def is_commuting(mat_1: np.ndarray, mat_2: np.ndarray) -&gt; bool:\n    r\"\"\"Determine if two linear operators commute with each other [@WikiComm].\n\n    For any pair of operators \\(X, Y \\in \\text{L}(\\mathcal{X})\\), the\n    Lie bracket \\(\\left[X, Y\\right] \\in \\text{L}(\\mathcal{X})\\) is defined\n    as\n\n    \\[\n        \\left[X, Y\\right] = XY - YX.\n    \\]\n\n    It holds that \\(\\left[X,Y\\right]=0\\) if and only if \\(X\\) and\n    \\(Y\\) commute (Section: Lie Brackets And Commutants from [@Watrous_2018_TQI]).\n\n    Examples:\n        Consider the following matrices:\n\n        \\[\n            A = \\begin{pmatrix} 0 &amp; 1 \\\\ 0 &amp; 0 \\end{pmatrix},\n            \\quad \\text{and} \\quad\n            B = \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; 0 \\end{pmatrix}.\n        \\]\n\n        It holds that \\(AB=0\\), however\n\n        \\[\n            BA = \\begin{pmatrix} 0 &amp; 1 \\\\ 0 &amp; 0 \\end{pmatrix} = A,\n        \\]\n\n        and hence, do not commute.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import is_commuting\n\n        mat_1 = np.array([[0, 1], [0, 0]])\n        mat_2 = np.array([[1, 0], [0, 0]])\n\n        print(is_commuting(mat_1, mat_2))\n        ```\n\n        Consider the following pair of matrices:\n\n        \\[\n            A = \\begin{pmatrix}\n                1 &amp; 0 &amp; 0 \\\\\n                0 &amp; 1 &amp; 0 \\\\\n                1 &amp; 0 &amp; 2\n                \\end{pmatrix} \\quad \\text{and} \\quad\n            B = \\begin{pmatrix}\n                2 &amp; 4 &amp; 0 \\\\\n                3 &amp; 1 &amp; 0 \\\\\n                -1 &amp; -4 &amp; 1\n                \\end{pmatrix}.\n        \\]\n\n        It may be verified that \\(AB = BA = 0\\), and therefore \\(A\\) and\n        \\(B\\) commute.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import is_commuting\n\n        mat_1 = np.array([[1, 0, 0], [0, 1, 0], [1, 0, 2]])\n        mat_2 = np.array([[2, 4, 0], [3, 1, 0], [-1, -4, 1]])\n\n        print(is_commuting(mat_1, mat_2))\n        ```\n\n    Args:\n        mat_1: First matrix to check.\n        mat_2: Second matrix to check.\n\n    Returns:\n        Return `True` if `mat_1` commutes with `mat_2` and False otherwise.\n\n    \"\"\"\n    return np.allclose(mat_1 @ mat_2 - mat_2 @ mat_1, 0)\n</code></pre>"},{"location":"reference/toqito/matrix_props/is_density/","title":"is_density","text":""},{"location":"reference/toqito/matrix_props/is_density/#toqito.matrix_props.is_density","title":"is_density","text":"<p>Checks if the matrix is a density matrix.</p>"},{"location":"reference/toqito/matrix_props/is_density/#toqito.matrix_props.is_density.is_density","title":"is_density","text":"<pre><code>is_density(mat: ndarray) -&gt; bool\n</code></pre> <p>Check if matrix is a density matrix <sup>1</sup>.</p> <p>A matrix is a density matrix if its trace is equal to one and it has the property of being positive semidefinite (PSD).</p> <p>Examples:</p> <p>Consider the Bell state:</p> \\[     u = \\frac{1}{\\sqrt{2}} |00 \\rangle + \\frac{1}{\\sqrt{2}} |11 \\rangle. \\] <p>Constructing the matrix \\(\\rho = u u^*\\) defined as</p> \\[     \\rho = \\frac{1}{2} \\begin{pmatrix}                             1 &amp; 0 &amp; 0 &amp; 1 \\\\                             0 &amp; 0 &amp; 0 &amp; 0 \\\\                             0 &amp; 0 &amp; 0 &amp; 0 \\\\                             1 &amp; 0 &amp; 0 &amp; 1                        \\end{pmatrix} \\] <p>our function indicates that this is indeed a density operator as the trace of \\(\\rho\\) is equal to \\(1\\) and the matrix is positive semidefinite.</p> <pre><code>from toqito.matrix_props import is_density\nfrom toqito.states import bell\nimport numpy as np\nrho = bell(0) @ bell(0).conj().T\nprint(is_density(rho))\n</code></pre> <p>True</p> <p>Alternatively, the following example matrix \\(\\sigma\\) defined as</p> \\[     \\sigma = \\frac{1}{2} \\begin{pmatrix}                             1 &amp; 2 \\\\                             3 &amp; 1                          \\end{pmatrix} \\] <p>does satisfy \\(\\text{Tr}(\\sigma) = 1\\), however fails to be positive semidefinite, and is therefore not a density operator. This can be illustrated using <code>|toqito\u27e9</code> as follows.</p> <pre><code>import numpy as np\nfrom toqito.states import bell\nfrom toqito.matrix_props import is_density\n\nsigma = 1/2 * np.array([[1, 2], [3, 1]])\n\nprint(is_density(sigma))\n</code></pre> <p>False</p> <p>Parameters:</p> <ul> <li> <code>mat</code>               (<code>ndarray</code>)           \u2013            <p>Matrix to check.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Return <code>True</code> if matrix is a density matrix, and <code>False</code> otherwise.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Density Matrix. link.</p> Source code in <code>toqito/matrix_props/is_density.py</code> <pre><code>def is_density(mat: np.ndarray) -&gt; bool:\n    r\"\"\"Check if matrix is a density matrix [@WikiDen].\n\n    A matrix is a density matrix if its trace is equal to one and it has the\n    property of being positive semidefinite (PSD).\n\n    Examples:\n        Consider the Bell state:\n\n        \\[\n            u = \\frac{1}{\\sqrt{2}} |00 \\rangle + \\frac{1}{\\sqrt{2}} |11 \\rangle.\n        \\]\n\n        Constructing the matrix \\(\\rho = u u^*\\) defined as\n\n        \\[\n            \\rho = \\frac{1}{2} \\begin{pmatrix}\n                                    1 &amp; 0 &amp; 0 &amp; 1 \\\\\n                                    0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                                    0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                                    1 &amp; 0 &amp; 0 &amp; 1\n                               \\end{pmatrix}\n        \\]\n\n        our function indicates that this is indeed a density operator as the trace\n        of \\(\\rho\\) is equal to \\(1\\) and the matrix is positive\n        semidefinite.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.matrix_props import is_density\n        from toqito.states import bell\n        import numpy as np\n        rho = bell(0) @ bell(0).conj().T\n        print(is_density(rho))\n        ```\n\n        Alternatively, the following example matrix \\(\\sigma\\) defined as\n\n        \\[\n            \\sigma = \\frac{1}{2} \\begin{pmatrix}\n                                    1 &amp; 2 \\\\\n                                    3 &amp; 1\n                                 \\end{pmatrix}\n        \\]\n\n        does satisfy \\(\\text{Tr}(\\sigma) = 1\\), however fails to be positive\n        semidefinite, and is therefore not a density operator. This can be\n        illustrated using `|toqito\u27e9` as follows.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.states import bell\n        from toqito.matrix_props import is_density\n\n        sigma = 1/2 * np.array([[1, 2], [3, 1]])\n\n        print(is_density(sigma))\n        ```\n\n    Args:\n        mat: Matrix to check.\n\n    Returns:\n        Return `True` if matrix is a density matrix, and `False` otherwise.\n\n    \"\"\"\n    return bool(is_positive_semidefinite(mat) and np.isclose(np.trace(mat), 1))\n</code></pre>"},{"location":"reference/toqito/matrix_props/is_diagonal/","title":"is_diagonal","text":""},{"location":"reference/toqito/matrix_props/is_diagonal/#toqito.matrix_props.is_diagonal","title":"is_diagonal","text":"<p>Checks if the matrix is a diagonal matrix.</p>"},{"location":"reference/toqito/matrix_props/is_diagonal/#toqito.matrix_props.is_diagonal.is_diagonal","title":"is_diagonal","text":"<pre><code>is_diagonal(mat: ndarray) -&gt; bool\n</code></pre> <p>Determine if a matrix is diagonal <sup>1</sup>.</p> <p>A matrix is diagonal if the matrix is square and if the diagonal of the matrix is non-zero, while the off-diagonal elements are all zero.</p> <p>The following is an example of a 3-by-3 diagonal matrix:</p> \\[     \\begin{equation}         \\begin{pmatrix}             1 &amp; 0 &amp; 0 \\\\             0 &amp; 2 &amp; 0 \\\\             0 &amp; 0 &amp; 3         \\end{pmatrix}     \\end{equation} \\] <p>This quick implementation is given by Daniel F. from StackOverflow in <sup>2</sup>.</p> <p>Examples:</p> <p>Consider the following diagonal matrix:</p> \\[     A = \\begin{pmatrix}             1 &amp; 0 \\\\             0 &amp; 1         \\end{pmatrix}. \\] <p>Our function indicates that this is indeed a diagonal matrix:</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import is_diagonal\n\nA = np.array([[1, 0], [0, 1]])\n\nprint(is_diagonal(A))\n</code></pre> <p>True</p> <p>Alternatively, the following example matrix</p> \\[     B = \\begin{pmatrix}             1 &amp; 2 \\\\             3 &amp; 4         \\end{pmatrix} \\] <p>is not diagonal, as shown using <code>|toqito\u27e9</code>.</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import is_diagonal\n\nB = np.array([[1, 2], [3, 4]])\n\nprint(is_diagonal(B))\n</code></pre> <p>False</p> <p>Parameters:</p> <ul> <li> <code>mat</code>               (<code>ndarray</code>)           \u2013            <p>The matrix to check.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Returns <code>True</code> if the matrix is diagonal and <code>False</code> otherwise.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Diagonal matrix. link. <sup>2</sup> Post, Stack. Check if a large matrix is diagonal matrix in python. link.</p> Source code in <code>toqito/matrix_props/is_diagonal.py</code> <pre><code>def is_diagonal(mat: np.ndarray) -&gt; bool:\n    r\"\"\"Determine if a matrix is diagonal [@WikiDiag].\n\n    A matrix is diagonal if the matrix is square and if the diagonal of the matrix is non-zero,\n    while the off-diagonal elements are all zero.\n\n    The following is an example of a 3-by-3 diagonal matrix:\n\n    \\[\n        \\begin{equation}\n            \\begin{pmatrix}\n                1 &amp; 0 &amp; 0 \\\\\n                0 &amp; 2 &amp; 0 \\\\\n                0 &amp; 0 &amp; 3\n            \\end{pmatrix}\n        \\end{equation}\n    \\]\n\n    This quick implementation is given by Daniel F. from StackOverflow in [@SO_43884189].\n\n    Examples:\n        Consider the following diagonal matrix:\n\n        \\[\n            A = \\begin{pmatrix}\n                    1 &amp; 0 \\\\\n                    0 &amp; 1\n                \\end{pmatrix}.\n        \\]\n\n        Our function indicates that this is indeed a diagonal matrix:\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import is_diagonal\n\n        A = np.array([[1, 0], [0, 1]])\n\n        print(is_diagonal(A))\n        ```\n\n        Alternatively, the following example matrix\n\n        \\[\n            B = \\begin{pmatrix}\n                    1 &amp; 2 \\\\\n                    3 &amp; 4\n                \\end{pmatrix}\n        \\]\n\n        is not diagonal, as shown using `|toqito\u27e9`.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import is_diagonal\n\n        B = np.array([[1, 2], [3, 4]])\n\n        print(is_diagonal(B))\n        ```\n\n    Args:\n        mat: The matrix to check.\n\n    Returns:\n        Returns `True` if the matrix is diagonal and `False` otherwise.\n\n    \"\"\"\n    if not is_square(mat):\n        return False\n    i, j = mat.shape\n    test = mat.reshape(-1)[:-1].reshape(i - 1, j + 1)\n    return bool(~np.any(test[:, 1:]))\n</code></pre>"},{"location":"reference/toqito/matrix_props/is_diagonally_dominant/","title":"is_diagonally_dominant","text":""},{"location":"reference/toqito/matrix_props/is_diagonally_dominant/#toqito.matrix_props.is_diagonally_dominant","title":"is_diagonally_dominant","text":"<p>Checks if the matrix is diagonally dominant.</p>"},{"location":"reference/toqito/matrix_props/is_diagonally_dominant/#toqito.matrix_props.is_diagonally_dominant.is_diagonally_dominant","title":"is_diagonally_dominant","text":"<pre><code>is_diagonally_dominant(mat: ndarray, is_strict: bool = True) -&gt; bool\n</code></pre> <p>Check if matrix is diagnal dominant (DD) <sup>1</sup>.</p> <p>A matrix is diagonally dominant if the matrix is square and if for every row of the matrix, the magnitude of the diagonal entry in a row is greater than or equal to the sum of the magnitudes of all the other (non-diagonal) entries in that row.</p> <p>Examples:</p> <p>The following is an example of a 3-by-3 diagonal matrix:</p> \\[     A = \\begin{pmatrix}             2 &amp; -1 &amp; 0 \\\\             0 &amp; 2 &amp; -1 \\\\             0 &amp; -1 &amp; 2         \\end{pmatrix} \\] <p>our function indicates that this is indeed a diagonally dominant matrix.</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import is_diagonally_dominant\n\nA = np.array([[2, -1, 0], [0, 2, -1], [0, -1, 2]])\n\nprint(is_diagonally_dominant(A))\n</code></pre> <p>True</p> <p>Alternatively, the following example matrix \\(B\\) defined as</p> \\[     B = \\begin{pmatrix}             -1 &amp; 2 \\\\             -1 &amp; -1         \\end{pmatrix} \\] <p>is not diagonally dominant.</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import is_diagonally_dominant\n\nB = np.array([[-1, 2], [-1, -1]])\n\nprint(is_diagonally_dominant(B))\n</code></pre> <p>False</p> <p>Parameters:</p> <ul> <li> <code>mat</code>               (<code>ndarray</code>)           \u2013            <p>Matrix to check.</p> </li> <li> <code>is_strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the inequality is strict.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Return <code>True</code> if matrix is diagnally dominant, and <code>False</code> otherwise.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Diagonally dominant matrix. link.</p> Source code in <code>toqito/matrix_props/is_diagonally_dominant.py</code> <pre><code>def is_diagonally_dominant(mat: np.ndarray, is_strict: bool = True) -&gt; bool:\n    r\"\"\"Check if matrix is diagnal dominant (DD) [@WikiDiagDom].\n\n    A matrix is diagonally dominant if the matrix is square\n    and if for every row of the matrix, the magnitude of the diagonal entry in a row is greater\n    than or equal to the sum of the magnitudes of all the other (non-diagonal) entries in that row.\n\n    Examples:\n        The following is an example of a 3-by-3 diagonal matrix:\n\n        \\[\n            A = \\begin{pmatrix}\n                    2 &amp; -1 &amp; 0 \\\\\n                    0 &amp; 2 &amp; -1 \\\\\n                    0 &amp; -1 &amp; 2\n                \\end{pmatrix}\n        \\]\n\n        our function indicates that this is indeed a diagonally dominant matrix.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import is_diagonally_dominant\n\n        A = np.array([[2, -1, 0], [0, 2, -1], [0, -1, 2]])\n\n        print(is_diagonally_dominant(A))\n        ```\n\n        Alternatively, the following example matrix \\(B\\) defined as\n\n        \\[\n            B = \\begin{pmatrix}\n                    -1 &amp; 2 \\\\\n                    -1 &amp; -1\n                \\end{pmatrix}\n        \\]\n\n        is not diagonally dominant.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import is_diagonally_dominant\n\n        B = np.array([[-1, 2], [-1, -1]])\n\n        print(is_diagonally_dominant(B))\n        ```\n\n    Args:\n        mat: Matrix to check.\n        is_strict: Whether the inequality is strict.\n\n    Returns:\n        Return `True` if matrix is diagnally dominant, and `False` otherwise.\n\n    \"\"\"\n    if not is_square(mat):\n        return False\n\n    mat = np.abs(mat)\n    diag_coeffs = np.diag(mat)\n    row_sum = np.sum(mat, axis=1) - diag_coeffs\n    return bool(np.all(diag_coeffs &gt; row_sum) if is_strict else np.all(diag_coeffs &gt;= row_sum))\n</code></pre>"},{"location":"reference/toqito/matrix_props/is_hermitian/","title":"is_hermitian","text":""},{"location":"reference/toqito/matrix_props/is_hermitian/#toqito.matrix_props.is_hermitian","title":"is_hermitian","text":"<p>Checks if the matrix is a Hermitian matrix.</p>"},{"location":"reference/toqito/matrix_props/is_hermitian/#toqito.matrix_props.is_hermitian.is_hermitian","title":"is_hermitian","text":"<pre><code>is_hermitian(mat: ndarray, rtol: float = 1e-05, atol: float = 1e-08) -&gt; bool\n</code></pre> <p>Check if matrix is Hermitian <sup>1</sup>.</p> <p>A Hermitian matrix is a complex square matrix that is equal to its own conjugate transpose.</p> <p>Examples:</p> <p>Consider the following matrix:</p> \\[     A = \\begin{pmatrix}             2 &amp; 2 +1j &amp; 4 \\\\             2 - 1j &amp; 3 &amp; 1j \\\\             4 &amp; -1j &amp; 1         \\end{pmatrix} \\] <p>our function indicates that this is indeed a Hermitian matrix as it holds that</p> \\[     A = A^*. \\] <pre><code>import numpy as np\nfrom toqito.matrix_props import is_hermitian\n\nmat = np.array([[2, 2 + 1j, 4], [2 - 1j, 3, 1j], [4, -1j, 1]])\n\nprint(is_hermitian(mat))\n</code></pre> <p>True</p> <p>Alternatively, the following example matrix \\(B\\) defined as</p> \\[     B = \\begin{pmatrix}             1 &amp; 2 &amp; 3 \\\\             4 &amp; 5 &amp; 6 \\\\             7 &amp; 8 &amp; 9         \\end{pmatrix} \\] <p>is not Hermitian.</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import is_hermitian\n\nmat = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n\nprint(is_hermitian(mat))\n</code></pre> <p>False</p> <p>Parameters:</p> <ul> <li> <code>mat</code>               (<code>ndarray</code>)           \u2013            <p>Matrix to check.</p> </li> <li> <code>rtol</code>               (<code>float</code>, default:                   <code>1e-05</code> )           \u2013            <p>The relative tolerance parameter (default 1e-05).</p> </li> <li> <code>atol</code>               (<code>float</code>, default:                   <code>1e-08</code> )           \u2013            <p>The absolute tolerance parameter (default 1e-08).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Return True if matrix is Hermitian, and False otherwise.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Hermitian matrix. link.</p> Source code in <code>toqito/matrix_props/is_hermitian.py</code> <pre><code>def is_hermitian(mat: np.ndarray, rtol: float = 1e-05, atol: float = 1e-08) -&gt; bool:\n    r\"\"\"Check if matrix is Hermitian [@WikiHerm].\n\n    A Hermitian matrix is a complex square matrix that is equal to its own conjugate transpose.\n\n    Examples:\n        Consider the following matrix:\n\n        \\[\n            A = \\begin{pmatrix}\n                    2 &amp; 2 +1j &amp; 4 \\\\\n                    2 - 1j &amp; 3 &amp; 1j \\\\\n                    4 &amp; -1j &amp; 1\n                \\end{pmatrix}\n        \\]\n\n        our function indicates that this is indeed a Hermitian matrix as it holds that\n\n        \\[\n            A = A^*.\n        \\]\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import is_hermitian\n\n        mat = np.array([[2, 2 + 1j, 4], [2 - 1j, 3, 1j], [4, -1j, 1]])\n\n        print(is_hermitian(mat))\n        ```\n\n        Alternatively, the following example matrix \\(B\\) defined as\n\n        \\[\n            B = \\begin{pmatrix}\n                    1 &amp; 2 &amp; 3 \\\\\n                    4 &amp; 5 &amp; 6 \\\\\n                    7 &amp; 8 &amp; 9\n                \\end{pmatrix}\n        \\]\n\n        is not Hermitian.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import is_hermitian\n\n        mat = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n\n        print(is_hermitian(mat))\n        ```\n\n    Args:\n        mat: Matrix to check.\n        rtol: The relative tolerance parameter (default 1e-05).\n        atol: The absolute tolerance parameter (default 1e-08).\n\n    Returns:\n        Return True if matrix is Hermitian, and False otherwise.\n\n    \"\"\"\n    if not is_square(mat):\n        return False\n    return np.allclose(mat, mat.conj().T, rtol=rtol, atol=atol)\n</code></pre>"},{"location":"reference/toqito/matrix_props/is_idempotent/","title":"is_idempotent","text":""},{"location":"reference/toqito/matrix_props/is_idempotent/#toqito.matrix_props.is_idempotent","title":"is_idempotent","text":"<p>Checks if the matrix is an idempotent matrix.</p>"},{"location":"reference/toqito/matrix_props/is_idempotent/#toqito.matrix_props.is_idempotent.is_idempotent","title":"is_idempotent","text":"<pre><code>is_idempotent(mat: ndarray, rtol: float = 1e-05, atol: float = 1e-08) -&gt; bool\n</code></pre> <p>Check if matrix is the idempotent matrix <sup>1</sup>.</p> <p>An idempotent matrix is a square matrix, which, when multiplied by itself, yields itself. That is, the matrix \\(A\\) is idempotent if and only if \\(A^2 = A\\).</p> <p>Examples:</p> <p>The following is an example of a \\(2 x 2\\) idempotent matrix:</p> \\[     A = \\begin{pmatrix}         3 &amp; -6 \\\\         1 &amp; -2     \\end{pmatrix} \\] <pre><code>import numpy as np\nfrom toqito.matrix_props import is_idempotent\n\nmat = np.array([[3, -6], [1, -2]])\n\nprint(is_idempotent(mat))\n</code></pre> <p>True</p> <p>Alternatively, the following matrix</p> \\[     B = \\begin{pmatrix}             1 &amp; 2 &amp; 3 \\\\             4 &amp; 5 &amp; 6 \\\\             7 &amp; 8 &amp; 9         \\end{pmatrix} \\] <p>is not idempotent.</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import is_idempotent\n\nmat = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n\nprint(is_idempotent(mat))\n</code></pre> <p>False</p> <p>Parameters:</p> <ul> <li> <code>mat</code>               (<code>ndarray</code>)           \u2013            <p>Matrix to check.</p> </li> <li> <code>rtol</code>               (<code>float</code>, default:                   <code>1e-05</code> )           \u2013            <p>The relative tolerance parameter (default 1e-05).</p> </li> <li> <code>atol</code>               (<code>float</code>, default:                   <code>1e-08</code> )           \u2013            <p>The absolute tolerance parameter (default 1e-08).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Return <code>True</code> if matrix is the idempotent matrix, and <code>False</code> otherwise.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Idempotent matrix. link.</p> Source code in <code>toqito/matrix_props/is_idempotent.py</code> <pre><code>def is_idempotent(mat: np.ndarray, rtol: float = 1e-05, atol: float = 1e-8) -&gt; bool:\n    r\"\"\"Check if matrix is the idempotent matrix [@WikiIdemPot].\n\n    An *idempotent matrix* is a square matrix, which, when multiplied by itself, yields itself.\n    That is, the matrix \\(A\\) is idempotent if and only if \\(A^2 = A\\).\n\n    Examples:\n        The following is an example of a \\(2 x 2\\) idempotent matrix:\n\n        \\[\n            A = \\begin{pmatrix}\n                3 &amp; -6 \\\\\n                1 &amp; -2\n            \\end{pmatrix}\n        \\]\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import is_idempotent\n\n        mat = np.array([[3, -6], [1, -2]])\n\n        print(is_idempotent(mat))\n        ```\n\n\n        Alternatively, the following matrix\n\n        \\[\n            B = \\begin{pmatrix}\n                    1 &amp; 2 &amp; 3 \\\\\n                    4 &amp; 5 &amp; 6 \\\\\n                    7 &amp; 8 &amp; 9\n                \\end{pmatrix}\n        \\]\n\n        is not idempotent.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import is_idempotent\n\n        mat = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n\n        print(is_idempotent(mat))\n        ```\n\n    Args:\n        mat: Matrix to check.\n        rtol: The relative tolerance parameter (default 1e-05).\n        atol: The absolute tolerance parameter (default 1e-08).\n\n    Returns:\n        Return `True` if matrix is the idempotent matrix, and `False` otherwise.\n\n    \"\"\"\n    if not is_square(mat):\n        return False\n    return np.allclose(mat, mat @ mat, rtol=rtol, atol=atol)\n</code></pre>"},{"location":"reference/toqito/matrix_props/is_identity/","title":"is_identity","text":""},{"location":"reference/toqito/matrix_props/is_identity/#toqito.matrix_props.is_identity","title":"is_identity","text":"<p>Checks if the matrix is an identity matrix.</p>"},{"location":"reference/toqito/matrix_props/is_identity/#toqito.matrix_props.is_identity.is_identity","title":"is_identity","text":"<pre><code>is_identity(mat: ndarray, rtol: float = 1e-05, atol: float = 1e-08) -&gt; bool\n</code></pre> <p>Check if matrix is the identity matrix <sup>1</sup>.</p> <p>For dimension \\(n\\), the \\(n \\times n\\) identity matrix is defined as</p> \\[     I_n =     \\begin{pmatrix}         1 &amp; 0 &amp; 0 &amp; \\ldots &amp; 0 \\\\         0 &amp; 1 &amp; 0 &amp; \\ldots &amp; 0 \\\\         0 &amp; 0 &amp; 1 &amp; \\ldots &amp; 0 \\\\         \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\         0 &amp; 0 &amp; 0 &amp; \\ldots &amp; 1     \\end{pmatrix}. \\] <p>Examples:</p> <p>Consider the following matrix:</p> \\[     A = \\begin{pmatrix}             1 &amp; 0 &amp; 0 \\\\             0 &amp; 1 &amp; 0 \\\\             0 &amp; 0 &amp; 1         \\end{pmatrix} \\] <p>our function indicates that this is indeed the identity matrix of dimension 3.</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import is_identity\n\nmat = np.eye(3)\n\nprint(is_identity(mat))\n</code></pre> <p>True</p> <p>Alternatively, the following example matrix \\(B\\) defined as</p> \\[     B = \\begin{pmatrix}             1 &amp; 2 &amp; 3 \\\\             4 &amp; 5 &amp; 6 \\\\             7 &amp; 8 &amp; 9         \\end{pmatrix} \\] <p>is not an identity matrix.</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import is_identity\n\nmat = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n\nprint(is_identity(mat))\n</code></pre> <p>False</p> <p>Parameters:</p> <ul> <li> <code>mat</code>               (<code>ndarray</code>)           \u2013            <p>Matrix to check.</p> </li> <li> <code>rtol</code>               (<code>float</code>, default:                   <code>1e-05</code> )           \u2013            <p>The relative tolerance parameter (default 1e-05).</p> </li> <li> <code>atol</code>               (<code>float</code>, default:                   <code>1e-08</code> )           \u2013            <p>The absolute tolerance parameter (default 1e-08).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Return <code>True</code> if matrix is the identity matrix, and <code>False</code> otherwise.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Identity matrix. link.</p> Source code in <code>toqito/matrix_props/is_identity.py</code> <pre><code>def is_identity(mat: np.ndarray, rtol: float = 1e-05, atol: float = 1e-8) -&gt; bool:\n    r\"\"\"Check if matrix is the identity matrix [@WikiIden].\n\n    For dimension \\(n\\), the \\(n \\times n\\) identity matrix is defined as\n\n    \\[\n        I_n =\n        \\begin{pmatrix}\n            1 &amp; 0 &amp; 0 &amp; \\ldots &amp; 0 \\\\\n            0 &amp; 1 &amp; 0 &amp; \\ldots &amp; 0 \\\\\n            0 &amp; 0 &amp; 1 &amp; \\ldots &amp; 0 \\\\\n            \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\\n            0 &amp; 0 &amp; 0 &amp; \\ldots &amp; 1\n        \\end{pmatrix}.\n    \\]\n\n    Examples:\n        Consider the following matrix:\n\n        \\[\n            A = \\begin{pmatrix}\n                    1 &amp; 0 &amp; 0 \\\\\n                    0 &amp; 1 &amp; 0 \\\\\n                    0 &amp; 0 &amp; 1\n                \\end{pmatrix}\n        \\]\n\n        our function indicates that this is indeed the identity matrix of dimension\n        3.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import is_identity\n\n        mat = np.eye(3)\n\n        print(is_identity(mat))\n        ```\n\n        Alternatively, the following example matrix \\(B\\) defined as\n\n        \\[\n            B = \\begin{pmatrix}\n                    1 &amp; 2 &amp; 3 \\\\\n                    4 &amp; 5 &amp; 6 \\\\\n                    7 &amp; 8 &amp; 9\n                \\end{pmatrix}\n        \\]\n\n        is not an identity matrix.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import is_identity\n\n        mat = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n\n        print(is_identity(mat))\n        ```\n\n    Args:\n        mat: Matrix to check.\n        rtol: The relative tolerance parameter (default 1e-05).\n        atol: The absolute tolerance parameter (default 1e-08).\n\n    Returns:\n        Return `True` if matrix is the identity matrix, and `False` otherwise.\n\n    \"\"\"\n    if not is_square(mat):\n        return False\n    id_mat = np.eye(len(mat))\n    return np.allclose(mat, id_mat, rtol=rtol, atol=atol)\n</code></pre>"},{"location":"reference/toqito/matrix_props/is_k_incoherent/","title":"is_k_incoherent","text":""},{"location":"reference/toqito/matrix_props/is_k_incoherent/#toqito.matrix_props.is_k_incoherent","title":"is_k_incoherent","text":"<p>Checks if the matrix is \\(k\\)-incoherent.</p>"},{"location":"reference/toqito/matrix_props/is_k_incoherent/#toqito.matrix_props.is_k_incoherent.is_k_incoherent","title":"is_k_incoherent","text":"<pre><code>is_k_incoherent(mat: ndarray, k: int, tol: float = 1e-15) -&gt; bool\n</code></pre> <p>Determine whether a quantum state is k-incoherent <sup>1</sup>.</p> <p>For a positive integers, \\(k\\) and \\(n\\), the matrix \\(X \\in \\text{Pos}(\\mathbb{C}^n)\\) is called \\(k\\)-incoherent if there exists a positive integer \\(m\\), a set  \\(S = \\{|\\psi_0\\rangle, |\\psi_1\\rangle,\\ldots, |\\psi_{m-1}\\rangle\\} \\subset \\mathbb{C}^n\\) with the property that each \\(|\\psi_i\\rangle\\) has at most \\(k\\) non-zero entries, and real scalars \\(c_0, c_1, \\ldots, c_{m-1} \\geq 0\\) for which</p> \\[     X = \\sum_{j=0}^{m-1} c_j |\\psi_j\\rangle \\langle \\psi_j|. \\] <p>This function checks if the provided density matrix <code>mat</code> is k-incoherent. It returns True if <code>mat</code> is k-incoherent and False if <code>mat</code> is not.</p> <p>The function first handles trivial cases. Then it computes the comparison matrix (via <code>comparison()</code>) and performs further tests based on the trace of \\(mat^2\\) and a dephasing channel. If no decision is reached, the function recurses by checking incoherence for k-1.  Finally, if still indeterminate, an SDP is formulated to decide incoherence.</p> <p>Examples:</p> <p>If \\(n = 3\\) and \\(k = 2\\), then the following matrix is \\(2\\)-incoherent:</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import is_k_incoherent\nmat = np.array([[2, 1, 2],\n            [1, 2, -1],\n            [2, -1, 5]])\nprint(is_k_incoherent(mat, 2))\n</code></pre> <p>True</p> <p>See</p> <p>is_antidistinguishable(), is_absolutely_k_incoherent()</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If k \u2264 0 or if <code>mat</code> is not square.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>mat</code>               (<code>ndarray</code>)           \u2013            <p>Density matrix to test.</p> </li> <li> <code>k</code>               (<code>int</code>)           \u2013            <p>The positive integer coherence level.</p> </li> <li> <code>tol</code>               (<code>float</code>, default:                   <code>1e-15</code> )           \u2013            <p>Tolerance for numerical comparisons (default is 1e-15).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if <code>mat</code> is k-incoherent, False otherwise.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Johnston, Nathaniel and Moein, Shirin and Pereira, Rajesh and Plosker, Sarah. Absolutely k-incoherent quantum states and spectral inequalities for the factor width of a matrix. Physical Review A. vol. 106(5). (2022).</p> Source code in <code>toqito/matrix_props/is_k_incoherent.py</code> <pre><code>def is_k_incoherent(mat: np.ndarray, k: int, tol: float = 1e-15) -&gt; bool:\n    r\"\"\"Determine whether a quantum state is k-incoherent [@Johnston_2022_Absolutely].\n\n    For a positive integers, \\(k\\) and \\(n\\), the matrix \\(X \\in \\text{Pos}(\\mathbb{C}^n)\\) is called\n    \\(k\\)-incoherent if there exists a positive integer \\(m\\), a set  \\(S = \\{|\\psi_0\\rangle,\n    |\\psi_1\\rangle,\\ldots, |\\psi_{m-1}\\rangle\\} \\subset \\mathbb{C}^n\\) with the property that each \\(|\\psi_i\\rangle\\)\n    has at most \\(k\\) non-zero entries, and real scalars \\(c_0, c_1, \\ldots, c_{m-1} \\geq 0\\) for which\n\n    \\[\n        X = \\sum_{j=0}^{m-1} c_j |\\psi_j\\rangle \\langle \\psi_j|.\n    \\]\n\n    This function checks if the provided density matrix `mat` is k-incoherent. It returns True if `mat` is\n    k-incoherent and False if `mat` is not.\n\n    The function first handles trivial cases. Then it computes the comparison matrix (via\n    [`comparison()`][toqito.matrices.comparison.comparison]) and performs further tests based on the trace of \\(mat^2\\)\n    and a dephasing channel. If no decision is reached, the function recurses by checking incoherence for k-1.  Finally,\n    if still indeterminate, an SDP is formulated to decide incoherence.\n\n    Examples:\n        If \\(n = 3\\) and \\(k = 2\\), then the following matrix is \\(2\\)-incoherent:\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import is_k_incoherent\n        mat = np.array([[2, 1, 2],\n                    [1, 2, -1],\n                    [2, -1, 5]])\n        print(is_k_incoherent(mat, 2))\n        ```\n\n        !!! See\n            [is_antidistinguishable()][toqito.state_props.is_antidistinguishable.is_antidistinguishable],\n            [is_absolutely_k_incoherent()][toqito.matrix_props.is_absolutely_k_incoherent.is_absolutely_k_incoherent]\n\n    Raises:\n        ValueError: If k \u2264 0 or if `mat` is not square.\n\n    Args:\n        mat: Density matrix to test.\n        k: The positive integer coherence level.\n        tol: Tolerance for numerical comparisons (default is 1e-15).\n\n    Returns:\n        True if `mat` is k-incoherent, False otherwise.\n\n    \"\"\"\n    if k &lt;= 0:\n        raise ValueError(\"k must be a positive integer.\")\n    if not is_square(mat):\n        raise ValueError(\"Input matrix must be square.\")\n    d = mat.shape[0]\n\n    # Trivial: every state is d-incoherent.\n    if k &gt;= d:\n        return True\n\n    # If `mat` is diagonal, it is declared k-incoherent.\n    if np.allclose(mat, np.diag(np.diag(mat)), atol=tol):\n        return True\n\n    # For k == 1, only diagonal states are 1-incoherent.\n    if k == 1:\n        return False\n\n    # [1] Theorem 1: Use the comparison matrix.\n    M = comparison(mat)\n    if is_positive_semidefinite(M):\n        return True\n    elif k == 2:\n        return False\n\n    # [@Johnston_2022_Absolutely] (8): Check if trace(mat^2) &lt;= 1/(d - 1) (for k &gt; 2).\n    if k &gt; 2 and np.trace(mat @ mat) &lt;= 1 / (d - 1):\n        return True\n\n    # Hierarchical recursion: for k &gt;= 2 check incoherence for k-1.\n    rec = is_k_incoherent(mat, k - 1)\n    if rec is not None and rec is not False:\n        return rec\n\n    # Fallback: use an SDP to decide incoherence.\n    # We follow the MATLAB method via projections onto k-element subsets.\n    n = d  # for clarity, n == d.\n    idx_sets = list(combinations(range(n), k))\n    s = len(idx_sets)\n    A_vars = [cp.Variable((k, k), hermitian=True) for _ in range(s)]\n    constraints = []\n    P_expr = 0\n    for idx, A_j in zip(idx_sets, A_vars):\n        # Build the projection matrix (constant, shape (k, n)).\n        proj = np.zeros((k, n))\n        for i, j in enumerate(idx):\n            proj[i, j] = 1.0\n        constraints.append(A_j &gt;&gt; 0)\n        P_expr = P_expr + proj.T @ A_j @ proj\n    constraints.append(mat == P_expr)\n    prob = cp.Problem(cp.Minimize(1), constraints)\n    opt_val = prob.solve(solver=cp.SCS, verbose=False)\n\n    # MATLAB sets ikinc = 1 - min(cvx_optval, 1); here we interpret an optimum near 1 as True.\n    return np.isclose(1 - min(opt_val, 1), 1.0)\n</code></pre>"},{"location":"reference/toqito/matrix_props/is_ldoi/","title":"is_ldoi","text":""},{"location":"reference/toqito/matrix_props/is_ldoi/#toqito.matrix_props.is_ldoi","title":"is_ldoi","text":"<p>Check if a quantum state is LDOI (Local Diagonal Orthogonal Invariant).</p>"},{"location":"reference/toqito/matrix_props/is_ldoi/#toqito.matrix_props.is_ldoi.is_ldoi","title":"is_ldoi","text":"<pre><code>is_ldoi(mat: ndarray, rtol: float = 1e-05, atol: float = 1e-08) -&gt; bool\n</code></pre> <p>Check if a quantum state is LDOI (Local Diagonal Orthogonal Invariant).</p> <p>A matrix \\(A \\in \\mathcal{L}(\\mathcal{X} \\otimes \\mathcal{Y})\\) is called local diagonal orthogonal invariant (LDOI) if \\(\\Phi_O(A) = A\\), where \\(\\Phi_O\\) is the local diagonal orthogonal twirl map defined as:</p> \\[     \\Phi_O(A) = \\frac{1}{2^n} \\sum_{O \\in \\text{DO}(\\mathcal{X})} (O \\otimes O) A (O \\otimes O) \\] <p>where \\(\\text{DO}(\\mathcal{X})\\) is the set of diagonal matrices with entries \\(\\pm 1\\).</p> <p>LDOI states include many important families such as Werner states, isotropic states, X-states, and mixtures of Dicke states. This function efficiently checks the LDOI property using the standard basis representation.</p> <p>Examples:</p> <p>X-states are examples of 2-qubit LDOI states:</p> <pre><code>from toqito.matrix_props import is_ldoi\nimport numpy as np\n\n# Example X-state\nx_state = np.array([[1, 0, 0, 2],\n                     [0, 3, 4, 0],\n                     [0, 5, 6, 0],\n                     [7, 0, 0, 8]])\nprint(is_ldoi(x_state))\n</code></pre> <p>True</p> <p>All diagonal states are LDOI:</p> <pre><code>from toqito.matrix_props import is_ldoi\nimport numpy as np\n\ndiagonal_state = np.diag([1, 2, 3, 4])\nprint(is_ldoi(diagonal_state))\n</code></pre> <p>True</p> <p>Non-LDOI states return False:</p> <pre><code>from toqito.matrix_props import is_ldoi\nimport numpy as np\n\n# Random non-LDOI state\nnon_ldoi = np.array([[1, 2, 3, 4],\n                      [5, 6, 7, 8],\n                      [9, 10, 11, 12],\n                      [13, 14, 15, 16]])\nprint(is_ldoi(non_ldoi))\n</code></pre> <p>False</p> <p>Parameters:</p> <ul> <li> <code>mat</code>               (<code>ndarray</code>)           \u2013            <p>A matrix representing a quantum state.</p> </li> <li> <code>rtol</code>               (<code>float</code>, default:                   <code>1e-05</code> )           \u2013            <p>Relative tolerance parameter (default: 1e-05).</p> </li> <li> <code>atol</code>               (<code>float</code>, default:                   <code>1e-08</code> )           \u2013            <p>Absolute tolerance parameter (default: 1e-08).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the matrix is LDOI, False otherwise.</p> </li> </ul> Source code in <code>toqito/matrix_props/is_ldoi.py</code> <pre><code>def is_ldoi(mat: np.ndarray, rtol: float = 1e-05, atol: float = 1e-08) -&gt; bool:\n    r\"\"\"Check if a quantum state is LDOI (Local Diagonal Orthogonal Invariant).\n\n    A matrix \\(A \\in \\mathcal{L}(\\mathcal{X} \\otimes \\mathcal{Y})\\) is called *local diagonal\n    orthogonal invariant* (LDOI) if \\(\\Phi_O(A) = A\\), where \\(\\Phi_O\\) is the local\n    diagonal orthogonal twirl map defined as:\n\n    \\[\n        \\Phi_O(A) = \\frac{1}{2^n} \\sum_{O \\in \\text{DO}(\\mathcal{X})} (O \\otimes O) A (O \\otimes O)\n    \\]\n\n    where \\(\\text{DO}(\\mathcal{X})\\) is the set of diagonal matrices with entries \\(\\pm 1\\).\n\n    LDOI states include many important families such as Werner states, isotropic states, X-states,\n    and mixtures of Dicke states. This function efficiently checks the LDOI property using the\n    standard basis representation.\n\n    Examples:\n        X-states are examples of 2-qubit LDOI states:\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.matrix_props import is_ldoi\n        import numpy as np\n\n        # Example X-state\n        x_state = np.array([[1, 0, 0, 2],\n                             [0, 3, 4, 0],\n                             [0, 5, 6, 0],\n                             [7, 0, 0, 8]])\n        print(is_ldoi(x_state))\n        ```\n\n        All diagonal states are LDOI:\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.matrix_props import is_ldoi\n        import numpy as np\n\n        diagonal_state = np.diag([1, 2, 3, 4])\n        print(is_ldoi(diagonal_state))\n        ```\n\n        Non-LDOI states return False:\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.matrix_props import is_ldoi\n        import numpy as np\n\n        # Random non-LDOI state\n        non_ldoi = np.array([[1, 2, 3, 4],\n                              [5, 6, 7, 8],\n                              [9, 10, 11, 12],\n                              [13, 14, 15, 16]])\n        print(is_ldoi(non_ldoi))\n        ```\n\n    Args:\n        mat: A matrix representing a quantum state.\n        rtol: Relative tolerance parameter (default: 1e-05).\n        atol: Absolute tolerance parameter (default: 1e-08).\n\n    Returns:\n        True if the matrix is LDOI, False otherwise.\n\n    \"\"\"\n    if mat.ndim != 2 or mat.shape[0] != mat.shape[1]:\n        raise ValueError(\"Input matrix must be square.\")\n\n    # A matrix is LDOI if \u03a6_O(mat) = mat\n    ldot_result = ldot_channel(mat)\n    return np.allclose(ldot_result, mat, rtol=rtol, atol=atol)\n</code></pre>"},{"location":"reference/toqito/matrix_props/is_linearly_independent/","title":"is_linearly_independent","text":""},{"location":"reference/toqito/matrix_props/is_linearly_independent/#toqito.matrix_props.is_linearly_independent","title":"is_linearly_independent","text":"<p>Checks if a set of vectors are linearly independent.</p>"},{"location":"reference/toqito/matrix_props/is_linearly_independent/#toqito.matrix_props.is_linearly_independent.is_linearly_independent","title":"is_linearly_independent","text":"<pre><code>is_linearly_independent(vectors: list[ndarray]) -&gt; bool\n</code></pre> <p>Check if set of vectors are linearly independent <sup>1</sup>.</p> <p>Examples:</p> <p>The following vectors are an example of a linearly independent set of vectors in \\(\\mathbb{R}^3\\).</p> \\[     \\begin{pmatrix}         1 \\\\ 0 \\\\ 1     \\end{pmatrix}, \\quad     \\begin{pmatrix}         1 \\\\ 1 \\\\ 0     \\end{pmatrix}, \\quad \\text{and} \\quad     \\begin{pmatrix}         0 \\\\ 0 \\\\ 1     \\end{pmatrix} \\] <p>We can see that these are linearly independent.</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import is_linearly_independent\n\nv_1 = np.array([[1], [0], [1]])\nv_2 = np.array([[1], [1], [0]])\nv_3 = np.array([[0], [0], [1]])\n\nprint(is_linearly_independent([v_1, v_2, v_3]))\n</code></pre> <p>True</p> <p>Parameters:</p> <ul> <li> <code>vectors</code>               (<code>list[ndarray]</code>)           \u2013            <p>Vectors to check the linear independence of.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Return <code>True</code> if vectors are linearly independent <code>False</code> otherwise.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Linear independence. link.</p> Source code in <code>toqito/matrix_props/is_linearly_independent.py</code> <pre><code>def is_linearly_independent(vectors: list[np.ndarray]) -&gt; bool:\n    r\"\"\"Check if set of vectors are linearly independent [@WikiLinearIndependence].\n\n    Examples:\n        The following vectors are an example of a linearly independent set of vectors in \\(\\mathbb{R}^3\\).\n\n        \\[\n            \\begin{pmatrix}\n                1 \\\\ 0 \\\\ 1\n            \\end{pmatrix}, \\quad\n            \\begin{pmatrix}\n                1 \\\\ 1 \\\\ 0\n            \\end{pmatrix}, \\quad \\text{and} \\quad\n            \\begin{pmatrix}\n                0 \\\\ 0 \\\\ 1\n            \\end{pmatrix}\n        \\]\n\n        We can see that these are linearly independent.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import is_linearly_independent\n\n        v_1 = np.array([[1], [0], [1]])\n        v_2 = np.array([[1], [1], [0]])\n        v_3 = np.array([[0], [0], [1]])\n\n        print(is_linearly_independent([v_1, v_2, v_3]))\n        ```\n\n    Args:\n        vectors: Vectors to check the linear independence of.\n\n    Returns:\n        Return `True` if vectors are linearly independent `False` otherwise.\n\n    \"\"\"\n    # Check if the rank of the matrix equals the number of vectors.\n    return bool(np.linalg.matrix_rank(np.column_stack(vectors)) == len(vectors))\n</code></pre>"},{"location":"reference/toqito/matrix_props/is_nonnegative/","title":"is_nonnegative","text":""},{"location":"reference/toqito/matrix_props/is_nonnegative/#toqito.matrix_props.is_nonnegative","title":"is_nonnegative","text":"<p>Checks if the matrix is nonnegative or doubly nonnegative.</p>"},{"location":"reference/toqito/matrix_props/is_nonnegative/#toqito.matrix_props.is_nonnegative.is_nonnegative","title":"is_nonnegative","text":"<pre><code>is_nonnegative(input_mat: ndarray, mat_type: str = 'nonnegative') -&gt; bool\n</code></pre> <p>Check if the matrix is nonnegative.</p> <p>When all the entries in the matrix are larger than or equal to zero the matrix of interest is a nonnegative matrix <sup>1</sup>.</p> <p>When a matrix is nonegative and positive semidefinite <sup>2</sup>, the matrix is doubly nonnegative.</p> <p>Examples:</p> <p>We expect an identity matrix to be nonnegative.</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import is_nonnegative\n\nprint(is_nonnegative(np.eye(2)))\nprint(is_nonnegative(np.eye(2), \"doubly\"))\nprint(is_nonnegative(np.array([[1, -1], [1, 1]])))\n</code></pre> <p>True True False</p> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If something other than <code>\"doubly\"</code>or <code>\"nonnegative\"</code> is used for <code>mat_type</code>.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>input_mat</code>               (<code>ndarray</code>)           \u2013            <p>np.ndarray Matrix of interest.</p> </li> <li> <code>mat_type</code>               (<code>str</code>, default:                   <code>'nonnegative'</code> )           \u2013            <p>Type of nonnegative matrix. <code>\"nonnegative\"</code> for a nonnegative matrix and <code>\"doubly\"</code> for a doubly</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Nonnegative matrix. link. <sup>2</sup> Wikipedia. Definite matrix. link.</p> Source code in <code>toqito/matrix_props/is_nonnegative.py</code> <pre><code>def is_nonnegative(input_mat: np.ndarray, mat_type: str = \"nonnegative\") -&gt; bool:\n    r\"\"\"Check if the matrix is nonnegative.\n\n    When all the entries in the matrix are larger than or equal to zero the matrix of interest is a\n    nonnegative matrix [@WikiNonNegative].\n\n    When a matrix is nonegative and positive semidefinite [@WikiPosDef], the matrix is doubly nonnegative.\n\n\n    Examples:\n        We expect an identity matrix to be nonnegative.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import is_nonnegative\n\n        print(is_nonnegative(np.eye(2)))\n        print(is_nonnegative(np.eye(2), \"doubly\"))\n        print(is_nonnegative(np.array([[1, -1], [1, 1]])))\n        ```\n\n\n    Raises:\n        TypeError: If something other than `\"doubly\"`or `\"nonnegative\"` is used for `mat_type`.\n\n    Args:\n        input_mat: np.ndarray Matrix of interest.\n        mat_type: Type of nonnegative matrix. `\"nonnegative\"` for a nonnegative matrix and `\"doubly\"` for a doubly\n        nonnegative matrix.\n\n    \"\"\"\n    valid_types = {\"nonnegative\", \"doubly\"}\n    if mat_type not in valid_types:\n        raise TypeError(f\"Invalid matrix check type: {mat_type}. Must be one of: {valid_types}.\")\n\n    is_entrywise_nonnegative = bool(np.all(input_mat &gt;= 0))\n\n    if mat_type == \"doubly\":\n        return is_entrywise_nonnegative and is_positive_semidefinite(input_mat)\n    else:\n        return is_entrywise_nonnegative\n</code></pre>"},{"location":"reference/toqito/matrix_props/is_normal/","title":"is_normal","text":""},{"location":"reference/toqito/matrix_props/is_normal/#toqito.matrix_props.is_normal","title":"is_normal","text":"<p>Checks if the matrix is a normal matrix.</p>"},{"location":"reference/toqito/matrix_props/is_normal/#toqito.matrix_props.is_normal.is_normal","title":"is_normal","text":"<pre><code>is_normal(mat: ndarray, rtol: float = 1e-05, atol: float = 1e-08) -&gt; bool\n</code></pre> <p>Determine if a matrix is normal <sup>1</sup>.</p> <p>A matrix is normal if it commutes with its adjoint</p> \\[     \\begin{equation}         [X, X^*] = 0,     \\end{equation} \\] <p>or, equivalently if</p> \\[     \\begin{equation}         X^* X = X X^*     \\end{equation}. \\] <p>Examples:</p> <p>Consider the following matrix</p> \\[     A = \\begin{pmatrix}             1 &amp; 0 &amp; 0 &amp; 0 \\\\             0 &amp; 1 &amp; 0 &amp; 0 \\\\             0 &amp; 0 &amp; 1 &amp; 0 \\\\             0 &amp; 0 &amp; 0 &amp; 1         \\end{pmatrix} \\] <p>our function indicates that this is indeed a normal matrix.</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import is_normal\n\nA = np.identity(4)\n\nprint(is_normal(A))\n</code></pre> <p>True</p> <p>Alternatively, the following example matrix \\(B\\) defined as</p> \\[     B = \\begin{pmatrix}             1 &amp; 2 &amp; 3 \\\\             4 &amp; 5 &amp; 6 \\\\             7 &amp; 8 &amp; 9         \\end{pmatrix} \\] <p>is not normal.</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import is_normal\n\nB = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n\nprint(is_normal(B))\n</code></pre> <p>False</p> <p>Parameters:</p> <ul> <li> <code>mat</code>               (<code>ndarray</code>)           \u2013            <p>The matrix to check.</p> </li> <li> <code>rtol</code>               (<code>float</code>, default:                   <code>1e-05</code> )           \u2013            <p>The relative tolerance parameter (default 1e-05).</p> </li> <li> <code>atol</code>               (<code>float</code>, default:                   <code>1e-08</code> )           \u2013            <p>The absolute tolerance parameter (default 1e-08).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Returns <code>True</code> if the matrix is normal and <code>False</code> otherwise.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Normal Matrix. link.</p> Source code in <code>toqito/matrix_props/is_normal.py</code> <pre><code>def is_normal(mat: np.ndarray, rtol: float = 1e-05, atol: float = 1e-08) -&gt; bool:\n    r\"\"\"Determine if a matrix is normal [@WikiNorm].\n\n    A matrix is normal if it commutes with its adjoint\n\n    \\[\n        \\begin{equation}\n            [X, X^*] = 0,\n        \\end{equation}\n    \\]\n\n    or, equivalently if\n\n    \\[\n        \\begin{equation}\n            X^* X = X X^*\n        \\end{equation}.\n    \\]\n\n    Examples:\n        Consider the following matrix\n\n        \\[\n            A = \\begin{pmatrix}\n                    1 &amp; 0 &amp; 0 &amp; 0 \\\\\n                    0 &amp; 1 &amp; 0 &amp; 0 \\\\\n                    0 &amp; 0 &amp; 1 &amp; 0 \\\\\n                    0 &amp; 0 &amp; 0 &amp; 1\n                \\end{pmatrix}\n        \\]\n\n        our function indicates that this is indeed a normal matrix.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import is_normal\n\n        A = np.identity(4)\n\n        print(is_normal(A))\n        ```\n\n        Alternatively, the following example matrix \\(B\\) defined as\n\n        \\[\n            B = \\begin{pmatrix}\n                    1 &amp; 2 &amp; 3 \\\\\n                    4 &amp; 5 &amp; 6 \\\\\n                    7 &amp; 8 &amp; 9\n                \\end{pmatrix}\n        \\]\n\n        is not normal.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import is_normal\n\n        B = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n\n        print(is_normal(B))\n        ```\n\n    Args:\n        mat: The matrix to check.\n        rtol: The relative tolerance parameter (default 1e-05).\n        atol: The absolute tolerance parameter (default 1e-08).\n\n    Returns:\n        Returns `True` if the matrix is normal and `False` otherwise.\n\n    \"\"\"\n    if not is_square(mat):\n        return False\n    return np.allclose(mat @ mat.conj().T, mat.conj().T @ mat, rtol=rtol, atol=atol)\n</code></pre>"},{"location":"reference/toqito/matrix_props/is_orthonormal/","title":"is_orthonormal","text":""},{"location":"reference/toqito/matrix_props/is_orthonormal/#toqito.matrix_props.is_orthonormal","title":"is_orthonormal","text":"<p>Checks if the set of vectors are orthonormal.</p>"},{"location":"reference/toqito/matrix_props/is_orthonormal/#toqito.matrix_props.is_orthonormal.is_orthonormal","title":"is_orthonormal","text":"<pre><code>is_orthonormal(vectors: list[ndarray]) -&gt; bool\n</code></pre> <p>Check if the vectors are orthonormal.</p> <p>Examples:</p> <p>The following vectors are an example of an orthonormal set of vectors in \\(\\mathbb{R}^3\\).</p> \\[     \\begin{pmatrix}         1 \\\\ 0 \\\\ 1     \\end{pmatrix}, \\quad     \\begin{pmatrix}         1 \\\\ 1 \\\\ 0     \\end{pmatrix}, \\quad \\text{and} \\quad     \\begin{pmatrix}         0 \\\\ 0 \\\\ 1     \\end{pmatrix} \\] <p>To check these are a known set of orthonormal vectors:</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import is_orthonormal\n\nv_1 = np.array([1, 0, 0])\nv_2 = np.array([0, 1, 0])\nv_3 = np.array([0, 0, 1])\n\nv = np.array([v_1, v_2, v_3])\n\nprint(is_orthonormal(v))\n</code></pre> <p>True</p> <p>Parameters:</p> <ul> <li> <code>vectors</code>               (<code>list[ndarray]</code>)           \u2013            <p>A list of <code>np.ndarray</code> 1-by-n vectors.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if vectors are orthonormal; False otherwise.</p> </li> </ul> Source code in <code>toqito/matrix_props/is_orthonormal.py</code> <pre><code>def is_orthonormal(vectors: list[np.ndarray]) -&gt; bool:\n    r\"\"\"Check if the vectors are orthonormal.\n\n    Examples:\n        The following vectors are an example of an orthonormal set of\n        vectors in \\(\\mathbb{R}^3\\).\n\n        \\[\n            \\begin{pmatrix}\n                1 \\\\ 0 \\\\ 1\n            \\end{pmatrix}, \\quad\n            \\begin{pmatrix}\n                1 \\\\ 1 \\\\ 0\n            \\end{pmatrix}, \\quad \\text{and} \\quad\n            \\begin{pmatrix}\n                0 \\\\ 0 \\\\ 1\n            \\end{pmatrix}\n        \\]\n\n        To check these are a known set of orthonormal vectors:\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import is_orthonormal\n\n        v_1 = np.array([1, 0, 0])\n        v_2 = np.array([0, 1, 0])\n        v_3 = np.array([0, 0, 1])\n\n        v = np.array([v_1, v_2, v_3])\n\n        print(is_orthonormal(v))\n        ```\n\n\n    Args:\n        vectors: A list of `np.ndarray` 1-by-n vectors.\n\n    Returns:\n        True if vectors are orthonormal; False otherwise.\n\n    \"\"\"\n    return is_mutually_orthogonal(vectors) and np.allclose(\n        np.dot(vectors, np.conjugate(vectors).T), np.eye(vectors.shape[0])\n    )\n</code></pre>"},{"location":"reference/toqito/matrix_props/is_permutation/","title":"is_permutation","text":""},{"location":"reference/toqito/matrix_props/is_permutation/#toqito.matrix_props.is_permutation","title":"is_permutation","text":"<p>Checks if the matrix is a permutation matrix.</p>"},{"location":"reference/toqito/matrix_props/is_permutation/#toqito.matrix_props.is_permutation.is_permutation","title":"is_permutation","text":"<pre><code>is_permutation(mat: ndarray) -&gt; bool\n</code></pre> <p>Determine if a matrix is a permutation matrix <sup>1</sup>.</p> <p>A matrix is a permutation matrix if each row and column has a single element of 1 and all others are 0.</p> <p>Examples:</p> <p>Consider the following permutation matrix</p> \\[     A = \\begin{pmatrix}             1 &amp; 0 &amp; 0 \\\\             0 &amp; 0 &amp; 1 \\\\             0 &amp; 1 &amp; 0         \\end{pmatrix} \\] <p>which is indeed a permutation matrix.</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import is_permutation\n\nA = np.array([[1, 0, 0], [0, 0, 1], [0, 1, 0]])\n\nprint(is_permutation(A))\n</code></pre> <p>True</p> <p>Alternatively, the following example matrix \\(B\\) defined as</p> \\[     B = \\begin{pmatrix}             1 &amp; 0 &amp; 0 \\\\             1 &amp; 0 &amp; 0 \\\\             1 &amp; 0 &amp; 0         \\end{pmatrix} \\] <p>has 2 columns with all zero values and is thus not a permutation matrix.</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import is_permutation\n\nB = np.array([[1, 0, 0], [1, 0, 0], [1, 0, 0]])\n\nprint(is_permutation(B))\n</code></pre> <p>False</p> <p>Parameters:</p> <ul> <li> <code>mat</code>               (<code>ndarray</code>)           \u2013            <p>The matrix to check.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Returns <code>True</code> if the matrix is a permutation matrix and <code>False</code> otherwise.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Permutation matrix. link.</p> Source code in <code>toqito/matrix_props/is_permutation.py</code> <pre><code>def is_permutation(mat: np.ndarray) -&gt; bool:\n    r\"\"\"Determine if a matrix is a permutation matrix [@WikiPerm].\n\n    A matrix is a permutation matrix if each row and column has a\n    single element of 1 and all others are 0.\n\n    Examples:\n        Consider the following permutation matrix\n\n        \\[\n            A = \\begin{pmatrix}\n                    1 &amp; 0 &amp; 0 \\\\\n                    0 &amp; 0 &amp; 1 \\\\\n                    0 &amp; 1 &amp; 0\n                \\end{pmatrix}\n        \\]\n\n        which is indeed a permutation matrix.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import is_permutation\n\n        A = np.array([[1, 0, 0], [0, 0, 1], [0, 1, 0]])\n\n        print(is_permutation(A))\n        ```\n\n\n        Alternatively, the following example matrix \\(B\\) defined as\n\n        \\[\n            B = \\begin{pmatrix}\n                    1 &amp; 0 &amp; 0 \\\\\n                    1 &amp; 0 &amp; 0 \\\\\n                    1 &amp; 0 &amp; 0\n                \\end{pmatrix}\n        \\]\n\n        has 2 columns with all zero values and is thus not a\n        permutation matrix.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import is_permutation\n\n        B = np.array([[1, 0, 0], [1, 0, 0], [1, 0, 0]])\n\n        print(is_permutation(B))\n        ```\n\n    Args:\n        mat: The matrix to check.\n\n    Returns:\n        Returns `True` if the matrix is a permutation matrix and `False` otherwise.\n\n    \"\"\"\n    for i in np.nditer(mat):\n        if i not in (0, 1):\n            return False\n\n    if all(sum(row) == 1 for row in mat):\n        return all(sum(col) == 1 for col in zip(*mat))\n    return False\n</code></pre>"},{"location":"reference/toqito/matrix_props/is_positive/","title":"is_positive","text":""},{"location":"reference/toqito/matrix_props/is_positive/#toqito.matrix_props.is_positive","title":"is_positive","text":"<p>Checks if the matrix is positive.</p>"},{"location":"reference/toqito/matrix_props/is_positive/#toqito.matrix_props.is_positive.is_positive","title":"is_positive","text":"<pre><code>is_positive(input_mat: ndarray) -&gt; bool\n</code></pre> <p>Check if the matrix is positive.</p> <p>When all the entries in the matrix are larger than zero the matrix of interest is a positive matrix <sup>1</sup>.</p> <p>Note</p> <p>This function is different from <code>is_positive_definite</code>, <code>is_totally_positive</code> and <code>is_positive_semidefinite</code>.</p> <p>Examples:</p> <p>We expect a matrix full of 1s to be positive.</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import is_positive\n\ninput_mat = np.array([[1, 1, 1],[1, 1, 1],[1, 1, 1]])\n\nprint(is_positive(input_mat))\n</code></pre> <p>True</p> <p>Parameters:</p> <ul> <li> <code>input_mat</code>               (<code>ndarray</code>)           \u2013            <p>Matrix of interest.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Nonnegative matrix. link.</p> Source code in <code>toqito/matrix_props/is_positive.py</code> <pre><code>def is_positive(input_mat: np.ndarray) -&gt; bool:\n    r\"\"\"Check if the matrix is positive.\n\n    When all the entries in the matrix are larger than zero the matrix of interest is a\n    positive matrix [@WikiNonNegative].\n\n    !!! note\n        This function is different from [`is_positive_definite`][toqito.matrix_props.is_positive_definite],\n        [`is_totally_positive`][toqito.matrix_props.is_totally_positive] and\n        [`is_positive_semidefinite`][toqito.matrix_props.is_positive_semidefinite].\n\n    Examples:\n        We expect a matrix full of 1s to be positive.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import is_positive\n\n        input_mat = np.array([[1, 1, 1],[1, 1, 1],[1, 1, 1]])\n\n        print(is_positive(input_mat))\n        ```\n\n    Args:\n        input_mat: Matrix of interest.\n\n    \"\"\"\n    return bool(np.all(input_mat &gt; 0))\n</code></pre>"},{"location":"reference/toqito/matrix_props/is_positive_definite/","title":"is_positive_definite","text":""},{"location":"reference/toqito/matrix_props/is_positive_definite/#toqito.matrix_props.is_positive_definite","title":"is_positive_definite","text":"<p>Checks if the matrix is a positive definite matrix.</p>"},{"location":"reference/toqito/matrix_props/is_positive_definite/#toqito.matrix_props.is_positive_definite.is_positive_definite","title":"is_positive_definite","text":"<pre><code>is_positive_definite(mat: ndarray) -&gt; bool\n</code></pre> <p>Check if matrix is positive definite (PD) <sup>1</sup>.</p> <p>Examples:</p> <p>Consider the following matrix</p> \\[     A = \\begin{pmatrix}             2 &amp; -1 &amp; 0 \\\\             -1 &amp; 2 &amp; -1 \\\\             0 &amp; -1 &amp; 2         \\end{pmatrix} \\] <p>our function indicates that this is indeed a positive definite matrix.</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import is_positive_definite\n\nA = np.array([[2, -1, 0], [-1, 2, -1], [0, -1, 2]])\n\nprint(is_positive_definite(A))\n</code></pre> <p>True</p> <p>Alternatively, the following example matrix \\(B\\) defined as</p> \\[     B = \\begin{pmatrix}             -1 &amp; -1 \\\\             -1 &amp; -1         \\end{pmatrix} \\] <p>is not positive definite.</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import is_positive_definite\n\nB = np.array([[-1, -1], [-1, -1]])\n\nprint(is_positive_definite(B))\n</code></pre> <p>False</p> <p>See</p> <p><code>is_positive_semidefinite</code></p> <p>Parameters:</p> <ul> <li> <code>mat</code>               (<code>ndarray</code>)           \u2013            <p>Matrix to check.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Return <code>True</code> if matrix is positive definite, and <code>False</code> otherwise.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Definite matrix. link.</p> Source code in <code>toqito/matrix_props/is_positive_definite.py</code> <pre><code>def is_positive_definite(mat: np.ndarray) -&gt; bool:\n    r\"\"\"Check if matrix is positive definite (PD) [@WikiPosDef].\n\n    Examples:\n        Consider the following matrix\n\n        \\[\n            A = \\begin{pmatrix}\n                    2 &amp; -1 &amp; 0 \\\\\n                    -1 &amp; 2 &amp; -1 \\\\\n                    0 &amp; -1 &amp; 2\n                \\end{pmatrix}\n        \\]\n\n        our function indicates that this is indeed a positive definite matrix.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import is_positive_definite\n\n        A = np.array([[2, -1, 0], [-1, 2, -1], [0, -1, 2]])\n\n        print(is_positive_definite(A))\n        ```\n\n        Alternatively, the following example matrix \\(B\\) defined as\n\n        \\[\n            B = \\begin{pmatrix}\n                    -1 &amp; -1 \\\\\n                    -1 &amp; -1\n                \\end{pmatrix}\n        \\]\n\n        is not positive definite.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import is_positive_definite\n\n        B = np.array([[-1, -1], [-1, -1]])\n\n        print(is_positive_definite(B))\n        ```\n\n        !!! See Also\n            [`is_positive_semidefinite`][toqito.matrix_props.is_positive_semidefinite.is_positive_semidefinite]\n\n    Args:\n        mat: Matrix to check.\n\n    Returns:\n        Return `True` if matrix is positive definite, and `False` otherwise.\n\n    \"\"\"\n    if np.array_equal(mat, mat.conj().T):\n        try:\n            # Cholesky decomp requires that the matrix in question is\n            # positive-definite. It will throw an error if this is not the case\n            # that we catch here.\n            np.linalg.cholesky(mat)\n            return True\n        except np.linalg.LinAlgError:\n            return False\n    else:\n        return False\n</code></pre>"},{"location":"reference/toqito/matrix_props/is_positive_semidefinite/","title":"is_positive_semidefinite","text":""},{"location":"reference/toqito/matrix_props/is_positive_semidefinite/#toqito.matrix_props.is_positive_semidefinite","title":"is_positive_semidefinite","text":"<p>Checks if the matrix is a positive semidefinite matrix.</p>"},{"location":"reference/toqito/matrix_props/is_positive_semidefinite/#toqito.matrix_props.is_positive_semidefinite.is_positive_semidefinite","title":"is_positive_semidefinite","text":"<pre><code>is_positive_semidefinite(mat: ndarray, rtol: float = 1e-05, atol: float = 1e-08) -&gt; bool\n</code></pre> <p>Check if matrix is positive semidefinite (PSD) <sup>1</sup>.</p> <p>Examples:</p> <p>Consider the following matrix</p> \\[     A = \\begin{pmatrix}             1 &amp; -1 \\\\             -1 &amp; 1         \\end{pmatrix} \\] <p>our function indicates that this is indeed a positive semidefinite matrix.</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import is_positive_semidefinite\n\nA = np.array([[1, -1], [-1, 1]])\n\nprint(is_positive_semidefinite(A))\n</code></pre> <p>True</p> <p>Alternatively, the following example matrix \\(B\\) defined as</p> \\[     B = \\begin{pmatrix}             -1 &amp; -1 \\\\             -1 &amp; -1         \\end{pmatrix} \\] <p>is not positive semidefinite.</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import is_positive_semidefinite\n\nB = np.array([[-1, -1], [-1, -1]])\n\nprint(is_positive_semidefinite(B))\n</code></pre> <p>False</p> <p>Parameters:</p> <ul> <li> <code>mat</code>               (<code>ndarray</code>)           \u2013            <p>Matrix to check.</p> </li> <li> <code>rtol</code>               (<code>float</code>, default:                   <code>1e-05</code> )           \u2013            <p>The relative tolerance parameter (default 1e-05).</p> </li> <li> <code>atol</code>               (<code>float</code>, default:                   <code>1e-08</code> )           \u2013            <p>The absolute tolerance parameter (default 1e-08).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Return <code>True</code> if matrix is PSD, and <code>False</code> otherwise.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Definite matrix. link.</p> Source code in <code>toqito/matrix_props/is_positive_semidefinite.py</code> <pre><code>def is_positive_semidefinite(mat: np.ndarray, rtol: float = 1e-05, atol: float = 1e-08) -&gt; bool:\n    r\"\"\"Check if matrix is positive semidefinite (PSD) [@WikiPosDef].\n\n    Examples:\n        Consider the following matrix\n\n        \\[\n            A = \\begin{pmatrix}\n                    1 &amp; -1 \\\\\n                    -1 &amp; 1\n                \\end{pmatrix}\n        \\]\n\n        our function indicates that this is indeed a positive semidefinite matrix.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import is_positive_semidefinite\n\n        A = np.array([[1, -1], [-1, 1]])\n\n        print(is_positive_semidefinite(A))\n        ```\n\n        Alternatively, the following example matrix \\(B\\) defined as\n\n        \\[\n            B = \\begin{pmatrix}\n                    -1 &amp; -1 \\\\\n                    -1 &amp; -1\n                \\end{pmatrix}\n        \\]\n\n        is not positive semidefinite.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import is_positive_semidefinite\n\n        B = np.array([[-1, -1], [-1, -1]])\n\n        print(is_positive_semidefinite(B))\n        ```\n\n    Args:\n        mat: Matrix to check.\n        rtol: The relative tolerance parameter (default 1e-05).\n        atol: The absolute tolerance parameter (default 1e-08).\n\n    Returns:\n        Return `True` if matrix is PSD, and `False` otherwise.\n\n    \"\"\"\n    if not is_hermitian(mat, rtol, atol):\n        return False\n    evals, _ = np.linalg.eigh(mat)\n    return all(x &gt;= -abs(atol) for x in evals)\n</code></pre>"},{"location":"reference/toqito/matrix_props/is_projection/","title":"is_projection","text":""},{"location":"reference/toqito/matrix_props/is_projection/#toqito.matrix_props.is_projection","title":"is_projection","text":"<p>Checks if the matrix is a projection matrix.</p>"},{"location":"reference/toqito/matrix_props/is_projection/#toqito.matrix_props.is_projection.is_projection","title":"is_projection","text":"<pre><code>is_projection(mat: ndarray, rtol: float = 1e-05, atol: float = 1e-08) -&gt; bool\n</code></pre> <p>Check if matrix is a projection matrix <sup>1</sup>.</p> <p>A matrix is a projection matrix if it is positive semidefinite (PSD) and if</p> \\[     \\begin{equation}         X^2 = X     \\end{equation} \\] <p>where \\(X\\) is the matrix in question.</p> <p>Examples:</p> <p>Consider the following matrix</p> \\[     A = \\begin{pmatrix}             0 &amp; 1 \\\\             0 &amp; 1         \\end{pmatrix} \\] <p>our function indicates that this is indeed a projection matrix.</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import is_projection\n\nA = np.array([[0, 1], [0, 1]])\n\nprint(is_projection(A))\n</code></pre> <p>True</p> <p>Alternatively, the following example matrix \\(B\\) defined as</p> \\[     B = \\begin{pmatrix}             -1 &amp; -1 \\\\             -1 &amp; -1         \\end{pmatrix} \\] <p>is not positive definite.</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import is_projection\n\nB = np.array([[-1, -1], [-1, -1]])\n\nprint(is_projection(B))\n</code></pre> <p>False</p> <p>Parameters:</p> <ul> <li> <code>mat</code>               (<code>ndarray</code>)           \u2013            <p>Matrix to check.</p> </li> <li> <code>rtol</code>               (<code>float</code>, default:                   <code>1e-05</code> )           \u2013            <p>The relative tolerance parameter (default 1e-05).</p> </li> <li> <code>atol</code>               (<code>float</code>, default:                   <code>1e-08</code> )           \u2013            <p>The absolute tolerance parameter (default 1e-08).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Return <code>True</code> if matrix is a projection matrix, and <code>False</code> otherwise.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Projection matrix. link.</p> Source code in <code>toqito/matrix_props/is_projection.py</code> <pre><code>def is_projection(mat: np.ndarray, rtol: float = 1e-05, atol: float = 1e-08) -&gt; bool:\n    r\"\"\"Check if matrix is a projection matrix [@WikiProjMat].\n\n    A matrix is a projection matrix if it is positive semidefinite (PSD) and if\n\n    \\[\n        \\begin{equation}\n            X^2 = X\n        \\end{equation}\n    \\]\n\n    where \\(X\\) is the matrix in question.\n\n    Examples:\n        Consider the following matrix\n\n        \\[\n            A = \\begin{pmatrix}\n                    0 &amp; 1 \\\\\n                    0 &amp; 1\n                \\end{pmatrix}\n        \\]\n\n        our function indicates that this is indeed a projection matrix.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import is_projection\n\n        A = np.array([[0, 1], [0, 1]])\n\n        print(is_projection(A))\n        ```\n\n        Alternatively, the following example matrix \\(B\\) defined as\n\n        \\[\n            B = \\begin{pmatrix}\n                    -1 &amp; -1 \\\\\n                    -1 &amp; -1\n                \\end{pmatrix}\n        \\]\n\n        is not positive definite.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import is_projection\n\n        B = np.array([[-1, -1], [-1, -1]])\n\n        print(is_projection(B))\n        ```\n\n    Args:\n        mat: Matrix to check.\n        rtol: The relative tolerance parameter (default 1e-05).\n        atol: The absolute tolerance parameter (default 1e-08).\n\n    Returns:\n        Return `True` if matrix is a projection matrix, and `False` otherwise.\n\n    \"\"\"\n    if not is_square(mat):\n        return False\n    return np.allclose(np.linalg.matrix_power(mat, 2), mat, rtol=rtol, atol=atol)\n</code></pre>"},{"location":"reference/toqito/matrix_props/is_pseudo_hermitian/","title":"is_pseudo_hermitian","text":""},{"location":"reference/toqito/matrix_props/is_pseudo_hermitian/#toqito.matrix_props.is_pseudo_hermitian","title":"is_pseudo_hermitian","text":"<p>Checks if matrix is pseudo hermitian with respect to given signature.</p>"},{"location":"reference/toqito/matrix_props/is_pseudo_hermitian/#toqito.matrix_props.is_pseudo_hermitian.is_pseudo_hermitian","title":"is_pseudo_hermitian","text":"<pre><code>is_pseudo_hermitian(mat: ndarray, signature: ndarray, rtol: float = 1e-05, atol: float = 1e-08) -&gt; bool\n</code></pre> <p>Check if a matrix is pseudo-Hermitian.</p> <p>A matrix \\(H\\) is pseudo-Hermitian with respect to a given signature matrix \\(\\eta\\) if it satisfies:</p> \\[     \\eta H \\eta^{-1} = H^{\\dagger}, \\] <p>where:</p> <ul> <li>\\(H^{\\dagger}\\) is the conjugate transpose (Hermitian transpose) of \\(H\\),</li> <li>\\(\\eta\\) is a Hermitian, invertible matrix.</li> </ul> <p>Examples:</p> <p>Consider the following matrix:</p> \\[     H = \\begin{pmatrix}         1 &amp; 1+i \\\\         -1+i &amp; -1     \\end{pmatrix} \\] <p>with the signature matrix:</p> \\[     \\eta = \\begin{pmatrix}         1 &amp; 0 \\\\         0 &amp; -1     \\end{pmatrix} \\] <p>Our function confirms that \\(H\\) is pseudo-Hermitian:</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import is_pseudo_hermitian\n\nH = np.array([[1, 1+1j], [-1+1j, -1]])\neta = np.array([[1, 0], [0, -1]])\n\nprint(is_pseudo_hermitian(H, eta))\n</code></pre> <p>True</p> <p>However, the following matrix \\(A\\)</p> \\[     A = \\begin{pmatrix}         1 &amp; i \\\\         -i &amp; 1     \\end{pmatrix} \\] <p>is not pseudo-Hermitian with respect to the same signature matrix.</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import is_pseudo_hermitian\neta = np.array([[1, 0], [0, -1]])\nA = np.array([[1, 1j], [-1j, 1]])\n\nprint(is_pseudo_hermitian(A, eta))\n</code></pre> <p>False</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>signature</code> is not Hermitian or not invertible.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>mat</code>               (<code>ndarray</code>)           \u2013            <p>The matrix to check.</p> </li> <li> <code>signature</code>               (<code>ndarray</code>)           \u2013            <p>The signature matrix \\(\\eta\\), which must be Hermitian and invertible.</p> </li> <li> <code>rtol</code>               (<code>float</code>, default:                   <code>1e-05</code> )           \u2013            <p>The relative tolerance parameter (default 1e-05).</p> </li> <li> <code>atol</code>               (<code>float</code>, default:                   <code>1e-08</code> )           \u2013            <p>The absolute tolerance parameter (default 1e-08).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Return <code>True</code> if the matrix is pseudo-Hermitian, and <code>False</code> otherwise.</p> </li> </ul> Source code in <code>toqito/matrix_props/is_pseudo_hermitian.py</code> <pre><code>def is_pseudo_hermitian(mat: np.ndarray, signature: np.ndarray, rtol: float = 1e-05, atol: float = 1e-08) -&gt; bool:\n    r\"\"\"Check if a matrix is pseudo-Hermitian.\n\n    A matrix \\(H\\) is pseudo-Hermitian with respect to a given signature matrix \\(\\eta\\) if it satisfies:\n\n    \\[\n        \\eta H \\eta^{-1} = H^{\\dagger},\n    \\]\n\n    where:\n\n    - \\(H^{\\dagger}\\) is the conjugate transpose (Hermitian transpose) of \\(H\\),\n    - \\(\\eta\\) is a Hermitian, invertible matrix.\n\n    Examples:\n        Consider the following matrix:\n\n        \\[\n            H = \\begin{pmatrix}\n                1 &amp; 1+i \\\\\n                -1+i &amp; -1\n            \\end{pmatrix}\n        \\]\n\n        with the signature matrix:\n\n        \\[\n            \\eta = \\begin{pmatrix}\n                1 &amp; 0 \\\\\n                0 &amp; -1\n            \\end{pmatrix}\n        \\]\n\n        Our function confirms that \\(H\\) is pseudo-Hermitian:\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import is_pseudo_hermitian\n\n        H = np.array([[1, 1+1j], [-1+1j, -1]])\n        eta = np.array([[1, 0], [0, -1]])\n\n        print(is_pseudo_hermitian(H, eta))\n        ```\n\n        However, the following matrix \\(A\\)\n\n        \\[\n            A = \\begin{pmatrix}\n                1 &amp; i \\\\\n                -i &amp; 1\n            \\end{pmatrix}\n        \\]\n\n        is not pseudo-Hermitian with respect to the same signature matrix.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import is_pseudo_hermitian\n        eta = np.array([[1, 0], [0, -1]])\n        A = np.array([[1, 1j], [-1j, 1]])\n\n        print(is_pseudo_hermitian(A, eta))\n        ```\n\n    Raises:\n        ValueError: If `signature` is not Hermitian or not invertible.\n\n    Args:\n        mat: The matrix to check.\n        signature: The signature matrix \\(\\eta\\), which must be Hermitian and invertible.\n        rtol: The relative tolerance parameter (default 1e-05).\n        atol: The absolute tolerance parameter (default 1e-08).\n\n    Returns:\n        Return `True` if the matrix is pseudo-Hermitian, and `False` otherwise.\n\n    \"\"\"\n    if not is_hermitian(signature):\n        raise ValueError(\"Signature not hermitian matrix.\")\n\n    if np.linalg.matrix_rank(signature) != signature.shape[0]:\n        raise ValueError(\"Signature is not invertible.\")\n\n    if not is_square(mat) or not has_same_dimension([mat, signature]):\n        return False\n\n    eta_H_inv_eta = signature @ mat @ np.linalg.inv(signature)\n    return np.allclose(eta_H_inv_eta, mat.conj().T, rtol=rtol, atol=atol)\n</code></pre>"},{"location":"reference/toqito/matrix_props/is_pseudo_unitary/","title":"is_pseudo_unitary","text":""},{"location":"reference/toqito/matrix_props/is_pseudo_unitary/#toqito.matrix_props.is_pseudo_unitary","title":"is_pseudo_unitary","text":"<p>Checks if matrix is pseudo unitary.</p>"},{"location":"reference/toqito/matrix_props/is_pseudo_unitary/#toqito.matrix_props.is_pseudo_unitary.is_pseudo_unitary","title":"is_pseudo_unitary","text":"<pre><code>is_pseudo_unitary(mat: ndarray, p: int, q: int, rtol: float = 1e-05, atol: float = 1e-08) -&gt; bool\n</code></pre> <p>Check if a matrix is pseudo-unitary.</p> <p>A matrix A of size (p+q)x(p+q) is pseudo-unitary with respect to a given signature matrix J if it satisfies</p> \\[     A^* J A = J, \\] <p>where:</p> <ul> <li>\\(A^*\\) is the conjugate transpose (Hermitian transpose) of \\(A\\),</li> <li>\\(J\\) is a diagonal matrix with first \\(p\\) diagonal entries equal to 1 and next \\(q\\)     diagonal entries equal to -1</li> </ul> <p>Examples:</p> <p>Consider the following matrix:</p> \\[     A = \\begin{pmatrix}         cosh(1) &amp; sinh(1) \\\\         sinh(1) &amp; cosh(1)     \\end{pmatrix} \\] <p>with the signature matrix:</p> \\[     J = \\begin{pmatrix}         1 &amp; 0 \\\\         0 &amp; -1     \\end{pmatrix} \\] <p>Our function confirms that \\(A\\) is pseudo-unitary.</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import is_pseudo_unitary\n\nA = np.array([[np.cosh(1), np.sinh(1)], [np.sinh(1), np.cosh(1)]])\n\nprint(is_pseudo_unitary(A, p=1, q=1))\n</code></pre> <p>True</p> <p>However, the following matrix \\(B\\)</p> \\[     B = \\begin{pmatrix}         1 &amp; 0 \\\\         1 &amp; 1     \\end{pmatrix} \\] <p>is not pseudo-unitary with respect to the same signature matrix:</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import is_pseudo_unitary\n\nB = np.array([[1, 0], [1, 1]])\n\nprint(is_pseudo_unitary(B, p=1, q=1))\n</code></pre> <p>False</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>When p &lt; 0 or q &lt; 0.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>mat</code>               (<code>ndarray</code>)           \u2013            <p>The matrix to check.</p> </li> <li> <code>p</code>               (<code>int</code>)           \u2013            <p>Number of positive entries in the signature matrix.</p> </li> <li> <code>q</code>               (<code>int</code>)           \u2013            <p>Number of negative entries in the signature matrix.</p> </li> <li> <code>rtol</code>               (<code>float</code>, default:                   <code>1e-05</code> )           \u2013            <p>The relative tolerance parameter (default 1e-05).</p> </li> <li> <code>atol</code>               (<code>float</code>, default:                   <code>1e-08</code> )           \u2013            <p>The absolute tolerance parameter (default 1e-08).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Return</code> (              <code>bool</code> )          \u2013            <p>code:True if the matrix is pseudo-unitary, and :code:False otherwise.</p> </li> </ul> Source code in <code>toqito/matrix_props/is_pseudo_unitary.py</code> <pre><code>def is_pseudo_unitary(mat: np.ndarray, p: int, q: int, rtol: float = 1e-05, atol: float = 1e-08) -&gt; bool:\n    r\"\"\"Check if a matrix is pseudo-unitary.\n\n    A matrix A of size (p+q)x(p+q) is pseudo-unitary with respect to a given signature matrix J if it satisfies\n\n    \\[\n        A^* J A = J,\n    \\]\n\n    where:\n\n    - \\(A^*\\) is the conjugate transpose (Hermitian transpose) of \\(A\\),\n    - \\(J\\) is a diagonal matrix with first \\(p\\) diagonal entries equal to 1 and next \\(q\\)\n        diagonal entries equal to -1\n\n    Examples:\n        Consider the following matrix:\n\n        \\[\n            A = \\begin{pmatrix}\n                cosh(1) &amp; sinh(1) \\\\\n                sinh(1) &amp; cosh(1)\n            \\end{pmatrix}\n        \\]\n\n        with the signature matrix:\n\n        \\[\n            J = \\begin{pmatrix}\n                1 &amp; 0 \\\\\n                0 &amp; -1\n            \\end{pmatrix}\n        \\]\n\n        Our function confirms that \\(A\\) is pseudo-unitary.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import is_pseudo_unitary\n\n        A = np.array([[np.cosh(1), np.sinh(1)], [np.sinh(1), np.cosh(1)]])\n\n        print(is_pseudo_unitary(A, p=1, q=1))\n        ```\n\n\n        However, the following matrix \\(B\\)\n\n        \\[\n            B = \\begin{pmatrix}\n                1 &amp; 0 \\\\\n                1 &amp; 1\n            \\end{pmatrix}\n        \\]\n\n        is not pseudo-unitary with respect to the same signature matrix:\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import is_pseudo_unitary\n\n        B = np.array([[1, 0], [1, 1]])\n\n        print(is_pseudo_unitary(B, p=1, q=1))\n        ```\n\n    Raises:\n        ValueError: When p &lt; 0 or q &lt; 0.\n\n    Args:\n        mat: The matrix to check.\n        p: Number of positive entries in the signature matrix.\n        q: Number of negative entries in the signature matrix.\n        rtol: The relative tolerance parameter (default 1e-05).\n        atol: The absolute tolerance parameter (default 1e-08).\n\n    Returns:\n        Return :code:True if the matrix is pseudo-unitary, and :code:False otherwise.\n\n    \"\"\"\n    if p &lt; 0 or q &lt; 0:\n        raise ValueError(\"p and q must be non-negative\")\n\n    if not is_square(mat):\n        return False\n\n    if p + q != mat.shape[0]:\n        return False\n\n    signature = np.diag(np.hstack((np.ones(p), -np.ones(q))))\n    ac_j_a_mat = mat.conj().T @ signature @ mat\n\n    return bool(np.allclose(ac_j_a_mat, signature, rtol=rtol, atol=atol))\n</code></pre>"},{"location":"reference/toqito/matrix_props/is_rank_one/","title":"is_rank_one","text":""},{"location":"reference/toqito/matrix_props/is_rank_one/#toqito.matrix_props.is_rank_one","title":"is_rank_one","text":"<p>Checks if a matrix has rank one.</p>"},{"location":"reference/toqito/matrix_props/is_rank_one/#toqito.matrix_props.is_rank_one.is_rank_one","title":"is_rank_one","text":"<pre><code>is_rank_one(mat: ndarray, tol: float = 1e-08) -&gt; bool\n</code></pre> <p>Determine whether the given matrix has rank one <sup>1</sup>.</p> <p>The function evaluates the singular values (equivalently, eigenvalues for Hermitian matrices) and counts how many are greater than the provided tolerance.</p> <p>Examples:</p> <p>Consider the Bell state density matrix \\(\\rho = \\ket{\\Phi^+}\\bra{\\Phi^+}\\). This matrix has rank one.</p> <pre><code>from toqito.matrix_props import is_rank_one\nfrom toqito.states import bell\n\nrho = bell(0) @ bell(0).conj().T\nprint(is_rank_one(rho))\n</code></pre> <p>True</p> <p>On the other hand, the maximally mixed state is not rank one.</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import is_rank_one\n\nmaximally_mixed = np.eye(2) / 2\nprint(is_rank_one(maximally_mixed))\n</code></pre> <p>False</p> <p>Parameters:</p> <ul> <li> <code>mat</code>               (<code>ndarray</code>)           \u2013            <p>Matrix to test.</p> </li> <li> <code>tol</code>               (<code>float</code>, default:                   <code>1e-08</code> )           \u2013            <p>Numerical tolerance used when distinguishing non-zero singular values.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if the matrix has rank at most one, <code>False</code> otherwise.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Rank (linear algebra). link.</p> Source code in <code>toqito/matrix_props/is_rank_one.py</code> <pre><code>def is_rank_one(mat: np.ndarray, tol: float = 1e-08) -&gt; bool:\n    r\"\"\"Determine whether the given matrix has rank one [@WikiMatrixRank].\n\n    The function evaluates the singular values (equivalently, eigenvalues for Hermitian matrices)\n    and counts how many are greater than the provided tolerance.\n\n    Examples:\n        Consider the Bell state density matrix \\(\\rho = \\ket{\\Phi^+}\\bra{\\Phi^+}\\). This matrix\n        has rank one.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.matrix_props import is_rank_one\n        from toqito.states import bell\n\n        rho = bell(0) @ bell(0).conj().T\n        print(is_rank_one(rho))\n        ```\n\n        On the other hand, the maximally mixed state is not rank one.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import is_rank_one\n\n        maximally_mixed = np.eye(2) / 2\n        print(is_rank_one(maximally_mixed))\n        ```\n\n    Args:\n        mat: Matrix to test.\n        tol: Numerical tolerance used when distinguishing non-zero singular values.\n\n    Returns:\n        `True` if the matrix has rank at most one, `False` otherwise.\n\n    \"\"\"\n    singular_values = np.linalg.svd(mat, compute_uv=False)\n    return np.count_nonzero(singular_values &gt; tol) &lt;= 1\n</code></pre>"},{"location":"reference/toqito/matrix_props/is_square/","title":"is_square","text":""},{"location":"reference/toqito/matrix_props/is_square/#toqito.matrix_props.is_square","title":"is_square","text":"<p>Checks if the matrix is a square matrix.</p>"},{"location":"reference/toqito/matrix_props/is_square/#toqito.matrix_props.is_square.is_square","title":"is_square","text":"<pre><code>is_square(mat: ndarray) -&gt; bool\n</code></pre> <p>Determine if a matrix is square <sup>1</sup>.</p> <p>A matrix is square if the dimensions of the rows and columns are equivalent.</p> <p>Examples:</p> <p>Consider the following matrix</p> \\[     A = \\begin{pmatrix}             1 &amp; 2 &amp; 3 \\\\             4 &amp; 5 &amp; 6 \\\\             7 &amp; 8 &amp; 9         \\end{pmatrix} \\] <p>our function indicates that this is indeed a square matrix.</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import is_square\n\nA = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n\nprint(is_square(A))\n</code></pre> <p>True</p> <p>Alternatively, the following example matrix \\(B\\) defined as</p> \\[     B = \\begin{pmatrix}             1 &amp; 2 &amp; 3 \\\\             4 &amp; 5 &amp; 6         \\end{pmatrix} \\] <p>is not square.</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import is_square\n\nB = np.array([[1, 2, 3], [4, 5, 6]])\n\nprint(is_square(B))\n</code></pre> <p>False</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If variable is not a matrix.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>mat</code>               (<code>ndarray</code>)           \u2013            <p>The matrix to check.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Returns <code>True</code> if the matrix is square and <code>False</code> otherwise.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Square matrix. link.</p> Source code in <code>toqito/matrix_props/is_square.py</code> <pre><code>def is_square(mat: np.ndarray) -&gt; bool:\n    r\"\"\"Determine if a matrix is square [@WikiSqMat].\n\n    A matrix is square if the dimensions of the rows and columns are equivalent.\n\n    Examples:\n        Consider the following matrix\n\n        \\[\n            A = \\begin{pmatrix}\n                    1 &amp; 2 &amp; 3 \\\\\n                    4 &amp; 5 &amp; 6 \\\\\n                    7 &amp; 8 &amp; 9\n                \\end{pmatrix}\n        \\]\n\n        our function indicates that this is indeed a square matrix.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import is_square\n\n        A = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n\n        print(is_square(A))\n        ```\n\n        Alternatively, the following example matrix \\(B\\) defined as\n\n        \\[\n            B = \\begin{pmatrix}\n                    1 &amp; 2 &amp; 3 \\\\\n                    4 &amp; 5 &amp; 6\n                \\end{pmatrix}\n        \\]\n\n        is not square.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import is_square\n\n        B = np.array([[1, 2, 3], [4, 5, 6]])\n\n        print(is_square(B))\n        ```\n\n    Raises:\n        ValueError: If variable is not a matrix.\n\n    Args:\n        mat: The matrix to check.\n\n    Returns:\n        Returns `True` if the matrix is square and `False` otherwise.\n\n    \"\"\"\n    if len(mat.shape) != 2:\n        raise ValueError(\"The variable is not a matrix.\")\n    return mat.shape[0] == mat.shape[1]\n</code></pre>"},{"location":"reference/toqito/matrix_props/is_stochastic/","title":"is_stochastic","text":""},{"location":"reference/toqito/matrix_props/is_stochastic/#toqito.matrix_props.is_stochastic","title":"is_stochastic","text":"<p>Checks if the matrix is stochastic.</p>"},{"location":"reference/toqito/matrix_props/is_stochastic/#toqito.matrix_props.is_stochastic.is_stochastic","title":"is_stochastic","text":"<pre><code>is_stochastic(mat: ndarray, mat_type: str) -&gt; bool\n</code></pre> <p>Verify matrix is doubly, right or left stochastic.</p> <p>When the nonnegative elements in a row of a square matrix sum up to 1, the matrix is right stochastic and if the columns sum up to 1, the matrix is left stochastic <sup>1</sup>.</p> <p>When a matrix is right and left stochastic, it is a doubly stochastic matrix <sup>2</sup> .</p> <p>See</p> <p>[<code>is_doubly_stochastic()</code>][toqito.matrix_props.is_doubly_stochastic]</p> <p>Examples:</p> <p>The elements of an identity matrix and a Pauli-X matrix are nonnegative such that the rows and columns sum up to 1. We expect these matrices to be left and right stochastic. The same cannot be said about a Pauli-Z or a Pauli-Y matrix.</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import is_stochastic\n\nprint(is_stochastic(np.eye(5), \"right\"))\nprint(is_stochastic(np.eye(5), \"left\"))\nprint(is_stochastic(np.eye(5), \"doubly\"))\n</code></pre> <p>True True True</p> <pre><code>from toqito.matrices import pauli\nfrom toqito.matrix_props import is_stochastic\n\nprint(is_stochastic(pauli(\"X\"), \"left\"))\nprint(is_stochastic(pauli(\"X\"), \"right\"))\nprint(is_stochastic(pauli(\"X\"), \"doubly\"))\n</code></pre> <p>True True True</p> <p><pre><code>from toqito.matrices import pauli\nfrom toqito.matrix_props import is_stochastic\n\nprint(is_stochastic(pauli(\"Z\"), \"right\"))\nprint(is_stochastic(pauli(\"Z\"), \"left\"))\nprint(is_stochastic(pauli(\"Z\"), \"doubly\"))\n</code></pre> <p>False False False</p> <code>mat_type</code></p> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If something other than <code>\"doubly\"</code>, <code>\"left\"</code> or <code>\"right\"</code> is used for</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>mat</code>               (<code>ndarray</code>)           \u2013            <p>Matrix of interest</p> </li> <li> <code>mat_type</code>               (<code>str</code>)           \u2013            <p>Type of stochastic matrix. <code>\"left\"</code> for left stochastic matrix and <code>\"right\"</code> for right stochastic</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Returns <code>True</code> if the matrix is doubly, right or left stochastic, <code>False</code> otherwise.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Stochastic Matrix. link. <sup>2</sup> Wikipedia. Doubly Stochastic Matrix. link.</p> Source code in <code>toqito/matrix_props/is_stochastic.py</code> <pre><code>def is_stochastic(mat: np.ndarray, mat_type: str) -&gt; bool:\n    r\"\"\"Verify matrix is doubly, right or left stochastic.\n\n    When the nonnegative elements in a row of a square matrix sum up to 1, the matrix is right stochastic and if the\n    columns sum up to 1, the matrix is left stochastic [@WikiStochasticMatrix].\n\n    When a matrix is right and left stochastic, it is a doubly stochastic matrix [@WikiDoublyStochasticMatrix]\n    .\n\n    !!! See Also\n        [`is_doubly_stochastic()`][toqito.matrix_props.is_doubly_stochastic]\n\n    Examples:\n        The elements of an identity matrix and a Pauli-X matrix are nonnegative such that the rows and columns\n        sum up to 1.\n        We expect these matrices to be left and right stochastic. The same cannot be said about a Pauli-Z or a Pauli-Y\n        matrix.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import is_stochastic\n\n        print(is_stochastic(np.eye(5), \"right\"))\n        print(is_stochastic(np.eye(5), \"left\"))\n        print(is_stochastic(np.eye(5), \"doubly\"))\n        ```\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.matrices import pauli\n        from toqito.matrix_props import is_stochastic\n\n        print(is_stochastic(pauli(\"X\"), \"left\"))\n        print(is_stochastic(pauli(\"X\"), \"right\"))\n        print(is_stochastic(pauli(\"X\"), \"doubly\"))\n        ```\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.matrices import pauli\n        from toqito.matrix_props import is_stochastic\n\n        print(is_stochastic(pauli(\"Z\"), \"right\"))\n        print(is_stochastic(pauli(\"Z\"), \"left\"))\n        print(is_stochastic(pauli(\"Z\"), \"doubly\"))\n        ```\n                          `mat_type`\n\n    Raises:\n        TypeError: If something other than `\"doubly\"`, `\"left\"` or `\"right\"` is used for\n\n    Args:\n        mat: Matrix of interest\n        mat_type: Type of stochastic matrix. `\"left\"` for left stochastic matrix and `\"right\"` for right stochastic\n        matrix and `\"doubly\"` for a doubly stochastic matrix.\n\n    Returns:\n        Returns `True` if the matrix is doubly, right or left stochastic, `False` otherwise.\n\n    \"\"\"\n    if mat_type not in {\"left\", \"right\", \"doubly\"}:\n        raise TypeError(\"Allowed stochastic matrix types are: left, right, and doubly.\")\n\n    if not (is_square(mat) and is_nonnegative(mat)):\n        return False\n\n    checks = []\n\n    if mat_type in {\"left\", \"doubly\"}:\n        col_sums = np.sum(mat, axis=0)\n        checks.append(np.allclose(col_sums, 1.0))\n\n    if mat_type in {\"right\", \"doubly\"}:\n        row_sums = np.sum(mat, axis=1)\n        checks.append(np.allclose(row_sums, 1.0))\n\n    return all(checks)\n</code></pre>"},{"location":"reference/toqito/matrix_props/is_symmetric/","title":"is_symmetric","text":""},{"location":"reference/toqito/matrix_props/is_symmetric/#toqito.matrix_props.is_symmetric","title":"is_symmetric","text":"<p>Checks if the matrix is a symmetric matrix.</p>"},{"location":"reference/toqito/matrix_props/is_symmetric/#toqito.matrix_props.is_symmetric.is_symmetric","title":"is_symmetric","text":"<pre><code>is_symmetric(mat: ndarray, rtol: float = 1e-05, atol: float = 1e-08) -&gt; bool\n</code></pre> <p>Determine if a matrix is symmetric <sup>1</sup>.</p> <p>The following 3x3 matrix is an example of a symmetric matrix:</p> \\[     \\begin{pmatrix}         1 &amp; 7 &amp; 3 \\\\         7 &amp; 4 &amp; -5 \\\\         3 &amp;-5 &amp; 6     \\end{pmatrix} \\] <p>Examples:</p> <p>Consider the following matrix</p> \\[     A = \\begin{pmatrix}             1 &amp; 7 &amp; 3 \\\\             7 &amp; 4 &amp; -5 \\\\             3 &amp; -5 &amp; 6         \\end{pmatrix} \\] <p>our function indicates that this is indeed a symmetric matrix.</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import is_symmetric\n\nA = np.array([[1, 7, 3], [7, 4, -5], [3, -5, 6]])\n\nprint(is_symmetric(A))\n</code></pre> <p>True</p> <p>Alternatively, the following example matrix \\(B\\) defined as</p> \\[     B = \\begin{pmatrix}             1 &amp; 2 \\\\             4 &amp; 5         \\end{pmatrix} \\] <p>is not symmetric.</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import is_symmetric\n\nB = np.array([[1, 2], [3, 4]])\n\nprint(is_symmetric(B))\n</code></pre> <p>False</p> <p>Parameters:</p> <ul> <li> <code>mat</code>               (<code>ndarray</code>)           \u2013            <p>The matrix to check.</p> </li> <li> <code>rtol</code>               (<code>float</code>, default:                   <code>1e-05</code> )           \u2013            <p>The relative tolerance parameter (default 1e-05).</p> </li> <li> <code>atol</code>               (<code>float</code>, default:                   <code>1e-08</code> )           \u2013            <p>The absolute tolerance parameter (default 1e-08).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Returns <code>True</code> if the matrix is symmetric and <code>False</code> otherwise.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Symmetric matrix. link.</p> Source code in <code>toqito/matrix_props/is_symmetric.py</code> <pre><code>def is_symmetric(mat: np.ndarray, rtol: float = 1e-05, atol: float = 1e-08) -&gt; bool:\n    r\"\"\"Determine if a matrix is symmetric [@WikiSymMat].\n\n    The following 3x3 matrix is an example of a symmetric matrix:\n\n    \\[\n        \\begin{pmatrix}\n            1 &amp; 7 &amp; 3 \\\\\n            7 &amp; 4 &amp; -5 \\\\\n            3 &amp;-5 &amp; 6\n        \\end{pmatrix}\n    \\]\n\n    Examples:\n        Consider the following matrix\n\n        \\[\n            A = \\begin{pmatrix}\n                    1 &amp; 7 &amp; 3 \\\\\n                    7 &amp; 4 &amp; -5 \\\\\n                    3 &amp; -5 &amp; 6\n                \\end{pmatrix}\n        \\]\n\n        our function indicates that this is indeed a symmetric matrix.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import is_symmetric\n\n        A = np.array([[1, 7, 3], [7, 4, -5], [3, -5, 6]])\n\n        print(is_symmetric(A))\n        ```\n\n        Alternatively, the following example matrix \\(B\\) defined as\n\n        \\[\n            B = \\begin{pmatrix}\n                    1 &amp; 2 \\\\\n                    4 &amp; 5\n                \\end{pmatrix}\n        \\]\n\n        is not symmetric.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import is_symmetric\n\n        B = np.array([[1, 2], [3, 4]])\n\n        print(is_symmetric(B))\n        ```\n\n    Args:\n        mat: The matrix to check.\n        rtol: The relative tolerance parameter (default 1e-05).\n        atol: The absolute tolerance parameter (default 1e-08).\n\n    Returns:\n        Returns `True` if the matrix is symmetric and `False` otherwise.\n\n    \"\"\"\n    if not is_square(mat):\n        return False\n    return np.allclose(mat, mat.T, rtol=rtol, atol=atol)\n</code></pre>"},{"location":"reference/toqito/matrix_props/is_totally_positive/","title":"is_totally_positive","text":""},{"location":"reference/toqito/matrix_props/is_totally_positive/#toqito.matrix_props.is_totally_positive","title":"is_totally_positive","text":"<p>Checks if the matrix is totally positive.</p>"},{"location":"reference/toqito/matrix_props/is_totally_positive/#toqito.matrix_props.is_totally_positive.is_totally_positive","title":"is_totally_positive","text":"<pre><code>is_totally_positive(mat: ndarray, tol: float = 1e-06, sub_sizes: list | None = None)\n</code></pre> <p>Determine whether a matrix is totally positive. <sup>1</sup>.</p> <p>A totally positive matrix is a square matrix where all the minors are positive. Equivalently, the determinant of every square submatrix is a positive number.</p> <p>Examples:</p> <p>Consider the matrix</p> \\[     X = \\begin{pmatrix}         1 &amp; 2 \\\\         3 &amp; 4     \\end{pmatrix} \\] <p>To determine if this matrix is totally positive, we need to check the positivity of all of its minors. The 1x1 minors are simply the individual entries of the matrix. For \\(X\\), these are</p> \\[     \\begin{equation}         \\begin{aligned}             X_{1,1} &amp;= 1 \\\\             X_{1,2} &amp;= 2 \\\\             X_{2,1} &amp;= 3 \\\\             X_{2,2} &amp;= 4 \\\\         \\end{aligned}     \\end{equation} \\] <p>Each of these entries is positive. There is only one 2x2 minor in this case, which is the determinant of the entire matrix \\(X\\). The determinant of \\(X\\) is calculated as:</p> \\[     \\text{det}(X) = 1 \\times 4 - 2 \\times 3 = 4 - 6 = 2 \\] <p>Our function indicates that this matrix is indeed totally positive.</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import is_totally_positive\n\nA = np.array([[1, 2], [3, 4]])\n\nprint(is_totally_positive(A))\n</code></pre> <p>False</p> <p>However, the following example matrix \\(B\\) defined as</p> \\[     B = \\begin{pmatrix}             1 &amp; 2 \\\\             3 &amp; -4         \\end{pmatrix} \\] <p>is not totally positive. The 2x2 minor of \\(B\\) is the determinant of the entire matrix \\(B\\). The determinant of \\(B\\) is calculated as:</p> \\[     \\text{det}(B) = 1 \\times -4 - 2 \\times 3 = -4 - 6 = -10 \\] <p>Since the determinant is negative, \\(B\\) is not totally positive.</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import is_totally_positive\n\nB = np.array([[1, 2], [3, -4]])\n\nprint(is_totally_positive(B))\n</code></pre> <p>False</p> <p>Parameters:</p> <ul> <li> <code>mat</code>               (<code>ndarray</code>)           \u2013            <p>Matrix to check.</p> </li> <li> <code>tol</code>               (<code>float</code>, default:                   <code>1e-06</code> )           \u2013            <p>The absolute tolerance parameter (default 1e-06).</p> </li> <li> <code>sub_sizes</code>               (<code>list | None</code>, default:                   <code>None</code> )           \u2013            <p>List of sizes of submatrices to consider. Default is all sizes up to <code>min(mat.shape)</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>Return <code>True</code> if matrix is totally positive, and <code>False</code> otherwise.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Totally positive matrix. link.</p> Source code in <code>toqito/matrix_props/is_totally_positive.py</code> <pre><code>def is_totally_positive(mat: np.ndarray, tol: float = 1e-6, sub_sizes: list | None = None):\n    r\"\"\"Determine whether a matrix is totally positive. [@WikiTotPosMat].\n\n    A totally positive matrix is a square matrix where all the minors are positive. Equivalently, the determinant of\n    every square submatrix is a positive number.\n\n    Examples:\n        Consider the matrix\n\n        \\[\n            X = \\begin{pmatrix}\n                1 &amp; 2 \\\\\n                3 &amp; 4\n            \\end{pmatrix}\n        \\]\n\n        To determine if this matrix is totally positive, we need to check the positivity of all of its minors. The 1x1\n        minors are simply the individual entries of the matrix. For \\(X\\), these are\n\n        \\[\n            \\begin{equation}\n                \\begin{aligned}\n                    X_{1,1} &amp;= 1 \\\\\n                    X_{1,2} &amp;= 2 \\\\\n                    X_{2,1} &amp;= 3 \\\\\n                    X_{2,2} &amp;= 4 \\\\\n                \\end{aligned}\n            \\end{equation}\n        \\]\n\n        Each of these entries is positive. There is only one 2x2 minor in this case, which is the determinant of\n        the entire\n        matrix \\(X\\). The determinant of \\(X\\) is calculated as:\n\n        \\[\n            \\text{det}(X) = 1 \\times 4 - 2 \\times 3 = 4 - 6 = 2\n        \\]\n\n        Our function indicates that this matrix is indeed totally positive.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import is_totally_positive\n\n        A = np.array([[1, 2], [3, 4]])\n\n        print(is_totally_positive(A))\n        ```\n\n        However, the following example matrix \\(B\\) defined as\n\n        \\[\n            B = \\begin{pmatrix}\n                    1 &amp; 2 \\\\\n                    3 &amp; -4\n                \\end{pmatrix}\n        \\]\n\n        is not totally positive. The 2x2 minor of \\(B\\) is the determinant of the entire matrix \\(B\\). The\n        determinant of \\(B\\) is calculated as:\n\n        \\[\n            \\text{det}(B) = 1 \\times -4 - 2 \\times 3 = -4 - 6 = -10\n        \\]\n\n        Since the determinant is negative, \\(B\\) is not totally positive.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import is_totally_positive\n\n        B = np.array([[1, 2], [3, -4]])\n\n        print(is_totally_positive(B))\n        ```\n\n    Args:\n        mat: Matrix to check.\n        tol: The absolute tolerance parameter (default 1e-06).\n        sub_sizes: List of sizes of submatrices to consider. Default is all sizes up to `min(mat.shape)`.\n\n    Returns:\n        Return `True` if matrix is totally positive, and `False` otherwise.\n\n    \"\"\"\n    if mat.size == 0:\n        raise ValueError(\"Empty matrix to be neither totally positive nor not totally positive.\")\n\n    dims = mat.shape\n\n    if sub_sizes is None:\n        sub_sizes = range(1, min(dims) + 1)\n\n    for j in sub_sizes:\n        # Handle 1x1 determinants separately.\n        if j == 1:\n            r, _ = np.where(np.minimum(np.real(mat), -np.abs(np.imag(mat))) &lt; -tol)\n            if r.size &gt; 0:\n                return False\n\n        # Handle larger determinants.\n        else:\n            sub_ind_r = list(combinations(range(dims[0]), j))\n            sub_ind_c = list(combinations(range(dims[1]), j)) if dims[0] != dims[1] else sub_ind_r\n\n            for kr in sub_ind_r:\n                for kc in sub_ind_c:\n                    d = np.linalg.det(mat[np.ix_(kr, kc)])\n                    if d &lt; tol or abs(np.imag(d)) &gt; tol:\n                        return False\n    return True\n</code></pre>"},{"location":"reference/toqito/matrix_props/is_unitary/","title":"is_unitary","text":""},{"location":"reference/toqito/matrix_props/is_unitary/#toqito.matrix_props.is_unitary","title":"is_unitary","text":"<p>Checks if the matrix is a unitary matrix.</p>"},{"location":"reference/toqito/matrix_props/is_unitary/#toqito.matrix_props.is_unitary.is_unitary","title":"is_unitary","text":"<pre><code>is_unitary(mat: ndarray, rtol: float = 1e-05, atol: float = 1e-08) -&gt; bool\n</code></pre> <p>Check if matrix is unitary <sup>1</sup>.</p> <p>A matrix is unitary if its inverse is equal to its conjugate transpose.</p> <p>Alternatively, a complex square matrix \\(U\\) is unitary if its conjugate transpose \\(U^*\\) is also its inverse, that is, if</p> \\[     \\begin{equation}         U^* U = U U^* = \\mathbb{I},     \\end{equation} \\] <p>where \\(\\mathbb{I}\\) is the identity matrix.</p> <p>Examples:</p> <p>Consider the following matrix</p> \\[     X = \\begin{pmatrix}         0 &amp; 1 \\\\         1 &amp; 0         \\end{pmatrix} \\] <p>our function indicates that this is indeed a unitary matrix.</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import is_unitary\n\nA = np.array([[0, 1], [1, 0]])\n\nprint(is_unitary(A))\n</code></pre> <p>True</p> <p>We may also use the <code>random_unitary</code> function from <code>toqito</code>, and can verify that a randomly generated matrix is unitary</p> <pre><code>from toqito.matrix_props import is_unitary\nfrom toqito.rand import random_unitary\n\nmat = random_unitary(2)\n\nprint(is_unitary(mat))\n</code></pre> <p>True</p> <p>Alternatively, the following example matrix \\(B\\) defined as</p> \\[     B = \\begin{pmatrix}         1 &amp; 0 \\\\         1 &amp; 1         \\end{pmatrix} \\] <p>is not unitary.</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import is_unitary\n\nB = np.array([[1, 0], [1, 1]])\n\nprint(is_unitary(B))\n</code></pre> <p>False</p> <p>Parameters:</p> <ul> <li> <code>mat</code>               (<code>ndarray</code>)           \u2013            <p>Matrix to check.</p> </li> <li> <code>rtol</code>               (<code>float</code>, default:                   <code>1e-05</code> )           \u2013            <p>The relative tolerance parameter (default 1e-05).</p> </li> <li> <code>atol</code>               (<code>float</code>, default:                   <code>1e-08</code> )           \u2013            <p>The absolute tolerance parameter (default 1e-08).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Return <code>True</code> if matrix is unitary, and <code>False</code> otherwise.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Unitary matrix. link.</p> Source code in <code>toqito/matrix_props/is_unitary.py</code> <pre><code>def is_unitary(mat: np.ndarray, rtol: float = 1e-05, atol: float = 1e-08) -&gt; bool:\n    r\"\"\"Check if matrix is unitary [@WikiUniMat].\n\n    A matrix is unitary if its inverse is equal to its conjugate transpose.\n\n    Alternatively, a complex square matrix \\(U\\) is unitary if its conjugate transpose\n    \\(U^*\\) is also its inverse, that is, if\n\n    \\[\n        \\begin{equation}\n            U^* U = U U^* = \\mathbb{I},\n        \\end{equation}\n    \\]\n\n    where \\(\\mathbb{I}\\) is the identity matrix.\n\n    Examples:\n        Consider the following matrix\n\n        \\[\n            X = \\begin{pmatrix}\n                0 &amp; 1 \\\\\n                1 &amp; 0\n                \\end{pmatrix}\n        \\]\n\n        our function indicates that this is indeed a unitary matrix.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import is_unitary\n\n        A = np.array([[0, 1], [1, 0]])\n\n        print(is_unitary(A))\n        ```\n\n        We may also use the `random_unitary` function from `toqito`, and can verify that a randomly\n        generated matrix is unitary\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.matrix_props import is_unitary\n        from toqito.rand import random_unitary\n\n        mat = random_unitary(2)\n\n        print(is_unitary(mat))\n        ```\n\n        Alternatively, the following example matrix \\(B\\) defined as\n\n        \\[\n            B = \\begin{pmatrix}\n                1 &amp; 0 \\\\\n                1 &amp; 1\n                \\end{pmatrix}\n        \\]\n\n        is not unitary.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import is_unitary\n\n        B = np.array([[1, 0], [1, 1]])\n\n        print(is_unitary(B))\n        ```\n\n    Args:\n        mat: Matrix to check.\n        rtol: The relative tolerance parameter (default 1e-05).\n        atol: The absolute tolerance parameter (default 1e-08).\n\n    Returns:\n        Return `True` if matrix is unitary, and `False` otherwise.\n\n    \"\"\"\n    if not is_square(mat):\n        return False\n\n    uc_u_mat = mat.conj().T @ mat\n    u_uc_mat = mat @ mat.conj().T\n    id_mat = np.eye(len(mat))\n\n    # If U^* @ U = I U @ U^*, the matrix \"U\" is unitary.\n    return bool(\n        np.allclose(uc_u_mat, id_mat, rtol=rtol, atol=atol) and np.allclose(u_uc_mat, id_mat, rtol=rtol, atol=atol)\n    )\n</code></pre>"},{"location":"reference/toqito/matrix_props/kp_norm/","title":"kp_norm","text":""},{"location":"reference/toqito/matrix_props/kp_norm/#toqito.matrix_props.kp_norm","title":"kp_norm","text":"<p>Computes the Kp-norm for matrices or vectors.</p>"},{"location":"reference/toqito/matrix_props/kp_norm/#toqito.matrix_props.kp_norm.kp_norm","title":"kp_norm","text":"<pre><code>kp_norm(mat: ndarray, k: int, p: int) -&gt; float | floating\n</code></pre> <p>Compute the kp_norm of vector or matrix.</p> <p>Calculate the p-norm of a vector or the k-largest singular values of a matrix.</p> <p>Examples:</p> <p>To compute the p-norm of a vector</p> <pre><code>import numpy as np\nfrom toqito.states import bell\nfrom toqito.matrix_props import kp_norm\n\nprint(np.around(kp_norm(bell(0), 1, np.inf), decimals=2))\n</code></pre> <p>1.0</p> <p>To compute the k-largest singular values of a matrix:</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import kp_norm\nfrom toqito.rand import random_unitary\n\nprint(np.around(kp_norm(random_unitary(5), 5, 2), decimals=2))\n</code></pre> <p>2.24</p> <p>Parameters:</p> <ul> <li> <code>mat</code>               (<code>ndarray</code>)           \u2013            <p>2D numpy ndarray</p> </li> <li> <code>k</code>               (<code>int</code>)           \u2013            <p>The number of singular values to take.</p> </li> <li> <code>p</code>               (<code>int</code>)           \u2013            <p>The order of the norm.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float | floating</code>           \u2013            <p>The kp-norm of a matrix.</p> </li> </ul> Source code in <code>toqito/matrix_props/kp_norm.py</code> <pre><code>def kp_norm(mat: np.ndarray, k: int, p: int) -&gt; float | np.floating:\n    r\"\"\"Compute the kp_norm of vector or matrix.\n\n    Calculate the p-norm of a vector or the k-largest singular values of a\n    matrix.\n\n    Examples:\n        To compute the p-norm of a vector\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.states import bell\n        from toqito.matrix_props import kp_norm\n\n        print(np.around(kp_norm(bell(0), 1, np.inf), decimals=2))\n        ```\n\n\n\n        To compute the k-largest singular values of a matrix:\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import kp_norm\n        from toqito.rand import random_unitary\n\n        print(np.around(kp_norm(random_unitary(5), 5, 2), decimals=2))\n        ```\n\n\n\n    Args:\n        mat: 2D numpy ndarray\n        k: The number of singular values to take.\n        p: The order of the norm.\n\n    Returns:\n        The kp-norm of a matrix.\n\n    \"\"\"\n    dim = min(mat.shape)\n\n    # If the requested norm is the Frobenius norm, compute it using numpy's\n    # built-in Frobenius norm calculation, which is significantly faster than\n    # computing singular values.\n    if k &gt;= dim and p == 2:\n        return np.linalg.norm(mat, ord=\"fro\")\n\n    s_vals = np.linalg.svd(mat, compute_uv=False)\n    return np.linalg.norm(s_vals[:k], ord=p)\n</code></pre>"},{"location":"reference/toqito/matrix_props/majorizes/","title":"majorizes","text":""},{"location":"reference/toqito/matrix_props/majorizes/#toqito.matrix_props.majorizes","title":"majorizes","text":"<p>Determine if one vector or matrix majorizes another.</p>"},{"location":"reference/toqito/matrix_props/majorizes/#toqito.matrix_props.majorizes.majorizes","title":"majorizes","text":"<pre><code>majorizes(a_var: ndarray | list[int], b_var: ndarray | list[int]) -&gt; bool\n</code></pre> <p>Determine if one vector or matrix majorizes another <sup>1</sup>.</p> <p>Given \\(a, b \\in \\mathbb{R}^d\\), we say that \\(a\\) weakly majorizes (or dominates) \\(b\\) from below if and only if</p> \\[     \\sum_{i=1}^k a_i^{\\downarrow} \\geq \\sum_{i=1}^k b_i^{\\downarrow} \\] <p>for all \\(k \\in \\{1, \\ldots, d\\}\\).</p> <p>This function was adapted from the QETLAB package.</p> <p>Examples:</p> <p>Simple example illustrating that the vector \\((3, 0, 0)\\) majorizes the vector \\((1, 1, 1)\\).</p> <pre><code>from toqito.matrix_props import majorizes\n\nprint(majorizes([3, 0, 0], [1, 1, 1]))\n</code></pre> <p>True</p> <p>The majorization criterion says that every separable state \\(\\rho \\in \\text{D}(\\mathcal{A} \\otimes \\mathcal{B})\\) is such that \\(\\text{Tr}_{\\mathcal{B}}(\\rho)\\) majorizes \\(\\text{Tr}_{\\mathcal{A}}(\\rho)\\).</p> <pre><code>from toqito.matrix_props import majorizes\nfrom toqito.states import max_entangled\nfrom toqito.matrix_ops import partial_trace\n\nv_vec = max_entangled(3)\nrho = v_vec @ v_vec.conj().T\n\nprint(majorizes(partial_trace(rho, [1]), rho))\n</code></pre> <p>False</p> <p>Parameters:</p> <ul> <li> <code>a_var</code>               (<code>ndarray | list[int]</code>)           \u2013            <p>Matrix or vector provided as list or np.array.</p> </li> <li> <code>b_var</code>               (<code>ndarray | list[int]</code>)           \u2013            <p>Matrix or vector provided as list or np.array.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Return <code>True</code> if <code>a_var</code> majorizes <code>b_var</code> and <code>False</code> otherwise.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Majorization. link.</p> Source code in <code>toqito/matrix_props/majorizes.py</code> <pre><code>def majorizes(a_var: np.ndarray | list[int], b_var: np.ndarray | list[int]) -&gt; bool:\n    r\"\"\"Determine if one vector or matrix majorizes another [@WikiMajorization].\n\n    Given \\(a, b \\in \\mathbb{R}^d\\), we say that \\(a\\) **weakly majorizes** (or dominates)\n    \\(b\\) from below if and only if\n\n    \\[\n        \\sum_{i=1}^k a_i^{\\downarrow} \\geq \\sum_{i=1}^k b_i^{\\downarrow}\n    \\]\n\n    for all \\(k \\in \\{1, \\ldots, d\\}\\).\n\n    This function was adapted from the QETLAB package.\n\n    Examples:\n        Simple example illustrating that the vector \\((3, 0, 0)\\) majorizes the vector\n        \\((1, 1, 1)\\).\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.matrix_props import majorizes\n\n        print(majorizes([3, 0, 0], [1, 1, 1]))\n        ```\n\n\n        The majorization criterion says that every separable state\n        \\(\\rho \\in \\text{D}(\\mathcal{A} \\otimes \\mathcal{B})\\) is such that\n        \\(\\text{Tr}_{\\mathcal{B}}(\\rho)\\) majorizes\n        \\(\\text{Tr}_{\\mathcal{A}}(\\rho)\\).\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.matrix_props import majorizes\n        from toqito.states import max_entangled\n        from toqito.matrix_ops import partial_trace\n\n        v_vec = max_entangled(3)\n        rho = v_vec @ v_vec.conj().T\n\n        print(majorizes(partial_trace(rho, [1]), rho))\n        ```\n\n    Args:\n        a_var: Matrix or vector provided as list or np.array.\n        b_var: Matrix or vector provided as list or np.array.\n\n    Returns:\n        Return `True` if `a_var` majorizes `b_var` and `False` otherwise.\n\n    \"\"\"\n    # If input if provided as list, convert to np.array.\n    if isinstance(a_var, list):\n        a_var = np.array(a_var)\n    if isinstance(b_var, list):\n        b_var = np.array(b_var)\n\n    # If matrix, obtain singular values for majorization.\n    if len(a_var.shape) == 1:\n        a_var = np.sort(a_var)[::-1]\n    # Otherwise, just sort in descending order.\n    else:\n        _, a_var, _ = np.linalg.svd(a_var)\n\n    # Do the same for second input argument.\n    if len(b_var.shape) == 1:\n        b_var = np.sort(b_var)[::-1]\n    else:\n        _, b_var, _ = np.linalg.svd(b_var)\n\n    la_var = len(a_var)\n    lb_var = len(b_var)\n\n    # If different length vectors, pad with zeros.\n    if la_var &lt; lb_var:\n        a_var = np.pad(a_var, (0, lb_var - la_var), \"constant\")\n    elif lb_var &lt; la_var:\n        b_var = np.pad(b_var, (0, la_var - lb_var), \"constant\")\n\n    cta = 0\n    ctb = -np.linalg.norm(a_var) * np.finfo(float).eps ** (3 / 4)\n\n    # Check for majorization.\n    for k, _ in enumerate(a_var):\n        cta = cta + a_var[k]\n        ctb = ctb + b_var[k]\n        if cta &lt; ctb:\n            return False\n    return True\n</code></pre>"},{"location":"reference/toqito/matrix_props/mutual_coherence/","title":"mutual_coherence","text":""},{"location":"reference/toqito/matrix_props/mutual_coherence/#toqito.matrix_props.mutual_coherence","title":"mutual_coherence","text":"<p>Computes the mutual coherence for a list of 1D numpy arrays.</p>"},{"location":"reference/toqito/matrix_props/mutual_coherence/#toqito.matrix_props.mutual_coherence.mutual_coherence","title":"mutual_coherence","text":"<pre><code>mutual_coherence(vectors: list[ndarray]) -&gt; float | floating\n</code></pre> <p>Calculate the mutual coherence of a collection of input vectors.</p> <p>The mutual coherence of a collection of input vectors is defined as the maximum absolute value of the inner product between any two distinct vectors, divided by the product of their norms\u00a0<sup>1</sup>. It provides a measure of how similar the vectors are to each other.</p> <p>Examples:</p> <pre><code>import numpy as np\nfrom toqito.matrix_props.mutual_coherence import mutual_coherence\nexample_A = [np.array([1, 0]), np.array([0, 1])]\nprint(\"Result for example_A = \",mutual_coherence(example_A))\n# An example with a larger set of vectors\nexample_B = [np.array([1, 0, 1]), np.array([0, 1, 1]), np.array([1, 1, 0])]\nprint(\"Result for example_B = \",mutual_coherence(example_B))\n</code></pre> <p>Result for example_A =  0.0 Result for example_B =  0.4999999999999999</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If arrays in list are not 1D.</p> </li> <li> <code>TypeError</code>             \u2013            <p>If input is not a list.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>vectors</code>               (<code>list[ndarray]</code>)           \u2013            <p>A list of 1D numpy arrays.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float | floating</code>           \u2013            <p>The mutual coherence of the collection of input vectors.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Mutual coherence (linear algebra). link.</p> Source code in <code>toqito/matrix_props/mutual_coherence.py</code> <pre><code>def mutual_coherence(vectors: list[np.ndarray]) -&gt; float | np.floating:\n    r\"\"\"Calculate the mutual coherence of a collection of input vectors.\n\n    The mutual coherence of a collection of input vectors is defined as the maximum\n    absolute value of the inner product between any two distinct vectors, divided by the\n    product of their norms\u00a0[@WikiMutualCoh]. It provides a measure of how\n    similar the vectors are to each other.\n\n    Examples:\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props.mutual_coherence import mutual_coherence\n        example_A = [np.array([1, 0]), np.array([0, 1])]\n        print(\"Result for example_A = \",mutual_coherence(example_A))\n        # An example with a larger set of vectors\n        example_B = [np.array([1, 0, 1]), np.array([0, 1, 1]), np.array([1, 1, 0])]\n        print(\"Result for example_B = \",mutual_coherence(example_B))\n        ```\n\n    Raises:\n        ValueError: If arrays in list are not 1D.\n        TypeError: If input is not a list.\n\n    Args:\n        vectors: A list of 1D numpy arrays.\n\n    Returns:\n        The mutual coherence of the collection of input vectors.\n\n    \"\"\"\n    # Check if the input is a valid list of 1D numpy arrays.\n    if not isinstance(vectors, list):\n        raise TypeError(\"Input must be a list of 1D numpy arrays.\")\n    if not all(isinstance(vec, np.ndarray) and vec.ndim == 1 for vec in vectors):\n        raise ValueError(\"All elements in the list must be 1D numpy arrays.\")\n\n    # Convert input into a 2D numpy array.\n    vectors = np.column_stack(vectors).astype(float)\n\n    # Normalize the vectors.\n    vectors /= np.linalg.norm(vectors, axis=0)\n\n    # Calculate the inner product between all pairs of columns.\n    inner_products = np.abs(np.conj(vectors.T) @ vectors)\n\n    # Set diagonal elements to zero (only respecting distinct vectors).\n    np.fill_diagonal(inner_products, 0)\n\n    return inner_products.max()\n</code></pre>"},{"location":"reference/toqito/matrix_props/positive_semidefinite_rank/","title":"positive_semidefinite_rank","text":""},{"location":"reference/toqito/matrix_props/positive_semidefinite_rank/#toqito.matrix_props.positive_semidefinite_rank","title":"positive_semidefinite_rank","text":"<p>Calculates the positive semidefinite rank of a nonnegative matrix.</p>"},{"location":"reference/toqito/matrix_props/positive_semidefinite_rank/#toqito.matrix_props.positive_semidefinite_rank.positive_semidefinite_rank","title":"positive_semidefinite_rank","text":"<pre><code>positive_semidefinite_rank(mat: ndarray, max_rank: int = 10) -&gt; int | None\n</code></pre> <p>Compute the positive semidefinite rank (PSD rank) of a nonnegative matrix.</p> <p>The definition of PSD rank is defined in <sup>1</sup>.</p> <p>Finds the PSD rank of an input matrix by checking feasibility for increasing rank.</p> <p>Examples:</p> <p>As an example (Equation 21 from <sup>2</sup>), the PSD rank of the following matrix</p> \\[     A = \\frac{1}{2}     \\begin{pmatrix}         0 &amp; 1 &amp; 1 \\\\         1 &amp; 0 &amp; 1 \\\\         1 &amp; 1 &amp; 0     \\end{pmatrix} \\] <p>is known to be \\(\\text{rank}_{\\text{PSD}}(A) = 2\\).</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import positive_semidefinite_rank\n\nprint(positive_semidefinite_rank(1/2 * np.array([[0, 1, 1], [1,0,1], [1,1,0]])))\n</code></pre> <p>2</p> <p>The PSD rank of the identity matrix is the dimension of the matrix <sup>1</sup>.</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import positive_semidefinite_rank\n\nprint(positive_semidefinite_rank(np.identity(3)))\n</code></pre> <p>3</p> <p>References</p> <p><sup>1</sup> Fawzi, Hamza and Gouveia, Jo{\\~a}o and Parrilo, Pablo and Robinson, Richard and Thomas, Rekha. Positive semidefinite rank. Mathematical Programming. vol. 153. (2015). link. <sup>2</sup> Heinosaari, Teiko and Hillery, Mark. Can a qudit carry more information than a dit?. arXiv preprint arXiv:2406.16566. (2024). link.</p> Source code in <code>toqito/matrix_props/positive_semidefinite_rank.py</code> <pre><code>def positive_semidefinite_rank(mat: np.ndarray, max_rank: int = 10) -&gt; int | None:\n    r\"\"\"Compute the positive semidefinite rank (PSD rank) of a nonnegative matrix.\n\n    The definition of PSD rank is defined in [@Fawzi_2015_Positive].\n\n    Finds the PSD rank of an input matrix by checking feasibility for increasing rank.\n\n    Examples:\n        As an example (Equation 21 from [@Heinosaari_2024_Can]), the PSD rank of the following matrix\n\n        \\[\n            A = \\frac{1}{2}\n            \\begin{pmatrix}\n                0 &amp; 1 &amp; 1 \\\\\n                1 &amp; 0 &amp; 1 \\\\\n                1 &amp; 1 &amp; 0\n            \\end{pmatrix}\n        \\]\n\n        is known to be \\(\\text{rank}_{\\text{PSD}}(A) = 2\\).\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import positive_semidefinite_rank\n\n        print(positive_semidefinite_rank(1/2 * np.array([[0, 1, 1], [1,0,1], [1,1,0]])))\n        ```\n\n\n        The PSD rank of the identity matrix is the dimension of the matrix [@Fawzi_2015_Positive].\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import positive_semidefinite_rank\n\n        print(positive_semidefinite_rank(np.identity(3)))\n        ```\n\n    \"\"\"\n    if not is_nonnegative(mat):\n        raise ValueError(\"Matrix must be nonnegative.\")\n    if not is_square(mat):\n        raise ValueError(\"Matrix must be square.\")\n\n    for k in range(1, max_rank + 1):\n        if _check_psd_rank(mat, k):\n            return k\n    return None\n</code></pre>"},{"location":"reference/toqito/matrix_props/sk_norm/","title":"sk_norm","text":""},{"location":"reference/toqito/matrix_props/sk_norm/#toqito.matrix_props.sk_norm","title":"sk_norm","text":"<p>Computes the S(k)-norm of a matrix.</p>"},{"location":"reference/toqito/matrix_props/sk_norm/#toqito.matrix_props.sk_norm.sk_operator_norm","title":"sk_operator_norm","text":"<pre><code>sk_operator_norm(mat: ndarray, k: int = 1, dim: int | list[int] | None = None, target: float | None = None, effort: int = 2) -&gt; tuple[float, float]\n</code></pre> <p>Compute the S(k)-norm of a matrix <sup>1</sup>.</p> <p>The \\(S(k)\\)-norm of of a matrix \\(X\\) is defined as:</p> \\[     \\big|\\big| X \\big|\\big|_{S(k)} := sup_{|v\\rangle, |w\\rangle}     \\Big\\{         |\\langle w | X |v \\rangle| :         \\text{Schmidt - rank}(|v\\rangle) \\leq k,         \\text{Schmidt - rank}(|w\\rangle) \\leq k     \\Big\\} \\] <p>Since computing the exact value of S(k)-norm <sup>2</sup> is in the general case an intractable problem, this function tries to find some good lower and upper bounds. You can control the amount of computation you want to devote to computing the bounds by <code>effort</code> input argument. Note that if the input matrix is not positive semidefinite the output bounds might be quite poor.</p> <p>This function was adapted from QETLAB.</p> <p>Examples:</p> <p>The \\(S(1)\\)-norm of a Werner state \\(\\rho_a \\in M_n \\otimes M_n\\) is</p> \\[     \\big|\\big| \\rho_a \\big|\\big|_{S(1)} = \\frac{1 + |min\\{a, 0\\}|}{n (n - a)} \\] <pre><code>from toqito.states.werner import werner\nfrom toqito.matrix_props.sk_norm import sk_operator_norm\n\nrho = werner(4, 0.)\n\nprint(sk_operator_norm(rho))\n</code></pre> <p>(np.float64(0.0625), np.float64(0.0625))</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If dimension of the input matrix is not specified.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>mat</code>               (<code>ndarray</code>)           \u2013            <p>A matrix.</p> </li> <li> <code>k</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The \"index\" of the norm--that is, it is the Schmidt rank of the vectors that are multiplying X on the left</p> </li> <li> <code>dim</code>               (<code>int | list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The dimension of the two sub-systems. By default it's assumed to be equal.</p> </li> <li> <code>target</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>A target value that you wish to prove that the norm is above or below.</p> </li> <li> <code>effort</code>               (<code>int</code>, default:                   <code>2</code> )           \u2013            <p>An integer value indicating the amount of computation you want to devote to computing the bounds.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[float, float]</code>           \u2013            <p>A lower and an upper bound on S(k)-norm of <code>mat</code>.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Johnston, Nathaniel and Kribs, David. A family of norms with applications in quantum information theory. Journal of Mathematical Physics. vol. 51(8). (2010). doi:10.1063/1.3459068. <sup>2</sup> Johnston, Nathaniel. Norms and Cones in the Theory of Quantum Entanglement. (2012).</p> Source code in <code>toqito/matrix_props/sk_norm.py</code> <pre><code>def sk_operator_norm(\n    mat: np.ndarray,\n    k: int = 1,\n    dim: int | list[int] | None = None,\n    target: float | None = None,\n    effort: int = 2,\n) -&gt; tuple[float, float]:\n    r\"\"\"Compute the S(k)-norm of a matrix [@Johnston_2010_AFamily].\n\n    The \\(S(k)\\)-norm of of a matrix \\(X\\) is defined as:\n\n    \\[\n        \\big|\\big| X \\big|\\big|_{S(k)} := sup_{|v\\rangle, |w\\rangle}\n        \\Big\\{\n            |\\langle w | X |v \\rangle| :\n            \\text{Schmidt - rank}(|v\\rangle) \\leq k,\n            \\text{Schmidt - rank}(|w\\rangle) \\leq k\n        \\Big\\}\n    \\]\n\n    Since computing the exact value of S(k)-norm [@Johnston_2012_Norms] is in the general case an intractable\n    problem, this function tries to find some good lower and upper bounds. You can control the amount of computation you\n    want to devote to computing the bounds by `effort` input argument. Note that if the input matrix is not positive\n    semidefinite the output bounds might be quite poor.\n\n    This function was adapted from QETLAB.\n\n    Examples:\n        The \\(S(1)\\)-norm of a Werner state \\(\\rho_a \\in M_n \\otimes M_n\\) is\n\n        \\[\n            \\big|\\big| \\rho_a \\big|\\big|_{S(1)} = \\frac{1 + |min\\{a, 0\\}|}{n (n - a)}\n        \\]\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states.werner import werner\n        from toqito.matrix_props.sk_norm import sk_operator_norm\n\n        rho = werner(4, 0.)\n\n        print(sk_operator_norm(rho))\n        ```\n\n    Raises:\n        ValueError: If dimension of the input matrix is not specified.\n\n    Args:\n        mat: A matrix.\n        k: The \"index\" of the norm--that is, it is the Schmidt rank of the vectors that are multiplying X on the left\n        and right in the definition of the norm.\n        dim: The dimension of the two sub-systems. By default it's assumed to be equal.\n        target: A target value that you wish to prove that the norm is above or below.\n        effort: An integer value indicating the amount of computation you want to devote to computing the bounds.\n\n    Returns:\n        A lower and an upper bound on S(k)-norm of `mat`.\n\n    \"\"\"\n    eps = np.finfo(float).eps\n    tol = eps ** (3 / 8)\n\n    if mat.shape[0] != mat.shape[1]:\n        raise ValueError(\"Input matrix must be square.\")\n\n    dim_xy = mat.shape[0]\n    # Set default dimension if none was provided.\n    if dim is None:\n        dim = int(np.round(np.sqrt(dim_xy)))\n\n    # Allow the user to enter in a single integer for dimension.\n    if isinstance(dim, int):\n        dim = np.array([dim, dim_xy / dim])\n        if np.abs(dim[1] - np.round(dim[1])) &gt;= 2 * dim_xy * np.finfo(float).eps:\n            raise ValueError(\"If `dim` is a scalar, it must evenly divide the length of the matrix.\")\n        dim[1] = int(np.round(dim[1]))\n\n    dim = np.array(dim, dtype=int)\n\n    # Some useful, repeatedly-used, values.\n    prod_dim = np.prod(dim)\n    op_norm = np.linalg.norm(mat, ord=2)\n    if np.allclose(op_norm, 0.0):\n        return 0.0, 0.0\n\n    rank = np.linalg.matrix_rank(mat)\n    # Rescale X to have unit norm.\n    mat = mat / op_norm\n\n    # The S(k)-norm is just the operator norm if k is large enough.\n    if k &gt;= min(dim):\n        lower_bound = op_norm\n        upper_bound = op_norm\n        return lower_bound, upper_bound\n\n    # If X is rank 1 then the S(k)-norm is easy to compute via Proposition 10 of [1].\n    if rank == 1:\n        u_mat, _, v_mat = np.linalg.svd(mat, full_matrices=False)\n        lower_bound = op_norm * sk_vector_norm(u_mat[:, 0], k, dim) * sk_vector_norm(v_mat[0, :], k, dim)\n        upper_bound = lower_bound\n        return lower_bound, upper_bound\n\n    # Compute some more simple bounds. We will multiply these by op_norm before we leave this function.\n    # This comes from Theorem 4.13 in [1].\n    lower_bound = k / min(dim)\n    # our most basic upper bound\n    upper_bound = 1\n\n    # Break out of the function if the target value has already been met.\n    if __target_is_proved(lower_bound, upper_bound, op_norm, tol, target):\n        return op_norm * lower_bound, op_norm * upper_bound\n\n    # If input is not Hermitian, we don't have better bounds, so we abort.\n    if not is_hermitian(mat):\n        return op_norm * lower_bound, op_norm * upper_bound\n\n    # Compute eigendecomposition and sort the eigenvalues.\n    eig_val, eig_vec = np.linalg.eigh(mat)\n    ind = np.argsort(eig_val)\n    eig_val = eig_val[ind]\n    eig_vec = eig_vec[:, ind]\n\n    atol = 1e-8\n    is_positive = all(x &gt;= -abs(atol) for x in eig_val)\n    is_projection = False\n    if is_positive:\n        is_projection = np.allclose(np.linalg.matrix_power(mat, 2), mat)\n\n    is_trans_exact = min(dim) == 2 and max(dim) &lt;= 3\n\n    # If the exact answer won't be found by SDP, compute bounds via other methods first.\n    if not (is_positive and is_trans_exact and k == 1 and effort &gt;= 1):\n        # Use the lower bound of Proposition 4.14 of [1].\n        for r in range(k, min(dim) + 1):\n            t_ind = np.prod(dim) - np.prod(dim - r) - 1\n            lower_bound = max(lower_bound, (k / r) * eig_val[t_ind])\n\n        # Use the lower bound of Theorem 4.2.15 of [3].\n        if k == 1:\n            lower_bound = max(\n                lower_bound,\n                (np.trace(mat) + np.sqrt((prod_dim * np.trace(mat @ mat) - np.trace(mat) ** 2) / (prod_dim - 1)))\n                / prod_dim,\n            )\n\n        if is_positive:\n            # Use the upper bound of Proposition 15 of [1].\n            upper_bound = min(\n                upper_bound,\n                sum(abs(eig_val[i]) * sk_vector_norm(eig_vec[:, i], k, dim) ** 2 for i in range(prod_dim)),\n            )\n\n            # Use the upper bound of Proposition 4.2.11 of [3].\n            upper_bound = min(upper_bound, kp_norm(realignment(mat, dim), k**2, 2))\n\n        # Use the lower bound of Theorem 4.2.17 of [3].\n        if is_projection:\n            lower_bound = max(\n                lower_bound,\n                min(\n                    1,\n                    k / np.ceil((dim[0] + dim[1] - np.sqrt((dim[0] - dim[1]) ** 2 + 4 * rank - 4)) / 2),\n                ),\n            )\n\n            lower_bound = max(\n                lower_bound,\n                (min(dim) - k)\n                * (rank + np.sqrt((prod_dim * rank - rank**2) / (prod_dim - 1)))\n                / (prod_dim * (min(dim) - 1))\n                + (k - 1) / (min(dim) - 1),\n            )\n\n        # Break out of the function if the target value has already been met.\n        if __target_is_proved(lower_bound, upper_bound, op_norm, tol, target):\n            return op_norm * lower_bound, op_norm * upper_bound\n\n        # Use a randomized iterative method to try to improve the lower bound.\n        if is_positive:\n            for _ in range(5**effort):\n                lower_bound = max(\n                    lower_bound,\n                    __lower_bound_sk_norm_randomized(mat, k, dim, tol**2),\n                )\n\n                # Break out of the function if the target value has already been met.\n                if __target_is_proved(lower_bound, upper_bound, op_norm, tol, target):\n                    return op_norm * lower_bound, op_norm * upper_bound\n\n    # Start the semidefinite programming approach for getting upper bounds.\n    bool_cond = [\n        (effort &gt;= 1 and lower_bound + tol &lt; upper_bound and is_positive),\n        (effort &gt;= 1 and is_positive and is_trans_exact and k == 1),\n    ]\n    if any(bool_cond):\n        rho = cvxpy.Variable((prod_dim, prod_dim), hermitian=True, name=\"rho\")\n        objective = cvxpy.Maximize(cvxpy.real(cvxpy.trace(mat @ rho)))\n\n        constraints = [rho &gt;&gt; 0, cvxpy.real(cvxpy.trace(rho)) &lt;= 1]\n        if k == 1:\n            constraints.append(partial_transpose(rho, [1], dim) &gt;&gt; 0)\n        else:\n            constraints.append(k * cvxpy.kron(partial_trace(rho, [1], dim), np.eye(dim[1])) &gt;&gt; rho)\n\n        problem = cvxpy.Problem(objective, constraints)\n        cvx_optval = problem.solve()\n        if problem.status != \"optimal\":\n            raise ValueError(\"Numerical problems encountered.\")\n\n        upper_bound = min(upper_bound, np.real(cvx_optval))\n\n        # In small dimensions, the transpose map gets the result exactly.\n        if is_trans_exact and k == 1:\n            lower_bound = upper_bound\n        elif k == 1:\n            # We can also get decent lower bounds from the SDP results when k=1\n            # See Theorem 5.2.8 of [2].\n            roots, _ = scipy.special.roots_jacobi(1, dim[1] - 2, 1)\n            gs = min(1 - roots)\n            xmineig = min(eig_val)\n            lower_bound = max(\n                lower_bound,\n                np.real(cvx_optval) * (1 - dim[1] * gs / (2 * dim[1] - 1)) + xmineig * gs / (2 * dim[1] - 2),\n            )\n\n            # Done the effort = 1 SDP, now get better upper bounds via symmetric\n            # extensions if effort &gt;= 2.\n            for j in range(2, effort + 1):\n                # Break out of the function if the target value has already been met.\n                if __target_is_proved(lower_bound, upper_bound, op_norm, tol, target):\n                    return op_norm * lower_bound, op_norm * upper_bound\n\n                sym_dim = [dim[0]] + [dim[1]] * j\n                prod_sym_dim = dim[0] * (dim[1] ** j)\n                sym_proj = np.kron(np.eye(dim[0]), symmetric_projection(dim[1], j))\n\n                rho = cvxpy.Variable((prod_sym_dim, prod_sym_dim), hermitian=True, name=\"rho\")\n                objective = cvxpy.Maximize(\n                    cvxpy.real(cvxpy.trace(mat @ partial_trace(rho, list(range(2, j + 1)), sym_dim)))\n                )\n\n                constraints = [\n                    rho &gt;&gt; 0,\n                    cvxpy.real(cvxpy.trace(rho)) &lt;= 1,\n                    sym_proj @ rho @ sym_proj == rho,\n                    partial_transpose(rho, list(range(0, int(np.ceil(j / 2)) + 1)), sym_dim) &gt;&gt; 0,\n                ]\n\n                problem = cvxpy.Problem(objective, constraints)\n                cvx_optval = problem.solve()\n                if problem.status != \"optimal\":\n                    raise ValueError(\"Numerical problems encountered.\")\n\n                upper_bound = min(upper_bound, np.real(cvx_optval))\n\n                roots, _ = scipy.special.roots_jacobi(np.floor(j / 2) + 1, dim[1] - 2, j % 2)\n                gs = min(1 - roots)\n                lower_bound = max(\n                    lower_bound,\n                    np.real(cvx_optval) * (1 - dim[1] * gs / (2 * dim[1] - 1)) + xmineig * gs / (2 * dim[1] - 2),\n                )\n\n    lower_bound = op_norm * lower_bound\n    upper_bound = op_norm * upper_bound\n\n    return lower_bound, upper_bound\n</code></pre>"},{"location":"reference/toqito/matrix_props/spark/","title":"spark","text":""},{"location":"reference/toqito/matrix_props/spark/#toqito.matrix_props.spark","title":"spark","text":"<p>Computes the spark of a matrix.</p>"},{"location":"reference/toqito/matrix_props/spark/#toqito.matrix_props.spark.spark","title":"spark","text":"<pre><code>spark(mat: ndarray) -&gt; int\n</code></pre> <p>Compute the spark of a matrix.</p> <p>The spark of a matrix A is the smallest number of columns from A that are linearly dependent <sup>1</sup>.</p> <p>Examples:</p> <pre><code>import numpy as np\nfrom toqito.matrix_props import spark\n\nA = np.array([[1, 0, 1, 2],\n              [0, 1, 1, 3],\n              [1, 1, 2, 5]])\n\nprint(spark(A))\n</code></pre> <p>3</p> Notes <ul> <li>This function only works for 2D NumPy arrays.</li> <li>If all columns are linearly independent, the function returns n_cols + 1.</li> <li>The time complexity of this implementation is O(2^n) in the worst case,   where n is the number of columns.</li> <li>For an m x n matrix A with n &gt;= m:<ul> <li>If spark(A) = m + 1, then rank(A) = m (full rank).</li> <li>If spark(A) = 1, then the matrix has a zero column.</li> <li>If spark(A) &lt;= rank(A) + 1, then the matrix has dependent columns.</li> </ul> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the input is not a 2D NumPy array.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>mat</code>               (<code>ndarray</code>)           \u2013            <p>The input matrix as a 2D NumPy array.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The spark of the input matrix <code>mat</code>.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Elad, Michael. Sparse and redundant representations: from theory to applications in signal and image processing. (2010).</p> Source code in <code>toqito/matrix_props/spark.py</code> <pre><code>def spark(mat: np.ndarray) -&gt; int:\n    \"\"\"Compute the spark of a matrix.\n\n    The spark of a matrix A is the smallest number of columns from A that are linearly\n    dependent [@Elad_2010_Sparse].\n\n    Examples:\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrix_props import spark\n\n        A = np.array([[1, 0, 1, 2],\n                      [0, 1, 1, 3],\n                      [1, 1, 2, 5]])\n\n        print(spark(A))\n        ```\n\n    Notes:\n        - This function only works for 2D NumPy arrays.\n        - If all columns are linearly independent, the function returns n_cols + 1.\n        - The time complexity of this implementation is O(2^n) in the worst case,\n          where n is the number of columns.\n        - For an m x n matrix A with n &gt;= m:\n            - If spark(A) = m + 1, then rank(A) = m (full rank).\n            - If spark(A) = 1, then the matrix has a zero column.\n            - If spark(A) &lt;= rank(A) + 1, then the matrix has dependent columns.\n\n    Raises:\n        ValueError: If the input is not a 2D NumPy array.\n\n    Args:\n        mat: The input matrix as a 2D NumPy array.\n\n    Returns:\n        The spark of the input matrix `mat`.\n\n    \"\"\"\n    if not isinstance(mat, np.ndarray) or mat.ndim != 2:\n        raise ValueError(\"Input must be a 2D NumPy array\")\n\n    m, n_cols = mat.shape\n\n    # Check for zero columns\n    if np.any(np.all(mat == 0, axis=0)):\n        return 1\n\n    for k in range(1, min(m, n_cols) + 1):\n        for cols in combinations(range(n_cols), k):\n            submatrix = mat[:, cols]\n            if np.linalg.matrix_rank(submatrix) &lt; k:\n                return k\n\n    # If all columns are linearly independent\n    return min(m, n_cols) + 1\n</code></pre>"},{"location":"reference/toqito/matrix_props/trace_norm/","title":"trace_norm","text":""},{"location":"reference/toqito/matrix_props/trace_norm/#toqito.matrix_props.trace_norm","title":"trace_norm","text":"<p>Computes the trace norm metric of a density matrix.</p>"},{"location":"reference/toqito/matrix_props/trace_norm/#toqito.matrix_props.trace_norm.trace_norm","title":"trace_norm","text":"<pre><code>trace_norm(rho: ndarray) -&gt; float | floating\n</code></pre> <p>Compute the trace norm of the state <sup>1</sup>.</p> <p>Also computes the operator 1-norm when inputting an operator.</p> <p>The trace norm \\(||\\rho||_1\\) of a density matrix \\(\\rho\\) is the sum of the singular values of \\(\\rho\\). The singular values are the roots of the eigenvalues of \\(\\rho \\rho^*\\).</p> <p>Examples:</p> <p>Consider the following Bell state</p> \\[     u = \\frac{1}{\\sqrt{2}} \\left( |00 \\rangle + |11 \\rangle \\right) \\in \\mathcal{X}. \\] <p>The corresponding density matrix of \\(u\\) may be calculated by:</p> \\[     \\rho = u u^* = \\begin{pmatrix}                      1 &amp; 0 &amp; 0 &amp; 1 \\\\                      0 &amp; 0 &amp; 0 &amp; 0 \\\\                      0 &amp; 0 &amp; 0 &amp; 0 \\\\                      1 &amp; 0 &amp; 0 &amp; 1                    \\end{pmatrix} \\in \\text{D}(\\mathcal{X}). \\] <p>It can be observed using <code>|toqito\u27e9</code> that \\(||\\rho||_1 = 1\\) as follows.</p> <pre><code>from toqito.states import bell\nfrom toqito.matrix_props import trace_norm\n\nrho = bell(0) @ bell(0).conj().T\n\nprint(trace_norm(rho))\n</code></pre> <p>0.9999999999999999</p> <p>Parameters:</p> <ul> <li> <code>rho</code>               (<code>ndarray</code>)           \u2013            <p>Density operator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float | floating</code>           \u2013            <p>The trace norm of <code>rho</code>.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Quantiki. Trace norm. link.</p> Source code in <code>toqito/matrix_props/trace_norm.py</code> <pre><code>def trace_norm(rho: np.ndarray) -&gt; float | np.floating:\n    r\"\"\"Compute the trace norm of the state [@Quantiki_TrNorm].\n\n    Also computes the operator 1-norm when inputting an operator.\n\n    The trace norm \\(||\\rho||_1\\) of a density matrix \\(\\rho\\) is the sum of the singular\n    values of \\(\\rho\\). The singular values are the roots of the eigenvalues of\n    \\(\\rho \\rho^*\\).\n\n    Examples:\n        Consider the following Bell state\n\n        \\[\n            u = \\frac{1}{\\sqrt{2}} \\left( |00 \\rangle + |11 \\rangle \\right) \\in \\mathcal{X}.\n        \\]\n\n        The corresponding density matrix of \\(u\\) may be calculated by:\n\n        \\[\n            \\rho = u u^* = \\begin{pmatrix}\n                             1 &amp; 0 &amp; 0 &amp; 1 \\\\\n                             0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                             0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                             1 &amp; 0 &amp; 0 &amp; 1\n                           \\end{pmatrix} \\in \\text{D}(\\mathcal{X}).\n        \\]\n\n        It can be observed using `|toqito\u27e9` that \\(||\\rho||_1 = 1\\) as follows.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import bell\n        from toqito.matrix_props import trace_norm\n\n        rho = bell(0) @ bell(0).conj().T\n\n        print(trace_norm(rho))\n        ```\n\n    Args:\n        rho: Density operator.\n\n    Returns:\n        The trace norm of `rho`.\n\n    \"\"\"\n    return np.linalg.norm(rho, ord=\"nuc\")\n</code></pre>"},{"location":"reference/toqito/measurement_ops/","title":"measurement_ops","text":""},{"location":"reference/toqito/measurement_ops/#toqito.measurement_ops","title":"measurement_ops","text":"<p>Measurement operations are the modules that are used to implement the operations for measurement operators.</p>"},{"location":"reference/toqito/measurement_ops/measure/","title":"measure","text":""},{"location":"reference/toqito/measurement_ops/measure/#toqito.measurement_ops.measure","title":"measure","text":"<p>Apply measurement to a quantum state.</p>"},{"location":"reference/toqito/measurement_ops/measure/#toqito.measurement_ops.measure.measure","title":"measure","text":"<pre><code>measure(state: ndarray, measurement: ndarray | list[ndarray] | tuple[ndarray, ...], tol: float = 1e-10, state_update: bool = False) -&gt; float | tuple[float, ndarray] | list[float | tuple[float, ndarray]]\n</code></pre> <p>Apply measurement to a quantum state.</p> <p>The measurement can be provided as a single operator (POVM element or Kraus operator) or as a list of operators (assumed to be Kraus operators) describing a complete quantum measurement.</p> <p>When a single operator is provided:</p> <ul> <li>Returns the measurement outcome probability if <code>state_update</code> is False.</li> <li>Returns a tuple (probability, post_state) if <code>state_update</code> is True.</li> </ul> <p>When a list of operators is provided, the function verifies that they satisfy the completeness relation when <code>state_update</code> is True.</p> \\[     \\sum_i K_i^\\dagger K_i = \\mathbb{I}, \\] <p>when <code>state_update</code> is True. Then, for each operator \\(K_i\\), the outcome probability is computed as</p> \\[     p_i = \\mathrm{Tr}\\Bigl(K_i^\\dagger K_i\\, \\rho\\Bigr), \\] <p>and, if \\(p_i &gt; tol\\), the post\u2010measurement state is updated via</p> \\[     u = \\frac{1}{\\sqrt{3}} e_0 + \\sqrt{\\frac{2}{3}} e_1 \\] <p>where we define \\(u u^* = \\rho \\in \\text{D}(\\mathcal{X})\\).</p> <p>Define measurement operators</p> \\[     P_0 = e_0 e_0^* \\quad \\text{and} \\quad P_1 = e_1 e_1^*. \\] <pre><code>import numpy as np\nfrom toqito.states import basis\nfrom toqito.measurement_ops import measure\n\ne_0, e_1 = basis(2, 0), basis(2, 1)\n\nu = 1/np.sqrt(3) * e_0 + np.sqrt(2/3) * e_1\nrho = u @ u.conj().T\n\nproj_0 = e_0 @ e_0.conj().T\nproj_1 = e_1 @ e_1.conj().T\nprint(measure(proj_0, rho))\n</code></pre> <p>0.3333333333333334</p> <p>Then the probability of obtaining outcome \\(0\\) is given by</p> \\[     \\langle P_0, \\rho \\rangle = \\frac{1}{3}. \\] <p>Similarly, the probability of obtaining outcome \\(1\\) is given by</p> \\[     \\langle P_1, \\rho \\rangle = \\frac{2}{3}. \\] <pre><code>import numpy as np\nfrom toqito.measurement_ops.measure import measure\n\nrho = np.array([[0.5, 0.5], [0.5, 0.5]])\nK0 = np.array([[1, 0], [0, 0]])\nK1 = np.array([[0, 0], [0, 1]])\n\n# Returns list of probabilities.\nprint(measure(rho, [K0, K1]))\n\n# Returns list of (probability, post_state) tuples.\nprint(measure(rho, [K0, K1], state_update=True))\n</code></pre> <p>[np.float64(0.5), np.float64(0.5)][(np.float64(0.5), array([[1., 0.],        [0., 0.]])), (np.float64(0.5), array([[0., 0.],        [0., 1.]]))]</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If a list of operators does not satisfy the completeness relation.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>state</code>               (<code>ndarray</code>)           \u2013            <p>Quantum state as a density matrix shape (d, d) where d is the dimension of the Hilbert space.</p> </li> <li> <code>measurement</code>               (<code>ndarray | list[ndarray] | tuple[ndarray, ...]</code>)           \u2013            <p>Either a single measurement operator (an np.ndarray) or a list/tuple of operators. When providing a</p> </li> <li> <code>tol</code>               (<code>float</code>, default:                   <code>1e-10</code> )           \u2013            <p>Tolerance for numerical precision (default is 1e-10).</p> </li> <li> <code>state_update</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, also return the post-measurement state(s); otherwise, only the probability or</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float | tuple[float, ndarray] | list[float | tuple[float, ndarray]]</code>           \u2013            <p>If a single operator is provided, returns a float (probability) or a tuple (probability, post_state) if</p> </li> <li> <code>float | tuple[float, ndarray] | list[float | tuple[float, ndarray]]</code>           \u2013            <p><code>state_update</code> is True. If a list is provided, returns a list of probabilities or a list of tuples if</p> </li> <li> <code>float | tuple[float, ndarray] | list[float | tuple[float, ndarray]]</code>           \u2013            <p><code>state_update</code> is True.</p> </li> </ul> Source code in <code>toqito/measurement_ops/measure.py</code> <pre><code>def measure(\n    state: np.ndarray,\n    measurement: np.ndarray | list[np.ndarray] | tuple[np.ndarray, ...],\n    tol: float = 1e-10,\n    state_update: bool = False,\n) -&gt; float | tuple[float, np.ndarray] | list[float | tuple[float, np.ndarray]]:\n    r\"\"\"Apply measurement to a quantum state.\n\n    The measurement can be provided as a single operator (POVM element or Kraus operator) or as a\n    list of operators (assumed to be Kraus operators) describing a complete quantum measurement.\n\n    When a single operator is provided:\n\n      - Returns the measurement outcome probability if ``state_update`` is False.\n      - Returns a tuple (probability, post_state) if ``state_update`` is True.\n\n    When a list of operators is provided, the function verifies that they satisfy the completeness relation when\n    ``state_update`` is True.\n\n    \\[\n        \\sum_i K_i^\\dagger K_i = \\mathbb{I},\n    \\]\n\n    when ``state_update`` is True. Then, for each operator \\(K_i\\), the outcome probability is computed as\n\n    \\[\n        p_i = \\mathrm{Tr}\\Bigl(K_i^\\dagger K_i\\, \\rho\\Bigr),\n    \\]\n\n    and, if \\(p_i &gt; tol\\), the post\u2010measurement state is updated via\n\n    \\[\n        u = \\frac{1}{\\sqrt{3}} e_0 + \\sqrt{\\frac{2}{3}} e_1\n    \\]\n\n    where we define \\(u u^* = \\rho \\in \\text{D}(\\mathcal{X})\\).\n\n    Define measurement operators\n\n    \\[\n        P_0 = e_0 e_0^* \\quad \\text{and} \\quad P_1 = e_1 e_1^*.\n    \\]\n\n    ```python exec=\"1\" source=\"above\"\n    import numpy as np\n    from toqito.states import basis\n    from toqito.measurement_ops import measure\n\n    e_0, e_1 = basis(2, 0), basis(2, 1)\n\n    u = 1/np.sqrt(3) * e_0 + np.sqrt(2/3) * e_1\n    rho = u @ u.conj().T\n\n    proj_0 = e_0 @ e_0.conj().T\n    proj_1 = e_1 @ e_1.conj().T\n    print(measure(proj_0, rho))\n    ```\n\n    Then the probability of obtaining outcome \\(0\\) is given by\n\n    \\[\n        \\langle P_0, \\rho \\rangle = \\frac{1}{3}.\n    \\]\n\n\n    Similarly, the probability of obtaining outcome \\(1\\) is given by\n\n    \\[\n        \\langle P_1, \\rho \\rangle = \\frac{2}{3}.\n    \\]\n\n    ```python exec=\"1\" source=\"above\"\n    import numpy as np\n    from toqito.measurement_ops.measure import measure\n\n    rho = np.array([[0.5, 0.5], [0.5, 0.5]])\n    K0 = np.array([[1, 0], [0, 0]])\n    K1 = np.array([[0, 0], [0, 1]])\n\n    # Returns list of probabilities.\n    print(measure(rho, [K0, K1]))\n\n    # Returns list of (probability, post_state) tuples.\n    print(measure(rho, [K0, K1], state_update=True))\n    ```\n\n\n    Raises:\n        ValueError: If a list of operators does not satisfy the completeness relation.\n\n    Args:\n        state: Quantum state as a density matrix shape (d, d) where d is the dimension of the Hilbert space.\n        measurement: Either a single measurement operator (an np.ndarray) or a list/tuple of operators. When providing a\n        list, they are assumed to be Kraus operators satisfying the completeness relation.\n        tol: Tolerance for numerical precision (default is 1e-10).\n        state_update: If True, also return the post-measurement state(s); otherwise, only the probability or\n        probabilities are returned.\n\n    Returns:\n        If a single operator is provided, returns a float (probability) or a tuple (probability, post_state) if\n        ``state_update`` is True. If a list is provided, returns a list of probabilities or a list of tuples if\n        ``state_update`` is True.\n\n    \"\"\"\n    if not is_density(state):\n        raise ValueError(\"Input must be a valid density matrix.\")\n\n    # Single-operator case.\n    if not isinstance(measurement, (list, tuple)):\n        result = measurement @ state @ measurement.conj().T\n        prob = np.trace(result).real\n        if prob &gt; tol:\n            post_state = result / prob\n        else:\n            post_state = np.zeros_like(state)\n        return (prob, post_state) if state_update else prob\n\n    # List-of-operators case.\n    outcomes: list[float | tuple[float, np.ndarray]] = []\n    probs: list[float] = []\n\n    for op in measurement:\n        result = op @ state @ op.conj().T\n        prob = np.trace(result).real\n        probs.append(prob)\n\n        if prob &gt; tol:\n            post_state = result / prob\n        else:\n            post_state = np.zeros_like(state)\n\n        outcomes.append((prob, post_state) if state_update else prob)\n\n    # Only enforce completeness if we're doing the update AND every outcome was nonzero.\n    if state_update and all(p &gt; tol for p in probs):\n        d = state.shape[0]\n        completeness = sum(op.T.conj() @ op for op in measurement)\n        if not np.allclose(completeness, np.eye(d), atol=tol):\n            raise ValueError(\"Kraus operators do not satisfy completeness relation: \u2211 K\u1d62\u2020K\u1d62 \u2260 I.\")\n\n    return outcomes\n</code></pre>"},{"location":"reference/toqito/measurement_props/","title":"measurement_props","text":""},{"location":"reference/toqito/measurement_props/#toqito.measurement_props","title":"measurement_props","text":"<p>Measurements properties are the modules that are used to implement the properties of measurement operators.</p>"},{"location":"reference/toqito/measurement_props/is_povm/","title":"is_povm","text":""},{"location":"reference/toqito/measurement_props/is_povm/#toqito.measurement_props.is_povm","title":"is_povm","text":"<p>Determine if a list of matrices are POVM elements.</p>"},{"location":"reference/toqito/measurement_props/is_povm/#toqito.measurement_props.is_povm.is_povm","title":"is_povm","text":"<pre><code>is_povm(mat_list: list[ndarray]) -&gt; bool\n</code></pre> <p>Determine if a list of matrices constitute a valid set of POVMs <sup>1</sup>.</p> <p>A valid set of measurements are defined by a set of positive semidefinite operators</p> \\[     \\{P_a : a \\in \\Gamma\\} \\subset \\text{Pos}(\\mathcal{X}), \\] <p>indexed by the alphabet \\(\\Gamma\\) of measurement outcomes satisfying the constraint that</p> \\[     \\sum_{a \\in \\Gamma} P_a = I_{\\mathcal{X}}. \\] <p>Examples:</p> <p>Consider the following matrices:</p> \\[     M_0 =     \\begin{pmatrix}         1 &amp; 0 \\\\         0 &amp; 0     \\end{pmatrix}     \\quad \\text{and} \\quad     M_1 =     \\begin{pmatrix}         0 &amp; 0 \\\\         0 &amp; 1     \\end{pmatrix}. \\] <p>Our function indicates that this set of operators constitute a set of POVMs.</p> <pre><code>import numpy as np\nfrom toqito.measurement_props import is_povm\n\nmeas_1 = np.array([[1, 0], [0, 0]])\nmeas_2 = np.array([[0, 0], [0, 1]])\nmeas = [meas_1, meas_2]\n\nprint(is_povm(meas))\n</code></pre> <p>True</p> <p>We may also use the <code>random_povm</code> function from <code>|toqito\u27e9</code>, and can verify that a randomly generated set satisfies the criteria for being a POVM set.</p> <pre><code>import numpy as np\nfrom toqito.rand import random_povm\nfrom toqito.measurement_props import is_povm\n\ndim, num_inputs, num_outputs = 2, 2, 2\nmeasurements = random_povm(dim, num_inputs, num_outputs)\n\nprint(is_povm([measurements[:, :, 0, 0], measurements[:, :, 0, 1]]))\n</code></pre> <p>True</p> <p>Alternatively, the following matrices</p> \\[     M_0 =     \\begin{pmatrix}         1 &amp; 2 \\\\         3 &amp; 4     \\end{pmatrix}     \\quad \\text{and} \\quad     M_1 =     \\begin{pmatrix}         5 &amp; 6 \\\\         7 &amp; 8     \\end{pmatrix}, \\] <p>do not constitute a POVM set.</p> <pre><code>import numpy as np\nfrom toqito.measurement_props import is_povm\n\nnon_meas_1 = np.array([[1, 2], [3, 4]])\nnon_meas_2 = np.array([[5, 6], [7, 8]])\nnon_meas = [non_meas_1, non_meas_2]\n\nprint(is_povm(non_meas))\n</code></pre> <p>False</p> <p>Parameters:</p> <ul> <li> <code>mat_list</code>               (<code>list[ndarray]</code>)           \u2013            <p>A list of matrices.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Return <code>True</code> if set of matrices constitutes a set of measurements, and <code>False</code> otherwise.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. {POVM}. link.</p> Source code in <code>toqito/measurement_props/is_povm.py</code> <pre><code>def is_povm(mat_list: list[np.ndarray]) -&gt; bool:\n    r\"\"\"Determine if a list of matrices constitute a valid set of POVMs [@WikiPOVM].\n\n    A valid set of measurements are defined by a set of positive semidefinite operators\n\n    \\[\n        \\{P_a : a \\in \\Gamma\\} \\subset \\text{Pos}(\\mathcal{X}),\n    \\]\n\n    indexed by the alphabet \\(\\Gamma\\) of measurement outcomes satisfying the constraint that\n\n    \\[\n        \\sum_{a \\in \\Gamma} P_a = I_{\\mathcal{X}}.\n    \\]\n\n    Examples:\n        Consider the following matrices:\n\n        \\[\n            M_0 =\n            \\begin{pmatrix}\n                1 &amp; 0 \\\\\n                0 &amp; 0\n            \\end{pmatrix}\n            \\quad \\text{and} \\quad\n            M_1 =\n            \\begin{pmatrix}\n                0 &amp; 0 \\\\\n                0 &amp; 1\n            \\end{pmatrix}.\n        \\]\n\n        Our function indicates that this set of operators constitute a set of\n        POVMs.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.measurement_props import is_povm\n\n        meas_1 = np.array([[1, 0], [0, 0]])\n        meas_2 = np.array([[0, 0], [0, 1]])\n        meas = [meas_1, meas_2]\n\n        print(is_povm(meas))\n        ```\n\n        We may also use the `random_povm` function from `|toqito\u27e9`, and can verify that a\n        randomly generated set satisfies the criteria for being a POVM set.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.rand import random_povm\n        from toqito.measurement_props import is_povm\n\n        dim, num_inputs, num_outputs = 2, 2, 2\n        measurements = random_povm(dim, num_inputs, num_outputs)\n\n        print(is_povm([measurements[:, :, 0, 0], measurements[:, :, 0, 1]]))\n        ```\n\n        Alternatively, the following matrices\n\n        \\[\n            M_0 =\n            \\begin{pmatrix}\n                1 &amp; 2 \\\\\n                3 &amp; 4\n            \\end{pmatrix}\n            \\quad \\text{and} \\quad\n            M_1 =\n            \\begin{pmatrix}\n                5 &amp; 6 \\\\\n                7 &amp; 8\n            \\end{pmatrix},\n        \\]\n\n        do not constitute a POVM set.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.measurement_props import is_povm\n\n        non_meas_1 = np.array([[1, 2], [3, 4]])\n        non_meas_2 = np.array([[5, 6], [7, 8]])\n        non_meas = [non_meas_1, non_meas_2]\n\n        print(is_povm(non_meas))\n        ```\n\n    Args:\n        mat_list: A list of matrices.\n\n    Returns:\n        Return `True` if set of matrices constitutes a set of measurements, and `False` otherwise.\n\n    \"\"\"\n    dim = mat_list[0].shape[0]\n\n    mat_sum = np.zeros((dim, dim), dtype=complex)\n    for mat in mat_list:\n        # Each measurement in the set must be positive semidefinite.\n        if not is_positive_semidefinite(mat):\n            return False\n        mat_sum += mat\n    # Summing all the measurements from the set must be equal to the identity.\n    if not np.allclose(np.identity(dim), mat_sum):\n        return False\n    return True\n</code></pre>"},{"location":"reference/toqito/measurements/","title":"measurements","text":""},{"location":"reference/toqito/measurements/#toqito.measurements","title":"measurements","text":"<p>Measurements is a set of modules that are used to compute a set of measurements from an ensemble.</p>"},{"location":"reference/toqito/measurements/pretty_bad_measurement/","title":"pretty_bad_measurement","text":""},{"location":"reference/toqito/measurements/pretty_bad_measurement/#toqito.measurements.pretty_bad_measurement","title":"pretty_bad_measurement","text":"<p>Compute the set of pretty bad measurements from an ensemble.</p>"},{"location":"reference/toqito/measurements/pretty_bad_measurement/#toqito.measurements.pretty_bad_measurement.pretty_bad_measurement","title":"pretty_bad_measurement","text":"<pre><code>pretty_bad_measurement(states: list[ndarray], probs: list[float] | None = None, tol: float = 1e-08) -&gt; list[ndarray]\n</code></pre> <p>Return the set of pretty bad measurements from a set of vectors and corresponding probabilities.</p> <p>This computes the \"pretty bad measurement\" (PBM) as defined in <sup>1</sup>. The PBM is an analogue to the \"pretty good measurement\" defined in [@Belavkin_1975_Optimal,Hughston_1993_Complete] and is useful for approximating the optimal measurement for state exclusion.</p> <p>The PBM is defined in terms of the pretty good measurement (PGM). Given the PGM operators \\((G_1, \\ldots, G_n)\\), the corresponding PBM is the set of POVMs \\((B_1, \\ldots, B_n)\\) where</p> \\[     B_i = \\frac{1}{n - 1} \\left(\\mathbb{I} - G_i\\right). \\] <p>See</p> <p>pretty_good_measurement()</p> <p>Examples:</p> <p>Consider the collection of trine states.</p> \\[     u_0 = |0\\rangle, \\quad     u_1 = -\\frac{1}{2}\\left(|0\\rangle + \\sqrt{3}|1\\rangle\\right), \\quad \\text{and} \\quad     u_2 = -\\frac{1}{2}\\left(|0\\rangle - \\sqrt{3}|1\\rangle\\right). \\] <pre><code>from toqito.states import trine\nfrom toqito.measurements import pretty_bad_measurement\n\nstates = trine()\nprobs = [1 / 3, 1 / 3, 1 / 3]\npbm = pretty_bad_measurement(states, probs)\nprint(pbm)\n</code></pre> <p>[array([[0.16666667, 0.        ],        [0.        , 0.5       ]]), array([[ 0.41666667, -0.14433757],        [-0.14433757,  0.25      ]]), array([[0.41666667, 0.14433757],        [0.14433757, 0.25      ]])]</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If number of states does not match number of probabilities.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If probabilities do not sum to 1.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>states</code>               (<code>list[ndarray]</code>)           \u2013            <p>A collection of states provided as either vectors or density matrices.</p> </li> <li> <code>probs</code>               (<code>list[float] | None</code>, default:                   <code>None</code> )           \u2013            <p>A set of fixed probabilities for each quantum state. If not provided, a uniform distribution is assumed.</p> </li> <li> <code>tol</code>               (<code>float</code>, default:                   <code>1e-08</code> )           \u2013            <p>A tolerance value for numerical comparisons.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[ndarray]</code>           \u2013            <p>A list of POVM operators for the PBM.</p> </li> </ul> <p>References</p> <p><sup>1</sup> McIrvin, Caleb and Mohan, Ankith and Sikora, Jamie. The pretty bad measurement. (2024).</p> Source code in <code>toqito/measurements/pretty_bad_measurement.py</code> <pre><code>def pretty_bad_measurement(\n    states: list[np.ndarray], probs: list[float] | None = None, tol: float = 1e-8\n) -&gt; list[np.ndarray]:\n    r\"\"\"Return the set of pretty bad measurements from a set of vectors and corresponding probabilities.\n\n    This computes the \"pretty bad measurement\" (PBM) as defined in\n    [@McIrvin_2024_Pretty]. The PBM is an analogue to the \"pretty\n    good measurement\" defined in [@Belavkin_1975_Optimal,Hughston_1993_Complete]\n    and is useful for approximating the optimal measurement\n    for state exclusion.\n\n    The PBM is defined in terms of the pretty good measurement (PGM).\n    Given the PGM operators \\((G_1, \\ldots, G_n)\\), the corresponding PBM\n    is the set of POVMs \\((B_1, \\ldots, B_n)\\) where\n\n    \\[\n        B_i = \\frac{1}{n - 1} \\left(\\mathbb{I} - G_i\\right).\n    \\]\n\n    !!! See Also\n        [pretty_good_measurement()][toqito.measurements.pretty_good_measurement.pretty_good_measurement]\n\n    Examples:\n        Consider the collection of trine states.\n\n        \\[\n            u_0 = |0\\rangle, \\quad\n            u_1 = -\\frac{1}{2}\\left(|0\\rangle + \\sqrt{3}|1\\rangle\\right), \\quad \\text{and} \\quad\n            u_2 = -\\frac{1}{2}\\left(|0\\rangle - \\sqrt{3}|1\\rangle\\right).\n        \\]\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import trine\n        from toqito.measurements import pretty_bad_measurement\n\n        states = trine()\n        probs = [1 / 3, 1 / 3, 1 / 3]\n        pbm = pretty_bad_measurement(states, probs)\n        print(pbm)\n        ```\n\n    Raises:\n        ValueError: If number of states does not match number of probabilities.\n        ValueError: If probabilities do not sum to 1.\n\n    Args:\n        states: A collection of states provided as either vectors or density matrices.\n        probs: A set of fixed probabilities for each quantum state. If not provided, a uniform distribution is assumed.\n        tol: A tolerance value for numerical comparisons.\n\n    Returns:\n        A list of POVM operators for the PBM.\n\n    \"\"\"\n    n = len(states)\n\n    # If not probabilities are explicitly given, assume a uniform distribution.\n    if probs is None:\n        probs = n * [1 / n]\n\n    if len(states) != len(probs):\n        raise ValueError(f\"Number of states {len(states)} must be equal to number of probabilities {len(probs)}\")\n\n    if not np.isclose(sum(probs), 1):\n        raise ValueError(\"Probability vector should sum to 1.\")\n\n    pbm = pretty_good_measurement(states, probs, tol=tol)\n    dim = pbm[0].shape[0]\n\n    return [1 / (n - 1) * (np.identity(dim) - pbm[i]) for i in range(n)]\n</code></pre>"},{"location":"reference/toqito/measurements/pretty_good_measurement/","title":"pretty_good_measurement","text":""},{"location":"reference/toqito/measurements/pretty_good_measurement/#toqito.measurements.pretty_good_measurement","title":"pretty_good_measurement","text":"<p>Compute the set of pretty good measurements from an ensemble.</p>"},{"location":"reference/toqito/measurements/pretty_good_measurement/#toqito.measurements.pretty_good_measurement.pretty_good_measurement","title":"pretty_good_measurement","text":"<pre><code>pretty_good_measurement(states: list[ndarray], probs: list[float] | None = None, tol: float = 1e-08) -&gt; list[ndarray]\n</code></pre> <p>Return the set of pretty good measurements from a set of vectors and corresponding probabilities.</p> <p>This computes the \"pretty good measurement\" (PGM), also known as the square-root measurement, which is a widely used measurement for quantum state discrimination [@Belavkin_1975_Optimal,Hughston_1993_Complete].</p> <p>The PGM is the set of POVMs \\((G_1, \\ldots, G_n)\\) such that</p> \\[     G_i = P^{-1/2} \\left(p_i \\rho_i\\right) P^{-1/2} \\quad \\text{where} \\quad     P = \\sum_{i=1}^n p_i \\rho_i. \\] <p>See</p> <p>pretty_bad_measurement()</p> <p>Examples:</p> <p>Consider the collection of trine states.</p> \\[     u_0 = |0\\rangle, \\quad     u_1 = -\\frac{1}{2}\\left(|0\\rangle + \\sqrt{3}|1\\rangle\\right), \\quad \\text{and} \\quad     u_2 = -\\frac{1}{2}\\left(|0\\rangle - \\sqrt{3}|1\\rangle\\right). \\] <pre><code>from toqito.states import trine\nfrom toqito.measurements import pretty_good_measurement\n\nstates = trine()\nprobs = [1 / 3, 1 / 3, 1 / 3]\npgm = pretty_good_measurement(states, probs)\nprint(pgm)\n</code></pre> <p>[array([[0.66666667, 0.        ],        [0.        , 0.        ]]), array([[0.16666667, 0.28867513],        [0.28867513, 0.5       ]]), array([[ 0.16666667, -0.28867513],        [-0.28867513,  0.5       ]])]</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If number of vectors does not match number of probabilities.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If probabilities do not sum to 1.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>states</code>               (<code>list[ndarray]</code>)           \u2013            <p>A collection of states provided as either vectors or density matrices.</p> </li> <li> <code>probs</code>               (<code>list[float] | None</code>, default:                   <code>None</code> )           \u2013            <p>A set of fixed probabilities for each quantum state. If not provided, a uniform distribution is assumed.</p> </li> <li> <code>tol</code>               (<code>float</code>, default:                   <code>1e-08</code> )           \u2013            <p>A tolerance value for numerical comparisons.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[ndarray]</code>           \u2013            <p>A list of POVM operators for the PGM.</p> </li> </ul> Source code in <code>toqito/measurements/pretty_good_measurement.py</code> <pre><code>def pretty_good_measurement(\n    states: list[np.ndarray], probs: list[float] | None = None, tol: float = 1e-8\n) -&gt; list[np.ndarray]:\n    r\"\"\"Return the set of pretty good measurements from a set of vectors and corresponding probabilities.\n\n    This computes the \"pretty good measurement\" (PGM), also known as the\n    square-root measurement, which is a widely used measurement for quantum\n    state discrimination [@Belavkin_1975_Optimal,Hughston_1993_Complete].\n\n    The PGM is the set of POVMs \\((G_1, \\ldots, G_n)\\) such that\n\n    \\[\n        G_i = P^{-1/2} \\left(p_i \\rho_i\\right) P^{-1/2} \\quad \\text{where} \\quad\n        P = \\sum_{i=1}^n p_i \\rho_i.\n    \\]\n\n    !!! See Also\n        [pretty_bad_measurement()][toqito.measurements.pretty_bad_measurement.pretty_bad_measurement]\n\n    Examples:\n        Consider the collection of trine states.\n\n        \\[\n            u_0 = |0\\rangle, \\quad\n            u_1 = -\\frac{1}{2}\\left(|0\\rangle + \\sqrt{3}|1\\rangle\\right), \\quad \\text{and} \\quad\n            u_2 = -\\frac{1}{2}\\left(|0\\rangle - \\sqrt{3}|1\\rangle\\right).\n        \\]\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import trine\n        from toqito.measurements import pretty_good_measurement\n\n        states = trine()\n        probs = [1 / 3, 1 / 3, 1 / 3]\n        pgm = pretty_good_measurement(states, probs)\n        print(pgm)\n        ```\n\n    Raises:\n        ValueError: If number of vectors does not match number of probabilities.\n        ValueError: If probabilities do not sum to 1.\n\n    Args:\n        states: A collection of states provided as either vectors or density matrices.\n        probs: A set of fixed probabilities for each quantum state. If not provided, a uniform distribution is assumed.\n        tol: A tolerance value for numerical comparisons.\n\n    Returns:\n        A list of POVM operators for the PGM.\n\n    \"\"\"\n    n = len(states)\n\n    # If not probabilities are explicitly given, assume a uniform distribution.\n    if probs is None:\n        probs = n * [1 / n]\n\n    if len(states) != len(probs):\n        raise ValueError(f\"Number of states {len(states)} must be equal to number of probabilities {len(probs)}\")\n\n    if not np.isclose(sum(probs), 1):\n        raise ValueError(\"Probability vector should sum to 1.\")\n\n    states = [to_density_matrix(state) for state in states]\n\n    # 1. Assemble the average state.\n    p_var = sum(probs[i] * states[i] for i in range(n))\n\n    # 2. Diagonalize.\n    vals, vecs = np.linalg.eigh(p_var)\n\n    # 3. Invert only the non\u2011zero eigenvalues.\n    inv_sqrt_vals = np.array([1 / np.sqrt(v) if v &gt; tol else 0.0 for v in vals])\n\n    # 4. Reconstruct P^{-1/2}.\n    P_inv_sqrt = vecs @ np.diag(inv_sqrt_vals) @ vecs.conj().T\n\n    # 5. Build PGM measurements.\n    return [P_inv_sqrt @ (probs[i] * states[i]) @ P_inv_sqrt for i in range(n)]\n</code></pre>"},{"location":"reference/toqito/nonlocal_games/","title":"nonlocal_games","text":""},{"location":"reference/toqito/nonlocal_games/#toqito.nonlocal_games","title":"nonlocal_games","text":"<p>A number of nonlocal game-related functions for toqito.</p>"},{"location":"reference/toqito/nonlocal_games/binary_constraint_system_game/","title":"binary_constraint_system_game","text":""},{"location":"reference/toqito/nonlocal_games/binary_constraint_system_game/#toqito.nonlocal_games.binary_constraint_system_game","title":"binary_constraint_system_game","text":"<p>Two-player binary constraint system (BCS) game.</p>"},{"location":"reference/toqito/nonlocal_games/binary_constraint_system_game/#toqito.nonlocal_games.binary_constraint_system_game.create_bcs_constraints","title":"create_bcs_constraints","text":"<pre><code>create_bcs_constraints(M: ndarray, b: ndarray) -&gt; list[ndarray]\n</code></pre> <p>Construct a list of constraints in tensor form for a binary constraint system (BCS) game.</p> <p>This function builds a list of constraints by converting each row of the binary matrix <code>M</code> of shape (m, n) and the corresponding element of the binary vector <code>b</code> into an n-dimensional tensor of shape (2, 2, ..., 2) (one axis per variable).</p> <p>The conversion works as follows:</p> <ol> <li>For the i-th constraint, compute the constant value as <code>rhs = (-1)**(b[i])</code>.</li> <li>Create an n-dimensional array (tensor) of shape <code>(2,)*n</code> filled with <code>-rhs</code>.</li> <li>Compute the index from the first n entries of the i-th row of <code>M</code> by taking each value modulo 2.</li> <li>Set the tensor element at that index to <code>rhs</code>.</li> </ol> <p>For example: If <code>M[i] = [1, 1]</code> and <code>b[i] = 0</code> (so <code>rhs = 1</code>): The tensor is of shape (2, 2) and is created as:</p> <p>np.array([[-1, -1], [-1, -1]]</p> <p>The index is computed as <code>(1 % 2, 1 % 2) = (1, 1)</code>. At position (1, 1), the value is set to 1, resulting in:</p> <p>np.array([[-1, -1], [-1, 1]]</p> <p>This tensor now represents the constraint in full detail.</p> <p>Parameters:</p> <ul> <li> <code>M</code>               (<code>ndarray</code>)           \u2013            <p>A 2D binary NumPy array of shape (m, n). Each row represents a constraint on n variables.</p> </li> <li> <code>b</code>               (<code>ndarray</code>)           \u2013            <p>A 1D binary array of length m. Each entry defines the sign of the constraint.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[ndarray]</code>           \u2013            <p>A list of NumPy arrays, each of shape <code>(2,)*n</code>. Each tensor represents one constraint in tensor form.</p> </li> </ul> <p>Examples:</p> <pre><code>import numpy as np\nfrom toqito.nonlocal_games.binary_constraint_system_game import create_bcs_constraints\n\nM = np.array([[1, 1], [1, 1]], dtype=int)\nb = np.array([0, 1], dtype=int)\nconstraints = create_bcs_constraints(M, b)\nprint(constraints[0].shape)\n</code></pre> <p>(2, 2)</p> Source code in <code>toqito/nonlocal_games/binary_constraint_system_game.py</code> <pre><code>def create_bcs_constraints(M: np.ndarray, b: np.ndarray) -&gt; list[np.ndarray]:\n    r\"\"\"Construct a list of constraints in tensor form for a binary constraint system (BCS) game.\n\n    This function builds a list of constraints by converting each row of the binary matrix\n    ``M`` of shape (m, n) and the corresponding element of the binary vector ``b``\n    into an n-dimensional tensor of shape (2, 2, ..., 2) (one axis per variable).\n\n    The conversion works as follows:\n\n      1. For the i-th constraint, compute the constant value as ``rhs = (-1)**(b[i])``.\n      2. Create an n-dimensional array (tensor) of shape ``(2,)*n`` filled with ``-rhs``.\n      3. Compute the index from the first n entries of the i-th row of ``M`` by taking each value modulo 2.\n      4. Set the tensor element at that index to ``rhs``.\n\n    For example:\n    If ``M[i] = [1, 1]`` and ``b[i] = 0`` (so ``rhs = 1``):\n    The tensor is of shape (2, 2) and is created as:\n\n    np.array([[-1, -1], [-1, -1]]\n\n    The index is computed as ``(1 % 2, 1 % 2) = (1, 1)``.\n    At position (1, 1), the value is set to 1, resulting in:\n\n    np.array([[-1, -1], [-1, 1]]\n\n    This tensor now represents the constraint in full detail.\n\n    Args:\n        M: A 2D binary NumPy array of shape (m, n). Each row represents a constraint on n variables.\n        b: A 1D binary array of length m. Each entry defines the sign of the constraint.\n\n    Returns:\n        A list of NumPy arrays, each of shape ``(2,)*n``. Each tensor represents one constraint in tensor form.\n\n    Examples:\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.nonlocal_games.binary_constraint_system_game import create_bcs_constraints\n\n        M = np.array([[1, 1], [1, 1]], dtype=int)\n        b = np.array([0, 1], dtype=int)\n        constraints = create_bcs_constraints(M, b)\n        print(constraints[0].shape)\n        ```\n\n    \"\"\"\n    m, n = M.shape\n    constraints = []\n    for i in range(m):\n        rhs = (-1) ** b[i]\n        constraint_tensor = np.full((2,) * n, fill_value=-rhs, dtype=int)\n        idx = tuple(M[i] % 2)\n        constraint_tensor[idx] = rhs\n        constraints.append(constraint_tensor)\n    return constraints\n</code></pre>"},{"location":"reference/toqito/nonlocal_games/binary_constraint_system_game/#toqito.nonlocal_games.binary_constraint_system_game.generate_solution_group","title":"generate_solution_group","text":"<pre><code>generate_solution_group(M: ndarray, b: ndarray) -&gt; tuple[list[int], list[int]]\n</code></pre> <p>Generate a bitmask representation for a binary constraint system (BCS) game.</p> <p>This function converts each row of the binary matrix <code>M</code> into an integer bitmask, pairing it with the corresponding parity from <code>b</code>. The bitmask representation can be useful for analyzing linear system games.</p> <p>Notes The method used to determine the existence of a perfect commuting strategy was originally introduced in <sup>1</sup>.</p> <p>Examples:</p> <pre><code>import numpy as np\nfrom toqito.nonlocal_games.binary_constraint_system_game import generate_solution_group\n\nM = np.array([[1, 1, 0], [0, 1, 1]])\nb = np.array([0, 1])\nrow_masks, parity = generate_solution_group(M, b)\nprint(row_masks)  # Output: [3, 6]\nprint(parity)     # Output: [0, 1]\n</code></pre> <p>[3, 6][0, 1]</p> <p>Parameters:</p> <ul> <li> <code>M</code>               (<code>ndarray</code>)           \u2013            <p>A binary matrix of shape (m, n).Each row encodes which variables appear in a constraint.</p> </li> <li> <code>b</code>               (<code>ndarray</code>)           \u2013            <p>A binary vector of length m.Each entry determines the parity for its corresponding constraint row.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[int]</code>           \u2013            <p>A list of integer bitmasks.</p> </li> <li> <code>list[int]</code>           \u2013            <p>A list of parity values.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Cleve, Richard and Liu, Li and Slofstra, William. Perfect commuting-operator strategies for linear system games. Journal of Mathematical Physics. vol. 58. (2016). doi:10.1063/1.4973422.</p> Source code in <code>toqito/nonlocal_games/binary_constraint_system_game.py</code> <pre><code>def generate_solution_group(M: np.ndarray, b: np.ndarray) -&gt; tuple[list[int], list[int]]:\n    r\"\"\"Generate a bitmask representation for a binary constraint system (BCS) game.\n\n    This function converts each row of the binary matrix ``M`` into an integer bitmask,\n    pairing it with the corresponding parity from ``b``. The bitmask representation\n    can be useful for analyzing linear system games.\n\n    Notes\n    The method used to determine the existence of a perfect commuting strategy was originally introduced\n    in [@Cleve_2016_Perfect].\n\n    Examples:\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.nonlocal_games.binary_constraint_system_game import generate_solution_group\n\n        M = np.array([[1, 1, 0], [0, 1, 1]])\n        b = np.array([0, 1])\n        row_masks, parity = generate_solution_group(M, b)\n        print(row_masks)  # Output: [3, 6]\n        print(parity)     # Output: [0, 1]\n        ```\n\n    Args:\n        M: A binary matrix of shape (m, n).Each row encodes which variables appear in a constraint.\n        b: A binary vector of length m.Each entry determines the parity for its corresponding constraint row.\n\n    Returns:\n        A list of integer bitmasks.\n        A list of parity values.\n\n    \"\"\"\n    # Ensure M and b are binary.\n    M = np.array(M, dtype=int) % 2\n    b = np.array(b, dtype=int) % 2\n\n    # Create an array of powers of 2 for each column: [1, 2, 4, ..., 2^(n-1)].\n    powers = 1 &lt;&lt; np.arange(M.shape[1])\n    return (M * powers).sum(axis=1).astype(int).tolist(), b.astype(int).tolist()\n</code></pre>"},{"location":"reference/toqito/nonlocal_games/binary_constraint_system_game/#toqito.nonlocal_games.binary_constraint_system_game.check_perfect_commuting_strategy","title":"check_perfect_commuting_strategy","text":"<pre><code>check_perfect_commuting_strategy(M: ndarray, b: ndarray) -&gt; bool\n</code></pre> <p>Determine whether a perfect commuting-operator strategy exists for a BCS game.</p> <p>This function checks if the binary constraint system defined by <code>Mx = b</code> admits a perfect commuting-operator strategy. It converts the constraints to bitmask form, performs Gaussian elimination over \\(\\mathrm{GF}(2)\\), and examines the resulting constraint graph for cycles that indicate a nontrivial solution.</p> <p>Parameters:</p> <ul> <li> <code>M</code>               (<code>ndarray</code>)           \u2013            <p>A binary matrix representing a system of parity constraints.</p> </li> <li> <code>b</code>               (<code>ndarray</code>)           \u2013            <p>A binary vector representing the right-hand side of the constraint equations.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if a perfect commuting-operator strategy exists; otherwise, <code>False</code>.</p> </li> </ul> <p>Examples:</p> <pre><code>import numpy as np\nfrom toqito.nonlocal_games.binary_constraint_system_game import check_perfect_commuting_strategy\n\nM = np.array([[1, 1], [1, 1]])\nb = np.array([0, 1])\nprint(check_perfect_commuting_strategy(M, b))\n</code></pre> <p>False</p> Source code in <code>toqito/nonlocal_games/binary_constraint_system_game.py</code> <pre><code>def check_perfect_commuting_strategy(M: np.ndarray, b: np.ndarray) -&gt; bool:\n    r\"\"\"Determine whether a perfect commuting-operator strategy exists for a BCS game.\n\n    This function checks if the binary constraint system defined by ``Mx = b``\n    admits a perfect commuting-operator strategy. It converts the constraints\n    to bitmask form, performs Gaussian elimination over \\(\\mathrm{GF}(2)\\),\n    and examines the resulting constraint graph for cycles that indicate a nontrivial\n    solution.\n\n    Args:\n        M: A binary matrix representing a system of parity constraints.\n        b: A binary vector representing the right-hand side of the constraint equations.\n\n    Returns:\n        ``True`` if a perfect commuting-operator strategy exists; otherwise, ``False``.\n\n    Examples:\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.nonlocal_games.binary_constraint_system_game import check_perfect_commuting_strategy\n\n        M = np.array([[1, 1], [1, 1]])\n        b = np.array([0, 1])\n        print(check_perfect_commuting_strategy(M, b))\n        ```\n\n    \"\"\"\n    row, parity = generate_solution_group(M, b)\n    m = len(row)\n    combo = [1 &lt;&lt; i for i in range(m)]\n\n    pivot = 0\n    n = M.shape[1] if m &gt; 0 else 0\n\n    # Perform Gaussian elimination in GF(2):\n    for j in range(n):\n        pivot_row = next((r for r in range(pivot, m) if row[r] &amp; (1 &lt;&lt; j)), None)\n        if pivot_row is None:\n            continue\n        row[pivot], row[pivot_row] = row[pivot_row], row[pivot]\n        parity[pivot], parity[pivot_row] = parity[pivot_row], parity[pivot]\n        combo[pivot], combo[pivot_row] = combo[pivot_row], combo[pivot]\n\n        for i in range(m):\n            if i != pivot and (row[i] &amp; (1 &lt;&lt; j)):\n                row[i] ^= row[pivot]\n                parity[i] ^= parity[pivot]\n                combo[i] ^= combo[pivot]\n\n        pivot += 1\n        if pivot == m:\n            break\n\n    # Check for contradiction: a row with 0 = 1.\n    contradiction = next((combo[r] for r in range(m) if row[r] == 0 and parity[r] == 1), None)\n    if contradiction is None:\n        return True  # no contradiction \u2192 perfect strategy exists.\n\n    # Build the subgraph of nodes involved in a contradiction.\n    nodes = [r for r in range(m) if (contradiction &gt;&gt; r) &amp; 1]\n    G = nx.Graph()\n    G.add_nodes_from(nodes)\n\n    # Add edges where two constraints share a variable.\n    edges = [(u, v) for i, u in enumerate(nodes) for v in nodes[i + 1 :] if row[u] &amp; row[v]]\n    G.add_edges_from(edges)\n    return bool(nx.cycle_basis(G))\n</code></pre>"},{"location":"reference/toqito/nonlocal_games/extended_nonlocal_game/","title":"extended_nonlocal_game","text":""},{"location":"reference/toqito/nonlocal_games/extended_nonlocal_game/#toqito.nonlocal_games.extended_nonlocal_game","title":"extended_nonlocal_game","text":"<p>Two-player extended nonlocal game.</p>"},{"location":"reference/toqito/nonlocal_games/extended_nonlocal_game/#toqito.nonlocal_games.extended_nonlocal_game.ExtendedNonlocalGame","title":"ExtendedNonlocalGame","text":"<pre><code>ExtendedNonlocalGame(prob_mat: ndarray, pred_mat: ndarray, reps: int = 1)\n</code></pre> <p>Create two-player extended nonlocal game object.</p> <p>Extended nonlocal games are a superset of nonlocal games in which the players share a tripartite state with the referee. In such games, the winning conditions for Alice and Bob may depend on outcomes of measurements made by the referee, on its part of the shared quantum state, in addition to Alice and Bob's answers to the questions sent by the referee.</p> <p>Extended nonlocal games were initially defined in <sup>1</sup> and more information on these games can be found in <sup>2</sup>.</p> <p>For a detailed walkthrough and several examples, including the BB84 and CHSH games, please see the tutorial on Extended Nonlocal Games.</p> <p>References</p> <p><sup>1</sup> Johnston, Nathaniel and Mittal, Rajat and Russo, Vincent and Watrous, John. Extended non-local games and monogamy-of-entanglement games. Proceedings of the Royal Society A: Mathematical, Physical and Engineering Sciences. vol. 472(2189). (2016). link. <sup>2</sup> Russo, Vincent. Extended Nonlocal Games. (2017).</p> <p>Construct extended nonlocal game object.</p> <p>Parameters:</p> <ul> <li> <code>prob_mat</code>               (<code>ndarray</code>)           \u2013            <p>A matrix whose (x, y)-entry gives the probability that the referee will give Alice the value <code>x</code></p> </li> <li> <code>pred_mat</code>               (<code>ndarray</code>)           \u2013            <p>A matrix representing the predictions for the game.</p> </li> <li> <code>reps</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Number of parallel repetitions to perform.</p> </li> </ul> Source code in <code>toqito/nonlocal_games/extended_nonlocal_game.py</code> <pre><code>def __init__(self, prob_mat: np.ndarray, pred_mat: np.ndarray, reps: int = 1) -&gt; None:\n    \"\"\"Construct extended nonlocal game object.\n\n    Args:\n        prob_mat: A matrix whose (x, y)-entry gives the probability that the referee will give Alice the value `x`\n        and Bob the value `y`.\n        pred_mat: A matrix representing the predictions for the game.\n        reps: Number of parallel repetitions to perform.\n\n    \"\"\"\n    if reps == 1:\n        self.prob_mat = prob_mat\n        self.pred_mat = pred_mat\n        self.reps = reps\n\n    else:\n        (\n            self.dim_x,\n            self.dim_y,\n            self.num_alice_out,\n            self.num_bob_out,\n            self.num_alice_in,\n            self.num_bob_in,\n        ) = pred_mat.shape\n        self.prob_mat = tensor(prob_mat, reps)\n\n        pred_mat2 = np.zeros(\n            (\n                self.dim_x**reps,\n                self.dim_y**reps,\n                self.num_alice_out**reps,\n                self.num_bob_out**reps,\n                self.num_alice_in**reps,\n                self.num_bob_in**reps,\n            )\n        )\n        i_ind = np.zeros(reps, dtype=int)\n        j_ind = np.zeros(reps, dtype=int)\n        for i in range(self.num_alice_in**reps):\n            for j in range(self.num_bob_in**reps):\n                to_tensor = np.empty([reps, self.dim_x, self.dim_y, self.num_alice_out, self.num_bob_out])\n                for k in range(reps - 1, -1, -1):\n                    to_tensor[k] = pred_mat[:, :, :, :, i_ind[k], j_ind[k]]\n                pred_mat2[:, :, :, :, i, j] = tensor(to_tensor)\n                j_ind = update_odometer(j_ind, self.num_bob_in * np.ones(reps))\n            i_ind = update_odometer(i_ind, self.num_alice_in * np.ones(reps))\n        self.pred_mat = pred_mat2\n        self.reps = reps\n    self.__get_game_dims()\n</code></pre>"},{"location":"reference/toqito/nonlocal_games/extended_nonlocal_game/#toqito.nonlocal_games.extended_nonlocal_game.ExtendedNonlocalGame.__get_game_dims","title":"__get_game_dims","text":"<pre><code>__get_game_dims()\n</code></pre> <p>Initialize game dimensions from the prediction matrix.</p> <p>This private method checks whether the game dimensions have already been initialized by inspecting the <code>_dims_initialized_by_get_game_dims</code> flag. If not, it extracts the dimensions from the shape of 'self.pred_mat' and assigns the following instance attributes:</p> <ul> <li>referee_dim: The first dimension of self.pred_mat.</li> <li>num_alice_out: The third element of self.pred_mat.shape.</li> <li>num_bob_out: The fourth element.</li> <li>num_alice_in: The fifth element.</li> <li>num_bob_in: The sixth element.</li> </ul> <p>After extracting these values, the flag '_dims_initialized_by_get_game_dims' is set to True to prevent re-initialization on subsequent calls.</p> Source code in <code>toqito/nonlocal_games/extended_nonlocal_game.py</code> <pre><code>def __get_game_dims(self):\n    \"\"\"Initialize game dimensions from the prediction matrix.\n\n    This private method checks whether the game dimensions have already been initialized by\n    inspecting the `_dims_initialized_by_get_game_dims` flag. If not, it extracts the dimensions\n    from the shape of 'self.pred_mat' and assigns the following instance attributes:\n\n      - referee_dim: The first dimension of self.pred_mat.\n      - num_alice_out: The third element of self.pred_mat.shape.\n      - num_bob_out: The fourth element.\n      - num_alice_in: The fifth element.\n      - num_bob_in: The sixth element.\n\n    After extracting these values, the flag '_dims_initialized_by_get_game_dims' is set to True\n    to prevent re-initialization on subsequent calls.\n    \"\"\"\n    if not hasattr(self, \"_dims_initialized_by_get_game_dims\") or not self._dims_initialized_by_get_game_dims:\n        (\n            self.referee_dim,\n            _,\n            self.num_alice_out,\n            self.num_bob_out,\n            self.num_alice_in,\n            self.num_bob_in,\n        ) = self.pred_mat.shape\n        self._dims_initialized_by_get_game_dims = True\n</code></pre>"},{"location":"reference/toqito/nonlocal_games/extended_nonlocal_game/#toqito.nonlocal_games.extended_nonlocal_game.ExtendedNonlocalGame.unentangled_value","title":"unentangled_value","text":"<pre><code>unentangled_value() -&gt; float\n</code></pre> <p>Calculate the unentangled value of an extended nonlocal game.</p> <p>The unentangled value of an extended nonlocal game is the supremum value for Alice and Bob's winning probability in the game over all unentangled strategies. Due to convexity and compactness, it is possible to calculate the unentangled extended nonlocal game by:</p> \\[     \\omega(G) = \\max_{f, g}     \\lVert     \\sum_{(x,y) \\in \\Sigma_A \\times \\Sigma_B} \\pi(x,y)     V(f(x), g(y)|x, y)     \\rVert \\] <p>where the maximum is over all functions \\(f : \\Sigma_A \\rightarrow \\Gamma_A\\) and \\(g : \\Sigma_B \\rightarrow \\Gamma_B\\).</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The unentangled value of the extended nonlocal game.</p> </li> </ul> Source code in <code>toqito/nonlocal_games/extended_nonlocal_game.py</code> <pre><code>def unentangled_value(self) -&gt; float:\n    r\"\"\"Calculate the unentangled value of an extended nonlocal game.\n\n    The *unentangled value* of an extended nonlocal game is the supremum\n    value for Alice and Bob's winning probability in the game over all\n    unentangled strategies. Due to convexity and compactness, it is possible\n    to calculate the unentangled extended nonlocal game by:\n\n    \\[\n        \\omega(G) = \\max_{f, g}\n        \\lVert\n        \\sum_{(x,y) \\in \\Sigma_A \\times \\Sigma_B} \\pi(x,y)\n        V(f(x), g(y)|x, y)\n        \\rVert\n    \\]\n\n    where the maximum is over all functions \\(f : \\Sigma_A \\rightarrow\n    \\Gamma_A\\) and \\(g : \\Sigma_B \\rightarrow \\Gamma_B\\).\n\n    Returns:\n        The unentangled value of the extended nonlocal game.\n\n    \"\"\"\n    dim_x, dim_y, alice_out, bob_out, alice_in, bob_in = self.pred_mat.shape\n\n    max_unent_val = float(\"-inf\")\n    for f_alice in itertools.product(range(alice_out), repeat=alice_in):\n        for g_bob in itertools.product(range(bob_out), repeat=bob_in):\n            p_win = np.zeros([dim_x, dim_y], dtype=complex)\n            for x_in in range(alice_in):\n                for y_in in range(bob_in):\n                    p_win += self.prob_mat[x_in, y_in] * self.pred_mat[:, :, f_alice[x_in], g_bob[y_in], x_in, y_in]\n\n            unent_val = max(np.linalg.eigvalsh(p_win))\n            max_unent_val = max(max_unent_val, unent_val)\n    return float(max_unent_val)\n</code></pre>"},{"location":"reference/toqito/nonlocal_games/extended_nonlocal_game/#toqito.nonlocal_games.extended_nonlocal_game.ExtendedNonlocalGame.nonsignaling_value","title":"nonsignaling_value","text":"<pre><code>nonsignaling_value() -&gt; float\n</code></pre> <p>Calculate the non-signaling value of an extended nonlocal game.</p> <p>The non-signaling value of an extended nonlocal game is the supremum value of the winning probability of the game taken over all non-signaling strategies for Alice and Bob.</p> <p>A non-signaling strategy for an extended nonlocal game consists of a function</p> \\[     K : \\Gamma_A \\times \\Gamma_B \\times \\Sigma_A \\times \\Sigma_B     \\rightarrow \\text{Pos}(\\mathcal{R}) \\] <p>such that</p> \\[     \\sum_{a \\in \\Gamma_A} K(a,b|x,y) = \\rho_b^y     \\quad \\text{and} \\quad     \\sum_{b \\in \\Gamma_B} K(a,b|x,y) = \\sigma_a^x, \\] <p>for all \\(x \\in \\Sigma_A\\) and \\(y \\in \\Sigma_B\\) where \\(\\{\\rho_b^y : y \\in \\Sigma_A, \\ b \\in \\Gamma_B\\}\\) and \\(\\{\\sigma_a^x : x \\in \\Sigma_A, \\ a \\in \\Gamma_B\\}\\) are collections of operators satisfying</p> \\[     \\sum_{a \\in \\Gamma_A} \\rho_b^y =     \\tau =     \\sum_{b \\in \\Gamma_B} \\sigma_a^x, \\] <p>for every choice of \\(x \\in \\Sigma_A\\) and \\(y \\in \\Sigma_B\\) where \\(\\tau \\in \\text{D}(\\mathcal{R})\\) is a density operator.</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The non-signaling value of the extended nonlocal game.</p> </li> </ul> Source code in <code>toqito/nonlocal_games/extended_nonlocal_game.py</code> <pre><code>def nonsignaling_value(self) -&gt; float:\n    r\"\"\"Calculate the non-signaling value of an extended nonlocal game.\n\n    The *non-signaling value* of an extended nonlocal game is the supremum\n    value of the winning probability of the game taken over all\n    non-signaling strategies for Alice and Bob.\n\n    A *non-signaling strategy* for an extended nonlocal game consists of a\n    function\n\n    \\[\n        K : \\Gamma_A \\times \\Gamma_B \\times \\Sigma_A \\times \\Sigma_B\n        \\rightarrow \\text{Pos}(\\mathcal{R})\n    \\]\n\n    such that\n\n    \\[\n        \\sum_{a \\in \\Gamma_A} K(a,b|x,y) = \\rho_b^y\n        \\quad \\text{and} \\quad\n        \\sum_{b \\in \\Gamma_B} K(a,b|x,y) = \\sigma_a^x,\n    \\]\n\n    for all \\(x \\in \\Sigma_A\\) and \\(y \\in \\Sigma_B\\) where\n    \\(\\{\\rho_b^y : y \\in \\Sigma_A, \\ b \\in \\Gamma_B\\}\\) and\n    \\(\\{\\sigma_a^x : x \\in \\Sigma_A, \\ a \\in \\Gamma_B\\}\\) are\n    collections of operators satisfying\n\n    \\[\n        \\sum_{a \\in \\Gamma_A} \\rho_b^y =\n        \\tau =\n        \\sum_{b \\in \\Gamma_B} \\sigma_a^x,\n    \\]\n\n    for every choice of \\(x \\in \\Sigma_A\\) and \\(y \\in \\Sigma_B\\)\n    where \\(\\tau \\in \\text{D}(\\mathcal{R})\\) is a density operator.\n\n    Returns:\n        The non-signaling value of the extended nonlocal game.\n\n    \"\"\"\n    dim_x, dim_y, alice_out, bob_out, alice_in, bob_in = self.pred_mat.shape\n    constraints = []\n\n    # The cvxpy package does not support optimizing over more than\n    # 2-dimensional objects. To overcome this, we use a dictionary to index\n    # between the questions and answers, while the cvxpy variables held at\n    # this positions are `dim_x`-by-`dim_y` cvxpy Variable objects.\n\n    # Define K(a,b|x,y) variable.\n    k_var = defaultdict(cvxpy.Variable)\n    for a_out in range(alice_out):\n        for b_out in range(bob_out):\n            for x_in in range(alice_in):\n                for y_in in range(bob_in):\n                    k_var[a_out, b_out, x_in, y_in] = cvxpy.Variable((dim_x, dim_y), hermitian=True)\n                    constraints.append(k_var[a_out, b_out, x_in, y_in] &gt;&gt; 0)\n\n    # Define \\sigma_a^x variable.\n    sigma = defaultdict(cvxpy.Variable)\n    for a_out in range(alice_out):\n        for x_in in range(alice_in):\n            sigma[a_out, x_in] = cvxpy.Variable((dim_x, dim_y), hermitian=True)\n\n    # Define \\rho_b^y variable.\n    rho = defaultdict(cvxpy.Variable)\n    for b_out in range(bob_out):\n        for y_in in range(bob_in):\n            rho[b_out, y_in] = cvxpy.Variable((dim_x, dim_y), hermitian=True)\n\n    # Define \\tau density operator variable.\n    tau = cvxpy.Variable((dim_x, dim_y), hermitian=True)\n\n    p_win = 0\n    for a_out in range(alice_out):\n        for b_out in range(bob_out):\n            for x_in in range(alice_in):\n                for y_in in range(bob_in):\n                    p_win += self.prob_mat[x_in, y_in] * cvxpy.trace(\n                        self.pred_mat[:, :, a_out, b_out, x_in, y_in].conj().T @ k_var[a_out, b_out, x_in, y_in]\n                    )\n\n    objective = cvxpy.Maximize(cvxpy.real(p_win))\n\n    # The following constraints enforce the so-called non-signaling\n    # constraints.\n\n    # Enforce that:\n    # \\sum_{b \\in \\Gamma_B} K(a,b|x,y) = \\sigma_a^x\n    for x_in in range(alice_in):\n        for y_in in range(bob_in):\n            for a_out in range(alice_out):\n                b_sum = 0\n                for b_out in range(bob_out):\n                    b_sum += k_var[a_out, b_out, x_in, y_in]\n                constraints.append(b_sum == sigma[a_out, x_in])\n\n    # Enforce non-signaling constraints on Alice marginal:\n    # \\sum_{a \\in \\Gamma_A} K(a,b|x,y) = \\rho_b^y\n    for x_in in range(alice_in):\n        for y_in in range(bob_in):\n            for b_out in range(bob_out):\n                a_sum = 0\n                for a_out in range(alice_out):\n                    a_sum += k_var[a_out, b_out, x_in, y_in]\n                constraints.append(a_sum == rho[b_out, y_in])\n\n    # Enforce non-signaling constraints on Bob marginal:\n    # \\sum_{a \\in \\Gamma_A} \\sigma_a^x = \\tau\n    for x_in in range(alice_in):\n        sig_a_sum = 0\n        for a_out in range(alice_out):\n            sig_a_sum += sigma[a_out, x_in]\n        constraints.append(sig_a_sum == tau)\n\n    # Enforce that:\n    # \\sum_{b \\in \\Gamma_B} \\rho_b^y = \\tau\n    for y_in in range(bob_in):\n        rho_b_sum = 0\n        for b_out in range(bob_out):\n            rho_b_sum += rho[b_out, y_in]\n        constraints.append(rho_b_sum == tau)\n\n    # Enforce that tau is a density operator.\n    constraints.append(cvxpy.trace(tau) == 1)\n    constraints.append(tau &gt;&gt; 0)\n\n    problem = cvxpy.Problem(objective, constraints)\n    ns_val = problem.solve()\n\n    return ns_val\n</code></pre>"},{"location":"reference/toqito/nonlocal_games/extended_nonlocal_game/#toqito.nonlocal_games.extended_nonlocal_game.ExtendedNonlocalGame.quantum_value_lower_bound","title":"quantum_value_lower_bound","text":"<pre><code>quantum_value_lower_bound(iters: int = 20, tol: float = 1e-08, seed: int | None = None, initial_bob_is_random: bool | dict = False, solver: str = SCS, solver_params: dict | None = None, verbose: bool = False) -&gt; float\n</code></pre> <p>Calculate lower bound on the quantum value of an extended nonlocal game.</p> <p>Uses an iterative see-saw method involving two SDPs.</p> <p>Parameters:</p> <ul> <li> <code>iters</code>               (<code>int</code>, default:                   <code>20</code> )           \u2013            <p>Maximum number of see-saw iterations (Alice optimizes, Bob optimizes (default is 20).</p> </li> <li> <code>tol</code>               (<code>float</code>, default:                   <code>1e-08</code> )           \u2013            <p>Tolerance for stopping see-saw iteration based on improvement (default is 1e-8).</p> </li> <li> <code>seed</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional seed for initializing random POVMs for reproducibility (default is None).</p> </li> <li> <code>initial_bob_is_random</code>               (<code>bool | dict</code>, default:                   <code>False</code> )           \u2013            <p>Optional</p> </li> <li> <code>solver</code>               (<code>str</code>, default:                   <code>SCS</code> )           \u2013            <p>Optional option for different solver (default is SCS).</p> </li> <li> <code>solver_params</code>               (<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional parameters for solver (default is {\"eps\": 1e-8, \"verbose\": False}).</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Optional printout for optimizer step (default is False).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The best lower bound found on the quantum value.</p> </li> </ul> Source code in <code>toqito/nonlocal_games/extended_nonlocal_game.py</code> <pre><code>def quantum_value_lower_bound(\n    self,\n    iters: int = 20,\n    tol: float = 1e-8,\n    seed: int | None = None,\n    initial_bob_is_random: bool | dict = False,\n    solver: str = cvxpy.SCS,\n    solver_params: dict | None = None,\n    verbose: bool = False,\n) -&gt; float:\n    r\"\"\"Calculate lower bound on the quantum value of an extended nonlocal game.\n\n    Uses an iterative see-saw method involving two SDPs.\n\n    Args:\n        iters: Maximum number of see-saw iterations (Alice optimizes, Bob optimizes (default is 20).\n        tol: Tolerance for stopping see-saw iteration based on improvement (default is 1e-8).\n        seed: Optional seed for initializing random POVMs for reproducibility (default is None).\n        initial_bob_is_random: Optional\n        solver: Optional option for different solver (default is SCS).\n        solver_params: Optional parameters for solver (default is {\"eps\": 1e-8, \"verbose\": False}).\n        verbose: Optional printout for optimizer step (default is False).\n\n    Returns:\n        The best lower bound found on the quantum value.\n\n    \"\"\"\n    self.__get_game_dims()\n    if solver_params is None:\n        solver_params = {\"eps_abs\": tol, \"eps_rel\": tol, \"max_iters\": 50000, \"verbose\": False}\n    if seed is not None:\n        np.random.seed(seed)\n\n    # Get number of inputs and outputs for Bob's measurements.\n    _, _, _, num_outputs_bob, _, num_inputs_bob = self.pred_mat.shape\n\n    # Initialize Bob's POVMs (NumPy arrays) - Default to RANDOM\n    bob_povms_np = defaultdict(lambda: np.zeros((num_outputs_bob, num_outputs_bob), dtype=complex))\n    if isinstance(initial_bob_is_random, bool):\n        if initial_bob_is_random:\n            for y_ques in range(num_inputs_bob):\n                random_u_mat = random_unitary(num_outputs_bob)\n                for b_ans in range(num_outputs_bob):\n                    ket = random_u_mat[:, b_ans].reshape(-1, 1)\n                    bra = ket.conj().T\n                    bob_povms_np[y_ques, b_ans] = ket @ bra\n        else:\n            for y_ques in range(num_inputs_bob):\n                bob_povms_np[y_ques, 0] = np.eye(num_outputs_bob)\n                for b_other_ans in range(1, num_outputs_bob):\n                    bob_povms_np[y_ques, b_other_ans] = np.zeros((num_outputs_bob, num_outputs_bob))\n    elif isinstance(initial_bob_is_random, dict):  # If you allow dict for custom POVMs\n        bob_povms_np = initial_bob_is_random\n    else:\n        raise TypeError(\n            f\"Expected initial_bob_is_random to be bool or dict, \"  # Adjust if only bool supported\n            f\"got {type(initial_bob_is_random).__name__} instead.\"\n        )\n\n    prev_win_val = -float(\"inf\")\n    current_best_lower_bound = -float(\"inf\")\n\n    if verbose:\n        init_bob_display = \"dict\" if isinstance(initial_bob_is_random, dict) else initial_bob_is_random\n        print(\n            f\"Starting see-saw: max_steps={iters}, tol={tol}, seed={seed}, solver={solver}, \"\n            + f\"random_init={init_bob_display}\"\n        )\n\n    for step in range(iters):\n        opt_alice_rho_cvxpy_vars, problem_alice = self.__optimize_alice(bob_povms_np, solver, solver_params)\n\n        if (\n            opt_alice_rho_cvxpy_vars is None\n            or problem_alice.status not in [cvxpy.OPTIMAL, cvxpy.OPTIMAL_INACCURATE]\n            or problem_alice.value is None\n        ):\n            if verbose:\n                print(\n                    f\"Warning: Alice optimization step failed (status: {problem_alice.status}) \"\n                    f\"in see-saw step {step + 1}. Value: {problem_alice.value}\"\n                )\n            return current_best_lower_bound if current_best_lower_bound &gt; -float(\"inf\") else 0.0\n\n        opt_bob_povm_cvxpy_vars, problem_bob = self.__optimize_bob(opt_alice_rho_cvxpy_vars, solver, solver_params)\n\n        if (\n            opt_bob_povm_cvxpy_vars is None\n            or problem_bob.status not in [cvxpy.OPTIMAL, cvxpy.OPTIMAL_INACCURATE]\n            or problem_bob.value is None\n        ):\n            if verbose:\n                print(\n                    f\"Warning: Bob optimization step failed (status: {problem_bob.status}) \"\n                    f\"in see-saw step {step + 1}. Value: {problem_bob.value}\"\n                )\n            return current_best_lower_bound if current_best_lower_bound &gt; -float(\"inf\") else 0.0\n\n        current_win_val = problem_bob.value\n\n        current_best_lower_bound = max(current_best_lower_bound, current_win_val)\n\n        improvement = abs(current_win_val - prev_win_val)\n\n        if verbose:\n            print(\n                f\"See-saw step {step + 1}/{iters}: Win prob = {current_win_val:.8f}, \"\n                + f\"Improv = {improvement:.2e}, Best = {current_best_lower_bound:.8f}\"\n            )\n\n        if (\n            improvement &lt; tol and step &gt; 0\n        ):  # step &gt; 0 to ensure prev_win_val is not -inf for the first real improvement check\n            if verbose:\n                print(f\"See-saw converged at step {step + 1} with value {current_best_lower_bound:.8f}\")\n            break\n        prev_win_val = current_win_val\n\n        # If not the last iteration, update Bob's POVMs for the next step\n        if step &lt; iters - 1:\n            for y_idx in range(self.num_bob_in):\n                for b_idx in range(self.num_bob_out):\n                    povm_var = opt_bob_povm_cvxpy_vars.get((y_idx, b_idx))  # Use .get for safety\n                    if povm_var is None or povm_var.value is None:\n                        if verbose:\n                            print(\n                                f\"Warning: Bob POVM var ({y_idx},{b_idx}) value is None in step {step + 1} \"\n                                f\"during POVM update. Exiting see-saw early.\"\n                            )\n                        return current_best_lower_bound if current_best_lower_bound &gt; -float(\"inf\") else 0.0\n                    bob_povms_np[y_idx, b_idx] = povm_var.value\n\n    else:\n        if verbose and iters &gt; 0:\n            print(f\"See-Saw reached max steps ({iters}) with value {current_best_lower_bound:.8f}\")\n\n    return current_best_lower_bound if current_best_lower_bound &gt; -float(\"inf\") else 0.0\n</code></pre>"},{"location":"reference/toqito/nonlocal_games/extended_nonlocal_game/#toqito.nonlocal_games.extended_nonlocal_game.ExtendedNonlocalGame.__optimize_alice","title":"__optimize_alice","text":"<pre><code>__optimize_alice(fixed_bob_povms_np: dict, solver: str = SCS, solver_params: dict | None = None) -&gt; tuple[dict | None, Problem]\n</code></pre> <p>Fix Bob's measurements and optimize over Alice's measurements.</p> Source code in <code>toqito/nonlocal_games/extended_nonlocal_game.py</code> <pre><code>def __optimize_alice(\n    self, fixed_bob_povms_np: dict, solver: str = cvxpy.SCS, solver_params: dict | None = None\n) -&gt; tuple[dict | None, cvxpy.Problem]:\n    \"\"\"Fix Bob's measurements and optimize over Alice's measurements.\"\"\"\n    # The cvxpy package does not support optimizing over 4-dimensional objects.\n    # To overcome this, we use a dictionary to index between the questions and\n    # answers, while the cvxpy variables held at this positions are\n    # `dim`-by-`dim` cvxpy variables.\n    self.__get_game_dims()\n\n    rho_xa_cvxpy_vars = defaultdict(cvxpy.Variable)\n    for x_ques in range(self.num_alice_in):\n        for a_ans in range(self.num_alice_out):\n            rho_xa_cvxpy_vars[x_ques, a_ans] = cvxpy.Variable(\n                (self.referee_dim * self.num_bob_out, self.referee_dim * self.num_bob_out),\n                hermitian=True,\n                name=f\"rho_A_{x_ques}{a_ans}\",\n            )\n    tau_A_cvxpy_var = cvxpy.Variable(\n        (self.referee_dim * self.num_bob_out, self.referee_dim * self.num_bob_out), hermitian=True, name=\"tau_A\"\n    )\n\n    win_objective = cvxpy.Constant(0)\n    for x_q in range(self.num_alice_in):\n        for y_q in range(self.num_bob_in):\n            if self.prob_mat[x_q, y_q] == 0:\n                continue\n            for a_ans_alice in range(self.num_alice_out):\n                for b_ans_bob in range(self.num_bob_out):\n                    # fixed_bob_povms_np is guaranteed to be np.ndarray here\n                    v_xyab = self.pred_mat[:, :, a_ans_alice, b_ans_bob, x_q, y_q]\n                    b_yb = fixed_bob_povms_np[y_q, b_ans_bob]\n                    op_for_trace = np.kron(v_xyab, b_yb)\n                    win_objective += self.prob_mat[x_q, y_q] * cvxpy.trace(\n                        op_for_trace.conj().T @ rho_xa_cvxpy_vars[x_q, a_ans_alice]\n                    )\n\n    objective = cvxpy.Maximize(cvxpy.real(win_objective))\n    constraints = []\n    for x_q_constr in range(self.num_alice_in):\n        rho_sum_a_constr = 0\n        for a_ans_constr in range(self.num_alice_out):\n            constraints.append(rho_xa_cvxpy_vars[x_q_constr, a_ans_constr] &gt;&gt; 0)\n            rho_sum_a_constr += rho_xa_cvxpy_vars[x_q_constr, a_ans_constr]\n        constraints.append(rho_sum_a_constr == tau_A_cvxpy_var)\n    constraints.append(cvxpy.trace(tau_A_cvxpy_var) == 1)\n    constraints.append(tau_A_cvxpy_var &gt;&gt; 0)\n\n    problem = cvxpy.Problem(objective, constraints)\n    problem.solve(solver=solver, **solver_params)  # Use passed solver and params\n\n    return rho_xa_cvxpy_vars, problem\n</code></pre>"},{"location":"reference/toqito/nonlocal_games/extended_nonlocal_game/#toqito.nonlocal_games.extended_nonlocal_game.ExtendedNonlocalGame.__optimize_bob","title":"__optimize_bob","text":"<pre><code>__optimize_bob(alice_rho_cvxpy_vars: dict | None, solver: str = SCS, solver_params: dict | None = None) -&gt; tuple[dict | None, Problem]\n</code></pre> <p>Fix Alice's measurements and optimize over Bob's measurements.</p> Source code in <code>toqito/nonlocal_games/extended_nonlocal_game.py</code> <pre><code>def __optimize_bob(\n    self, alice_rho_cvxpy_vars: dict | None, solver: str = cvxpy.SCS, solver_params: dict | None = None\n) -&gt; tuple[dict | None, cvxpy.Problem]:\n    \"\"\"Fix Alice's measurements and optimize over Bob's measurements.\"\"\"\n    # Get number of inputs and outputs.\n    self.__get_game_dims()\n\n    # The cvxpy package does not support optimizing over 4-dimensional objects.\n    # To overcome this, we use a dictionary to index between the questions and\n    # answers, while the cvxpy variables held at this positions are\n    # `dim`-by-`dim` cvxpy variables.\n\n    bob_povm_cvxpy_vars = defaultdict(cvxpy.Variable)\n    for y_ques in range(self.num_bob_in):\n        for b_ans in range(self.num_bob_out):\n            bob_povm_cvxpy_vars[y_ques, b_ans] = cvxpy.Variable(\n                (self.num_bob_out, self.num_bob_out), hermitian=True, name=f\"B_POVM_{y_ques}{b_ans}\"\n            )\n\n    win_objective = cvxpy.Constant(0)\n\n    for x_q in range(self.num_alice_in):\n        for y_q in range(self.num_bob_in):\n            if self.prob_mat[x_q, y_q] == 0:\n                continue\n            for a_ans_alice in range(self.num_alice_out):\n                rho_xa_val = alice_rho_cvxpy_vars[x_q, a_ans_alice].value\n\n                for b_ans_bob in range(self.num_bob_out):\n                    v_xyab = self.pred_mat[:, :, a_ans_alice, b_ans_bob, x_q, y_q]\n                    win_objective += self.prob_mat[x_q, y_q] * cvxpy.trace(\n                        cvxpy.kron(v_xyab, bob_povm_cvxpy_vars[y_q, b_ans_bob]) @ rho_xa_val\n                    )\n\n    objective = cvxpy.Maximize(cvxpy.real(win_objective))\n    constraints = []\n    ident_bob_space = np.identity(self.num_bob_out)\n    for y_q_constr in range(self.num_bob_in):\n        sum_b_povm = 0\n        for b_ans_constr in range(self.num_bob_out):\n            constraints.append(bob_povm_cvxpy_vars[y_q_constr, b_ans_constr] &gt;&gt; 0)\n            sum_b_povm += bob_povm_cvxpy_vars[y_q_constr, b_ans_constr]\n        constraints.append(sum_b_povm == ident_bob_space)\n\n    problem = cvxpy.Problem(objective, constraints)\n    problem.solve(solver=solver, **solver_params)  # Use passed solver and params\n\n    return bob_povm_cvxpy_vars, problem\n</code></pre>"},{"location":"reference/toqito/nonlocal_games/extended_nonlocal_game/#toqito.nonlocal_games.extended_nonlocal_game.ExtendedNonlocalGame.commuting_measurement_value_upper_bound","title":"commuting_measurement_value_upper_bound","text":"<pre><code>commuting_measurement_value_upper_bound(k: int | str = 1, no_signaling: bool = True) -&gt; float\n</code></pre> <p>Compute an upper bound on the commuting measurement value of an extended nonlocal game.</p> <p>This function calculates an upper bound on the commuting measurement value by     using k-levels of the NPA hierarchy <sup>1</sup>. The NPA hierarchy is a uniform     family of semidefinite programs that converges to the commuting measurement value of     any extended nonlocal game.</p> <p>You can determine the level of the hierarchy by a positive integer or a string     of a form like '1+ab+aab', which indicates that an intermediate level of the hierarchy     should be used, where this example uses all products of one measurement, all products of     one Alice and one Bob measurement, and all products of two Alice and one Bob measurements.</p> <p>Parameters:</p> <ul> <li> <code>k</code>               (<code>int | str</code>, default:                   <code>1</code> )           \u2013            <p>The level of the NPA hierarchy to use (default=1).</p> </li> <li> <code>no_signaling</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to enforce the no-signaling constraints (default=True).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The upper bound on the commuting strategy value of an extended nonlocal game.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Navascu\u00e9s, Miguel and Pironio, Stefano and Ac\u00edn, Antonio. A convergent hierarchy of semidefinite programs characterizing the set of quantum correlations. New Journal of Physics. vol. 10(7). (2008). doi:10.1088/1367-2630/10/7/073013.</p> Source code in <code>toqito/nonlocal_games/extended_nonlocal_game.py</code> <pre><code>def commuting_measurement_value_upper_bound(self, k: int | str = 1, no_signaling: bool = True) -&gt; float:\n    r\"\"\"Compute an upper bound on the commuting measurement value of an extended nonlocal game.\n\n    This function calculates an upper bound on the commuting measurement value by\n        using k-levels of the NPA hierarchy [@Navascues_2008_AConvergent]. The NPA hierarchy is a uniform\n        family of semidefinite programs that converges to the commuting measurement value of\n        any extended nonlocal game.\n\n    You can determine the level of the hierarchy by a positive integer or a string\n        of a form like '1+ab+aab', which indicates that an intermediate level of the hierarchy\n        should be used, where this example uses all products of one measurement, all products of\n        one Alice and one Bob measurement, and all products of two Alice and one Bob measurements.\n\n    Args:\n        k: The level of the NPA hierarchy to use (default=1).\n        no_signaling: Whether to enforce the no-signaling constraints (default=True).\n\n    Returns:\n        The upper bound on the commuting strategy value of an extended nonlocal game.\n\n    \"\"\"\n    dR, _, A_out, B_out, A_in, B_in = self.pred_mat.shape\n    K = {}\n    for x in range(A_in):\n        for y in range(B_in):\n            blocks = [[None for _ in range(B_out)] for _ in range(A_out)]\n            for a in range(A_out):\n                for b in range(B_out):\n                    blocks[a][b] = cvxpy.Variable((dR, dR), hermitian=True, name=f\"K({x},{y})_{a}{b}\")\n            K[(x, y)] = cvxpy.bmat(blocks)\n    total_win = cvxpy.Constant(0)\n    for x in range(A_in):\n        for y in range(B_in):\n            for a in range(A_out):\n                for b in range(B_out):\n                    P_ref = self.pred_mat[:, :, a, b, x, y]\n                    blk = K[(x, y)][a * dR : (a + 1) * dR, b * dR : (b + 1) * dR]\n                    total_win += self.prob_mat[x, y] * cvxpy.trace(P_ref.conj().T @ blk)\n    cons = npa_constraints(K, k, referee_dim=dR, no_signaling=no_signaling)\n    prob = cvxpy.Problem(cvxpy.Maximize(cvxpy.real(total_win)), cons)\n    cs_val = prob.solve(solver=cvxpy.SCS, eps=1e-8, max_iters=100_000, verbose=False)\n\n    return cs_val\n</code></pre>"},{"location":"reference/toqito/nonlocal_games/nonlocal_game/","title":"nonlocal_game","text":""},{"location":"reference/toqito/nonlocal_games/nonlocal_game/#toqito.nonlocal_games.nonlocal_game","title":"nonlocal_game","text":"<p>Two-player nonlocal game.</p>"},{"location":"reference/toqito/nonlocal_games/nonlocal_game/#toqito.nonlocal_games.nonlocal_game.NonlocalGame","title":"NonlocalGame","text":"<pre><code>NonlocalGame(prob_mat: ndarray, pred_mat: ndarray, reps: int = 1)\n</code></pre> <p>Create two-player nonlocal game object.</p> <p>Nonlocal games are a mathematical framework that abstractly models a physical system. This game is played between two players, Alice and Bob, who are not allowed to communicate with each other once the game has started and who play cooperative against an adversary referred to as the referee.</p> <p>The nonlocal game framework was originally introduced in <sup>1</sup>.</p> <p>A tutorial is available in the documentation. For more info, see Nonlocal Games.</p> <p>References</p> <p><sup>1</sup> Cleve, Richard and Hoyer, Peter and Toner, Ben and Watrous, John. Consequences and Limits of Nonlocal Strategies. (2010).</p> <p>Construct nonlocal game object.</p> <p>Parameters:</p> <ul> <li> <code>prob_mat</code>               (<code>ndarray</code>)           \u2013            <p>A matrix whose (x, y)-entry gives the probability       that the referee will give Alice the value <code>x</code> and Bob       the value <code>y</code>.</p> </li> <li> <code>pred_mat</code>               (<code>ndarray</code>)           \u2013            <p>A four-dimensional matrix whose (a,b,x,y)-entry gives       the outcome for answers \"a\" and \"b\" given questions       \"x\" and \"y\".</p> </li> <li> <code>reps</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Number of parallel repetitions to perform. Default is 1.</p> </li> </ul> Source code in <code>toqito/nonlocal_games/nonlocal_game.py</code> <pre><code>def __init__(self, prob_mat: np.ndarray, pred_mat: np.ndarray, reps: int = 1) -&gt; None:\n    \"\"\"Construct nonlocal game object.\n\n    Args:\n        prob_mat: A matrix whose (x, y)-entry gives the probability\n                  that the referee will give Alice the value `x` and Bob\n                  the value `y`.\n        pred_mat: A four-dimensional matrix whose (a,b,x,y)-entry gives\n                  the outcome for answers \"a\" and \"b\" given questions\n                  \"x\" and \"y\".\n        reps: Number of parallel repetitions to perform. Default is 1.\n\n    \"\"\"\n    if reps == 1:\n        self.prob_mat = prob_mat\n        self.pred_mat = pred_mat\n        self.reps = reps\n\n    else:\n        num_alice_out, num_bob_out, num_alice_in, num_bob_in = pred_mat.shape\n        self.prob_mat = tensor(prob_mat, reps)\n\n        pred_mat2 = np.zeros(\n            (\n                num_alice_out**reps,\n                num_bob_out**reps,\n                num_alice_in**reps,\n                num_bob_in**reps,\n            )\n        )\n        i_ind = np.zeros(reps, dtype=int)\n        j_ind = np.zeros(reps, dtype=int)\n        for i in range(num_alice_in**reps):\n            for j in range(num_bob_in**reps):\n                to_tensor = np.empty([reps, num_alice_out, num_bob_out])\n                for k in range(reps - 1, -1, -1):\n                    to_tensor[k] = pred_mat[:, :, i_ind[k], j_ind[k]]\n                pred_mat2[:, :, i, j] = tensor(to_tensor)\n                j_ind = update_odometer(j_ind, num_bob_in * np.ones(reps))\n            i_ind = update_odometer(i_ind, num_alice_in * np.ones(reps))\n        self.pred_mat = pred_mat2\n        self.reps = reps\n    # _raw_constraints will store the original 1D BCS constraints (if provided) for later analysis.\n    self._raw_constraints = None\n</code></pre>"},{"location":"reference/toqito/nonlocal_games/nonlocal_game/#toqito.nonlocal_games.nonlocal_game.NonlocalGame.from_bcs_game","title":"from_bcs_game  <code>classmethod</code>","text":"<pre><code>from_bcs_game(constraints: list[ndarray], reps: int = 1) -&gt; NonlocalGame\n</code></pre> <p>Convert constraints that specify a binary constraint system game to a nonlocal game.</p> <p>Binary constraint system games (BCS) games were originally defined in <sup>1</sup>.</p> <p>Parameters:</p> <ul> <li> <code>constraints</code>               (<code>list[ndarray]</code>)           \u2013            <p>List of binary constraints that define the game.</p> </li> <li> <code>reps</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Number of parallel repetitions to perform. Default is 1.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NonlocalGame</code>           \u2013            <p>A NonlocalGame object arising from the variables and constraints that define the game.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Cleve, Richard and Mittal, Rajat. Characterization of binary constraint system games. Automata, Languages, and Programming: 41st International Colloquium, ICALP 2014, Copenhagen, Denmark, July 8-11, 2014, Proceedings, Part I 41. (2014).</p> Source code in <code>toqito/nonlocal_games/nonlocal_game.py</code> <pre><code>@classmethod\ndef from_bcs_game(cls, constraints: list[np.ndarray], reps: int = 1) -&gt; \"NonlocalGame\":\n    r\"\"\"Convert constraints that specify a binary constraint system game to a nonlocal game.\n\n    Binary constraint system games (BCS) games were originally defined in [@Cleve_2014_Characterization].\n\n    Args:\n        constraints: List of binary constraints that define the game.\n        reps: Number of parallel repetitions to perform. Default is 1.\n\n    Returns:\n        A NonlocalGame object arising from the variables and constraints that define the game.\n\n    \"\"\"\n    if (num_constraints := len(constraints)) == 0:\n        raise ValueError(\"At least 1 constraint is required\")\n    num_variables = constraints[0].ndim\n\n    # Retrieve dependent variables for each constraint.\n    dependent_variables = np.zeros((num_constraints, num_variables))\n\n    for j in range(num_constraints):\n        for i in range(num_variables):\n            # Identifying independent variables based on equality check.\n            dependent_variables[j, i] = np.diff(constraints[j], axis=i).any()\n\n    # Compute the probability matrix.\n    prob_mat = np.zeros((num_constraints, num_variables))\n    for j in range(num_constraints):\n        p_x = 1.0 / num_constraints\n        num_dependent_vars = dependent_variables[j].sum()\n        if num_dependent_vars == 0:\n            raise ValueError(f\"Constraint {j} is degenerate (has no dependent variables).\")\n        else:\n            p_y = dependent_variables[j] / num_dependent_vars\n        prob_mat[j] = p_x * p_y\n\n    # Compute the prediction matrix.\n    pred_mat = np.zeros((2**num_variables, 2, num_constraints, num_variables))\n    for x_ques in range(num_constraints):\n        for a_ans in range(pred_mat.shape[0]):\n            # Convert Alice's truth assignment to binary.\n            bin_a = np.array(list(map(int, np.binary_repr(a_ans, num_variables))))\n\n            # Convert truth assignment to a tuple for easy indexing.\n            truth_assignment = tuple(bin_a)\n\n            for y_ques in range(num_variables):\n                # Bob\u2019s assignment is Alice\u2019s truth assignment for the current variable.\n                b_ans = truth_assignment[y_ques]\n\n                # Check if this satisfies the constraint.\n                if constraints[x_ques][truth_assignment] == 1:\n                    pred_mat[a_ans, b_ans, x_ques, y_ques] = 1\n    game = cls(prob_mat, pred_mat, reps)\n    game._raw_constraints = constraints\n    return game\n</code></pre>"},{"location":"reference/toqito/nonlocal_games/nonlocal_game/#toqito.nonlocal_games.nonlocal_game.NonlocalGame.is_bcs_perfect_commuting_strategy","title":"is_bcs_perfect_commuting_strategy","text":"<pre><code>is_bcs_perfect_commuting_strategy() -&gt; bool\n</code></pre> <p>Determine if the BCS game admits a perfect commuting-operator strategy.</p> <p>This method checks whether the binary constraint system game, from which the current nonlocal game was constructed, has a perfect quantum strategy in the commuting-operator model. It converts the raw BCS tensor constraints (if needed) into matrix form and evaluates their satisfiability using a helper function.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if a perfect commuting-operator strategy exists; False otherwise.</p> </li> </ul> Source code in <code>toqito/nonlocal_games/nonlocal_game.py</code> <pre><code>def is_bcs_perfect_commuting_strategy(self) -&gt; bool:\n    r\"\"\"Determine if the BCS game admits a perfect commuting-operator strategy.\n\n    This method checks whether the binary constraint system game, from which the current\n    nonlocal game was constructed, has a perfect quantum strategy in the commuting-operator model.\n    It converts the raw BCS tensor constraints (if needed) into matrix form and evaluates\n    their satisfiability using a helper function.\n\n    Raises:\n        If no constraints are stored (i.e., if the game was not created from a BCS game).\n\n    Returns:\n        True if a perfect commuting-operator strategy exists; False otherwise.\n\n    \"\"\"\n    # If the stored constraints are tensor-form (i.e. not 1D), convert them to raw (1D) form.\n    if self._raw_constraints[0].ndim != 1:\n        converted = []\n        for tensor_constraint in self._raw_constraints:\n            converted.append(tensor_unravel(tensor_constraint))\n        raw_constraints = converted\n    else:\n        raw_constraints = self._raw_constraints\n\n    # Now, for each raw constraint (which should be a 1D array of length n+1),\n    # extract M (all entries except the last) and b (derived from the last entry).\n    M_list = [c[:-1] for c in raw_constraints]\n    b_list = [0 if c[-1] == 1 else 1 for c in raw_constraints]\n    M_array = np.array(M_list, dtype=int)\n    b_array = np.array(b_list, dtype=int)\n    return check_perfect_commuting_strategy(M_array, b_array)\n</code></pre>"},{"location":"reference/toqito/nonlocal_games/nonlocal_game/#toqito.nonlocal_games.nonlocal_game.NonlocalGame.classical_value","title":"classical_value","text":"<pre><code>classical_value() -&gt; float\n</code></pre> <p>Compute the classical value of the nonlocal game using Numba acceleration.</p> Source code in <code>toqito/nonlocal_games/nonlocal_game.py</code> <pre><code>def classical_value(self) -&gt; float:\n    r\"\"\"Compute the classical value of the nonlocal game using Numba acceleration.\"\"\"\n    A_out, B_out, A_in, B_in = self.pred_mat.shape\n    pm = np.copy(self.pred_mat)\n    pm *= self.prob_mat[np.newaxis, np.newaxis, :A_in, :B_in]\n\n    # Align dimensions for Bob's strategies\n    if A_out**A_in &lt; B_out**B_in:\n        pm = pm.transpose((1, 0, 3, 2))\n        A_out, B_out, A_in, B_in = pm.shape\n\n    # Reorder axes to (A_out, A_in, B_out, B_in)\n    pm = pm.transpose((0, 2, 1, 3))\n\n    # Build power array for decoding Bob's outputs\n    pow_arr = np.array([B_out ** (B_in - 1 - y) for y in range(B_in)], dtype=np.int64)\n\n    # === Begin fast classical value logic ===\n    p_win = 0.0\n    total = B_out**B_in\n\n    for i in range(total):\n        best_sum = 0.0\n        for x in range(A_in):\n            best_for_x = 0.0\n            for a in range(A_out):\n                acc = 0.0\n                for y in range(B_in):\n                    b_q = (i // pow_arr[y]) % B_out\n                    acc += pm[a, x, b_q, y]\n                best_for_x = max(best_for_x, acc)\n            best_sum += best_for_x\n        p_win = max(p_win, best_sum)\n\n    return p_win\n</code></pre>"},{"location":"reference/toqito/nonlocal_games/nonlocal_game/#toqito.nonlocal_games.nonlocal_game.NonlocalGame.quantum_value_lower_bound","title":"quantum_value_lower_bound","text":"<pre><code>quantum_value_lower_bound(dim: int = 2, iters: int = 5, tol: float = 1e-05)\n</code></pre> <p>Compute a lower bound on the quantum value of a nonlocal game <sup>1</sup>.</p> <p>Calculates a lower bound on the maximum value that the specified nonlocal game can take on in quantum mechanical settings where Alice and Bob each have access to <code>dim</code>-dimensional quantum system.</p> <p>This function works by starting with a randomly-generated POVM for Bob, and then optimizing Alice's POVM and the shared entangled state. Then Alice's POVM and the entangled state are fixed, and Bob's POVM is optimized. And so on, back and forth between Alice and Bob until convergence is reached.</p> <p>Note that the algorithm is not guaranteed to obtain the optimal local bound and can get stuck in local minimum values. The alleviate this, the <code>iter</code> parameter allows one to run the algorithm some pre-specified number of times and keep the highest value obtained.</p> <p>The algorithm is based on the alternating projections algorithm as it can be applied to Bell inequalities as shown in <sup>1</sup>.</p> <p>The alternating projection algorithm has also been referred to as the \"see-saw\" algorithm as it goes back and forth between the following two semidefinite programs:</p> \\[     \\begin{equation}         \\begin{aligned}             \\textbf{SDP-1:} \\quad &amp; \\\\             \\text{maximize:} \\quad &amp; \\sum_{(x,y \\in \\Sigma)} \\pi(x,y)                                      \\sum_{(a,b) \\in \\Gamma}                                      V(a,b|x,y)                                      \\langle B_b^y, A_a^x \\rangle \\\\             \\text{subject to:} \\quad &amp; \\sum_{a \\in \\Gamma_{\\mathsf{A}}}=                                 \\tau, \\qquad \\qquad                                 \\forall x \\in \\Sigma_{\\mathsf{A}}, \\\\                                \\quad &amp; A_a^x \\in \\text{Pos}(\\mathcal{A}),                                 \\qquad                                 \\forall x \\in \\Sigma_{\\mathsf{A}}, \\                                 \\forall a \\in \\Gamma_{\\mathsf{A}}, \\\\                                 &amp; \\tau \\in \\text{D}(\\mathcal{A}).         \\end{aligned}     \\end{equation} \\] \\[     \\begin{equation}         \\begin{aligned}             \\textbf{SDP-2:} \\quad &amp; \\\\             \\text{maximize:} \\quad &amp; \\sum_{(x,y \\in \\Sigma)} \\pi(x,y)                                      \\sum_{(a,b) \\in \\Gamma} V(a,b|x,y)                                      \\langle B_b^y, A_a^x \\rangle \\\\             \\text{subject to:} \\quad &amp; \\sum_{b \\in \\Gamma_{\\mathsf{B}}}=                                 \\mathbb{I}, \\qquad \\qquad                                 \\forall y \\in \\Sigma_{\\mathsf{B}}, \\\\                             \\quad &amp; B_b^y \\in \\text{Pos}(\\mathcal{B}),                             \\qquad \\forall y \\in \\Sigma_{\\mathsf{B}}, \\                             \\forall b \\in \\Gamma_{\\mathsf{B}}.         \\end{aligned}     \\end{equation} \\] <p>Examples:</p> <p>The CHSH game</p> <p>The CHSH game is a two-player nonlocal game with the following probability distribution and question and answer sets.</p> \\[     \\begin{equation}     \\begin{aligned}         \\pi(x,y) = \\frac{1}{4}, \\qquad (x,y) \\in \\Sigma_A \\times \\Sigma_B,         \\qquad \\text{and} \\qquad (a, b) \\in \\Gamma_A \\times \\Gamma_B,     \\end{aligned}     \\end{equation} \\] <p>where</p> \\[     \\begin{equation}     \\Sigma_A = \\{0, 1\\}, \\quad \\Sigma_B = \\{0, 1\\}, \\quad \\Gamma_A =     \\{0,1\\}, \\quad \\text{and} \\quad \\Gamma_B = \\{0, 1\\}.     \\end{equation} \\] <p>Alice and Bob win the CHSH game if and only if the following equation is satisfied.</p> \\[     \\begin{equation}     a \\oplus b = x \\land y.     \\end{equation} \\] <p>Recall that \\(\\oplus\\) refers to the XOR operation.</p> <p>The optimal quantum value of CHSH is \\(\\cos(\\pi/8)^2 \\approx 0.8536\\) where the optimal classical value is \\(3/4\\).</p> <pre><code>import numpy as np\nfrom toqito.nonlocal_games.nonlocal_game import NonlocalGame\n\ndim = 2\nnum_alice_inputs, num_alice_outputs = 2, 2\nnum_bob_inputs, num_bob_outputs = 2, 2\nprob_mat = np.array([[1 / 4, 1 / 4], [1 / 4, 1 / 4]])\npred_mat = np.zeros((num_alice_outputs, num_bob_outputs, num_alice_inputs, num_bob_inputs))\n\nfor a_alice in range(num_alice_outputs):\n    for b_bob in range(num_bob_outputs):\n       for x_alice in range(num_alice_inputs):\n           for y_bob in range(num_bob_inputs):\n               if np.mod(a_alice + b_bob + x_alice * y_bob, dim) == 0:\n                   pred_mat[a_alice, b_bob, x_alice, y_bob] = 1\n\nchsh = NonlocalGame(prob_mat, pred_mat)\n\nprint(chsh.quantum_value_lower_bound())\n</code></pre> <p>0.8535525450915863</p> <p>Parameters:</p> <ul> <li> <code>dim</code>               (<code>int</code>, default:                   <code>2</code> )           \u2013            <p>The dimension of the quantum system that Alice and Bob have     access to (default = 2).</p> </li> <li> <code>iters</code>               (<code>int</code>, default:                   <code>5</code> )           \u2013            <p>The number of times to run the alternating projection       algorithm.</p> </li> <li> <code>tol</code>               (<code>float</code>, default:                   <code>1e-05</code> )           \u2013            <p>The tolerance before quitting out of the alternating     projection semidefinite program.</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>The lower bound on the quantum value of a nonlocal game.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Liang, Yeong-Cherng and Doherty, Andrew. Bounds on quantum correlations in Bell-inequality experiments. Physical Review A. vol. 75(4). (2007). doi:10.1103/physreva.75.042103.</p> Source code in <code>toqito/nonlocal_games/nonlocal_game.py</code> <pre><code>def quantum_value_lower_bound(\n    self,\n    dim: int = 2,\n    iters: int = 5,\n    tol: float = 10e-6,\n):\n    r\"\"\"Compute a lower bound on the quantum value of a nonlocal game [@Liang_2007_Bounds].\n\n    Calculates a lower bound on the maximum value that the specified\n    nonlocal game can take on in quantum mechanical settings where Alice and\n    Bob each have access to `dim`-dimensional quantum system.\n\n    This function works by starting with a randomly-generated POVM for Bob,\n    and then optimizing Alice's POVM and the shared entangled state. Then\n    Alice's POVM and the entangled state are fixed, and Bob's POVM is\n    optimized. And so on, back and forth between Alice and Bob until\n    convergence is reached.\n\n    Note that the algorithm is not guaranteed to obtain the optimal local\n    bound and can get stuck in local minimum values. The alleviate this, the\n    `iter` parameter allows one to run the algorithm some pre-specified\n    number of times and keep the highest value obtained.\n\n    The algorithm is based on the alternating projections algorithm as it\n    can be applied to Bell inequalities as shown in [@Liang_2007_Bounds].\n\n    The alternating projection algorithm has also been referred to as the\n    \"see-saw\" algorithm as it goes back and forth between the following two\n    semidefinite programs:\n\n    \\[\n        \\begin{equation}\n            \\begin{aligned}\n                \\textbf{SDP-1:} \\quad &amp; \\\\\n                \\text{maximize:} \\quad &amp; \\sum_{(x,y \\in \\Sigma)} \\pi(x,y)\n                                         \\sum_{(a,b) \\in \\Gamma}\n                                         V(a,b|x,y)\n                                         \\langle B_b^y, A_a^x \\rangle \\\\\n                \\text{subject to:} \\quad &amp; \\sum_{a \\in \\Gamma_{\\mathsf{A}}}=\n                                    \\tau, \\qquad \\qquad\n                                    \\forall x \\in \\Sigma_{\\mathsf{A}}, \\\\\n                                   \\quad &amp; A_a^x \\in \\text{Pos}(\\mathcal{A}),\n                                    \\qquad\n                                    \\forall x \\in \\Sigma_{\\mathsf{A}}, \\\n                                    \\forall a \\in \\Gamma_{\\mathsf{A}}, \\\\\n                                    &amp; \\tau \\in \\text{D}(\\mathcal{A}).\n            \\end{aligned}\n        \\end{equation}\n    \\]\n\n    \\[\n        \\begin{equation}\n            \\begin{aligned}\n                \\textbf{SDP-2:} \\quad &amp; \\\\\n                \\text{maximize:} \\quad &amp; \\sum_{(x,y \\in \\Sigma)} \\pi(x,y)\n                                         \\sum_{(a,b) \\in \\Gamma} V(a,b|x,y)\n                                         \\langle B_b^y, A_a^x \\rangle \\\\\n                \\text{subject to:} \\quad &amp; \\sum_{b \\in \\Gamma_{\\mathsf{B}}}=\n                                    \\mathbb{I}, \\qquad \\qquad\n                                    \\forall y \\in \\Sigma_{\\mathsf{B}}, \\\\\n                                \\quad &amp; B_b^y \\in \\text{Pos}(\\mathcal{B}),\n                                \\qquad \\forall y \\in \\Sigma_{\\mathsf{B}}, \\\n                                \\forall b \\in \\Gamma_{\\mathsf{B}}.\n            \\end{aligned}\n        \\end{equation}\n    \\]\n\n    Examples:\n        The CHSH game\n\n        The CHSH game is a two-player nonlocal game with the following\n        probability distribution and question and answer sets.\n\n        \\[\n            \\begin{equation}\n            \\begin{aligned}\n                \\pi(x,y) = \\frac{1}{4}, \\qquad (x,y) \\in \\Sigma_A \\times \\Sigma_B,\n                \\qquad \\text{and} \\qquad (a, b) \\in \\Gamma_A \\times \\Gamma_B,\n            \\end{aligned}\n            \\end{equation}\n        \\]\n\n        where\n\n        \\[\n            \\begin{equation}\n            \\Sigma_A = \\{0, 1\\}, \\quad \\Sigma_B = \\{0, 1\\}, \\quad \\Gamma_A =\n            \\{0,1\\}, \\quad \\text{and} \\quad \\Gamma_B = \\{0, 1\\}.\n            \\end{equation}\n        \\]\n\n        Alice and Bob win the CHSH game if and only if the following equation is\n        satisfied.\n\n        \\[\n            \\begin{equation}\n            a \\oplus b = x \\land y.\n            \\end{equation}\n        \\]\n\n        Recall that \\(\\oplus\\) refers to the XOR operation.\n\n        The optimal quantum value of CHSH is\n        \\(\\cos(\\pi/8)^2 \\approx 0.8536\\) where the optimal classical value\n        is \\(3/4\\).\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.nonlocal_games.nonlocal_game import NonlocalGame\n\n        dim = 2\n        num_alice_inputs, num_alice_outputs = 2, 2\n        num_bob_inputs, num_bob_outputs = 2, 2\n        prob_mat = np.array([[1 / 4, 1 / 4], [1 / 4, 1 / 4]])\n        pred_mat = np.zeros((num_alice_outputs, num_bob_outputs, num_alice_inputs, num_bob_inputs))\n\n        for a_alice in range(num_alice_outputs):\n            for b_bob in range(num_bob_outputs):\n               for x_alice in range(num_alice_inputs):\n                   for y_bob in range(num_bob_inputs):\n                       if np.mod(a_alice + b_bob + x_alice * y_bob, dim) == 0:\n                           pred_mat[a_alice, b_bob, x_alice, y_bob] = 1\n\n        chsh = NonlocalGame(prob_mat, pred_mat)\n\n        print(chsh.quantum_value_lower_bound())\n        ```\n\n    Args:\n        dim: The dimension of the quantum system that Alice and Bob have\n                access to (default = 2).\n        iters: The number of times to run the alternating projection\n                  algorithm.\n        tol: The tolerance before quitting out of the alternating\n                projection semidefinite program.\n\n    Returns:\n        The lower bound on the quantum value of a nonlocal game.\n\n    \"\"\"\n    # Get number of inputs and outputs.\n    _, num_outputs_bob, _, num_inputs_bob = self.pred_mat.shape\n\n    best_lower_bound = float(\"-inf\")\n    for _ in range(iters):\n        # Generate a set of random POVMs for Bob. These measurements serve\n        # as a rough starting point for the alternating projection\n        # algorithm.\n        bob_tmp = random_povm(dim, num_inputs_bob, num_outputs_bob)\n        bob_povms = defaultdict(int)\n        for y_ques in range(num_inputs_bob):\n            for b_ans in range(num_outputs_bob):\n                bob_povms[y_ques, b_ans] = bob_tmp[:, :, y_ques, b_ans]\n\n        # Run the alternating projection algorithm between the two SDPs.\n        it_diff = 1\n        prev_win = -1\n        best = float(\"-inf\")\n        while it_diff &gt; tol:\n            # Optimize over Alice's measurement operators while fixing\n            # Bob's. If this is the first iteration, then the previously\n            # randomly generated operators in the outer loop are Bob's.\n            # Otherwise, Bob's operators come from running the next SDP.\n            alice_povms, lower_bound = self.__optimize_alice(dim, bob_povms)\n            bob_povms, lower_bound = self.__optimize_bob(dim, alice_povms)\n\n            it_diff = lower_bound - prev_win\n            prev_win = lower_bound\n\n            # As the SDPs keep alternating, check if the winning probability\n            # becomes any higher. If so, replace with new best.\n            best = max(best, lower_bound)\n\n        best_lower_bound = max(best, best_lower_bound)\n\n    return best_lower_bound\n</code></pre>"},{"location":"reference/toqito/nonlocal_games/nonlocal_game/#toqito.nonlocal_games.nonlocal_game.NonlocalGame.__optimize_alice","title":"__optimize_alice","text":"<pre><code>__optimize_alice(dim, bob_povms) -&gt; tuple[dict, float]\n</code></pre> <p>Fix Bob's measurements and optimize over Alice's measurements.</p> Source code in <code>toqito/nonlocal_games/nonlocal_game.py</code> <pre><code>def __optimize_alice(self, dim, bob_povms) -&gt; tuple[dict, float]:\n    \"\"\"Fix Bob's measurements and optimize over Alice's measurements.\"\"\"\n    # Get number of inputs and outputs.\n    (\n        num_outputs_alice,\n        num_outputs_bob,\n        num_inputs_alice,\n        num_inputs_bob,\n    ) = self.pred_mat.shape\n\n    # The cvxpy package does not support optimizing over 4-dimensional\n    # objects. To overcome this, we use a dictionary to index between the\n    # questions and answers, while the cvxpy variables held at this\n    # positions are `dim`-by-`dim` cvxpy variables.\n    alice_povms = defaultdict(cvxpy.Variable)\n    for x_ques in range(num_inputs_alice):\n        for a_ans in range(num_outputs_alice):\n            alice_povms[x_ques, a_ans] = cvxpy.Variable((dim, dim), hermitian=True)\n\n    tau = cvxpy.Variable((dim, dim), hermitian=True)\n\n    # .. math::\n    #    \\sum_{(x,y) \\in \\Sigma} \\pi(x, y) V(a,b|x,y) \\ip{B_b^y}{A_a^x}\n    win = 0\n    for x_ques in range(num_inputs_alice):\n        for y_ques in range(num_inputs_bob):\n            for a_ans in range(num_outputs_alice):\n                for b_ans in range(num_outputs_bob):\n                    if isinstance(bob_povms[y_ques, b_ans], np.ndarray):\n                        win += (\n                            self.prob_mat[x_ques, y_ques]\n                            * self.pred_mat[a_ans, b_ans, x_ques, y_ques]\n                            * cvxpy.trace(bob_povms[y_ques, b_ans].conj().T @ alice_povms[x_ques, a_ans])\n                        )\n                    if isinstance(\n                        bob_povms[y_ques, b_ans],\n                        cvxpy.expressions.variable.Variable,\n                    ):\n                        win += (\n                            self.prob_mat[x_ques, y_ques]\n                            * self.pred_mat[a_ans, b_ans, x_ques, y_ques]\n                            * cvxpy.trace(bob_povms[y_ques, b_ans].value.conj().T @ alice_povms[x_ques, a_ans])\n                        )\n\n    objective = cvxpy.Maximize(cvxpy.real(win))\n\n    constraints = []\n\n    # Sum over \"a\" for all \"x\" for Alice's measurements.\n    for x_ques in range(num_inputs_alice):\n        alice_sum_a = 0\n        for a_ans in range(num_outputs_alice):\n            alice_sum_a += alice_povms[x_ques, a_ans]\n            constraints.append(alice_povms[x_ques, a_ans] &gt;&gt; 0)\n        constraints.append(alice_sum_a == tau)\n\n    constraints.append(cvxpy.trace(tau) == 1)\n    constraints.append(tau &gt;&gt; 0)\n\n    problem = cvxpy.Problem(objective, constraints)\n\n    lower_bound = problem.solve()\n    return alice_povms, lower_bound\n</code></pre>"},{"location":"reference/toqito/nonlocal_games/nonlocal_game/#toqito.nonlocal_games.nonlocal_game.NonlocalGame.__optimize_bob","title":"__optimize_bob","text":"<pre><code>__optimize_bob(dim, alice_povms) -&gt; tuple[dict, float]\n</code></pre> <p>Fix Alice's measurements and optimize over Bob's measurements.</p> Source code in <code>toqito/nonlocal_games/nonlocal_game.py</code> <pre><code>def __optimize_bob(self, dim, alice_povms) -&gt; tuple[dict, float]:\n    \"\"\"Fix Alice's measurements and optimize over Bob's measurements.\"\"\"\n    # Get number of inputs and outputs.\n    (\n        num_outputs_alice,\n        num_outputs_bob,\n        num_inputs_alice,\n        num_inputs_bob,\n    ) = self.pred_mat.shape\n\n    # Now, optimize over Bob's measurement operators and fix Alice's\n    # operators as those are coming from the previous SDP.\n    bob_povms = defaultdict(cvxpy.Variable)\n    for y_ques in range(num_inputs_bob):\n        for b_ans in range(num_outputs_bob):\n            bob_povms[y_ques, b_ans] = cvxpy.Variable((dim, dim), hermitian=True)\n\n    win = 0\n    for x_ques in range(num_inputs_alice):\n        for y_ques in range(num_inputs_bob):\n            for a_ans in range(num_outputs_alice):\n                for b_ans in range(num_outputs_bob):\n                    win += (\n                        self.prob_mat[x_ques, y_ques]\n                        * self.pred_mat[a_ans, b_ans, x_ques, y_ques]\n                        * cvxpy.trace(bob_povms[y_ques, b_ans].H @ alice_povms[x_ques, a_ans].value)\n                    )\n\n    objective = cvxpy.Maximize(cvxpy.real(win))\n    constraints = []\n\n    # Sum over \"b\" for all \"y\" for Bob's measurements.\n    for y_ques in range(num_inputs_bob):\n        bob_sum_b = 0\n        for b_ans in range(num_outputs_bob):\n            bob_sum_b += bob_povms[y_ques, b_ans]\n            constraints.append(bob_povms[y_ques, b_ans] &gt;&gt; 0)\n        constraints.append(bob_sum_b == np.identity(dim))\n\n    problem = cvxpy.Problem(objective, constraints)\n\n    lower_bound = problem.solve()\n    return bob_povms, lower_bound\n</code></pre>"},{"location":"reference/toqito/nonlocal_games/nonlocal_game/#toqito.nonlocal_games.nonlocal_game.NonlocalGame.nonsignaling_value","title":"nonsignaling_value","text":"<pre><code>nonsignaling_value() -&gt; float\n</code></pre> <p>Compute the non-signaling value of the nonlocal game.</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>A value between [0, 1] representing the non-signaling value.</p> </li> </ul> Source code in <code>toqito/nonlocal_games/nonlocal_game.py</code> <pre><code>def nonsignaling_value(self) -&gt; float:\n    \"\"\"Compute the non-signaling value of the nonlocal game.\n\n    Returns:\n        A value between [0, 1] representing the non-signaling value.\n\n    \"\"\"\n    alice_out, bob_out, alice_in, bob_in = self.pred_mat.shape\n    dim_x, dim_y = 2, 2\n\n    constraints = []\n\n    # Define K(a,b|x,y) variable.\n    k_var = defaultdict(cvxpy.Variable)\n    for a_out in range(alice_out):\n        for b_out in range(bob_out):\n            for x_in in range(alice_in):\n                for y_in in range(bob_in):\n                    k_var[a_out, b_out, x_in, y_in] = cvxpy.Variable((dim_x, dim_y), hermitian=True)\n                    constraints.append(k_var[a_out, b_out, x_in, y_in] &gt;&gt; 0)\n\n    # Define \\sigma_a^x variable.\n    sigma = defaultdict(cvxpy.Variable)\n    for a_out in range(alice_out):\n        for x_in in range(alice_in):\n            sigma[a_out, x_in] = cvxpy.Variable((dim_x, dim_y), hermitian=True)\n\n    # Define \\rho_b^y variable.\n    rho = defaultdict(cvxpy.Variable)\n    for b_out in range(bob_out):\n        for y_in in range(bob_in):\n            rho[b_out, y_in] = cvxpy.Variable((dim_x, dim_y), hermitian=True)\n\n    # Define \\tau density operator variable.\n    tau = cvxpy.Variable((dim_x, dim_y), hermitian=True)\n\n    p_win = cvxpy.Constant(0)\n    for a_out in range(alice_out):\n        for b_out in range(bob_out):\n            for x_in in range(alice_in):\n                for y_in in range(bob_in):\n                    p_win += self.prob_mat[x_in, y_in] * cvxpy.trace(\n                        self.pred_mat[a_out, b_out, x_in, y_in].conj().T * k_var[a_out, b_out, x_in, y_in]\n                    )\n\n    objective = cvxpy.Maximize(cvxpy.real(p_win))\n\n    # The following constraints enforce the so-called non-signaling\n    # constraints.\n\n    # Enforce that:\n    # \\sum_{b \\in \\Gamma_B} K(a,b|x,y) = \\sigma_a^x\n    for x_in in range(alice_in):\n        for y_in in range(bob_in):\n            for a_out in range(alice_out):\n                b_sum = 0\n                for b_out in range(bob_out):\n                    b_sum += k_var[a_out, b_out, x_in, y_in]\n                constraints.append(b_sum == sigma[a_out, x_in])\n\n    # Enforce non-signaling constraints on Alice marginal:\n    # \\sum_{a \\in \\Gamma_A} K(a,b|x,y) = \\rho_b^y\n    for x_in in range(alice_in):\n        for y_in in range(bob_in):\n            for b_out in range(bob_out):\n                a_sum = 0\n                for a_out in range(alice_out):\n                    a_sum += k_var[a_out, b_out, x_in, y_in]\n                constraints.append(a_sum == rho[b_out, y_in])\n\n    # Enforce non-signaling constraints on Bob marginal:\n    # \\sum_{a \\in \\Gamma_A} \\sigma_a^x = \\tau\n    for x_in in range(alice_in):\n        sig_a_sum = 0\n        for a_out in range(alice_out):\n            sig_a_sum += sigma[a_out, x_in]\n        constraints.append(sig_a_sum == tau)\n\n    # Enforce that:\n    # \\sum_{b \\in \\Gamma_B} \\rho_b^y = \\tau\n    for y_in in range(bob_in):\n        rho_b_sum = 0\n        for b_out in range(bob_out):\n            rho_b_sum += rho[b_out, y_in]\n        constraints.append(rho_b_sum == tau)\n\n    # Enforce that tau is a density operator.\n    constraints.append(cvxpy.trace(tau) == 1)\n    constraints.append(tau &gt;&gt; 0)\n\n    problem = cvxpy.Problem(objective, constraints)\n    ns_val = problem.solve()\n\n    return ns_val\n</code></pre>"},{"location":"reference/toqito/nonlocal_games/nonlocal_game/#toqito.nonlocal_games.nonlocal_game.NonlocalGame.commuting_measurement_value_upper_bound","title":"commuting_measurement_value_upper_bound","text":"<pre><code>commuting_measurement_value_upper_bound(k: int | str = 1) -&gt; float\n</code></pre> <p>Compute an upper bound on the commuting measurement value of the nonlocal game.</p> <p>This function calculates an upper bound on the commuting measurement value by     using k-levels of the NPA hierarchy <sup>1</sup>. The NPA hierarchy is a uniform     family of semidefinite programs that converges to the commuting measurement value of     any nonlocal game.</p> <p>You can determine the level of the hierarchy by a positive integer or a string     of a form like '1+ab+aab', which indicates that an intermediate level of the hierarchy     should be used, where this example uses all products of one measurement, all products of     one Alice and one Bob measurement, and all products of two Alice and one Bob measurements.</p> <p>Parameters:</p> <ul> <li> <code>k</code>               (<code>int | str</code>, default:                   <code>1</code> )           \u2013            <p>The level of the NPA hierarchy to use (default=1).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The upper bound on the commuting strategy value of a nonlocal game.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Navascu\u00e9s, Miguel and Pironio, Stefano and Ac\u00edn, Antonio. A convergent hierarchy of semidefinite programs characterizing the set of quantum correlations. New Journal of Physics. vol. 10(7). (2008). doi:10.1088/1367-2630/10/7/073013.</p> Source code in <code>toqito/nonlocal_games/nonlocal_game.py</code> <pre><code>def commuting_measurement_value_upper_bound(self, k: int | str = 1) -&gt; float:\n    r\"\"\"Compute an upper bound on the commuting measurement value of the nonlocal game.\n\n    This function calculates an upper bound on the commuting measurement value by\n        using k-levels of the NPA hierarchy [@Navascues_2008_AConvergent]. The NPA hierarchy is a uniform\n        family of semidefinite programs that converges to the commuting measurement value of\n        any nonlocal game.\n\n    You can determine the level of the hierarchy by a positive integer or a string\n        of a form like '1+ab+aab', which indicates that an intermediate level of the hierarchy\n        should be used, where this example uses all products of one measurement, all products of\n        one Alice and one Bob measurement, and all products of two Alice and one Bob measurements.\n\n    Args:\n        k: The level of the NPA hierarchy to use (default=1).\n\n    Returns:\n        The upper bound on the commuting strategy value of a nonlocal game.\n\n    \"\"\"\n    alice_out, bob_out, alice_in, bob_in = self.pred_mat.shape\n\n    mat = defaultdict(cvxpy.Variable)\n    for x_in in range(alice_in):\n        for y_in in range(bob_in):\n            mat[x_in, y_in] = cvxpy.Variable((alice_out, bob_out), name=f\"M(a, b | {x_in}, {y_in})\")\n\n    p_win = cvxpy.Constant(0)\n    for a_out in range(alice_out):\n        for b_out in range(bob_out):\n            for x_in in range(alice_in):\n                for y_in in range(bob_in):\n                    p_win += (\n                        self.prob_mat[x_in, y_in]\n                        * self.pred_mat[a_out, b_out, x_in, y_in]\n                        * mat[x_in, y_in][a_out, b_out]\n                    )\n\n    npa = npa_constraints(mat, k)\n    objective = cvxpy.Maximize(p_win)\n    problem = cvxpy.Problem(objective, npa)\n    cs_val = problem.solve()\n\n    return cs_val\n</code></pre>"},{"location":"reference/toqito/nonlocal_games/quantum_hedging/","title":"quantum_hedging","text":""},{"location":"reference/toqito/nonlocal_games/quantum_hedging/#toqito.nonlocal_games.quantum_hedging","title":"quantum_hedging","text":"<p>Semidefinite programs for obtaining values of quantum hedging scenarios.</p>"},{"location":"reference/toqito/nonlocal_games/quantum_hedging/#toqito.nonlocal_games.quantum_hedging.QuantumHedging","title":"QuantumHedging","text":"<pre><code>QuantumHedging(q_a: ndarray, num_reps: int)\n</code></pre> <p>Calculate optimal winning probabilities for hedging scenarios.</p> <p>Calculate the maximal and minimal winning probabilities for quantum hedging to occur in certain two-party scenarios [@Arunachalam_2017_QuantumHedging, Molina_2012_Hedging].</p> <p>Examples:</p> <p>This example illustrates the initial example of perfect hedging when Alice and Bob play two repetitions of the game where Alice prepares the maximally entangled state:</p> \\[     u = \\frac{1}{\\sqrt{2}}|00\\rangle + \\frac{1}{\\sqrt{2}}|11\\rangle, \\] <p>and Alice applies the measurement operator defined by vector</p> \\[     v = \\cos(\\pi/8)|00\\rangle + \\sin(\\pi/8)|11\\rangle. \\] <p>As was illustrated in <sup>1</sup>, the hedging value of the above scenario is \\(\\cos(\\pi/8)^2 \\approx 0.8536\\)</p> <pre><code>import numpy as np\nfrom toqito.states import basis\nfrom numpy import kron, cos, sin, pi, sqrt, isclose\nfrom toqito.nonlocal_games.quantum_hedging import QuantumHedging\n\ne_0, e_1 = basis(2, 0), basis(2, 1)\ne_00, e_01 = kron(e_0, e_0), kron(e_0, e_1)\ne_10, e_11 = kron(e_1, e_0), kron(e_1, e_1)\n\nalpha = 1 / sqrt(2)\ntheta = pi / 8\nw_var = alpha * cos(theta) * e_00 + sqrt(1 - alpha ** 2) * sin(theta) * e_11\n\nl_1 = -alpha * sin(theta) * e_00 + sqrt(1 - alpha ** 2) * cos(theta) * e_11\nl_2 = alpha * sin(theta) * e_10\nl_3 = sqrt(1 - alpha ** 2) * cos(theta) * e_01\n\nq_1 = w_var @ w_var.conj().T\nq_0 = l_1 @ l_1.conj().T + l_2 @ l_2.conj().T + l_3 @ l_3.conj().T\n\nmolina_watrous = QuantumHedging(q_0, 1)\n\n# cos(pi/8)**2 \\approx 0.8536\nprint(np.around(molina_watrous.max_prob_outcome_a_primal(), decimals=2))\n</code></pre> <p>0.85</p> <p>This example demonstrates strong duality with matching primal and dual values, as can be seen below:</p> <pre><code>import numpy as np\nfrom toqito.states import basis\nfrom numpy import kron, cos, sin, pi, sqrt, isclose\nfrom toqito.nonlocal_games.quantum_hedging import QuantumHedging\n\ne_0, e_1 = basis(2, 0), basis(2, 1)\ne_00, e_01 = kron(e_0, e_0), kron(e_0, e_1)\ne_10, e_11 = kron(e_1, e_0), kron(e_1, e_1)\n\nalpha = 1 / sqrt(2)\ntheta = pi / 8\nw_var = alpha * cos(theta) * e_00 + sqrt(1 - alpha ** 2) * sin(theta) * e_11\n\nl_1 = -alpha * sin(theta) * e_00 + sqrt(1 - alpha ** 2) * cos(theta) * e_11\nl_2 = alpha * sin(theta) * e_10\nl_3 = sqrt(1 - alpha ** 2) * cos(theta) * e_01\n\nq_1 = w_var @ w_var.conj().T\nq_0 = l_1 @ l_1.conj().T + l_2 @ l_2.conj().T + l_3 @ l_3.conj().T\n\nmolina_watrous = QuantumHedging(q_0, 1)\nprint(np.around(molina_watrous.max_prob_outcome_a_dual(), decimals=2))\n</code></pre> <p>0.85</p> <p>and</p> <pre><code>import numpy as np\nfrom toqito.states import basis\nfrom numpy import kron, cos, sin, pi, sqrt, isclose\nfrom toqito.nonlocal_games.quantum_hedging import QuantumHedging\n\ne_0, e_1 = basis(2, 0), basis(2, 1)\ne_00, e_01 = kron(e_0, e_0), kron(e_0, e_1)\ne_10, e_11 = kron(e_1, e_0), kron(e_1, e_1)\n\nalpha = 1 / sqrt(2)\ntheta = pi / 8\nw_var = alpha * cos(theta) * e_00 + sqrt(1 - alpha ** 2) * sin(theta) * e_11\n\nl_1 = -alpha * sin(theta) * e_00 + sqrt(1 - alpha ** 2) * cos(theta) * e_11\nl_2 = alpha * sin(theta) * e_10\nl_3 = sqrt(1 - alpha ** 2) * cos(theta) * e_01\n\nq_1 = w_var @ w_var.conj().T\nq_0 = l_1 @ l_1.conj().T + l_2 @ l_2.conj().T + l_3 @ l_3.conj().T\n\nmolina_watrous = QuantumHedging(q_0, 1)\nprint(np.around(molina_watrous.min_prob_outcome_a_primal(), decimals=2))\n</code></pre> <p>0.15</p> <pre><code>import numpy as np\nfrom toqito.states import basis\nfrom numpy import kron, cos, sin, pi, sqrt, isclose\nfrom toqito.nonlocal_games.quantum_hedging import QuantumHedging\n\ne_0, e_1 = basis(2, 0), basis(2, 1)\ne_00, e_01 = kron(e_0, e_0), kron(e_0, e_1)\ne_10, e_11 = kron(e_1, e_0), kron(e_1, e_1)\n\nalpha = 1 / sqrt(2)\ntheta = pi / 8\nw_var = alpha * cos(theta) * e_00 + sqrt(1 - alpha ** 2) * sin(theta) * e_11\n\nl_1 = -alpha * sin(theta) * e_00 + sqrt(1 - alpha ** 2) * cos(theta) * e_11\nl_2 = alpha * sin(theta) * e_10\nl_3 = sqrt(1 - alpha ** 2) * cos(theta) * e_01\n\nq_1 = w_var @ w_var.conj().T\nq_0 = l_1 @ l_1.conj().T + l_2 @ l_2.conj().T + l_3 @ l_3.conj().T\n\nmolina_watrous = QuantumHedging(q_0, 1)\nprint(np.around(molina_watrous.min_prob_outcome_a_dual(), decimals=2))\n</code></pre> <p>0.15</p> <p>References</p> <p><sup>1</sup> Molina, Abel and Watrous, John. Hedging bets with correlated quantum strategies. Proceedings of the Royal Society A: Mathematical, Physical and Engineering Sciences. vol. 468(2145). (2012). link.</p> <p>Initialize the variables for semidefinite program.</p> <p>Parameters:</p> <ul> <li> <code>q_a</code>               (<code>ndarray</code>)           \u2013            <p>The fixed SDP variable.</p> </li> <li> <code>num_reps</code>               (<code>int</code>)           \u2013            <p>The number of parallel repetitions.</p> </li> </ul> Source code in <code>toqito/nonlocal_games/quantum_hedging.py</code> <pre><code>def __init__(self, q_a: np.ndarray, num_reps: int) -&gt; None:\n    \"\"\"Initialize the variables for semidefinite program.\n\n    Args:\n        q_a: The fixed SDP variable.\n        num_reps: The number of parallel repetitions.\n\n    \"\"\"\n    self._q_a = q_a\n    self._num_reps = num_reps\n\n    self._sys = list(range(0, 2 * self._num_reps - 1, 2))\n\n    self._dim = 2 * np.ones((1, 2 * self._num_reps)).astype(int).flatten()\n    self._dim = self._dim.tolist()\n\n    # For the dual problem, the following unitary operator is used to\n    # permute the subsystems of Alice and Bob which is defined by the\n    # action:\n    #   \u03c0(y1 \u2297 y2 \u2297 x1 \u2297 x2) = y1 \u2297 x1 \u2297 y2 \u2297 x2\n    # for all y1 \u2208 Y1, y2 \u2208 Y2, x1 \u2208 X1, x2 \u2208 X2.).\n    l_1 = list(range(self._num_reps))\n    l_2 = list(range(self._num_reps, self._num_reps**2))\n    if self._num_reps == 1:\n        self._pperm = np.array([1])\n    else:\n        perm = [*sum(zip(l_1, l_2), ())]\n        self._pperm = permutation_operator(2, perm)\n</code></pre>"},{"location":"reference/toqito/nonlocal_games/quantum_hedging/#toqito.nonlocal_games.quantum_hedging.QuantumHedging.max_prob_outcome_a_primal","title":"max_prob_outcome_a_primal","text":"<pre><code>max_prob_outcome_a_primal() -&gt; float\n</code></pre> <p>Compute the maximal probability for calculating outcome \"a\".</p> <p>The primal problem for the maximal probability of \"a\" is given as:</p> \\[     \\begin{equation}         \\begin{aligned}             \\text{maximize:} \\quad &amp; \\langle Q_{a_1} \\otimes \\ldots                                      \\otimes Q_{a_n}, X \\rangle \\\\         \\text{subject to:} \\quad &amp; \\text{Tr}_{\\mathcal{Y}_1 \\otimes                                     \\ldots \\otimes \\mathcal{Y}_n}(X) =                                     I_{\\mathcal{X}_1 \\otimes \\ldots                                     \\otimes \\mathcal{X}_n},\\\\                                     &amp; X \\in \\text{Pos}(\\mathcal{Y}_1                                     \\otimes \\mathcal{X}_1 \\otimes \\ldots                                     \\otimes \\mathcal{Y}_n \\otimes                                     \\mathcal{X}_n)         \\end{aligned}     \\end{equation} \\] <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The optimal maximal probability for obtaining outcome \"a\".</p> </li> </ul> Source code in <code>toqito/nonlocal_games/quantum_hedging.py</code> <pre><code>def max_prob_outcome_a_primal(self) -&gt; float:\n    r\"\"\"Compute the maximal probability for calculating outcome \"a\".\n\n    The primal problem for the maximal probability of \"a\" is given as:\n\n    \\[\n        \\begin{equation}\n            \\begin{aligned}\n                \\text{maximize:} \\quad &amp; \\langle Q_{a_1} \\otimes \\ldots\n                                         \\otimes Q_{a_n}, X \\rangle \\\\\n            \\text{subject to:} \\quad &amp; \\text{Tr}_{\\mathcal{Y}_1 \\otimes\n                                        \\ldots \\otimes \\mathcal{Y}_n}(X) =\n                                        I_{\\mathcal{X}_1 \\otimes \\ldots\n                                        \\otimes \\mathcal{X}_n},\\\\\n                                        &amp; X \\in \\text{Pos}(\\mathcal{Y}_1\n                                        \\otimes \\mathcal{X}_1 \\otimes \\ldots\n                                        \\otimes \\mathcal{Y}_n \\otimes\n                                        \\mathcal{X}_n)\n            \\end{aligned}\n        \\end{equation}\n    \\]\n\n    Returns:\n        The optimal maximal probability for obtaining outcome \"a\".\n\n    \"\"\"\n    x_var = cvxpy.Variable((4**self._num_reps, 4**self._num_reps), hermitian=True)\n    objective = cvxpy.Maximize(cvxpy.real(cvxpy.trace(self._q_a.conj().T @ x_var)))\n    constraints = [partial_trace(x_var, self._sys, self._dim) == np.identity(2**self._num_reps), x_var &gt;&gt; 0]\n    problem = cvxpy.Problem(objective, constraints)\n\n    return problem.solve()\n</code></pre>"},{"location":"reference/toqito/nonlocal_games/quantum_hedging/#toqito.nonlocal_games.quantum_hedging.QuantumHedging.max_prob_outcome_a_dual","title":"max_prob_outcome_a_dual","text":"<pre><code>max_prob_outcome_a_dual() -&gt; float\n</code></pre> <p>Compute the maximal probability for calculating outcome \"a\".</p> <p>The dual problem for the maximal probability of \"a\" is given as:</p> \\[     \\begin{equation}         \\begin{aligned}             \\text{minimize:} \\quad &amp; \\text{Tr}(Y) \\\\             \\text{subject to:} \\quad &amp; \\pi \\left(I_{\\mathcal{Y}_1             \\otimes \\ldots \\otimes \\mathcal{Y}_n} \\otimes Y \\right)             \\pi^* \\geq Q_{a_1} \\otimes \\ldots \\otimes Q_{a_n}, \\\\             &amp; Y \\in \\text{Herm} \\left(\\mathcal{X} \\otimes \\ldots \\otimes             \\mathcal{X}_n \\right)         \\end{aligned}     \\end{equation} \\] <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The optimal maximal probability for obtaining outcome \"a\".</p> </li> </ul> Source code in <code>toqito/nonlocal_games/quantum_hedging.py</code> <pre><code>def max_prob_outcome_a_dual(self) -&gt; float:\n    r\"\"\"Compute the maximal probability for calculating outcome \"a\".\n\n    The dual problem for the maximal probability of \"a\" is given as:\n\n    \\[\n        \\begin{equation}\n            \\begin{aligned}\n                \\text{minimize:} \\quad &amp; \\text{Tr}(Y) \\\\\n                \\text{subject to:} \\quad &amp; \\pi \\left(I_{\\mathcal{Y}_1\n                \\otimes \\ldots \\otimes \\mathcal{Y}_n} \\otimes Y \\right)\n                \\pi^* \\geq Q_{a_1} \\otimes \\ldots \\otimes Q_{a_n}, \\\\\n                &amp; Y \\in \\text{Herm} \\left(\\mathcal{X} \\otimes \\ldots \\otimes\n                \\mathcal{X}_n \\right)\n            \\end{aligned}\n        \\end{equation}\n    \\]\n\n    Returns:\n        The optimal maximal probability for obtaining outcome \"a\".\n\n    \"\"\"\n    y_var = cvxpy.Variable((2**self._num_reps, 2**self._num_reps), hermitian=True)\n    objective = cvxpy.Minimize(cvxpy.trace(cvxpy.real(y_var)))\n\n    kron_var = cvxpy.kron(np.eye(2**self._num_reps), y_var)\n    if self._num_reps == 1:\n        u_var = cvxpy.multiply(cvxpy.multiply(self._pperm, kron_var), self._pperm.conj().T)\n        constraints = [cvxpy.real(u_var) &gt;&gt; self._q_a]\n    else:\n        constraints = [cvxpy.real(self._pperm @ kron_var @ self._pperm.conj().T) &gt;&gt; self._q_a]\n    problem = cvxpy.Problem(objective, constraints)\n\n    return problem.solve()\n</code></pre>"},{"location":"reference/toqito/nonlocal_games/quantum_hedging/#toqito.nonlocal_games.quantum_hedging.QuantumHedging.min_prob_outcome_a_primal","title":"min_prob_outcome_a_primal","text":"<pre><code>min_prob_outcome_a_primal() -&gt; float\n</code></pre> <p>Compute the minimal probability for calculating outcome \"a\".</p> <p>The primal problem for the minimal probability of \"a\" is given as:</p> \\[     \\begin{equation}         \\begin{aligned}             \\text{minimize:} \\quad &amp; \\langle Q_{a_1} \\otimes \\ldots                                      \\otimes Q_{a_n}, X \\rangle \\\\         \\text{subject to:} \\quad &amp; \\text{Tr}_{\\mathcal{Y}_1 \\otimes                                     \\ldots \\otimes \\mathcal{Y}_n}(X) =                                     I_{\\mathcal{X}_1 \\otimes \\ldots                                     \\otimes \\mathcal{X}_n},\\\\                                     &amp; X \\in \\text{Pos}(\\mathcal{Y}_1                                     \\otimes \\mathcal{X}_1 \\otimes \\ldots                                     \\otimes \\mathcal{Y}_n \\otimes                                     \\mathcal{X}_n)         \\end{aligned}     \\end{equation} \\] <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The optimal minimal probability for obtaining outcome \"a\".</p> </li> </ul> Source code in <code>toqito/nonlocal_games/quantum_hedging.py</code> <pre><code>def min_prob_outcome_a_primal(self) -&gt; float:\n    r\"\"\"Compute the minimal probability for calculating outcome \"a\".\n\n    The primal problem for the minimal probability of \"a\" is given as:\n\n    \\[\n        \\begin{equation}\n            \\begin{aligned}\n                \\text{minimize:} \\quad &amp; \\langle Q_{a_1} \\otimes \\ldots\n                                         \\otimes Q_{a_n}, X \\rangle \\\\\n            \\text{subject to:} \\quad &amp; \\text{Tr}_{\\mathcal{Y}_1 \\otimes\n                                        \\ldots \\otimes \\mathcal{Y}_n}(X) =\n                                        I_{\\mathcal{X}_1 \\otimes \\ldots\n                                        \\otimes \\mathcal{X}_n},\\\\\n                                        &amp; X \\in \\text{Pos}(\\mathcal{Y}_1\n                                        \\otimes \\mathcal{X}_1 \\otimes \\ldots\n                                        \\otimes \\mathcal{Y}_n \\otimes\n                                        \\mathcal{X}_n)\n            \\end{aligned}\n        \\end{equation}\n    \\]\n\n    Returns:\n        The optimal minimal probability for obtaining outcome \"a\".\n\n    \"\"\"\n    x_var = cvxpy.Variable((4**self._num_reps, 4**self._num_reps), hermitian=True)\n    objective = cvxpy.Minimize(cvxpy.real(cvxpy.trace(self._q_a.conj().T @ x_var)))\n    constraints = [partial_trace(x_var, self._sys, self._dim) == np.identity(2**self._num_reps), x_var &gt;&gt; 0]\n    problem = cvxpy.Problem(objective, constraints)\n\n    return problem.solve()\n</code></pre>"},{"location":"reference/toqito/nonlocal_games/quantum_hedging/#toqito.nonlocal_games.quantum_hedging.QuantumHedging.min_prob_outcome_a_dual","title":"min_prob_outcome_a_dual","text":"<pre><code>min_prob_outcome_a_dual() -&gt; float\n</code></pre> <p>Compute the minimal probability for calculating outcome \"a\".</p> <p>The dual problem for the minimal probability of \"a\" is given as:</p> \\[ \\begin{equation}     \\begin{aligned}         \\text{maximize:} \\quad &amp; \\text{Tr}(Y) \\\\         \\text{subject to:} \\quad &amp; \\pi \\left(I_{\\mathcal{Y}_1         \\otimes \\ldots \\otimes \\mathcal{Y}_n} \\otimes Y \\right)         \\pi^* \\leq Q_{a_1} \\otimes \\ldots \\otimes Q_{a_n}, \\\\         &amp; Y \\in \\text{Herm} \\left(\\mathcal{X} \\otimes \\ldots \\otimes         \\mathcal{X}_n \\right)     \\end{aligned} \\end{equation} \\] <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The optimal minimal probability for obtaining outcome \"a\".</p> </li> </ul> Source code in <code>toqito/nonlocal_games/quantum_hedging.py</code> <pre><code>def min_prob_outcome_a_dual(self) -&gt; float:\n    r\"\"\"Compute the minimal probability for calculating outcome \"a\".\n\n    The dual problem for the minimal probability of \"a\" is given as:\n\n    \\[\n    \\begin{equation}\n        \\begin{aligned}\n            \\text{maximize:} \\quad &amp; \\text{Tr}(Y) \\\\\n            \\text{subject to:} \\quad &amp; \\pi \\left(I_{\\mathcal{Y}_1\n            \\otimes \\ldots \\otimes \\mathcal{Y}_n} \\otimes Y \\right)\n            \\pi^* \\leq Q_{a_1} \\otimes \\ldots \\otimes Q_{a_n}, \\\\\n            &amp; Y \\in \\text{Herm} \\left(\\mathcal{X} \\otimes \\ldots \\otimes\n            \\mathcal{X}_n \\right)\n        \\end{aligned}\n    \\end{equation}\n    \\]\n\n    Returns:\n        The optimal minimal probability for obtaining outcome \"a\".\n\n    \"\"\"\n    y_var = cvxpy.Variable((2**self._num_reps, 2**self._num_reps), hermitian=True)\n    objective = cvxpy.Maximize(cvxpy.trace(cvxpy.real(y_var)))\n\n    kron_var = cvxpy.kron(np.eye(2**self._num_reps), y_var)\n\n    if self._num_reps == 1:\n        u_var = cvxpy.multiply(cvxpy.multiply(self._pperm, kron_var), self._pperm.conj().T)\n        constraints = [cvxpy.real(u_var) &lt;&lt; self._q_a]\n    else:\n        constraints = [cvxpy.real(self._pperm @ kron_var @ self._pperm.conj().T) &lt;&lt; self._q_a]\n    problem = cvxpy.Problem(objective, constraints)\n\n    return problem.solve()\n</code></pre>"},{"location":"reference/toqito/nonlocal_games/xor_game/","title":"xor_game","text":""},{"location":"reference/toqito/nonlocal_games/xor_game/#toqito.nonlocal_games.xor_game","title":"xor_game","text":"<p>Two-player XOR game.</p>"},{"location":"reference/toqito/nonlocal_games/xor_game/#toqito.nonlocal_games.xor_game.XORGame","title":"XORGame","text":"<pre><code>XORGame(prob_mat: ndarray, pred_mat: ndarray, reps: int = 1, tol: float | None = None)\n</code></pre> <p>Create two-player XOR game object.</p> <p>Calculates the optimal probability that Alice and Bob win the game if they are allowed to determine a join strategy beforehand, but not allowed to communicate during the game itself.</p> <p>The quantum value of an XOR game can be solved via the semidefinite program from <sup>1</sup>.</p> <p>This function is adapted from the QETLAB package.</p> <p>A tutorial is available in the documentation. Go to [Calculating the quantum and classical value of a two-player XOR game] (../../../generated/gallery/nonlocal_games/xor_quantum_val.md).</p> <p>Examples:</p> <p>The CHSH game</p> <p>The CHSH game is a two-player nonlocal game with the following probability distribution and question and answer sets <sup>2</sup>.</p> \\[     \\begin{equation}             \\begin{aligned} \\pi(x,y) = \\frac{1}{4}, \\qquad (x,y) \\in                                             \\Sigma_A \\times                     \\Sigma_B, \\qquad \\text{and} \\qquad (a, b) \\in \\Gamma_A \\times                     \\Gamma_B,             \\end{aligned}     \\end{equation} \\] <p>where</p> \\[     \\begin{equation}             \\Sigma_A = \\{0, 1\\}, \\quad \\Sigma_B = \\{0, 1\\}, \\quad \\Gamma_A =             \\{0,1\\}, \\quad \\text{and} \\quad \\Gamma_B = \\{0, 1\\}.     \\end{equation} \\] <p>Alice and Bob win the CHSH game if and only if the following equation is satisfied</p> \\[     \\begin{equation}     a \\oplus b = x \\land y.     \\end{equation} \\] <p>Recall that \\(\\oplus\\) refers to the XOR operation.</p> <p>The optimal quantum value of CHSH is \\(\\cos(\\pi/8)^2 \\approx 0.8536\\) where the optimal classical value is \\(3/4\\).</p> <p>In order to specify the CHSH game, we can define the probability matrix and predicate matrix for the CHSH game as <code>numpy</code> arrays as follows.</p> <pre><code>import numpy as np\n\nprob_mat = np.array([[1 / 4, 1 / 4], [1 / 4, 1 / 4]])\npred_mat = np.array([[0, 0], [0, 1]])\n</code></pre> <p>In <code>toqito</code>, we can calculate both the quantum and classical value of the CHSH game as follows.</p> <pre><code>import numpy as np\nfrom toqito.nonlocal_games.xor_game import XORGame\n\nchsh = XORGame(prob_mat, pred_mat)\n\nprint(f\"Quantum value of the CHSH game is {np.around(chsh.quantum_value(), decimals=2)}\")\nprint(f\"Classical value of the CHSH game is {chsh.classical_value()}\")\n</code></pre> <p>Quantum value of the CHSH game is 0.85 Classical value of the CHSH game is 0.75</p> <p>The odd cycle game</p> <p>The odd cycle game is another XOR game <sup>1</sup>. For this game, we can specify the probability and predicate matrices as follows.</p> <pre><code>import numpy as np\nprob_mat = np.array(\n[\n    [0.1, 0.1, 0, 0, 0],\n    [0, 0.1, 0.1, 0, 0],\n    [0, 0, 0.1, 0.1, 0],\n    [0, 0, 0, 0.1, 0.1],\n    [0.1, 0, 0, 0, 0.1],\n]\n)\npred_mat = np.array(\n[\n    [0, 1, 0, 0, 0],\n    [0, 0, 1, 0, 0],\n    [0, 0, 0, 1, 0],\n    [0, 0, 0, 0, 1],\n    [1, 0, 0, 0, 0],\n])\n</code></pre> <p>In <code>|toqito\u27e9</code>, we can calculate both the quantum and classical value of the odd cycle game as follows.</p> <pre><code>import numpy as np\nfrom toqito.nonlocal_games.xor_game import XORGame\n\nodd_cycle = XORGame(prob_mat, pred_mat)\n\nprint(f\"Quantum value of the odd cycle game is {np.around(odd_cycle.quantum_value(), decimals=2)}\")\nprint(f\"Classical value of the odd cycle game is {np.around(odd_cycle.classical_value(), decimals=1)}\")\n</code></pre> <p>Quantum value of the odd cycle game is 0.98 Classical value of the odd cycle game is 0.9</p> <p>We can also calculate the nonsignaling value of the odd cycle game.</p> <pre><code>print(f\"Nonsignaling value of the odd cycle game is {np.around(odd_cycle.nonsignaling_value(), decimals=1)}\")\n</code></pre> <p>Nonsignaling value of the odd cycle game is 1.0</p> <p>References</p> <p><sup>1</sup> Cleve, Richard and Hoyer, Peter and Toner, Ben and Watrous, John. Consequences and Limits of Nonlocal Strategies. (2010). <sup>2</sup> Cleve, Richard and Slofstra, William and Unger, Falk and Upadhyay, Sarvagya. Strong Parallel Repetition Theorem for Quantum XOR Proof Systems. (2008).</p> <p>Construct XOR game object.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If dimension of probability matrix is not equal to                                 dimension of predicate matrix.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>prob_mat</code>               (<code>ndarray</code>)           \u2013            <p>A matrix whose (q_0, q_1)-entry gives the probability that                  the referee will give Alice the value <code>q_0</code> and Bob the                  value <code>q_1</code>.</p> </li> <li> <code>pred_mat</code>               (<code>ndarray</code>)           \u2013            <p>A binary matrix whose (q_0, q_1)-entry indicates the                  winning choice (either 0 or 1) when Alice and Bob receive                  values <code>q_0</code> and <code>q_1</code> from the referee.</p> </li> <li> <code>reps</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>int</p> </li> <li> <code>tol</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>The error tolerance for the value.                                 dimension of predicate matrix.</p> </li> </ul> Source code in <code>toqito/nonlocal_games/xor_game.py</code> <pre><code>def __init__(\n    self,\n    prob_mat: np.ndarray,\n    pred_mat: np.ndarray,\n    reps: int = 1,\n    tol: float | None = None,\n) -&gt; None:\n    \"\"\"Construct XOR game object.\n\n    Raises:\n        ValueError: If dimension of probability matrix is not equal to\n                                            dimension of predicate matrix.\n\n    Args:\n        prob_mat: A matrix whose (q_0, q_1)-entry gives the probability that\n                             the referee will give Alice the value `q_0` and Bob the\n                             value `q_1`.\n        pred_mat: A binary matrix whose (q_0, q_1)-entry indicates the\n                             winning choice (either 0 or 1) when Alice and Bob receive\n                             values `q_0` and `q_1` from the referee.\n        reps: int\n        tol: The error tolerance for the value.\n                                            dimension of predicate matrix.\n\n    \"\"\"\n    self.prob_mat = prob_mat\n    self.pred_mat = pred_mat\n    self.reps = reps\n\n    q_0, q_1 = self.prob_mat.shape\n    if tol is None:\n        self.tol = np.finfo(float).eps * q_0**2 * q_1**2\n    else:\n        self.tol = tol\n\n    # Perform some basic error checking to ensure the probability and\n    # predicate matrices are well-defined.\n    if (q_0, q_1) != self.pred_mat.shape:\n        raise ValueError(\"Invalid: The matrices `prob_mat` and `pred_mat` must be matrices of the same size.\")\n    if -np.min(np.min(self.prob_mat)) &gt; self.tol:\n        raise ValueError(\n            \"Invalid: The variable `prob_mat` must be a probability matrix: its entries must be non-negative.\"\n        )\n    if np.abs(np.sum(np.sum(self.prob_mat)) - 1) &gt; self.tol:\n        raise ValueError(\n            \"Invalid: The variable `prob_mat` must be a probability matrix: its entries must sum to 1.\"\n        )\n</code></pre>"},{"location":"reference/toqito/nonlocal_games/xor_game/#toqito.nonlocal_games.xor_game.XORGame.quantum_value","title":"quantum_value","text":"<pre><code>quantum_value() -&gt; float\n</code></pre> <p>Compute the quantum value of the XOR game.</p> <p>To obtain the quantum value of the XOR game, we calculate the following simplified dual problem of the semidefinite program from the set of notes: Lecture 6 of <sup>1</sup></p> \\[ \\begin{equation}         \\begin{aligned}                 \\text{minimize:} \\quad &amp; \\frac{1}{2} \\sum_{x \\in X} u(x) +                                                                     \\frac{1}{2} \\sum_{                                                                     y \\in Y} v(y) \\\\                 \\text{subject to:} \\quad &amp;                                 \\begin{pmatrix}                                         \\text{Diag}(u) &amp; -D \\\\                                         -D^* &amp; \\text{Diag}(v)                                 \\end{pmatrix} \\geq 0, \\\\                                 &amp; u \\in \\mathbb{R}^X, \\                                     v \\in \\mathbb{R}^Y.         \\end{aligned} \\end{equation} \\] <p>where \\(D\\) is the matrix defined to be</p> \\[ D(x,y) = \\pi(x, y) (-1)^{f(x,y)} \\] <p>In other words, \\(\\pi(x, y)\\) corresponds to <code>prob_mat[x, y]</code>, and \\(f(x,y)\\) corresponds to <code>pred_mat[x, y]</code>.</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>A value between [0, 1] representing the quantum value.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Watrous, John. Theory of Quantum Information Lecture Notes. (2011). link.</p> Source code in <code>toqito/nonlocal_games/xor_game.py</code> <pre><code>def quantum_value(self) -&gt; float:\n    r\"\"\"Compute the quantum value of the XOR game.\n\n    To obtain the quantum value of the XOR game, we calculate the following\n    simplified dual problem of the semidefinite program from the set of\n    notes: Lecture 6 of [@Watrous_2011_Lecture_Notes]\n\n    \\[\n    \\begin{equation}\n            \\begin{aligned}\n                    \\text{minimize:} \\quad &amp; \\frac{1}{2} \\sum_{x \\in X} u(x) +\n                                                                        \\frac{1}{2} \\sum_{\n                                                                        y \\in Y} v(y) \\\\\n                    \\text{subject to:} \\quad &amp;\n                                    \\begin{pmatrix}\n                                            \\text{Diag}(u) &amp; -D \\\\\n                                            -D^* &amp; \\text{Diag}(v)\n                                    \\end{pmatrix} \\geq 0, \\\\\n                                    &amp; u \\in \\mathbb{R}^X, \\\n                                        v \\in \\mathbb{R}^Y.\n            \\end{aligned}\n    \\end{equation}\n    \\]\n\n    where \\(D\\) is the matrix defined to be\n\n    \\[\n    D(x,y) = \\pi(x, y) (-1)^{f(x,y)}\n    \\]\n\n    In other words, \\(\\pi(x, y)\\) corresponds to `prob_mat[x, y]`, and \\(f(x,y)\\) corresponds to `pred_mat[x, y]`.\n\n    Returns:\n        A value between [0, 1] representing the quantum value.\n\n    \"\"\"\n    alice_in, bob_in = self.prob_mat.shape\n    d_mat = np.zeros([alice_in, bob_in])\n\n    for x_alice in range(alice_in):\n        for y_bob in range(bob_in):\n            d_mat[x_alice, y_bob] = self.prob_mat[x_alice, y_bob] * (-1) ** (self.pred_mat[x_alice, y_bob])\n\n    u_vec = cvxpy.Variable(alice_in, complex=False)\n    v_vec = cvxpy.Variable(bob_in, complex=False)\n\n    objective = cvxpy.Minimize(cvxpy.sum(u_vec) + cvxpy.sum(v_vec))\n    constraints = [\n        cvxpy.bmat(\n            [\n                [cvxpy.diag(u_vec), -d_mat],\n                [np.negative(d_mat.conj().T), cvxpy.diag(v_vec)],\n            ]\n        )\n        &gt;&gt; 0\n    ]\n\n    problem = cvxpy.Problem(objective, constraints)\n    problem.solve()\n\n    if self.reps == 1:\n        return np.real(problem.value) / 4 + 1 / 2\n    # It holds from (https://arxiv.org/abs/quant-ph/0608146) that the\n    # quantum value of any XOR game obeys strong parallel repetition. That\n    # is, it holds that:\n    #   \\omega^*(G^{^n}) = \\omega^*(G)^n,\n    # where G^{^n} denotes playing the game G n-times.\n    return (np.real(problem.value) / 4 + 1 / 2) ** self.reps\n</code></pre>"},{"location":"reference/toqito/nonlocal_games/xor_game/#toqito.nonlocal_games.xor_game.XORGame.classical_value","title":"classical_value","text":"<pre><code>classical_value() -&gt; float\n</code></pre> <p>Compute the classical value of the XOR game.</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>A value between [0, 1] representing the classical value.</p> </li> </ul> Source code in <code>toqito/nonlocal_games/xor_game.py</code> <pre><code>def classical_value(self) -&gt; float:\n    r\"\"\"Compute the classical value of the XOR game.\n\n    Returns:\n        A value between [0, 1] representing the classical value.\n\n    \"\"\"\n    return self.to_nonlocal_game().classical_value()\n</code></pre>"},{"location":"reference/toqito/nonlocal_games/xor_game/#toqito.nonlocal_games.xor_game.XORGame.nonsignaling_value","title":"nonsignaling_value","text":"<pre><code>nonsignaling_value() -&gt; float\n</code></pre> <p>Compute the nonsignaling value of an XOR game.</p> <p>Here, the existing function in the <code>NonlocalGame</code> class is called.</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>A value between [0, 1] representing the nonsignaling value.</p> </li> </ul> Source code in <code>toqito/nonlocal_games/xor_game.py</code> <pre><code>def nonsignaling_value(self) -&gt; float:\n    \"\"\"Compute the nonsignaling value of an XOR game.\n\n    Here, the existing function in the `NonlocalGame` class is called.\n\n    Returns:\n        A value between [0, 1] representing the nonsignaling value.\n\n    \"\"\"\n    return self.to_nonlocal_game().nonsignaling_value()\n</code></pre>"},{"location":"reference/toqito/nonlocal_games/xor_game/#toqito.nonlocal_games.xor_game.XORGame.to_nonlocal_game","title":"to_nonlocal_game","text":"<pre><code>to_nonlocal_game() -&gt; NonlocalGame\n</code></pre> <p>Given an XOR game, compute a predicate matrix representing the more generic <code>NonlocalGame</code> equivalent.</p> <p>Returns:</p> <ul> <li> <code>NonlocalGame</code>           \u2013            <p>A <code>NonlocalGame</code> object equivalent to the XOR game.</p> </li> </ul> Source code in <code>toqito/nonlocal_games/xor_game.py</code> <pre><code>def to_nonlocal_game(self) -&gt; NonlocalGame:\n    \"\"\"Given an XOR game, compute a predicate matrix representing the more generic `NonlocalGame` equivalent.\n\n    Returns:\n        A `NonlocalGame` object equivalent to the XOR game.\n\n    \"\"\"\n    q_0, q_1 = self.prob_mat.shape\n    xor_pred_mat = self.pred_mat\n    nlg_pred_mat = np.ndarray((2, 2, q_0, q_1))\n\n    for a in range(2):\n        for b in range(2):\n            for x in range(q_0):\n                for y in range(q_1):\n                    nlg_pred_mat[a, b, x, y] = xor_pred_mat[x, y] == a ^ b\n\n    return NonlocalGame(self.prob_mat, nlg_pred_mat, reps=self.reps)\n</code></pre>"},{"location":"reference/toqito/perms/","title":"perms","text":""},{"location":"reference/toqito/perms/#toqito.perms","title":"perms","text":"<p>Permutations is a set of modules that are used to implement various permutations and combinatorial functions.</p>"},{"location":"reference/toqito/perms/antisymmetric_projection/","title":"antisymmetric_projection","text":""},{"location":"reference/toqito/perms/antisymmetric_projection/#toqito.perms.antisymmetric_projection","title":"antisymmetric_projection","text":"<p>Antisymmetric projection operator produces an orthogonal projection onto an anti-symmetric subspace.</p>"},{"location":"reference/toqito/perms/antisymmetric_projection/#toqito.perms.antisymmetric_projection.antisymmetric_projection","title":"antisymmetric_projection","text":"<pre><code>antisymmetric_projection(dim: int, p_param: int = 2, partial: bool = False) -&gt; ndarray\n</code></pre> <p>Produce the projection onto the antisymmetric subspace <sup>1</sup>.</p> <p>Produces the orthogonal projection onto the anti-symmetric subspace of <code>p_param</code> copies of <code>dim</code>-dimensional space. If <code>partial = True</code>, then the antisymmetric projection (PA) isn't the orthogonal projection itself, but rather a matrix whose columns form an orthonormal basis for the symmetric subspace (and hence the PA * PA' is the orthogonal projection onto the symmetric subspace.)</p> <p>Examples:</p> <p>The \\(2\\)-dimensional antisymmetric projection with \\(p=1\\) is given as \\(2\\)-by-\\(2\\) identity matrix</p> \\[     A_{2,1} =     \\begin{pmatrix}         1 &amp; 0 \\\\         0 &amp; 1     \\end{pmatrix}. \\] <p>Using <code>|toqito\u27e9</code>, we can see this gives the proper result.</p> <pre><code>from toqito.perms import antisymmetric_projection\n\nprint(antisymmetric_projection(2, 1))\n</code></pre> <p>[[1. 0.]  [0. 1.]]</p> <p>When the \\(p\\) value is greater than the dimension of the antisymmetric projection, this just gives the matrix consisting of all zero entries. For instance, when \\(d = 2\\) and \\(p = 3\\) we have that</p> \\[     A_{2, 3} =     \\begin{pmatrix}         0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0     \\end{pmatrix}. \\] <p>Using <code>|toqito\u27e9</code> we can see this gives the proper result.</p> <pre><code>from toqito.perms import antisymmetric_projection\n\nprint(antisymmetric_projection(2, 3))\n</code></pre> <p>[[0. 0. 0. 0. 0. 0. 0. 0.]  [0. 0. 0. 0. 0. 0. 0. 0.]  [0. 0. 0. 0. 0. 0. 0. 0.]  [0. 0. 0. 0. 0. 0. 0. 0.]  [0. 0. 0. 0. 0. 0. 0. 0.]  [0. 0. 0. 0. 0. 0. 0. 0.]  [0. 0. 0. 0. 0. 0. 0. 0.]  [0. 0. 0. 0. 0. 0. 0. 0.]]</p> <p>Parameters:</p> <ul> <li> <code>dim</code>               (<code>int</code>)           \u2013            <p>The dimension of the local systems.</p> </li> <li> <code>p_param</code>               (<code>int</code>, default:                   <code>2</code> )           \u2013            <p>Default value of 2.</p> </li> <li> <code>partial</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Default value of 0.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Projection onto the antisymmetric subspace.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Anti-symmetric operator. link.</p> Source code in <code>toqito/perms/antisymmetric_projection.py</code> <pre><code>def antisymmetric_projection(dim: int, p_param: int = 2, partial: bool = False) -&gt; np.ndarray:\n    r\"\"\"Produce the projection onto the antisymmetric subspace [@WikiAsymmOp].\n\n    Produces the orthogonal projection onto the anti-symmetric subspace of `p_param` copies of\n    `dim`-dimensional space. If `partial = True`, then the antisymmetric projection (PA) isn't the\n    orthogonal projection itself, but rather a matrix whose columns form an orthonormal basis for the symmetric subspace\n    (and hence the PA * PA' is the orthogonal projection onto the symmetric subspace.)\n\n    Examples:\n        The \\(2\\)-dimensional antisymmetric projection with \\(p=1\\) is given as\n        \\(2\\)-by-\\(2\\) identity matrix\n\n        \\[\n            A_{2,1} =\n            \\begin{pmatrix}\n                1 &amp; 0 \\\\\n                0 &amp; 1\n            \\end{pmatrix}.\n        \\]\n\n        Using `|toqito\u27e9`, we can see this gives the proper result.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.perms import antisymmetric_projection\n\n        print(antisymmetric_projection(2, 1))\n        ```\n\n        When the \\(p\\) value is greater than the dimension of the antisymmetric projection, this just gives the matrix\n        consisting of all zero entries. For instance, when \\(d = 2\\) and \\(p = 3\\) we have that\n\n        \\[\n            A_{2, 3} =\n            \\begin{pmatrix}\n                0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\n            \\end{pmatrix}.\n        \\]\n\n        Using `|toqito\u27e9` we can see this gives the proper result.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.perms import antisymmetric_projection\n\n        print(antisymmetric_projection(2, 3))\n        ```\n\n    Args:\n        dim: The dimension of the local systems.\n        p_param: Default value of 2.\n        partial: Default value of 0.\n\n    Returns:\n        Projection onto the antisymmetric subspace.\n\n    \"\"\"\n    dimp = dim**p_param\n\n    if p_param == 1:\n        return np.eye(dim)\n    # The antisymmetric subspace is empty if `dim &lt; p`.\n    if dim &lt; p_param:\n        return np.zeros((dimp, dimp * (1 - partial)))\n\n    p_list = np.array(list(permutations(np.arange(p_param))))\n    p_fac = p_list.shape[0]\n\n    anti_proj = np.zeros((dimp, dimp))\n    for j in range(p_fac):\n        anti_proj += perm_sign(p_list[j, :]) * permutation_operator(dim * np.ones(p_param), p_list[j, :], False, True)\n    anti_proj = anti_proj / p_fac\n\n    if partial:\n        anti_proj = np.array(np.linalg.qr(anti_proj))\n    return anti_proj\n</code></pre>"},{"location":"reference/toqito/perms/perfect_matchings/","title":"perfect_matchings","text":""},{"location":"reference/toqito/perms/perfect_matchings/#toqito.perms.perfect_matchings","title":"perfect_matchings","text":"<p>Perfect matchings refers to ways of grouping an even number of objects into pairs.</p>"},{"location":"reference/toqito/perms/perfect_matchings/#toqito.perms.perfect_matchings.perfect_matchings","title":"perfect_matchings","text":"<pre><code>perfect_matchings(num: list[int] | int | ndarray) -&gt; ndarray\n</code></pre> <p>Give all perfect matchings of <code>num</code> objects.</p> <p>The input can be either an even natural number (the number of objects to be matched) or a <code>numpy</code> array containing an even number of distinct objects to be matched.</p> <p>Returns all perfect matchings of a given list of objects. That is, it returns all ways of grouping an even number of objects into pairs.</p> <p>This function is adapted from QETLAB. <sup>1</sup>.</p> <p>Examples:</p> <p>This is an example of how to generate all perfect matchings of the numbers 0, 1, 2, 3.</p> <pre><code>from toqito.perms import perfect_matchings\n\nprint(perfect_matchings(4))\n</code></pre> <p>[[0 1 2 3]  [0 2 1 3]  [0 3 2 1]]</p> <p>Parameters:</p> <ul> <li> <code>num</code>               (<code>list[int] | int | ndarray</code>)           \u2013            <p>Either an even integer, indicating that you would like all perfect matchings of the integers 0, 1, ... N-1,</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>An array containing all valid perfect matchings of size <code>num</code>.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Johnston, Nathaniel. {{QETLAB}: {A MATLAB} toolbox for quantum entanglement}. doi:10.5281/zenodo.44637.</p> Source code in <code>toqito/perms/perfect_matchings.py</code> <pre><code>def perfect_matchings(num: list[int] | int | np.ndarray) -&gt; np.ndarray:\n    r\"\"\"Give all perfect matchings of `num` objects.\n\n    The input can be either an even natural number (the number of objects to be matched) or a `numpy` array containing\n    an even number of distinct objects to be matched.\n\n    Returns all perfect matchings of a given list of objects. That is, it returns all ways of grouping an even number of\n    objects into pairs.\n\n    This function is adapted from QETLAB. [@QETLAB_link].\n\n    Examples:\n        This is an example of how to generate all perfect matchings of the numbers 0, 1, 2, 3.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.perms import perfect_matchings\n\n        print(perfect_matchings(4))\n        ```\n\n    Args:\n        num: Either an even integer, indicating that you would like all perfect matchings of the integers 0, 1, ... N-1,\n        or a `list` or `np.array` containing an even number of distinct entries, indicating that you would like all\n        perfect matchings of those entries.\n\n    Returns:\n        An array containing all valid perfect matchings of size `num`.\n\n    \"\"\"\n    if isinstance(num, int):\n        num = np.arange(num)\n    if isinstance(num, list):\n        num = np.array(num)\n\n    # Base case, `num = 2`: only one perfect matching.\n    if (len_num := len(num)) == 2:\n        return num\n\n    # There are no perfect matchings of an odd number of objects.\n    if len_num % 2 == 1:\n        return np.zeros((0, len_num))\n\n    # Recursive step: build perfect matchings from smaller ones.\n\n    # Only do the recursive step once instead of `num-1` times: we will then tweak\n    # the output n-1 times.\n    lower_fac = perfect_matchings(num[2:])\n    if len(lower_fac.shape) == 1:\n        lfac_size = 1\n    else:\n        lfac_size = lower_fac.shape[0]\n    matchings = np.zeros((0, len_num), dtype=int)\n\n    # Now build the perfect matchings we actually want.\n    for j in range(1, len_num):\n        tlower_fac = lower_fac.copy()\n        tlower_fac[tlower_fac == num[j]] = num[1]\n\n        one_vec = np.ones((lfac_size, 2), dtype=int) * [num[0], num[j]]\n        if lfac_size == 1:\n            one_vec = one_vec[0]\n\n        s_vec = np.hstack((one_vec, tlower_fac))\n        matchings = np.vstack((matchings, s_vec))\n\n    return matchings\n</code></pre>"},{"location":"reference/toqito/perms/perm_sign/","title":"perm_sign","text":""},{"location":"reference/toqito/perms/perm_sign/#toqito.perms.perm_sign","title":"perm_sign","text":"<p>Calculates the permutation sign.</p>"},{"location":"reference/toqito/perms/perm_sign/#toqito.perms.perm_sign.perm_sign","title":"perm_sign","text":"<pre><code>perm_sign(perm: ndarray | list[int]) -&gt; float\n</code></pre> <p>Compute the \"sign\" of a permutation <sup>1</sup>.</p> <p>The sign (either -1 or 1) of the permutation <code>perm</code> is <code>-1**inv</code>, where <code>inv</code> is the number of inversions contained in <code>perm</code>.</p> <p>Examples:</p> <p>For the following vector</p> \\[     [1, 2, 3, 4] \\] <p>the permutation sign is positive as the number of elements in the vector are even. This can be performed in <code>|toqito\u27e9</code> as follows.</p> <pre><code>from toqito.perms import perm_sign\n\nprint(perm_sign([1, 2, 3, 4]))\n</code></pre> <p>1.0</p> <p>For the following vector</p> \\[     [1, 2, 3, 4, 5] \\] <p>the permutation sign is negative as the number of elements in the vector are odd. This can be performed in <code>|toqito\u27e9</code> as follows.</p> <pre><code>from toqito.perms import perm_sign\n\nprint(perm_sign([1, 2, 4, 3, 5]))\n</code></pre> <p>-1.0</p> <p>Parameters:</p> <ul> <li> <code>perm</code>               (<code>ndarray | list[int]</code>)           \u2013            <p>The permutation vector to be checked.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The value 1 if the permutation is of even length and the value of -1 if the permutation is of odd length.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Parity of a permutation. link.</p> Source code in <code>toqito/perms/perm_sign.py</code> <pre><code>def perm_sign(perm: np.ndarray | list[int]) -&gt; float:\n    r\"\"\"Compute the \"sign\" of a permutation [@WikiParPerm].\n\n    The sign (either -1 or 1) of the permutation `perm` is `-1**inv`, where `inv` is the number of\n    inversions contained in `perm`.\n\n    Examples:\n        For the following vector\n\n        \\[\n            [1, 2, 3, 4]\n        \\]\n\n        the permutation sign is positive as the number of elements in the vector are even. This can be performed in\n        `|toqito\u27e9` as follows.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.perms import perm_sign\n\n        print(perm_sign([1, 2, 3, 4]))\n        ```\n\n        For the following vector\n\n        \\[\n            [1, 2, 3, 4, 5]\n        \\]\n\n        the permutation sign is negative as the number of elements in the vector are odd. This can be performed in\n        `|toqito\u27e9` as follows.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.perms import perm_sign\n\n        print(perm_sign([1, 2, 4, 3, 5]))\n        ```\n\n    Args:\n        perm: The permutation vector to be checked.\n\n    Returns:\n        The value 1 if the permutation is of even length and the value of -1 if the permutation is of odd length.\n\n    \"\"\"\n    return linalg.det(np.eye(len(perm))[:, np.array(perm) - 1])\n</code></pre>"},{"location":"reference/toqito/perms/permutation_operator/","title":"permutation_operator","text":""},{"location":"reference/toqito/perms/permutation_operator/#toqito.perms.permutation_operator","title":"permutation_operator","text":"<p>Permutation operator is a unitary operator that permutes subsystems.</p>"},{"location":"reference/toqito/perms/permutation_operator/#toqito.perms.permutation_operator.permutation_operator","title":"permutation_operator","text":"<pre><code>permutation_operator(dim: list[int] | int, perm: list[int], inv_perm: bool = False, is_sparse: bool = False) -&gt; ndarray\n</code></pre> <p>Produce a unitary operator that permutes subsystems.</p> <p>Generates a unitary operator that permutes the order of subsystems according to the permutation vector <code>perm</code>, where the \\(i^{th}\\) subsystem has dimension <code>dim[i]</code>.</p> <p>If <code>inv_perm</code> = True, it implements the inverse permutation of <code>perm</code>. The permutation operator return is full is <code>is_sparse</code> is <code>False</code> and sparse if <code>is_sparse</code> is <code>True</code>.</p> <p>Examples:</p> <p>The permutation operator obtained with dimension \\(d = 2\\) is equivalent to the standard swap operator on two qubits</p> \\[     P_{2, [1, 0]} =     \\begin{pmatrix}         1 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 1 &amp; 0 \\\\         0 &amp; 1 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 1     \\end{pmatrix} \\] <p>Using <code>|toqito\u27e9</code>, this can be achieved in the following manner.</p> <pre><code>from toqito.perms import permutation_operator\n\nprint(permutation_operator(2, [1, 0]))\n</code></pre> <p>[[1. 0. 0. 0.]  [0. 0. 1. 0.]  [0. 1. 0. 0.]  [0. 0. 0. 1.]]</p> <p>Parameters:</p> <ul> <li> <code>dim</code>               (<code>list[int] | int</code>)           \u2013            <p>The dimensions of the subsystems to be permuted.</p> </li> <li> <code>perm</code>               (<code>list[int]</code>)           \u2013            <p>A permutation vector.</p> </li> <li> <code>inv_perm</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Boolean dictating if <code>perm</code> is inverse or not.</p> </li> <li> <code>is_sparse</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Boolean indicating if return is sparse or not.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Permutation operator of dimension <code>dim</code>.</p> </li> </ul> Source code in <code>toqito/perms/permutation_operator.py</code> <pre><code>def permutation_operator(\n    dim: list[int] | int,\n    perm: list[int],\n    inv_perm: bool = False,\n    is_sparse: bool = False,\n) -&gt; np.ndarray:\n    r\"\"\"Produce a unitary operator that permutes subsystems.\n\n    Generates a unitary operator that permutes the order of subsystems according to the permutation vector `perm`,\n    where the \\(i^{th}\\) subsystem has dimension `dim[i]`.\n\n    If `inv_perm` = True, it implements the inverse permutation of `perm`. The permutation operator return\n    is full is `is_sparse` is `False` and sparse if `is_sparse` is `True`.\n\n    Examples:\n        The permutation operator obtained with dimension \\(d = 2\\) is equivalent to the standard swap operator on two\n        qubits\n\n        \\[\n            P_{2, [1, 0]} =\n            \\begin{pmatrix}\n                1 &amp; 0 &amp; 0 &amp; 0 \\\\\n                0 &amp; 0 &amp; 1 &amp; 0 \\\\\n                0 &amp; 1 &amp; 0 &amp; 0 \\\\\n                0 &amp; 0 &amp; 0 &amp; 1\n            \\end{pmatrix}\n        \\]\n\n        Using `|toqito\u27e9`, this can be achieved in the following manner.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.perms import permutation_operator\n\n        print(permutation_operator(2, [1, 0]))\n        ```\n\n\n    Args:\n        dim: The dimensions of the subsystems to be permuted.\n        perm: A permutation vector.\n        inv_perm: Boolean dictating if `perm` is inverse or not.\n        is_sparse: Boolean indicating if return is sparse or not.\n\n    Returns:\n        Permutation operator of dimension `dim`.\n\n    \"\"\"\n    # Allow the user to enter a single number for `dim`.\n    if isinstance(dim, int):\n        dim_arr = np.array([dim] * np.ones(max(perm) + 1))\n    elif isinstance(dim, list):\n        dim_arr = np.array(dim)\n    else:\n        dim_arr = dim\n\n    mat = sp.sparse.identity(int(np.prod(dim_arr))) if is_sparse else np.identity(int(np.prod(dim_arr)))\n    # Swap the rows of the identity matrix appropriately.\n\n    return permute_systems(mat, perm, dim_arr, True, inv_perm)\n</code></pre>"},{"location":"reference/toqito/perms/permute_systems/","title":"permute_systems","text":""},{"location":"reference/toqito/perms/permute_systems/#toqito.perms.permute_systems","title":"permute_systems","text":"<p>Permute systems is used to permute subsystems within a quantum state or an operator.</p>"},{"location":"reference/toqito/perms/permute_systems/#toqito.perms.permute_systems.permute_systems","title":"permute_systems","text":"<pre><code>permute_systems(input_mat: ndarray, perm: ndarray | list[int], dim: ndarray | list[int] | None = None, row_only: bool = False, inv_perm: bool = False) -&gt; ndarray\n</code></pre> <p>Permute subsystems within a state or operator.</p> <p>Permutes the order of the subsystems of the vector or matrix <code>input_mat</code> according to the permutation vector <code>perm</code>, where the dimensions of the subsystems are given by the vector <code>dim</code>. If <code>input_mat</code> is non-square and not a vector, different row and column dimensions can be specified by putting the row dimensions in the first row of <code>dim</code> and the columns dimensions in the second row of <code>dim</code>.</p> <p>If <code>row_only = True</code>, then only the rows of <code>input_mat</code> are permuted, but not the columns -- this is equivalent to multiplying <code>input_mat</code> on the left by the corresponding permutation operator, but not on the right.</p> <p>If <code>row_only = False</code>, then <code>dim</code> only needs to contain the row dimensions of the subsystems, even if <code>input_mat</code> is not square. If <code>inv_perm = True</code>, then the inverse permutation of <code>perm</code> is applied instead of <code>perm</code> itself.</p> <p>Examples:</p> <p>For spaces \\(\\mathcal{A}\\) and \\(\\mathcal{B}\\) where \\(\\text{dim}(\\mathcal{A}) = \\text{dim}(\\mathcal{B}) = 2\\) we may consider an operator \\(X \\in \\mathcal{A} \\otimes \\mathcal{B}\\). Applying the <code>permute_systems</code> function with vector \\([1,0]\\) on \\(X\\), we may reorient the spaces such that \\(X \\in \\mathcal{B} \\otimes \\mathcal{A}\\).</p> <p>For example, if we define \\(X \\in \\mathcal{A} \\otimes \\mathcal{B}\\) as</p> \\[     X = \\begin{pmatrix}         1 &amp; 2 &amp; 3 &amp; 4 \\\\         5 &amp; 6 &amp; 7 &amp; 8 \\\\         9 &amp; 10 &amp; 11 &amp; 12 \\\\         13 &amp; 14 &amp; 15 &amp; 16     \\end{pmatrix}, \\] <p>then applying the <code>permute_systems</code> function on \\(X\\) to obtain \\(X \\in \\mathcal{B} \\otimes \\mathcal{A}\\) yield the following matrix</p> \\[     X_{[1,0]} = \\begin{pmatrix}         1 &amp; 3 &amp; 2 &amp; 4 \\\\         9 &amp; 11 &amp; 10 &amp; 12 \\\\         5 &amp; 7 &amp; 6 &amp; 8 \\\\         13 &amp; 15 &amp; 14 &amp; 16     \\end{pmatrix}. \\] <pre><code>import numpy as np\nfrom toqito.perms import permute_systems\n\ntest_input_mat = np.arange(1, 17).reshape(4, 4)\n\nprint(permute_systems(test_input_mat, [1, 0]))\n</code></pre> <p>[[ 1  3  2  4]  [ 9 11 10 12]  [ 5  7  6  8]  [13 15 14 16]]</p> <p>For spaces \\(\\mathcal{A}, \\mathcal{B}\\), and \\(\\mathcal{C}\\) where \\(\\text{dim}(\\mathcal{A}) = \\text{dim}(\\mathcal{B}) = \\text{dim}(\\mathcal{C}) = 2\\) we may consider an operator \\(X \\in \\mathcal{A} \\otimes \\mathcal{B} \\otimes \\mathcal{C}\\). Applying the <code>permute_systems</code> function with vector \\([1,2,0]\\) on \\(X\\), we may reorient the spaces such that \\(X \\in \\mathcal{B} \\otimes \\mathcal{C} \\otimes \\mathcal{A}\\).</p> <p>For example, if we define \\(X \\in \\mathcal{A} \\otimes \\mathcal{B} \\otimes \\mathcal{C}\\) as</p> \\[     X =     \\begin{pmatrix}         1 &amp; 2 &amp; 3 &amp; 4, 5 &amp; 6 &amp; 7 &amp; 8 \\\\         9 &amp; 10 &amp; 11 &amp; 12 &amp; 13 &amp; 14 &amp; 15 &amp; 16 \\\\         17 &amp; 18 &amp; 19 &amp; 20 &amp; 21 &amp; 22 &amp; 23 &amp; 24 \\\\         25 &amp; 26 &amp; 27 &amp; 28 &amp; 29 &amp; 30 &amp; 31 &amp; 32 \\\\         33 &amp; 34 &amp; 35 &amp; 36 &amp; 37 &amp; 38 &amp; 39 &amp; 40 \\\\         41 &amp; 42 &amp; 43 &amp; 44 &amp; 45 &amp; 46 &amp; 47 &amp; 48 \\\\         49 &amp; 50 &amp; 51 &amp; 52 &amp; 53 &amp; 54 &amp; 55 &amp; 56 \\\\         57 &amp; 58 &amp; 59 &amp; 60 &amp; 61 &amp; 62 &amp; 63 &amp; 64     \\end{pmatrix}, \\] <p>then applying the <code>permute_systems</code> function on \\(X\\) to obtain \\(X \\in \\mathcal{B} \\otimes \\mathcal{C} \\otimes \\mathcal{C}\\) yield the following matrix</p> \\[     X_{[1, 2, 0]} =     \\begin{pmatrix}         1 &amp; 5 &amp; 2 &amp; 6 &amp; 3 &amp; 7 &amp; 4, 8 \\\\         33 &amp; 37 &amp; 34 &amp; 38 &amp; 35 &amp; 39 &amp; 36 &amp; 40 \\\\         9 &amp; 13 &amp; 10 &amp; 14 &amp; 11 &amp; 15 &amp; 12 &amp; 16 \\\\         41 &amp; 45 &amp; 42 &amp; 46 &amp; 43 &amp; 47 &amp; 44 &amp; 48 \\\\         17 &amp; 21 &amp; 18 &amp; 22 &amp; 19 &amp; 23 &amp; 20 &amp; 24 \\\\         49 &amp; 53 &amp; 50 &amp; 54 &amp; 51 &amp; 55 &amp; 52 &amp; 56 \\\\         25 &amp; 29 &amp; 26 &amp; 30 &amp; 27 &amp; 31 &amp; 28 &amp; 32 \\\\         57 &amp; 61 &amp; 58 &amp; 62 &amp; 59 &amp; 63 &amp; 60 &amp; 64     \\end{pmatrix}. \\] <pre><code>import numpy as np\nfrom toqito.perms import permute_systems\n\ntest_input_mat = np.arange(1, 65).reshape(8, 8)\n\nprint(permute_systems(test_input_mat, [1, 2, 0]))\n</code></pre> <p>[[ 1  5  2  6  3  7  4  8]  [33 37 34 38 35 39 36 40]  [ 9 13 10 14 11 15 12 16]  [41 45 42 46 43 47 44 48]  [17 21 18 22 19 23 20 24]  [49 53 50 54 51 55 52 56]  [25 29 26 30 27 31 28 32]  [57 61 58 62 59 63 60 64]]</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If dimension does not match the number of subsystems.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>input_mat</code>               (<code>ndarray</code>)           \u2013            <p>The vector or matrix.</p> </li> <li> <code>perm</code>               (<code>ndarray | list[int]</code>)           \u2013            <p>A permutation vector.</p> </li> <li> <code>dim</code>               (<code>ndarray | list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The default has all subsystems of equal dimension.</p> </li> <li> <code>row_only</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Default: <code>False</code></p> </li> <li> <code>inv_perm</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Default: <code>True</code></p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>The matrix or vector that has been permuted.</p> </li> </ul> Source code in <code>toqito/perms/permute_systems.py</code> <pre><code>def permute_systems(\n    input_mat: np.ndarray,\n    perm: np.ndarray | list[int],\n    dim: np.ndarray | list[int] | None = None,\n    row_only: bool = False,\n    inv_perm: bool = False,\n) -&gt; np.ndarray:\n    r\"\"\"Permute subsystems within a state or operator.\n\n    Permutes the order of the subsystems of the vector or matrix `input_mat` according to the permutation vector\n    `perm`, where the dimensions of the subsystems are given by the vector `dim`. If `input_mat` is\n    non-square and not a vector, different row and column dimensions can be specified by putting the row dimensions in\n    the first row of `dim` and the columns dimensions in the second row of `dim`.\n\n    If `row_only = True`, then only the rows of `input_mat` are permuted, but not the columns -- this is\n    equivalent to multiplying `input_mat` on the left by the corresponding permutation operator, but not on the\n    right.\n\n    If `row_only = False`, then `dim` only needs to contain the row dimensions of the subsystems, even if\n    `input_mat` is not square. If `inv_perm = True`, then the inverse permutation of `perm` is applied\n    instead of `perm` itself.\n\n    Examples:\n        For spaces \\(\\mathcal{A}\\) and \\(\\mathcal{B}\\) where \\(\\text{dim}(\\mathcal{A}) =\n        \\text{dim}(\\mathcal{B}) = 2\\) we may consider an operator \\(X \\in \\mathcal{A} \\otimes \\mathcal{B}\\).\n        Applying the\n        `permute_systems` function with vector \\([1,0]\\) on \\(X\\), we may reorient the spaces such that \\(X \\in\n        \\mathcal{B} \\otimes \\mathcal{A}\\).\n\n        For example, if we define \\(X \\in \\mathcal{A} \\otimes \\mathcal{B}\\) as\n\n        \\[\n            X = \\begin{pmatrix}\n                1 &amp; 2 &amp; 3 &amp; 4 \\\\\n                5 &amp; 6 &amp; 7 &amp; 8 \\\\\n                9 &amp; 10 &amp; 11 &amp; 12 \\\\\n                13 &amp; 14 &amp; 15 &amp; 16\n            \\end{pmatrix},\n        \\]\n\n        then applying the `permute_systems` function on \\(X\\) to obtain \\(X \\in \\mathcal{B} \\otimes \\mathcal{A}\\)\n        yield the following matrix\n\n        \\[\n            X_{[1,0]} = \\begin{pmatrix}\n                1 &amp; 3 &amp; 2 &amp; 4 \\\\\n                9 &amp; 11 &amp; 10 &amp; 12 \\\\\n                5 &amp; 7 &amp; 6 &amp; 8 \\\\\n                13 &amp; 15 &amp; 14 &amp; 16\n            \\end{pmatrix}.\n        \\]\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.perms import permute_systems\n\n        test_input_mat = np.arange(1, 17).reshape(4, 4)\n\n        print(permute_systems(test_input_mat, [1, 0]))\n        ```\n\n\n        For spaces \\(\\mathcal{A}, \\mathcal{B}\\), and \\(\\mathcal{C}\\) where \\(\\text{dim}(\\mathcal{A}) =\n        \\text{dim}(\\mathcal{B}) = \\text{dim}(\\mathcal{C}) = 2\\) we may consider an operator \\(X \\in \\mathcal{A} \\otimes\n        \\mathcal{B} \\otimes \\mathcal{C}\\). Applying the `permute_systems` function with vector \\([1,2,0]\\) on\n        \\(X\\), we may reorient the spaces such that \\(X \\in \\mathcal{B} \\otimes \\mathcal{C} \\otimes \\mathcal{A}\\).\n\n        For example, if we define \\(X \\in \\mathcal{A} \\otimes \\mathcal{B} \\otimes \\mathcal{C}\\) as\n\n        \\[\n            X =\n            \\begin{pmatrix}\n                1 &amp; 2 &amp; 3 &amp; 4, 5 &amp; 6 &amp; 7 &amp; 8 \\\\\n                9 &amp; 10 &amp; 11 &amp; 12 &amp; 13 &amp; 14 &amp; 15 &amp; 16 \\\\\n                17 &amp; 18 &amp; 19 &amp; 20 &amp; 21 &amp; 22 &amp; 23 &amp; 24 \\\\\n                25 &amp; 26 &amp; 27 &amp; 28 &amp; 29 &amp; 30 &amp; 31 &amp; 32 \\\\\n                33 &amp; 34 &amp; 35 &amp; 36 &amp; 37 &amp; 38 &amp; 39 &amp; 40 \\\\\n                41 &amp; 42 &amp; 43 &amp; 44 &amp; 45 &amp; 46 &amp; 47 &amp; 48 \\\\\n                49 &amp; 50 &amp; 51 &amp; 52 &amp; 53 &amp; 54 &amp; 55 &amp; 56 \\\\\n                57 &amp; 58 &amp; 59 &amp; 60 &amp; 61 &amp; 62 &amp; 63 &amp; 64\n            \\end{pmatrix},\n        \\]\n\n        then applying the `permute_systems` function on \\(X\\) to obtain \\(X \\in \\mathcal{B} \\otimes \\mathcal{C}\n        \\otimes \\mathcal{C}\\) yield the following matrix\n\n        \\[\n            X_{[1, 2, 0]} =\n            \\begin{pmatrix}\n                1 &amp; 5 &amp; 2 &amp; 6 &amp; 3 &amp; 7 &amp; 4, 8 \\\\\n                33 &amp; 37 &amp; 34 &amp; 38 &amp; 35 &amp; 39 &amp; 36 &amp; 40 \\\\\n                9 &amp; 13 &amp; 10 &amp; 14 &amp; 11 &amp; 15 &amp; 12 &amp; 16 \\\\\n                41 &amp; 45 &amp; 42 &amp; 46 &amp; 43 &amp; 47 &amp; 44 &amp; 48 \\\\\n                17 &amp; 21 &amp; 18 &amp; 22 &amp; 19 &amp; 23 &amp; 20 &amp; 24 \\\\\n                49 &amp; 53 &amp; 50 &amp; 54 &amp; 51 &amp; 55 &amp; 52 &amp; 56 \\\\\n                25 &amp; 29 &amp; 26 &amp; 30 &amp; 27 &amp; 31 &amp; 28 &amp; 32 \\\\\n                57 &amp; 61 &amp; 58 &amp; 62 &amp; 59 &amp; 63 &amp; 60 &amp; 64\n            \\end{pmatrix}.\n        \\]\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.perms import permute_systems\n\n        test_input_mat = np.arange(1, 65).reshape(8, 8)\n\n        print(permute_systems(test_input_mat, [1, 2, 0]))\n        ```\n\n\n\n    Raises:\n        ValueError: If dimension does not match the number of subsystems.\n\n    Args:\n        input_mat: The vector or matrix.\n        perm: A permutation vector.\n        dim: The default has all subsystems of equal dimension.\n        row_only: Default: `False`\n        inv_perm: Default: `True`\n\n    Returns:\n        The matrix or vector that has been permuted.\n\n    \"\"\"\n    if len(input_mat.shape) == 1:\n        input_mat_dims = (1, input_mat.shape[0])\n    else:\n        input_mat_dims = input_mat.shape\n\n    is_vec = np.min(input_mat_dims) == 1\n    num_sys = len(perm)\n\n    if dim is None:\n        x_tmp = input_mat_dims[0] ** (1 / num_sys) * np.ones(num_sys)\n        y_tmp = input_mat_dims[1] ** (1 / num_sys) * np.ones(num_sys)\n        dim_arr = np.array([x_tmp, y_tmp])\n    elif isinstance(dim, list):\n        dim_arr = np.array(dim)\n    else:\n        dim_arr = dim\n\n    if is_vec:\n        # 1 if column vector\n        if len(input_mat.shape) &gt; 1:\n            vec_orien = 0\n        # 2 if row vector\n        else:\n            vec_orien = 1\n\n    if len(dim_arr.shape) == 1:\n        # Force dim to be a row vector.\n        dim_tmp = dim_arr[:].T\n        if is_vec:\n            dim_arr = np.ones((2, len(dim_arr)))\n            dim_arr[vec_orien, :] = dim_tmp\n        else:\n            dim_arr = np.array([[dim_tmp], [dim_tmp]])\n\n    prod_dim_r = int(np.prod(dim_arr[0, :]))\n    prod_dim_c = int(np.prod(dim_arr[1, :]))\n\n    if sorted(perm) != list(range(num_sys)):\n        raise ValueError(\"InvalidPerm: `perm` must be a permutation vector.\")\n    if input_mat_dims[0] != prod_dim_r or (not row_only and input_mat_dims[1] != prod_dim_c):\n        raise ValueError(\"InvalidDim: The dimensions specified in DIM do not agree with the size of X.\")\n    if is_vec:\n        # If `input_mat` is a 1-by-X row vector, ensure we \"flatten it\" appropriately:\n        if input_mat.shape[0] == 1:\n            input_mat = input_mat[0]\n            vec_orien = 1\n        # Rather than using subtraction to generate new indices,\n        # it's better to use methods designed for handling permutations directly.\n        # This avoids the risk of negative indices and is more straightforward.\n        num_sys -= 1  # 0-indexing (Since we're using 0-indexing, we need to subtract 1 from the number of subsystems.)\n        permuted_mat_1 = input_mat.reshape(dim_arr[vec_orien, ::-1].astype(int), order=\"F\")\n        if inv_perm:\n            permuted_mat = vec(np.transpose(permuted_mat_1, np.argsort(num_sys - np.array(perm[::-1])))).T\n        else:\n            permuted_mat = vec(np.transpose(permuted_mat_1, num_sys - np.array(perm[::-1]))).T\n\n        # We need to flatten out the array.\n        permuted_mat = functools.reduce(operator.iconcat, permuted_mat, [])\n        return np.array(permuted_mat)\n\n    vec_arg = np.array(list(range(0, input_mat_dims[0])))\n\n    # If the dimensions are specified, ensure they are given to the\n    # recursive calls as flattened lists.\n    if len(dim_arr[0][:]) == 1:\n        dim_arr = functools.reduce(operator.iconcat, dim_arr, [])\n\n    row_perm = permute_systems(vec_arg, perm, dim_arr[0][:], False, inv_perm)\n\n    # This condition is only necessary if the `input_mat` variable is sparse.\n    if sparse.issparse(input_mat):\n        input_mat = input_mat.toarray()\n        permuted_mat = input_mat[row_perm, :]\n        permuted_mat = np.array(permuted_mat)\n    else:\n        permuted_mat = input_mat[row_perm, :]\n\n    if not row_only:\n        vec_arg = np.array(list(range(0, input_mat_dims[1])))\n        col_perm = permute_systems(vec_arg, perm, dim_arr[1][:], False, inv_perm)\n        permuted_mat = permuted_mat[:, col_perm]\n\n    return permuted_mat\n</code></pre>"},{"location":"reference/toqito/perms/swap/","title":"swap","text":""},{"location":"reference/toqito/perms/swap/#toqito.perms.swap","title":"swap","text":"<p>Swap is used to apply the swap function within a quantum state or an operator.</p>"},{"location":"reference/toqito/perms/swap/#toqito.perms.swap.swap","title":"swap","text":"<pre><code>swap(rho: ndarray, sys: list[int] | None = None, dim: list[int] | list[list[int]] | int | ndarray | None = None, row_only: bool = False) -&gt; ndarray\n</code></pre> <p>Swap two subsystems within a state or operator.</p> <p>Swaps the two subsystems of the vector or matrix <code>rho</code>, where the dimensions of the (possibly more than 2) subsystems are given by <code>dim</code> and the indices of the two subsystems to be swapped are specified in the 1-by-2 vector <code>sys</code>.</p> <p>If <code>rho</code> is non-square and not a vector, different row and column dimensions can be specified by putting the row dimensions in the first row of <code>dim</code> and the column dimensions in the second row of <code>dim</code>.</p> <p>If <code>row_only</code> is set to <code>True</code>, then only the rows of <code>rho</code> are swapped, but not the columns -- this is equivalent to multiplying <code>rho</code> on the left by the corresponding swap operator, but not on the right.</p> <p>Examples:</p> <p>Consider the following matrix</p> \\[     X =     \\begin{pmatrix}         1 &amp; 5 &amp; 9 &amp; 13 \\\\         2 &amp; 6 &amp; 10 &amp; 14 \\\\         3 &amp; 7 &amp; 11 &amp; 15 \\\\         4 &amp; 8 &amp; 12 &amp; 16     \\end{pmatrix}. \\] <p>If we apply the <code>swap</code> function provided by <code>|toqito\u27e9</code> on \\(X\\), we should obtain the following matrix</p> \\[     \\text{Swap}(X) =     \\begin{pmatrix}         1 &amp; 9 &amp; 5 &amp; 13 \\\\         3 &amp; 11 &amp; 7 &amp; 15 \\\\         2 &amp; 10 &amp; 6 &amp; 14 \\\\         4 &amp; 12 &amp; 8 &amp; 16     \\end{pmatrix}. \\] <p>This can be observed by the following example in <code>|toqito\u27e9</code>.</p> <pre><code>import numpy as np\nfrom toqito.perms import swap\n\ntest_mat = np.arange(1, 17).reshape(4, 4)\n\nprint(swap(test_mat))\n</code></pre> <p>[[ 1  3  2  4]  [ 9 11 10 12]  [ 5  7  6  8]  [13 15 14 16]]</p> <p>It is also possible to use the <code>sys</code> and <code>dim</code> arguments, it is possible to specify the system and dimension on which to apply the swap operator. For instance for <code>sys = [1 ,2]</code> and <code>dim = 2</code> we have that</p> \\[     \\text{Swap}(X)_{2, [1, 2]} =     \\begin{pmatrix}         1 &amp; 9 &amp; 5 &amp; 13 \\\\         3 &amp; 11 &amp; 7 &amp; 15 \\\\         2 &amp; 10 &amp; 6 &amp; 14 \\\\         4 &amp; 12 &amp; 8 &amp; 16     \\end{pmatrix}. \\] <p>Using <code>|toqito\u27e9</code> we can see this gives the proper result.</p> <pre><code>import numpy as np\nfrom toqito.perms import swap\n\ntest_mat = np.array(\n    [[1, 5, 9, 13], [2, 6, 10, 14], [3, 7, 11, 15], [4, 8, 12, 16]]\n)\nprint(swap(test_mat, [1, 2], 2))\n</code></pre> <p>[[ 1  9  5 13]  [ 3 11  7 15]  [ 2 10  6 14]  [ 4 12  8 16]]</p> <p>It is also possible to perform the <code>swap</code> function on vectors in addition to matrices.</p> <pre><code>import numpy as np\nfrom toqito.perms import swap\n\ntest_vec = np.array([1, 2, 3, 4])\n\nprint(swap(test_vec))\n</code></pre> <p>[1 3 2 4]</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If dimension does not match the number of subsystems.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>rho</code>               (<code>ndarray</code>)           \u2013            <p>A vector or matrix to have its subsystems swapped.</p> </li> <li> <code>sys</code>               (<code>list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>Default: [1, 2]</p> </li> <li> <code>dim</code>               (<code>list[int] | list[list[int]] | int | ndarray | None</code>, default:                   <code>None</code> )           \u2013            <p>Default: <code>[sqrt(len(X), sqrt(len(X)))]</code></p> </li> <li> <code>row_only</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Default: <code>False</code></p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>The swapped matrix.</p> </li> </ul> Source code in <code>toqito/perms/swap.py</code> <pre><code>def swap(\n    rho: np.ndarray,\n    sys: list[int] | None = None,\n    dim: list[int] | list[list[int]] | int | np.ndarray | None = None,\n    row_only: bool = False,\n) -&gt; np.ndarray:\n    r\"\"\"Swap two subsystems within a state or operator.\n\n    Swaps the two subsystems of the vector or matrix `rho`, where the dimensions of the (possibly more than 2)\n    subsystems are given by `dim` and the indices of the two subsystems to be swapped are specified in the 1-by-2\n    vector `sys`.\n\n    If `rho` is non-square and not a vector, different row and column dimensions can be specified by putting the\n    row dimensions in the first row of `dim` and the column dimensions in the second row of `dim`.\n\n    If `row_only` is set to `True`, then only the rows of `rho` are swapped, but not the columns --\n    this is equivalent to multiplying `rho` on the left by the corresponding swap operator, but not on the right.\n\n    Examples:\n        Consider the following matrix\n\n        \\[\n            X =\n            \\begin{pmatrix}\n                1 &amp; 5 &amp; 9 &amp; 13 \\\\\n                2 &amp; 6 &amp; 10 &amp; 14 \\\\\n                3 &amp; 7 &amp; 11 &amp; 15 \\\\\n                4 &amp; 8 &amp; 12 &amp; 16\n            \\end{pmatrix}.\n        \\]\n\n        If we apply the `swap` function provided by `|toqito\u27e9` on \\(X\\), we should obtain the following\n        matrix\n\n        \\[\n            \\text{Swap}(X) =\n            \\begin{pmatrix}\n                1 &amp; 9 &amp; 5 &amp; 13 \\\\\n                3 &amp; 11 &amp; 7 &amp; 15 \\\\\n                2 &amp; 10 &amp; 6 &amp; 14 \\\\\n                4 &amp; 12 &amp; 8 &amp; 16\n            \\end{pmatrix}.\n        \\]\n\n        This can be observed by the following example in `|toqito\u27e9`.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.perms import swap\n\n        test_mat = np.arange(1, 17).reshape(4, 4)\n\n        print(swap(test_mat))\n        ```\n\n        It is also possible to use the `sys` and `dim` arguments, it is possible to specify the system and\n        dimension on which to apply the swap operator. For instance for `sys = [1 ,2]` and `dim = 2` we have\n        that\n\n        \\[\n            \\text{Swap}(X)_{2, [1, 2]} =\n            \\begin{pmatrix}\n                1 &amp; 9 &amp; 5 &amp; 13 \\\\\n                3 &amp; 11 &amp; 7 &amp; 15 \\\\\n                2 &amp; 10 &amp; 6 &amp; 14 \\\\\n                4 &amp; 12 &amp; 8 &amp; 16\n            \\end{pmatrix}.\n        \\]\n\n        Using `|toqito\u27e9` we can see this gives the proper result.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.perms import swap\n\n        test_mat = np.array(\n            [[1, 5, 9, 13], [2, 6, 10, 14], [3, 7, 11, 15], [4, 8, 12, 16]]\n        )\n        print(swap(test_mat, [1, 2], 2))\n        ```\n\n        It is also possible to perform the `swap` function on vectors in addition to matrices.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.perms import swap\n\n        test_vec = np.array([1, 2, 3, 4])\n\n        print(swap(test_vec))\n        ```\n\n\n\n\n    Raises:\n        ValueError: If dimension does not match the number of subsystems.\n\n    Args:\n        rho: A vector or matrix to have its subsystems swapped.\n        sys: Default: [1, 2]\n        dim: Default: `[sqrt(len(X), sqrt(len(X)))]`\n        row_only: Default: `False`\n\n    Returns:\n        The swapped matrix.\n\n    \"\"\"\n    if dim is not None and not isinstance(dim, (int, list, np.ndarray)):\n        raise TypeError(\"dim must be None, int, list, or np.ndarray.\")\n\n    if len(rho.shape) == 1:\n        rho_dims = (1, rho.shape[0])\n    else:\n        rho_dims = rho.shape\n\n    round_dim = np.rint(np.sqrt(rho_dims)).astype(int)\n\n    if sys is None:\n        sys = [1, 2]\n\n    if dim is None:\n        # Assume square subsystems inferred from rho_dims.\n        dim = np.array([[round_dim[0], round_dim[0]], [round_dim[1], round_dim[1]]], dtype=int)\n        num_sys = len(dim)\n    elif isinstance(dim, int):\n        # Split dimensions into two factors: dim and rho_dim/dim.\n        if rho_dims[0] % dim != 0 or rho_dims[1] % dim != 0:\n            raise ValueError(\"InvalidDim: The value of dim must evenly divide the number of rows and columns of rho.\")\n        dim = np.array([[dim, rho_dims[0] // dim], [dim, rho_dims[1] // dim]], dtype=int)\n        num_sys = 2\n    elif isinstance(dim, (list, np.ndarray)):\n        if not all(isinstance(d, (int, float, np.integer, np.floating)) for d in np.ravel(dim)):\n            raise TypeError(\"dim entries must be int or float values.\")\n        dim = np.array(dim, dtype=int)\n        num_sys = len(dim)\n\n    if len(sys) != 2:\n        raise ValueError(\"InvalidSys: sys must be a vector with exactly two elements.\")\n\n    if not (1 &lt;= sys[0] &lt;= num_sys and 1 &lt;= sys[1] &lt;= num_sys):\n        raise ValueError(\"InvalidSys: The subsystems in sys must be between 1 and len(dim). inclusive.\")\n\n    # Swap the indicated subsystems.\n    perm = np.arange(num_sys)\n    sys = np.array(sys) - 1\n\n    perm[sys] = perm[sys[::-1]]\n\n    return permute_systems(input_mat=rho, perm=perm, dim=dim, row_only=row_only)\n</code></pre>"},{"location":"reference/toqito/perms/swap_operator/","title":"swap_operator","text":""},{"location":"reference/toqito/perms/swap_operator/#toqito.perms.swap_operator","title":"swap_operator","text":"<p>Swap operator. is used to generate a unitary operator that can swap two subsystems.</p>"},{"location":"reference/toqito/perms/swap_operator/#toqito.perms.swap_operator.swap_operator","title":"swap_operator","text":"<pre><code>swap_operator(dim: list[int] | int, is_sparse: bool = False) -&gt; ndarray\n</code></pre> <p>Produce a unitary operator that swaps two subsystems.</p> <p>Provides the unitary operator that swaps two copies of <code>dim</code>-dimensional space. If the two subsystems are not of the same dimension, <code>dim</code> should be a 1-by-2 vector containing the dimension of the subsystems.</p> <p>Examples:</p> <p>The \\(2\\)-dimensional swap operator is given by the following matrix</p> \\[     X_2 =     \\begin{pmatrix}         1 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 1 &amp; 0 \\\\         0 &amp; 1 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 1     \\end{pmatrix} \\] <p>Using <code>|toqito\u27e9</code> we can obtain this matrix as follows.</p> <pre><code>from toqito.perms import swap_operator\n\nprint(swap_operator(2))\n</code></pre> <p>[[1. 0. 0. 0.]  [0. 0. 1. 0.]  [0. 1. 0. 0.]  [0. 0. 0. 1.]]</p> <p>The \\(3\\)-dimensional operator may be obtained using <code>|toqito\u27e9</code> as follows.</p> <pre><code>from toqito.perms import swap_operator\n\nprint(swap_operator(3))\n</code></pre> <p>[[1. 0. 0. 0. 0. 0. 0. 0. 0.]  [0. 0. 0. 1. 0. 0. 0. 0. 0.]  [0. 0. 0. 0. 0. 0. 1. 0. 0.]  [0. 1. 0. 0. 0. 0. 0. 0. 0.]  [0. 0. 0. 0. 1. 0. 0. 0. 0.]  [0. 0. 0. 0. 0. 0. 0. 1. 0.]  [0. 0. 1. 0. 0. 0. 0. 0. 0.]  [0. 0. 0. 0. 0. 1. 0. 0. 0.]  [0. 0. 0. 0. 0. 0. 0. 0. 1.]]</p> <p>Parameters:</p> <ul> <li> <code>dim</code>               (<code>list[int] | int</code>)           \u2013            <p>The dimensions of the subsystems.</p> </li> <li> <code>is_sparse</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Sparse if <code>True</code> and non-sparse if <code>False</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>The swap operator of dimension <code>dim</code>.</p> </li> </ul> Source code in <code>toqito/perms/swap_operator.py</code> <pre><code>def swap_operator(dim: list[int] | int, is_sparse: bool = False) -&gt; np.ndarray:\n    r\"\"\"Produce a unitary operator that swaps two subsystems.\n\n    Provides the unitary operator that swaps two copies of `dim`-dimensional space. If the two subsystems are not\n    of the same dimension, `dim` should be a 1-by-2 vector containing the dimension of the subsystems.\n\n    Examples:\n        The \\(2\\)-dimensional swap operator is given by the following matrix\n\n        \\[\n            X_2 =\n            \\begin{pmatrix}\n                1 &amp; 0 &amp; 0 &amp; 0 \\\\\n                0 &amp; 0 &amp; 1 &amp; 0 \\\\\n                0 &amp; 1 &amp; 0 &amp; 0 \\\\\n                0 &amp; 0 &amp; 0 &amp; 1\n            \\end{pmatrix}\n        \\]\n\n        Using `|toqito\u27e9` we can obtain this matrix as follows.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.perms import swap_operator\n\n        print(swap_operator(2))\n        ```\n\n        The \\(3\\)-dimensional operator may be obtained using `|toqito\u27e9` as follows.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.perms import swap_operator\n\n        print(swap_operator(3))\n        ```\n\n\n\n    Args:\n        dim: The dimensions of the subsystems.\n        is_sparse: Sparse if `True` and non-sparse if `False`.\n\n    Returns:\n        The swap operator of dimension `dim`.\n\n    \"\"\"\n    # Allow the user to enter a single number for dimension.\n    if isinstance(dim, int):\n        dim = np.array([dim, dim])\n\n    mat = sparse.identity(int(np.prod(dim))) if is_sparse else np.identity(int(np.prod(dim)))\n    # Swap the rows of the identity appropriately.\n    return swap(rho=mat, sys=[1, 2], dim=dim, row_only=True)\n</code></pre>"},{"location":"reference/toqito/perms/symmetric_projection/","title":"symmetric_projection","text":""},{"location":"reference/toqito/perms/symmetric_projection/#toqito.perms.symmetric_projection","title":"symmetric_projection","text":"<p>Symmetric projection operator produces a projection onto a symmetric subspace.</p>"},{"location":"reference/toqito/perms/symmetric_projection/#toqito.perms.symmetric_projection.symmetric_projection","title":"symmetric_projection","text":"<pre><code>symmetric_projection(dim: int, p_val: int = 2, partial: bool = False) -&gt; ndarray\n</code></pre> <p>Produce the projection onto the symmetric subspace <sup>1</sup>.</p> <p>For a complex Euclidean space \\(\\mathcal{X}\\) and a positive integer \\(n\\), the projection onto the symmetric subspace is given by</p> \\[     \\frac{1}{n!} \\sum_{\\pi \\in S_n} W_{\\pi} \\] <p>where \\(W_{\\pi}\\) is the swap operator and where \\(S_n\\) is the symmetric group on \\(n\\) symbols.</p> <p>Produces the orthogonal projection onto the symmetric subspace of <code>p_val</code> copies of <code>dim</code>-dimensional space. If <code>partial = True</code>, then the symmetric projection (PS) isn't the orthogonal projection itself, but rather a matrix whose columns form an orthonormal basis for the symmetric subspace (and hence the PS * PS' is the orthogonal projection onto the symmetric subspace).</p> <p>This function was adapted from the QETLAB package.</p> <p>Examples:</p> <p>The \\(2\\)-dimensional symmetric projection with \\(p=1\\) is given as \\(2\\)-by-\\(2\\) identity matrix</p> \\[     \\begin{pmatrix}         1 &amp; 0 \\\\         0 &amp; 1     \\end{pmatrix}. \\] <p>Using <code>|toqito\u27e9</code>, we can see this gives the proper result.</p> <pre><code>from toqito.perms import symmetric_projection\n\nprint(symmetric_projection(2, 1))\n</code></pre> <p>[[1. 0.]  [0. 1.]]</p> <p>When \\(d = 2\\) and \\(p = 2\\) we have that</p> \\[     \\begin{pmatrix}         1 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 1/2 &amp; 1/2 &amp; 0 \\\\         0 &amp; 1/2 &amp; 1/2 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 1     \\end{pmatrix}. \\] <p>Using <code>|toqito\u27e9</code> we can see this gives the proper result.</p> <pre><code>from toqito.perms import symmetric_projection\n\nprint(symmetric_projection(dim=2))\n</code></pre> <p>[[1.  0.  0.  0. ]  [0.  0.5 0.5 0. ]  [0.  0.5 0.5 0. ]  [0.  0.  0.  1. ]]</p> <p>Parameters:</p> <ul> <li> <code>dim</code>               (<code>int</code>)           \u2013            <p>The dimension of the local systems.</p> </li> <li> <code>p_val</code>               (<code>int</code>, default:                   <code>2</code> )           \u2013            <p>Default value of 2.</p> </li> <li> <code>partial</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Default value of 0.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Projection onto the symmetric subspace.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Chen, Jianxin and Ji, Zhengfeng and Kribs, David and L\u00fctkenhaus, Norbert and Zeng, Bei. Symmetric extension of two-qubit states. Physical Review A. vol. 90(3). (2014). doi:10.1103/physreva.90.032318.</p> Source code in <code>toqito/perms/symmetric_projection.py</code> <pre><code>def symmetric_projection(dim: int, p_val: int = 2, partial: bool = False) -&gt; np.ndarray:\n    r\"\"\"Produce the projection onto the symmetric subspace [@Chen_2014_Symmetric].\n\n    For a complex Euclidean space \\(\\mathcal{X}\\) and a positive integer \\(n\\), the projection onto the\n    symmetric subspace is given by\n\n    \\[\n        \\frac{1}{n!} \\sum_{\\pi \\in S_n} W_{\\pi}\n    \\]\n\n    where \\(W_{\\pi}\\) is the swap operator and where \\(S_n\\) is the symmetric group on \\(n\\) symbols.\n\n    Produces the orthogonal projection onto the symmetric subspace of `p_val` copies of `dim`-dimensional space.\n    If `partial = True`, then the symmetric projection (PS) isn't the orthogonal projection itself, but rather a matrix\n    whose columns form an orthonormal basis for the symmetric subspace (and hence the PS * PS' is the orthogonal\n    projection onto the symmetric subspace).\n\n    This function was adapted from the QETLAB package.\n\n    Examples:\n        The \\(2\\)-dimensional symmetric projection with \\(p=1\\) is given as \\(2\\)-by-\\(2\\) identity matrix\n\n        \\[\n            \\begin{pmatrix}\n                1 &amp; 0 \\\\\n                0 &amp; 1\n            \\end{pmatrix}.\n        \\]\n\n        Using `|toqito\u27e9`, we can see this gives the proper result.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.perms import symmetric_projection\n\n        print(symmetric_projection(2, 1))\n        ```\n\n\n        When \\(d = 2\\) and \\(p = 2\\) we have that\n\n        \\[\n            \\begin{pmatrix}\n                1 &amp; 0 &amp; 0 &amp; 0 \\\\\n                0 &amp; 1/2 &amp; 1/2 &amp; 0 \\\\\n                0 &amp; 1/2 &amp; 1/2 &amp; 0 \\\\\n                0 &amp; 0 &amp; 0 &amp; 1\n            \\end{pmatrix}.\n        \\]\n\n        Using `|toqito\u27e9` we can see this gives the proper result.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.perms import symmetric_projection\n\n        print(symmetric_projection(dim=2))\n        ```\n\n    Args:\n        dim: The dimension of the local systems.\n        p_val: Default value of 2.\n        partial: Default value of 0.\n\n    Returns:\n        Projection onto the symmetric subspace.\n\n    \"\"\"\n    if dim &lt; 1:\n        raise ValueError(\"InvalidDim: `dim` must be at least 1.\")\n    if p_val &lt; 1:\n        raise ValueError(\"InvalidPVal: `p_val` must be at least 1.\")\n\n    dimp = dim**p_val\n\n    if p_val == 1:\n        return np.eye(dim)\n\n    p_list = np.array(list(permutations(np.arange(p_val))))\n    p_fac = math.factorial(p_val)\n    sym_proj = np.zeros((dimp, dimp))\n\n    for perm in p_list:\n        sym_proj += permutation_operator(dim * np.ones(p_val), perm, False, True)\n    sym_proj /= p_fac\n\n    if partial:\n        sym_proj = orth(sym_proj)\n\n    return sym_proj\n</code></pre>"},{"location":"reference/toqito/perms/unique_perms/","title":"unique_perms","text":""},{"location":"reference/toqito/perms/unique_perms/#toqito.perms.unique_perms","title":"unique_perms","text":"<p>Unique permutations is used to calculate the unique permutations of a list/vector and their count.</p>"},{"location":"reference/toqito/perms/unique_perms/#toqito.perms.unique_perms.UniqueElement","title":"UniqueElement  <code>dataclass</code>","text":"<pre><code>UniqueElement(value: int, occurrences: int)\n</code></pre> <p>Class for unique elements to keep track of occurrences.</p>"},{"location":"reference/toqito/perms/unique_perms/#toqito.perms.unique_perms.unique_perms","title":"unique_perms","text":"<pre><code>unique_perms(elements: list[int])\n</code></pre> <p>Determine the number of unique permutations of a list.</p> <p>Examples:</p> <p>Consider the following vector</p> \\[     \\left[1, 1, 2, 2, 1, 2, 1, 3, 3, 3\\right]. \\] <p>The number of possible permutations possible with the above vector is \\(4200\\). This can be obtained using the <code>|toqito\u27e9</code> package as follows.</p> <pre><code>from toqito.perms import unique_perms\n\nvec_nums = [1, 1, 2, 2, 1, 2, 1, 3, 3, 3]\n\nprint(len(list(unique_perms(vec_nums))))\n</code></pre> <p>4200</p> <p>Parameters:</p> <ul> <li> <code>elements</code>               (<code>list[int]</code>)           \u2013            <p>List of integers.</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>The number of possible permutations possible.</p> </li> </ul> Source code in <code>toqito/perms/unique_perms.py</code> <pre><code>def unique_perms(elements: list[int]):\n    r\"\"\"Determine the number of unique permutations of a list.\n\n    Examples:\n        Consider the following vector\n\n        \\[\n            \\left[1, 1, 2, 2, 1, 2, 1, 3, 3, 3\\right].\n        \\]\n\n        The number of possible permutations possible with the above vector is \\(4200\\). This can be\n        obtained using the `|toqito\u27e9` package as follows.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.perms import unique_perms\n\n        vec_nums = [1, 1, 2, 2, 1, 2, 1, 3, 3, 3]\n\n        print(len(list(unique_perms(vec_nums))))\n        ```\n\n    Args:\n        elements: List of integers.\n\n    Returns:\n        The number of possible permutations possible.\n\n    \"\"\"\n    elem_set = set(elements)\n    list_unique = [UniqueElement(value=i, occurrences=elements.count(i)) for i in elem_set]\n    len_elems = len(elements)\n\n    return perm_unique_helper(list_unique, [0] * len_elems, len_elems - 1)\n</code></pre>"},{"location":"reference/toqito/perms/unique_perms/#toqito.perms.unique_perms.perm_unique_helper","title":"perm_unique_helper","text":"<pre><code>perm_unique_helper(list_unique: list[UniqueElement], result_list: list[int], elem_d: int)\n</code></pre> <p>Provide helper function for unique_perms.</p> <p>Parameters:</p> <ul> <li> <code>list_unique</code>               (<code>list[UniqueElement]</code>)           \u2013            <p>list[UniqueElement]</p> </li> <li> <code>result_list</code>               (<code>list[int]</code>)           \u2013            <p>list[int]</p> </li> <li> <code>elem_d</code>               (<code>int</code>)           \u2013            <p>int</p> </li> </ul> Source code in <code>toqito/perms/unique_perms.py</code> <pre><code>def perm_unique_helper(list_unique: list[UniqueElement], result_list: list[int], elem_d: int):\n    \"\"\"Provide helper function for unique_perms.\n\n    Args:\n        list_unique: list[UniqueElement]\n        result_list: list[int]\n        elem_d: int\n\n    \"\"\"\n    if elem_d &lt; 0:\n        yield tuple(result_list)\n    else:\n        for i in list_unique:\n            if i.occurrences &gt; 0:\n                result_list[elem_d] = i.value\n                i.occurrences -= 1\n                yield from perm_unique_helper(list_unique, result_list, elem_d - 1)\n                i.occurrences += 1\n</code></pre>"},{"location":"reference/toqito/perms/vec/","title":"vec","text":""},{"location":"reference/toqito/perms/vec/#toqito.perms.vec","title":"vec","text":"<p>Performs the vec operation on a matrix.</p>"},{"location":"reference/toqito/perms/vec/#toqito.perms.vec.vec","title":"vec","text":"<pre><code>vec(mat: ndarray) -&gt; ndarray\n</code></pre> <p>Perform the vec operation on a matrix.</p> <p>For more info, see Section: The Operator-Vector Correspondence from <sup>1</sup>.</p> <p>The function reorders the given matrix into a column vector by stacking the columns of the matrix sequentially.</p> <p>For instance, for the following matrix:</p> \\[     X =     \\begin{pmatrix}         1 &amp; 2 \\\\         3 &amp; 4     \\end{pmatrix} \\] <p>it holds that</p> \\[     \\text{vec}(X) = \\begin{pmatrix} 1 &amp; 3 &amp; 2 &amp; 4 \\end{pmatrix}^T \\] <p>More formally, the vec operation is defined by</p> \\[     \\text{vec}(E_{a,b}) = e_a \\otimes e_b \\] <p>for all \\(a\\) and \\(b\\) where</p> \\[     E_{a,b}(c,d) = \\begin{cases}                       1 &amp; \\text{if} \\ (c,d) = (a,b) \\\\                       0 &amp; \\text{otherwise}                     \\end{cases} \\] <p>for all \\(c\\) and \\(d\\) and where</p> \\[     e_a(b) = \\begin{cases}                  1 &amp; \\text{if} \\ a = b \\\\                  0 &amp; \\text{if} \\ a \\not= b              \\end{cases} \\] <p>for all \\(a\\) and \\(b\\).</p> <p>Examples:</p> <p>Consider the following matrix</p> \\[     A = \\begin{pmatrix}             1 &amp; 2 \\\\             3 &amp; 4         \\end{pmatrix} \\] <p>Performing the \\(\\text{vec}\\) operation on \\(A\\) yields</p> \\[     \\text{vec}(A) = \\left[1, 3, 2, 4 \\right]^{T}. \\] <pre><code>import numpy as np\nfrom toqito.perms import vec\n\nX = np.array([[1, 2], [3, 4]])\n\nprint(vec(X))\n</code></pre> <p>[[1]  [3]  [2]  [4]]</p> <p>See</p> <p><code>unvec()</code></p> <p>Parameters:</p> <ul> <li> <code>mat</code>               (<code>ndarray</code>)           \u2013            <p>The input matrix.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>The vec representation of the matrix.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Watrous, John. The Theory of Quantum Information. (2018). doi:10.1017/9781316848142.</p> Source code in <code>toqito/perms/vec.py</code> <pre><code>def vec(mat: np.ndarray) -&gt; np.ndarray:\n    r\"\"\"Perform the vec operation on a matrix.\n\n    For more info, see Section: The Operator-Vector Correspondence from [@Watrous_2018_TQI].\n\n    The function reorders the given matrix into a column vector by stacking the columns of the matrix sequentially.\n\n    For instance, for the following matrix:\n\n    \\[\n        X =\n        \\begin{pmatrix}\n            1 &amp; 2 \\\\\n            3 &amp; 4\n        \\end{pmatrix}\n    \\]\n\n    it holds that\n\n    \\[\n        \\text{vec}(X) = \\begin{pmatrix} 1 &amp; 3 &amp; 2 &amp; 4 \\end{pmatrix}^T\n    \\]\n\n    More formally, the vec operation is defined by\n\n    \\[\n        \\text{vec}(E_{a,b}) = e_a \\otimes e_b\n    \\]\n\n    for all \\(a\\) and \\(b\\) where\n\n    \\[\n        E_{a,b}(c,d) = \\begin{cases}\n                          1 &amp; \\text{if} \\ (c,d) = (a,b) \\\\\n                          0 &amp; \\text{otherwise}\n                        \\end{cases}\n    \\]\n\n    for all \\(c\\) and \\(d\\) and where\n\n    \\[\n        e_a(b) = \\begin{cases}\n                     1 &amp; \\text{if} \\ a = b \\\\\n                     0 &amp; \\text{if} \\ a \\not= b\n                 \\end{cases}\n    \\]\n\n    for all \\(a\\) and \\(b\\).\n\n    Examples:\n        Consider the following matrix\n\n        \\[\n            A = \\begin{pmatrix}\n                    1 &amp; 2 \\\\\n                    3 &amp; 4\n                \\end{pmatrix}\n        \\]\n\n        Performing the \\(\\text{vec}\\) operation on \\(A\\) yields\n\n        \\[\n            \\text{vec}(A) = \\left[1, 3, 2, 4 \\right]^{T}.\n        \\]\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.perms import vec\n\n        X = np.array([[1, 2], [3, 4]])\n\n        print(vec(X))\n        ```\n\n        !!! See Also\n            [`unvec()`][toqito.matrix_ops.unvec.unvec]\n\n    Args:\n        mat: The input matrix.\n\n    Returns:\n        The vec representation of the matrix.\n\n    \"\"\"\n    return mat.reshape((-1, 1), order=\"F\")\n</code></pre>"},{"location":"reference/toqito/rand/","title":"rand","text":""},{"location":"reference/toqito/rand/#toqito.rand","title":"rand","text":"<p>Rand is a set of modules used to generate random quantum states and measurements.</p>"},{"location":"reference/toqito/rand/random_circulant_gram_matrix/","title":"random_circulant_gram_matrix","text":""},{"location":"reference/toqito/rand/random_circulant_gram_matrix/#toqito.rand.random_circulant_gram_matrix","title":"random_circulant_gram_matrix","text":"<p>Generates a random circulant Gram matrix.</p>"},{"location":"reference/toqito/rand/random_circulant_gram_matrix/#toqito.rand.random_circulant_gram_matrix.random_circulant_gram_matrix","title":"random_circulant_gram_matrix","text":"<pre><code>random_circulant_gram_matrix(dim: int, seed: int | None = None) -&gt; ndarray\n</code></pre> <p>Generate a random circulant Gram matrix of specified dimension.</p> <p>A circulant matrix is a square matrix where the elements of each row are identical to the elements of the previous row such that the elements in one row are relocated by 1 position (in a cyclic manner) compared to the previous row. The eigenvalues and eigenvectors of this matrix are derived from the Discrete Fourier Transform (DFT).</p> <p>For more information on circulant matrices, see <sup>1</sup>. This function utilizes the normalized DFT, a variation of DFT with normalized basis vectors.</p> <p>For additional information, see <sup>2</sup>.</p> <p>The function creates a circulant matrix from a random diagonal matrix and the normalized DFT matrix. First, it generates a diagonal matrix with random non-negative entries. Next, it constructs the normalized DFT matrix. Finally, it computes the circulant matrix, which is real due to its origin from the DFT of a real diagonal matrix.</p> <p>Examples:</p> <p>Generate a random circulant Gram matrix of dimension 4.</p> <pre><code>import numpy as np\nfrom toqito.rand import random_circulant_gram_matrix\n\ncirculant_matrix = random_circulant_gram_matrix(4)\n\nprint(f\"Shape of circulant matrix is {circulant_matrix.shape}\")\n</code></pre> <p>Shape of circulant matrix is (4, 4)</p> <pre><code>print(np.allclose(circulant_matrix, circulant_matrix.T))\n</code></pre> <p>True</p> <pre><code>print(circulant_matrix)\n</code></pre> <p>[[ 0.54180893 -0.14646976  0.05947073 -0.14646976]  [-0.14646976  0.54180893 -0.14646976  0.05947073]  [ 0.05947073 -0.14646976  0.54180893 -0.14646976]  [-0.14646976  0.05947073 -0.14646976  0.54180893]]</p> <p>It is also possible to pass a seed to this function for reproducibility.</p> <pre><code>from toqito.rand import random_circulant_gram_matrix\n\ncirculant_matrix = random_circulant_gram_matrix(4, seed=42)\n\nprint(circulant_matrix)\n</code></pre> <p>[[ 0.69220011 -0.02116047  0.12407687 -0.02116047]  [-0.02116047  0.69220011 -0.02116047  0.12407687]  [ 0.12407687 -0.02116047  0.69220011 -0.02116047]  [-0.02116047  0.12407687 -0.02116047  0.69220011]]</p> <p>Parameters:</p> <ul> <li> <code>dim</code>               (<code>int</code>)           \u2013            <p>int The dimension of the circulant matrix to generate.</p> </li> <li> <code>seed</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>int | None A seed used to instantiate numpy's random number generator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>numpy.ndarray A <code>dim</code> x <code>dim</code> real, symmetric, circulant matrix.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Circulant matrix. link. <sup>2</sup> DSPRelated. Normalized DFT. link.</p> Source code in <code>toqito/rand/random_circulant_gram_matrix.py</code> <pre><code>def random_circulant_gram_matrix(dim: int, seed: int | None = None) -&gt; np.ndarray:\n    r\"\"\"Generate a random circulant Gram matrix of specified dimension.\n\n    A circulant matrix is a square matrix where the elements of each row are identical to the elements of the\n    previous row such that the elements in one row are relocated by 1 position (in a cyclic manner) compared\n    to the previous row. The eigenvalues and eigenvectors of this matrix are derived from the Discrete\n    Fourier Transform (DFT).\n\n    For more information on circulant matrices, see [@WikiCirculantMat]. This function utilizes the\n    normalized DFT, a variation of DFT with normalized basis vectors.\n\n    For additional information, see [@DSPNormDFT].\n\n    The function creates a circulant matrix from a random diagonal matrix and the normalized DFT matrix.\n    First, it generates a diagonal matrix with random non-negative entries. Next, it constructs the\n    normalized DFT matrix. Finally, it computes the circulant matrix, which is real due to its origin\n    from the DFT of a real diagonal matrix.\n\n    Examples:\n        Generate a random circulant Gram matrix of dimension 4.\n\n        ```python exec=\"1\" source=\"above\" session=\"random_circulant_gram_matrix_example\"\n        import numpy as np\n        from toqito.rand import random_circulant_gram_matrix\n\n        circulant_matrix = random_circulant_gram_matrix(4)\n\n        print(f\"Shape of circulant matrix is {circulant_matrix.shape}\")\n        ```\n\n        ```python exec=\"1\" source=\"above\" session=\"random_circulant_gram_matrix_example\"\n        print(np.allclose(circulant_matrix, circulant_matrix.T))\n        ```\n\n        ```python exec=\"1\" source=\"above\" session=\"random_circulant_gram_matrix_example\"\n        print(circulant_matrix)\n        ```\n\n        It is also possible to pass a seed to this function for reproducibility.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.rand import random_circulant_gram_matrix\n\n        circulant_matrix = random_circulant_gram_matrix(4, seed=42)\n\n        print(circulant_matrix)\n        ```\n\n\n    Args:\n        dim: int The dimension of the circulant matrix to generate.\n        seed: int | None A seed used to instantiate numpy's random number generator.\n\n    Returns:\n        numpy.ndarray A `dim` x `dim` real, symmetric, circulant matrix.\n\n    \"\"\"\n    gen = np.random.default_rng(seed=seed)\n    # Step 1: Generate a random diagonal matrix with non-negative entries\n    diag_mat = np.diag(gen.random(dim))\n\n    # Step 2: Construct the normalized DFT matrix\n    dft_mat = np.fft.fft(np.eye(dim)) / np.sqrt(dim)\n\n    # Step 3: Compute the circulant matrix. Since circ_mat is formed from the DFT of a real\n    # diagonal matrix, it should be real\n    return np.real(np.conj(dft_mat.T) @ diag_mat @ dft_mat)\n</code></pre>"},{"location":"reference/toqito/rand/random_density_matrix/","title":"random_density_matrix","text":""},{"location":"reference/toqito/rand/random_density_matrix/#toqito.rand.random_density_matrix","title":"random_density_matrix","text":"<p>Generates a random density matrix.</p>"},{"location":"reference/toqito/rand/random_density_matrix/#toqito.rand.random_density_matrix.random_density_matrix","title":"random_density_matrix","text":"<pre><code>random_density_matrix(dim: int, is_real: bool = False, k_param: list[int] | int | None = None, distance_metric: str = 'haar', seed: int | None = None) -&gt; ndarray\n</code></pre> <p>Generate a random density matrix.</p> <p>Generates a random <code>dim</code>-by-<code>dim</code> density matrix distributed according to the Hilbert-Schmidt measure. The matrix is of rank &lt;= <code>k_param</code> distributed according to the distribution <code>distance_metric</code> If <code>is_real = True</code>, then all of its entries will be real. The variable <code>distance_metric</code> must be one of:</p> <ul> <li> <p><code>haar</code> (default):     Generate a larger pure state according to the Haar measure and trace out the extra dimensions. Sometimes     called the Hilbert-Schmidt measure when <code>k_param = dim</code>.</p> </li> <li> <p><code>bures</code>:     The Bures measure.</p> </li> </ul> <p>Examples:</p> <p>Using <code>|toqito\u27e9</code>, we may generate a random complex-valued \\(n\\)- dimensional density matrix. For \\(d=2\\), this can be accomplished as follows.</p> <pre><code>from toqito.rand import random_density_matrix\n\ncomplex_dm = random_density_matrix(2)\n\nprint(complex_dm)\n</code></pre> <p>[[ 0.46810353+0.j         -0.18723026-0.45480177j]  [-0.18723026+0.45480177j  0.53189647+0.j        ]]</p> <p>We can verify that this is in fact a valid density matrix using the <code>is_density</code> function from <code>|toqito\u27e9</code> as follows</p> <pre><code>from toqito.matrix_props import is_density\n\nprint(is_density(complex_dm))\n</code></pre> <p>True</p> <p>We can also generate random density matrices that are real-valued as follows.</p> <pre><code>from toqito.rand import random_density_matrix\n\nreal_dm = random_density_matrix(2, is_real=True)\n\nprint(real_dm)\n</code></pre> <p>[[0.44303468 0.48481471]  [0.48481471 0.55696532]]</p> <p>Again, verifying that this is a valid density matrix can be done as follows.</p> <pre><code>from toqito.matrix_props import is_density\n\nprint(is_density(real_dm))\n</code></pre> <p>True</p> <p>By default, the random density operators are constructed using the Haar measure. We can select to generate the random density matrix according to the Bures metric instead as follows.</p> <pre><code>from toqito.rand import random_density_matrix\n\nbures_mat = random_density_matrix(2, distance_metric=\"bures\")\n\nprint(bures_mat)\n</code></pre> <p>[[ 0.28077492+0.j         -0.28720146-0.12432977j]  [-0.28720146+0.12432977j  0.71922508+0.j        ]]</p> <p>As before, we can verify that this matrix generated is a valid density matrix.</p> <pre><code>from toqito.matrix_props import is_density\n\nprint(is_density(bures_mat))\n</code></pre> <p>True</p> <p>It is also possible to pass a seed to this function for reproducibility. <pre><code>from toqito.rand import random_density_matrix\n\nseeded = random_density_matrix(2, seed=42)\n\nprint(seeded)\n</code></pre> <p>[[0.82448019+0.j         0.14841568-0.33318114j]  [0.14841568+0.33318114j 0.17551981+0.j        ]]</p></p> <p>We can once again verify that this is in fact a valid density matrix using the <code>is_density</code> function from <code>|toqito\u27e9</code> as follows</p> <pre><code>from toqito.matrix_props import is_density\n\nseeded = random_density_matrix(2, seed=42)\n\nprint(is_density(seeded))\n</code></pre> <p>True</p> <p>Parameters:</p> <ul> <li> <code>dim</code>               (<code>int</code>)           \u2013            <p>The number of rows (and columns) of the density matrix.</p> </li> <li> <code>is_real</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Boolean denoting whether the returned matrix will have all real entries or not.</p> </li> <li> <code>k_param</code>               (<code>list[int] | int | None</code>, default:                   <code>None</code> )           \u2013            <p>Default value is equal to <code>dim</code>.</p> </li> <li> <code>distance_metric</code>               (<code>str</code>, default:                   <code>'haar'</code> )           \u2013            <p>The distance metric used to randomly generate the density matrix. This metric is either the</p> </li> <li> <code>seed</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>A seed used to instantiate numpy's random number generator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>A <code>dim</code>-by-<code>dim</code> random density matrix.</p> </li> </ul> Source code in <code>toqito/rand/random_density_matrix.py</code> <pre><code>def random_density_matrix(\n    dim: int,\n    is_real: bool = False,\n    k_param: list[int] | int | None = None,\n    distance_metric: str = \"haar\",\n    seed: int | None = None,\n) -&gt; np.ndarray:\n    r\"\"\"Generate a random density matrix.\n\n    Generates a random `dim`-by-`dim` density matrix distributed according to the Hilbert-Schmidt measure.\n    The matrix is of rank &lt;= `k_param` distributed according to the distribution `distance_metric` If\n    `is_real = True`, then all of its entries will be real. The variable `distance_metric` must be one of:\n\n    - `haar` (default):\n        Generate a larger pure state according to the Haar measure and trace out the extra dimensions. Sometimes\n        called the Hilbert-Schmidt measure when `k_param = dim`.\n\n    - `bures`:\n        The Bures measure.\n\n    Examples:\n        Using `|toqito\u27e9`, we may generate a random complex-valued \\(n\\)- dimensional density matrix. For\n        \\(d=2\\), this can be accomplished as follows.\n\n        ```python exec=\"1\" source=\"above\" session=\"complex_dm_example\"\n        from toqito.rand import random_density_matrix\n\n        complex_dm = random_density_matrix(2)\n\n        print(complex_dm)\n        ```\n\n\n        We can verify that this is in fact a valid density matrix using the `is_density` function from\n        `|toqito\u27e9` as follows\n\n        ```python exec=\"1\" source=\"above\" session=\"complex_dm_example\"\n        from toqito.matrix_props import is_density\n\n        print(is_density(complex_dm))\n        ```\n\n\n        We can also generate random density matrices that are real-valued as follows.\n\n        ```python exec=\"1\" source=\"above\" session=\"real_dm_example\"\n        from toqito.rand import random_density_matrix\n\n        real_dm = random_density_matrix(2, is_real=True)\n\n        print(real_dm)\n        ```\n\n\n\n        Again, verifying that this is a valid density matrix can be done as follows.\n\n        ```python exec=\"1\" source=\"above\" session=\"real_dm_example\"\n        from toqito.matrix_props import is_density\n\n        print(is_density(real_dm))\n        ```\n\n        By default, the random density operators are constructed using the Haar measure. We can select to generate the\n        random density matrix according to the Bures metric instead as follows.\n\n        ```python exec=\"1\" source=\"above\" session=\"bures_dm_example\"\n        from toqito.rand import random_density_matrix\n\n        bures_mat = random_density_matrix(2, distance_metric=\"bures\")\n\n        print(bures_mat)\n        ```\n\n\n        As before, we can verify that this matrix generated is a valid density matrix.\n\n        ```python exec=\"1\" source=\"above\" session=\"bures_dm_example\"\n        from toqito.matrix_props import is_density\n\n        print(is_density(bures_mat))\n        ```\n\n        It is also possible to pass a seed to this function for reproducibility.\n        ```python exec=\"1\" source=\"above\" session=\"seeded_dm_example\"\n        from toqito.rand import random_density_matrix\n\n        seeded = random_density_matrix(2, seed=42)\n\n        print(seeded)\n        ```\n\n        We can once again verify that this is in fact a valid density matrix using the\n        `is_density` function from `|toqito\u27e9` as follows\n\n        ```python exec=\"1\" source=\"above\" session=\"seeded_dm_example\"\n        from toqito.matrix_props import is_density\n\n        seeded = random_density_matrix(2, seed=42)\n\n        print(is_density(seeded))\n        ```\n\n\n\n    Args:\n        dim: The number of rows (and columns) of the density matrix.\n        is_real: Boolean denoting whether the returned matrix will have all real entries or not.\n        k_param: Default value is equal to `dim`.\n        distance_metric: The distance metric used to randomly generate the density matrix. This metric is either the\n        Haar measure or the Bures measure. Default value is to use the Haar measure.\n        seed: A seed used to instantiate numpy's random number generator.\n\n    Returns:\n        A `dim`-by-`dim` random density matrix.\n\n    \"\"\"\n    gen = np.random.default_rng(seed=seed)\n    if k_param is None:\n        k_param = dim\n\n    # Haar / Hilbert-Schmidt measure.\n    gin = gen.random((dim, k_param))\n\n    if not is_real:\n        gin = gin + 1j * gen.standard_normal((dim, k_param))\n\n    if distance_metric == \"bures\":\n        gin = random_unitary(dim, is_real, seed=seed) + np.identity(dim) @ gin\n\n    rho = gin @ gin.conj().T\n\n    return np.divide(rho, np.trace(rho))\n</code></pre>"},{"location":"reference/toqito/rand/random_ginibre/","title":"random_ginibre","text":""},{"location":"reference/toqito/rand/random_ginibre/#toqito.rand.random_ginibre","title":"random_ginibre","text":"<p>Generates a Ginibre random matrix.</p>"},{"location":"reference/toqito/rand/random_ginibre/#toqito.rand.random_ginibre.random_ginibre","title":"random_ginibre","text":"<pre><code>random_ginibre(dim_n: int, dim_m: int, seed: int | None = None) -&gt; ndarray\n</code></pre> <p>Generate a Ginibre random matrix <sup>1</sup>.</p> <p>Generates a random <code>dim_n</code>-by-<code>dim_m</code> Ginibre matrix.</p> <p>A Ginibre random matrix is a matrix with independent and identically distributed complex standard Gaussian entries.</p> <p>Ginibre random matrices are used in the construction of Wishart-random POVMs <sup>2</sup>.</p> <p>Examples:</p> <p>Generate a random \\(2\\)-by-\\(2\\) Ginibre random matrix.</p> <pre><code>from toqito.rand import random_ginibre\n\nprint(random_ginibre(2, 2))\n</code></pre> <p>[[-0.98655092-0.52044188j -0.20373317-0.12770285j]  [-0.91538501+0.56346875j  0.65656166+0.02245805j]]</p> <p>It is also possible to pass a seed to this function for reproducibility.</p> <pre><code>from toqito.rand import random_ginibre\n\nprint(random_ginibre(2, 2, seed=42))\n</code></pre> <p>[[ 0.21546751-1.37959021j -0.73537981-0.92077996j]  [ 0.53064913+0.09039682j  0.66507969-0.22361728j]]</p> <p>Parameters:</p> <ul> <li> <code>dim_n</code>               (<code>int</code>)           \u2013            <p>The number of rows of the Ginibre random matrix.</p> </li> <li> <code>dim_m</code>               (<code>int</code>)           \u2013            <p>The number of columns of the Ginibre random matrix.</p> </li> <li> <code>seed</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>A seed used to instantiate numpy's random number generator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>A <code>dim_n</code>-by-<code>dim_m</code> Ginibre random matrix.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Circular law. link. <sup>2</sup> Heinosaari, Teiko and Jivulescu, Maria and Nechita, Ion. Random positive operator valued measures. Journal of Mathematical Physics. vol. 61(4). (2020). doi:10.1063/1.5131028.</p> Source code in <code>toqito/rand/random_ginibre.py</code> <pre><code>def random_ginibre(dim_n: int, dim_m: int, seed: int | None = None) -&gt; np.ndarray:\n    r\"\"\"Generate a Ginibre random matrix [@WikiCircLaw].\n\n    Generates a random `dim_n`-by-`dim_m` Ginibre matrix.\n\n    A *Ginibre random matrix* is a matrix with independent and identically distributed complex standard Gaussian\n    entries.\n\n    Ginibre random matrices are used in the construction of Wishart-random POVMs [@Heinosaari_2020_Random].\n\n    Examples:\n        Generate a random \\(2\\)-by-\\(2\\) Ginibre random matrix.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.rand import random_ginibre\n\n        print(random_ginibre(2, 2))\n        ```\n\n        It is also possible to pass a seed to this function for reproducibility.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.rand import random_ginibre\n\n        print(random_ginibre(2, 2, seed=42))\n        ```\n\n    Args:\n        dim_n: The number of rows of the Ginibre random matrix.\n        dim_m: The number of columns of the Ginibre random matrix.\n        seed: A seed used to instantiate numpy's random number generator.\n\n    Returns:\n        A `dim_n`-by-`dim_m` Ginibre random matrix.\n\n    \"\"\"\n    gen = np.random.default_rng(seed=seed)\n    return (gen.standard_normal((dim_n, dim_m)) + 1j * gen.standard_normal((dim_n, dim_m))) / np.sqrt(2)\n</code></pre>"},{"location":"reference/toqito/rand/random_orthonormal_basis/","title":"random_orthonormal_basis","text":""},{"location":"reference/toqito/rand/random_orthonormal_basis/#toqito.rand.random_orthonormal_basis","title":"random_orthonormal_basis","text":"<p>Generates a random orthonormal basis.</p>"},{"location":"reference/toqito/rand/random_orthonormal_basis/#toqito.rand.random_orthonormal_basis.random_orthonormal_basis","title":"random_orthonormal_basis","text":"<pre><code>random_orthonormal_basis(dim: int, is_real: bool = False, seed: int | None = None) -&gt; list[ndarray]\n</code></pre> <p>Generate a real random orthonormal basis of given dimension \\(d\\).</p> <p>The basis is generated from the columns of a random unitary matrix of the same dimension as the columns of a unitary matrix typically form an orthonormal basis <sup>1</sup>.</p> <p>Examples:</p> <p>To generate a random orthonormal basis of dimension \\(4\\),</p> <pre><code>from toqito.rand import random_orthonormal_basis\n\nprint(random_orthonormal_basis(4, is_real = True))\n</code></pre> <p>[array([0.46931363, 0.3357571 , 0.48624827, 0.65618176]), array([ 0.68584816,  0.30861855, -0.63449823, -0.17826631]), array([ 0.34984174, -0.8783445 , -0.13266253,  0.29752706]), array([ 0.4323977 , -0.14329236,  0.58598231, -0.67016734])]</p> <p>It is also possible to add a seed for reproducibility.</p> <pre><code>from toqito.rand import random_orthonormal_basis\n\nprint(random_orthonormal_basis(2, is_real=True, seed=42))\n</code></pre> <p>[array([0.37621414, 0.92653274]), array([-0.92653274,  0.37621414])]</p> <p>Parameters:</p> <ul> <li> <code>dim</code>               (<code>int</code>)           \u2013            <p>Number of elements in the random orthonormal basis.</p> </li> <li> <code>is_real</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Bool</p> </li> <li> <code>seed</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>A seed used to instantiate numpy's random number generator.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Mathematics, Stack. Why do the columns of a unitary matrix form an orthonormal basis?. link.</p> Source code in <code>toqito/rand/random_orthonormal_basis.py</code> <pre><code>def random_orthonormal_basis(dim: int, is_real: bool = False, seed: int | None = None) -&gt; list[np.ndarray]:\n    r\"\"\"Generate a real random orthonormal basis of given dimension \\(d\\).\n\n    The basis is generated from the columns of a random unitary matrix of the same dimension\n    as the columns of a unitary matrix typically form an orthonormal basis [@SE_1688950].\n\n    Examples:\n        To generate a random orthonormal basis of dimension \\(4\\),\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.rand import random_orthonormal_basis\n\n        print(random_orthonormal_basis(4, is_real = True))\n        ```\n\n        It is also possible to add a seed for reproducibility.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.rand import random_orthonormal_basis\n\n        print(random_orthonormal_basis(2, is_real=True, seed=42))\n        ```\n\n    Args:\n        dim: Number of elements in the random orthonormal basis.\n        is_real: Bool\n        seed: A seed used to instantiate numpy's random number generator.\n\n    \"\"\"\n    random_mat = random_unitary(dim, is_real, seed)\n    return [random_mat[:, i] for i in range(dim)]\n</code></pre>"},{"location":"reference/toqito/rand/random_povm/","title":"random_povm","text":""},{"location":"reference/toqito/rand/random_povm/#toqito.rand.random_povm","title":"random_povm","text":"<p>Generates a random POVM.</p>"},{"location":"reference/toqito/rand/random_povm/#toqito.rand.random_povm.random_povm","title":"random_povm","text":"<pre><code>random_povm(dim: int, num_inputs: int, num_outputs: int, seed: int | None = None) -&gt; ndarray\n</code></pre> <p>Generate random positive operator valued measurements (POVMs) <sup>1</sup>.</p>"},{"location":"reference/toqito/rand/random_povm/#toqito.rand.random_povm.random_povm--randomness-model","title":"Randomness model","text":"<p>For each input we draw \\(n_{\\text{out}}\\) matrices from the real Ginibre ensemble, i.e., each entry is sampled independently from the standard normal distribution using <code>numpy</code>'s <code>default_rng</code>.  We interpret these matrices as Kraus operators \\(A_{x,a}\\) and normalize them so that the measurement is complete.  Concretely, for each input \\(x\\) we form</p> \\[     G_x = \\sum_a A_{x,a}^\\dagger A_{x,a}, \\qquad     B_{x,a} = G_x^{-1/2} A_{x,a}, \\qquad     M_{x,a} = B_{x,a}^\\dagger B_{x,a}. \\] <p>The matrices \\(M_{x,a}\\) constitute a POVM satisfying \\(\\sum_a M_{x,a} = \\mathbb{I}\\).  This procedure induces the (Hilbert\u2013Schmidt) normalized Wishart measure on the POVM effects.  Supplying <code>seed</code> reproduces the same sample sequence.</p> <p>Examples:</p> <p>We can generate a set of <code>dim</code>-by-<code>dim</code> POVMs consisting of a specific dimension along with a given number of measurement inputs and measurement outputs. As an example, we can construct a random set of \\(2\\)-by-\\(2\\) POVMs of dimension with \\(2\\) inputs and \\(2\\) outputs.</p> <pre><code>import numpy as np\nfrom toqito.rand import random_povm\n\ndim, num_inputs, num_outputs = 2, 2, 2\n\npovms = random_povm(dim, num_inputs, num_outputs)\n\nprint(povms)\n</code></pre> <p>[[[[ 0.00598604+0.j  0.99401396+0.j]    [ 0.76033092+0.j  0.23966908+0.j]]</p> <p>[[ 0.03967677+0.j -0.03967677+0.j]    [-0.15519233+0.j  0.15519233+0.j]]]</p> <p>[[[ 0.03967677+0.j -0.03967677+0.j]    [-0.15519233+0.j  0.15519233+0.j]]</p> <p>[[ 0.51957969+0.j  0.48042031+0.j]    [ 0.06297305+0.j  0.93702695+0.j]]]]</p> <p>We can verify that this constitutes a valid set of POVM elements as checking that these operators all sum to the identity operator.</p> <pre><code>print(np.round(povms[:, :, 0, 0] + povms[:, :, 0, 1]))\n</code></pre> <p>[[ 1.+0.j -0.+0.j]  [-0.+0.j  1.+0.j]]</p> <p>It is also possible to add a seed for reproducibility.</p> <pre><code>import numpy as np\nfrom toqito.rand import random_povm\n\ndim, num_inputs, num_outputs = 2, 2, 2\n\npovms = random_povm(dim, num_inputs, num_outputs, seed=42)\n\nprint(povms)\n</code></pre> <p>[[[[ 0.22988028+0.j  0.77011972+0.j]    [ 0.45021752+0.j  0.54978248+0.j]]</p> <p>[[-0.23938341+0.j  0.23938341+0.j]    [ 0.32542956+0.j -0.32542956+0.j]]]</p> <p>[[[-0.23938341+0.j  0.23938341+0.j]    [ 0.32542956+0.j -0.32542956+0.j]]</p> <p>[[ 0.83184406+0.j  0.16815594+0.j]    [ 0.61323275+0.j  0.38676725+0.j]]]]</p> <p>We can once again verify that this constitutes a valid set of POVM elements as checking that these operators all sum to the identity operator.</p> <pre><code>print(np.round(povms[:, :, 0, 0] + povms[:, :, 0, 1]))\n</code></pre> <p>[[ 1.+0.j -0.+0.j]  [-0.+0.j  1.+0.j]]</p> <p>Parameters:</p> <ul> <li> <code>dim</code>               (<code>int</code>)           \u2013            <p>The dimensions of the measurements.</p> </li> <li> <code>num_inputs</code>               (<code>int</code>)           \u2013            <p>The number of inputs for the measurement.</p> </li> <li> <code>num_outputs</code>               (<code>int</code>)           \u2013            <p>The number of outputs for the measurement.</p> </li> <li> <code>seed</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>A seed used to instantiate numpy's random number generator (Ginibre sampling).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>A set of <code>dim</code>-by-<code>dim</code> POVMs of shape <code>(dim, dim, num_inputs, num_outputs)</code>.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. {POVM}. link.</p> Source code in <code>toqito/rand/random_povm.py</code> <pre><code>def random_povm(dim: int, num_inputs: int, num_outputs: int, seed: int | None = None) -&gt; np.ndarray:\n    r\"\"\"Generate random positive operator valued measurements (POVMs) [@WikiPOVM].\n\n    Randomness model\n    ----------------\n\n    For each input we draw \\(n_{\\text{out}}\\) matrices from the real Ginibre ensemble, i.e., each\n    entry is sampled independently from the standard normal distribution using ``numpy``'s\n    ``default_rng``.  We interpret these matrices as Kraus operators \\(A_{x,a}\\) and normalize\n    them so that the measurement is complete.  Concretely, for each input \\(x\\) we form\n\n    \\[\n        G_x = \\sum_a A_{x,a}^\\dagger A_{x,a}, \\qquad\n        B_{x,a} = G_x^{-1/2} A_{x,a}, \\qquad\n        M_{x,a} = B_{x,a}^\\dagger B_{x,a}.\n    \\]\n\n    The matrices \\(M_{x,a}\\) constitute a POVM satisfying\n    \\(\\sum_a M_{x,a} = \\mathbb{I}\\).  This procedure induces the (Hilbert\u2013Schmidt) normalized\n    Wishart measure on the POVM effects.  Supplying ``seed`` reproduces the same sample sequence.\n\n    Examples:\n        We can generate a set of `dim`-by-`dim` POVMs consisting of a specific dimension along with a given number of\n        measurement inputs and measurement outputs. As an example, we can construct a random set of \\(2\\)-by-\\(2\\)\n        POVMs of dimension with \\(2\\) inputs and \\(2\\) outputs.\n\n        ```python exec=\"1\" source=\"above\" session=\"povm_example\"\n        import numpy as np\n        from toqito.rand import random_povm\n\n        dim, num_inputs, num_outputs = 2, 2, 2\n\n        povms = random_povm(dim, num_inputs, num_outputs)\n\n        print(povms)\n        ```\n\n\n        We can verify that this constitutes a valid set of POVM elements as checking that these operators all sum to the\n        identity operator.\n\n        ```python exec=\"1\" source=\"above\" session=\"povm_example\"\n        print(np.round(povms[:, :, 0, 0] + povms[:, :, 0, 1]))\n        ```\n\n        It is also possible to add a seed for reproducibility.\n\n        ```python exec=\"1\" source=\"above\" session=\"povm_example\"\n        import numpy as np\n        from toqito.rand import random_povm\n\n        dim, num_inputs, num_outputs = 2, 2, 2\n\n        povms = random_povm(dim, num_inputs, num_outputs, seed=42)\n\n        print(povms)\n        ```\n\n        We can once again verify that this constitutes a valid set of POVM elements as checking that\n        these operators all sum to the identity operator.\n\n        ```python exec=\"1\" source=\"above\" session=\"povm_example\"\n        print(np.round(povms[:, :, 0, 0] + povms[:, :, 0, 1]))\n        ```\n\n    Args:\n        dim: The dimensions of the measurements.\n        num_inputs: The number of inputs for the measurement.\n        num_outputs: The number of outputs for the measurement.\n        seed: A seed used to instantiate numpy's random number generator (Ginibre sampling).\n\n    Returns:\n        A set of `dim`-by-`dim` POVMs of shape `(dim, dim, num_inputs, num_outputs)`.\n\n    \"\"\"\n    povms = []\n    gen = np.random.default_rng(seed=seed)\n    gram_vectors = gen.normal(size=(num_inputs, num_outputs, dim, dim))\n    for input_block in gram_vectors:\n        normalizer = sum(np.array(output_block).T.conj() @ output_block for output_block in input_block)\n        u_mat, d_mat, _ = np.linalg.svd(normalizer)\n\n        output_povms = []\n        for output_block in input_block:\n            partial = np.array(output_block, dtype=complex).dot(u_mat).dot(np.diag(d_mat ** (-1 / 2.0)))\n            internal = partial.dot(np.diag(np.ones(dim)) ** (1 / 2.0))\n            output_povms.append(internal.T.conj() @ internal)\n        povms.append(output_povms)\n\n    # This allows us to index the POVMs as [dim, dim, num_inputs, num_outputs].\n    povms = np.swapaxes(np.array(povms), 0, 2)\n    povms = np.swapaxes(povms, 1, 3)\n\n    return povms\n</code></pre>"},{"location":"reference/toqito/rand/random_psd_operator/","title":"random_psd_operator","text":""},{"location":"reference/toqito/rand/random_psd_operator/#toqito.rand.random_psd_operator","title":"random_psd_operator","text":"<p>Generates a random positive semidefinite operator.</p>"},{"location":"reference/toqito/rand/random_psd_operator/#toqito.rand.random_psd_operator.random_psd_operator","title":"random_psd_operator","text":"<pre><code>random_psd_operator(dim: int, is_real: bool = False, seed: int | None = None) -&gt; ndarray\n</code></pre> <p>Generate a random positive semidefinite operator.</p> <p>A positive semidefinite operator is a Hermitian operator that has only real and non-negative eigenvalues. This function generates a random positive semidefinite operator by constructing a Hermitian matrix, based on the fact that a Hermitian matrix can have real eigenvalues.</p> <p>Examples:</p> <p>Using <code>|toqito\u27e9</code>, we may generate a random positive semidefinite matrix. For \\(\\text{dim}=2\\), this can be accomplished as follows.</p> <pre><code>from toqito.rand import random_psd_operator\n\ncomplex_psd_mat = random_psd_operator(2)\n\nprint(complex_psd_mat)\n</code></pre> <p>[[0.76236315+0.j        0.23289148-0.1250373j]  [0.23289148+0.1250373j 0.77047096+0.j       ]]</p> <p>We can confirm that this matrix indeed represents a valid positive semidefinite matrix by utilizing the <code>is_positive_semidefinite</code> function from the <code>|toqito\u27e9</code> library, as demonstrated below:</p> <pre><code>from toqito.matrix_props import is_positive_semidefinite\n\nprint(is_positive_semidefinite(complex_psd_mat))\n</code></pre> <p>True</p> <p>We can also generate random positive semidefinite matrices that are real-valued as follows.</p> <pre><code>from toqito.rand import random_psd_operator\n\nreal_psd_mat = random_psd_operator(2, is_real=True)\n\nprint(real_psd_mat)\n</code></pre> <p>[[0.70966266 0.6563125 ]  [0.6563125  0.95671098]]</p> <p>Again, verifying that this is a valid positive semidefinite matrix can be done as follows.</p> <pre><code>from toqito.matrix_props import is_positive_semidefinite\nprint(is_positive_semidefinite(real_psd_mat))\n</code></pre> <p>True</p> <p>It is also possible to add a seed for reproducibility.</p> <pre><code>from toqito.rand import random_psd_operator\n\nseeded = random_psd_operator(2, is_real=True, seed=42)\n\nprint(seeded)\n</code></pre> <p>[[0.77395605 0.64873818]  [0.64873818 0.69736803]]</p> <p>Parameters:</p> <ul> <li> <code>dim</code>               (<code>int</code>)           \u2013            <p>The dimension of the operator.</p> </li> <li> <code>is_real</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Boolean denoting whether the returned matrix will have all real entries or not. Default is <code>False</code>.</p> </li> <li> <code>seed</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>A seed used to instantiate numpy's random number generator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>A <code>dim</code> x <code>dim</code> random positive semidefinite matrix.</p> </li> </ul> Source code in <code>toqito/rand/random_psd_operator.py</code> <pre><code>def random_psd_operator(\n    dim: int,\n    is_real: bool = False,\n    seed: int | None = None,\n) -&gt; np.ndarray:\n    r\"\"\"Generate a random positive semidefinite operator.\n\n    A positive semidefinite operator is a Hermitian operator that has only real and non-negative eigenvalues.\n    This function generates a random positive semidefinite operator by constructing a Hermitian matrix,\n    based on the fact that a Hermitian matrix can have real eigenvalues.\n\n    Examples:\n        Using `|toqito\u27e9`, we may generate a random positive semidefinite matrix.\n        For \\(\\text{dim}=2\\), this can be accomplished as follows.\n\n        ```python exec=\"1\" source=\"above\" session=\"psd_operator\"\n        from toqito.rand import random_psd_operator\n\n        complex_psd_mat = random_psd_operator(2)\n\n        print(complex_psd_mat)\n        ```\n\n        We can confirm that this matrix indeed represents a valid positive semidefinite matrix by utilizing\n        the `is_positive_semidefinite` function from the `|toqito\u27e9` library, as demonstrated below:\n\n        ```python exec=\"1\" source=\"above\" session=\"psd_operator\"\n        from toqito.matrix_props import is_positive_semidefinite\n\n        print(is_positive_semidefinite(complex_psd_mat))\n        ```\n\n\n        We can also generate random positive semidefinite matrices that are real-valued as follows.\n\n        ```python exec=\"1\" source=\"above\" session=\"psd_operator\"\n        from toqito.rand import random_psd_operator\n\n        real_psd_mat = random_psd_operator(2, is_real=True)\n\n        print(real_psd_mat)\n        ```\n\n\n        Again, verifying that this is a valid positive semidefinite matrix can be done as follows.\n\n        ```python exec=\"1\" source=\"above\" session=\"psd_operator\"\n        from toqito.matrix_props import is_positive_semidefinite\n        print(is_positive_semidefinite(real_psd_mat))\n        ```\n\n\n        It is also possible to add a seed for reproducibility.\n\n        ```python exec=\"1\" source=\"above\" session=\"psd_operator\"\n        from toqito.rand import random_psd_operator\n\n        seeded = random_psd_operator(2, is_real=True, seed=42)\n\n        print(seeded)\n        ```\n\n    Args:\n        dim: The dimension of the operator.\n        is_real: Boolean denoting whether the returned matrix will have all real entries or not. Default is `False`.\n        seed: A seed used to instantiate numpy's random number generator.\n\n    Returns:\n        A `dim` x `dim` random positive semidefinite matrix.\n\n    \"\"\"\n    # Generate a random matrix of dimension dim x dim.\n    gen = np.random.default_rng(seed=seed)\n    rand_mat = gen.random((dim, dim))\n\n    # If is_real is False, add an imaginary component to the matrix.\n    if not is_real:\n        rand_mat = rand_mat + 1j * gen.random((dim, dim))\n\n    # Constructing a Hermitian matrix.\n    rand_mat = (rand_mat.conj().T + rand_mat) / 2\n    eigenvals, eigenvecs = np.linalg.eigh(rand_mat)\n\n    Q, R = np.linalg.qr(eigenvecs)\n\n    return Q @ np.diag(np.abs(eigenvals)) @ Q.conj().T\n</code></pre>"},{"location":"reference/toqito/rand/random_state_vector/","title":"random_state_vector","text":""},{"location":"reference/toqito/rand/random_state_vector/#toqito.rand.random_state_vector","title":"random_state_vector","text":"<p>Generates a random state vector.</p>"},{"location":"reference/toqito/rand/random_state_vector/#toqito.rand.random_state_vector.random_state_vector","title":"random_state_vector","text":"<pre><code>random_state_vector(dim: list[int] | tuple[int, ...] | int, is_real: bool = False, k_param: int = 0, seed: int | None = None) -&gt; ndarray\n</code></pre> <p>Generate a random pure state vector.</p> <p>Randomness model</p> <p>We sample entries independently from the standard normal distribution using <code>numpy</code>'s <code>default_rng</code>.  If <code>is_real</code> is <code>False</code> (default), the imaginary part is sampled in the same way and added with the factor \\(i\\); otherwise the vector is real.  The sampled vector is normalized to have unit Euclidean norm.  When <code>k_param</code> is strictly positive, the returned state describes a bipartite system of dimensions <code>dim</code> (or <code>[dim, dim]</code> if <code>dim</code> is an integer) with Schmidt rank at most <code>k_param</code>.  This is achieved by drawing local factors and combining them with a maximally entangled resource state.</p> <p>Examples:</p> <p>We may generate a random state vector. For instance, here is an example where we can generate a \\(2\\)-dimensional random state vector.</p> <pre><code>from toqito.rand import random_state_vector\n\nvec = random_state_vector(2)\n\nprint(vec)\n</code></pre> <p>[[0.16090626+0.68806226j]  [0.70744249+0.01430505j]]</p> <p>We can verify that this is in fact a valid state vector by computing the corresponding density matrix of the vector and checking if the density matrix is pure.</p> <pre><code>from toqito.state_props import is_pure\n\ndm = vec @ vec.conj().T\n\nprint(is_pure(dm))\n</code></pre> <p>True</p> <p>It is also possible to pass a seed for reproducibility.</p> <pre><code>from toqito.rand import random_state_vector\n\nvec = random_state_vector(2, seed=42)\n\nprint(vec)\n</code></pre> <p>[[0.54521054+0.60483621j]  [0.30916633+0.49125839j]]</p> <p>We can once again verify that this is in fact a valid state vector by computing the corresponding density matrix of the vector and checking if the density matrix is pure.</p> <pre><code>from toqito.state_props import is_pure\n\ndm = vec @ vec.conj().T\n\nprint(is_pure(dm))\n</code></pre> <p>True</p> <p>Parameters:</p> <ul> <li> <code>dim</code>               (<code>list[int] | tuple[int, ...] | int</code>)           \u2013            <p>Either a positive integer giving the total Hilbert-space dimension, or a length-2 sequence specifying the</p> </li> <li> <code>is_real</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Boolean denoting whether the returned vector has real entries. Default is <code>False</code>, which produces</p> </li> <li> <code>k_param</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Optional upper bound on the Schmidt rank when <code>dim</code> describes a bipartite system.  Set to <code>0</code></p> </li> <li> <code>seed</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>A seed used to instantiate numpy's random number generator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>A normalized column vector of shape <code>(total_dim, 1)</code> where <code>total_dim</code> equals <code>dim</code> if <code>dim</code> is an integer</p> </li> <li> <code>ndarray</code>           \u2013            <p>and equals the product of entries in <code>dim</code> otherwise.</p> </li> </ul> Source code in <code>toqito/rand/random_state_vector.py</code> <pre><code>def random_state_vector(\n    dim: list[int] | tuple[int, ...] | int,\n    is_real: bool = False,\n    k_param: int = 0,\n    seed: int | None = None,\n) -&gt; np.ndarray:\n    r\"\"\"Generate a random pure state vector.\n\n    Randomness model\n\n    We sample entries independently from the standard normal distribution using ``numpy``'s\n    ``default_rng``.  If ``is_real`` is ``False`` (default), the imaginary part is sampled in the\n    same way and added with the factor \\(i\\); otherwise the vector is real.  The sampled vector\n    is normalized to have unit Euclidean norm.  When ``k_param`` is strictly positive, the returned\n    state describes a bipartite system of dimensions ``dim`` (or ``[dim, dim]`` if ``dim`` is an\n    integer) with Schmidt rank at most ``k_param``.  This is achieved by drawing local factors and\n    combining them with a maximally entangled resource state.\n\n    Examples:\n        We may generate a random state vector. For instance, here is an example where we can generate a\n        \\(2\\)-dimensional random state vector.\n\n        ```python exec=\"1\" source=\"above\" session=\"vec_example\"\n        from toqito.rand import random_state_vector\n\n        vec = random_state_vector(2)\n\n        print(vec)\n        ```\n\n        We can verify that this is in fact a valid state vector by computing the corresponding density\n        matrix of the vector and checking if the density matrix is pure.\n\n        ```python exec=\"1\" source=\"above\" session=\"vec_example\"\n        from toqito.state_props import is_pure\n\n        dm = vec @ vec.conj().T\n\n        print(is_pure(dm))\n        ```\n\n        It is also possible to pass a seed for reproducibility.\n\n        ```python exec=\"1\" source=\"above\" session=\"vec_example\"\n        from toqito.rand import random_state_vector\n\n        vec = random_state_vector(2, seed=42)\n\n        print(vec)\n        ```\n\n        We can once again verify that this is in fact a valid state vector by computing the\n        corresponding density matrix of the vector and checking if the density matrix is pure.\n\n        ```python exec=\"1\" source=\"above\" session=\"vec_example\"\n        from toqito.state_props import is_pure\n\n        dm = vec @ vec.conj().T\n\n        print(is_pure(dm))\n        ```\n\n\n    Args:\n        dim: Either a positive integer giving the total Hilbert-space dimension, or a length-2 sequence specifying the\n        individual subsystem dimensions for bipartite sampling.\n        is_real: Boolean denoting whether the returned vector has real entries. Default is `False`, which produces\n        complex amplitudes.\n        k_param: Optional upper bound on the Schmidt rank when ``dim`` describes a bipartite system.  Set to `0`\n        (default) to ignore the Schmidt rank constraint.  Must be non-negative and strictly less than the smaller\n        subsystem dimension when used.\n        seed: A seed used to instantiate numpy's random number generator.\n\n    Returns:\n        A normalized column vector of shape ``(total_dim, 1)`` where ``total_dim`` equals `dim` if ``dim`` is an integer\n        and equals the product of entries in ``dim`` otherwise.\n\n    \"\"\"\n    gen = np.random.default_rng(seed=seed)\n    if k_param &lt; 0:\n        msg = \"k_param must be non-negative.\"\n        raise ValueError(msg)\n\n    if isinstance(dim, int):\n        dims_seq: list[int] | None = None\n        min_dim = dim\n        total_dim = dim\n    else:\n        dims_seq = list(dim)\n        if len(dims_seq) == 0:\n            msg = \"dim must not be empty when provided as a sequence.\"\n            raise ValueError(msg)\n        if not all(isinstance(val, int) and val &gt; 0 for val in dims_seq):\n            msg = \"dim entries must be positive integers.\"\n            raise ValueError(msg)\n        min_dim = min(dims_seq)\n        total_dim = int(np.prod(dims_seq))\n\n    if 0 &lt; k_param &lt; min_dim:\n        if isinstance(dim, int):\n            dims_pair = [dim, dim]\n        else:\n            if len(dims_seq) != 2:\n                msg = \"When k_param &gt; 0, dim must be an integer or a length-2 sequence.\"\n                raise ValueError(msg)\n            dims_pair = dims_seq\n\n        psi = max_entangled(k_param, True, False).toarray()\n\n        a_param = gen.random((dims_pair[0] * k_param, 1))\n        b_param = gen.random((dims_pair[1] * k_param, 1))\n\n        if not is_real:\n            a_param = a_param + 1j * gen.random((dims_pair[0] * k_param, 1))\n            b_param = b_param + 1j * gen.random((dims_pair[1] * k_param, 1))\n\n        mat_1 = np.kron(psi.conj().T, np.identity(int(np.prod(dims_pair))))\n        mat_2 = swap(\n            np.kron(a_param, b_param),\n            sys=[2, 3],\n            dim=[k_param, dims_pair[0], k_param, dims_pair[1]],\n        )\n\n        ret_vec = mat_1 @ mat_2\n        ret_vec = ret_vec.reshape(-1, 1)\n        return np.divide(ret_vec, np.linalg.norm(ret_vec))\n\n    ret_vec = gen.random((total_dim, 1))\n    if not is_real:\n        ret_vec = ret_vec + 1j * gen.random((total_dim, 1))\n    return np.divide(ret_vec, np.linalg.norm(ret_vec))\n</code></pre>"},{"location":"reference/toqito/rand/random_states/","title":"random_states","text":""},{"location":"reference/toqito/rand/random_states/#toqito.rand.random_states","title":"random_states","text":"<p>Generates random quantum states using Qiskit.</p>"},{"location":"reference/toqito/rand/random_states/#toqito.rand.random_states.random_states","title":"random_states","text":"<pre><code>random_states(n: int, d: int, seed: int | None = None) -&gt; list[ndarray]\n</code></pre> <p>Generate a list of random quantum states.</p> <p>This function generates a list of quantum states, each of a specified dimension. The states are valid quantum states distributed according to the Haar measure.</p> <p>Examples:</p> <p>Generating three quantum states each of dimension 4.</p> <pre><code>from toqito.rand import random_states\n\nstates = random_states(3, 4)\nprint(f\"length of states is {len(states)}\")\n\nprint(f\"Shape of each state vector: {states[0].shape}\")\n\nfor idx, state in enumerate(states):\n   print(f\"\\nState {idx}:\")\n   print(state)\n</code></pre> <p>length of states is 3 Shape of each state vector: (4, 1)</p> <p>State 0: [[-0.06524285-0.3049359j ]  [ 0.00313974-0.46751022j]  [-0.13439893+0.58566157j]  [ 0.2151773 +0.52613494j]]</p> <p>State 1: [[-0.13924325-0.27081174j]  [ 0.71150494-0.12156774j]  [ 0.47142823+0.24052935j]  [-0.1940422 +0.26173078j]]</p> <p>State 2: [[-0.51787113+0.45072012j]  [ 0.41381973-0.07744775j]  [-0.14587676-0.31109399j]  [-0.39844062-0.27313279j]]</p> <p>It is also possible to pass a seed to this function for reproducibility.</p> <pre><code>from toqito.rand import random_states\n\nstates = random_states(3, 4, seed=42)\n\nfor idx, state in enumerate(states):\n   print(f\"\\nState {idx}:\")\n   print(state)\n</code></pre> <p>State 0: [[ 0.13830446+0.0299699j ]  [-0.47202619+0.51163029j]  [ 0.34061349+0.21219233j]  [ 0.42690188-0.39001418j]]</p> <p>State 1: [[-0.71489214+0.1351165j ]  [-0.47714049-0.35135073j]  [ 0.04684288+0.32187898j]  [-0.11587661-0.01829369j]]</p> <p>State 2: [[-0.00827473-0.0910465j ]  [-0.42013238-0.33536439j]  [ 0.43311201+0.60211343j]  [ 0.38307005-0.07610726j]]</p> <p>Parameters:</p> <ul> <li> <code>n</code>               (<code>int</code>)           \u2013            <p>int The number of random states to generate.</p> </li> <li> <code>d</code>               (<code>int</code>)           \u2013            <p>int The dimension of each quantum state.</p> </li> <li> <code>seed</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>int | None A seed used to instantiate numpy's random number generator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[ndarray]</code>           \u2013            <p>A list of <code>n</code> numpy arrays, each representing a d-dimensional quantum state as a column vector.</p> </li> </ul> Source code in <code>toqito/rand/random_states.py</code> <pre><code>def random_states(n: int, d: int, seed: int | None = None) -&gt; list[np.ndarray]:\n    r\"\"\"Generate a list of random quantum states.\n\n    This function generates a list of quantum states, each of a specified dimension. The states are\n    valid quantum states distributed according to the Haar measure.\n\n    Examples:\n        Generating three quantum states each of dimension 4.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.rand import random_states\n\n        states = random_states(3, 4)\n        print(f\"length of states is {len(states)}\")\n\n        print(f\"Shape of each state vector: {states[0].shape}\")\n\n        for idx, state in enumerate(states):\n           print(f\"\\nState {idx}:\")\n           print(state)\n        ```\n\n        It is also possible to pass a seed to this function for reproducibility.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.rand import random_states\n\n        states = random_states(3, 4, seed=42)\n\n        for idx, state in enumerate(states):\n           print(f\"\\nState {idx}:\")\n           print(state)\n        ```\n\n\n\n\n\n    Args:\n        n: int The number of random states to generate.\n        d: int The dimension of each quantum state.\n        seed: int | None A seed used to instantiate numpy's random number generator.\n\n    Returns:\n        A list of `n` numpy arrays, each representing a d-dimensional quantum state as a column vector.\n\n    \"\"\"\n    gen = np.random.default_rng(seed=seed)\n    samples = gen.normal(size=(n, d)) + 1j * gen.normal(size=(n, d))\n    samples /= np.linalg.norm(samples, axis=1)[:, np.newaxis]\n    return [sample.reshape(-1, 1) for sample in samples]\n</code></pre>"},{"location":"reference/toqito/rand/random_unitary/","title":"random_unitary","text":""},{"location":"reference/toqito/rand/random_unitary/#toqito.rand.random_unitary","title":"random_unitary","text":"<p>Generates a random unitary matrix.</p>"},{"location":"reference/toqito/rand/random_unitary/#toqito.rand.random_unitary.random_unitary","title":"random_unitary","text":"<pre><code>random_unitary(dim: list[int] | int, is_real: bool = False, seed: int | None = None) -&gt; ndarray\n</code></pre> <p>Generate a random unitary or orthogonal matrix <sup>1</sup>.</p> <p>Calculates a random unitary matrix (if <code>is_real = False</code>) or a random real orthogonal matrix (if <code>is_real = True</code>), uniformly distributed according to the Haar measure.</p> <p>Examples:</p> <p>We may generate a random unitary matrix. Here is an example of how we may be able to generate a random \\(2\\)-dimensional random unitary matrix with complex entries.</p> <pre><code>from toqito.rand import random_unitary\n\ncomplex_dm = random_unitary(2)\n\nprint(complex_dm)\n</code></pre> <p>[[ 0.10691636-0.88552904j  0.42350556+0.15827273j]  [ 0.2860407 -0.35012559j -0.53859613-0.71099015j]]</p> <p>We can verify that this is in fact a valid unitary matrix using the <code>is_unitary</code> function from <code>|toqito\u27e9</code> as follows</p> <pre><code>from toqito.matrix_props import is_unitary\n\nprint(is_unitary(complex_dm))\n</code></pre> <p>True</p> <p>We can also generate random unitary matrices that are real-valued as follows.</p> <pre><code>from toqito.rand import random_unitary\n\nreal_dm = random_unitary(2, True)\n\nprint(real_dm)\n</code></pre> <p>[[ 0.68093024  0.73234828]  [-0.73234828  0.68093024]]</p> <p>Again, verifying that this is a valid unitary matrix can be done as follows.</p> <pre><code>from toqito.matrix_props import is_unitary\n\nprint(is_unitary(real_dm))\n</code></pre> <p>True</p> <p>We may also generate unitaries such that the dimension argument provided is a <code>list</code> as opposed to an <code>int</code>. Here is an example of a random unitary matrix of dimension \\(4\\).</p> <pre><code>from toqito.rand import random_unitary\n\nmat = random_unitary([4, 4], True)\n\nprint(mat)\n</code></pre> <p>[[ 0.06245906 -0.47880785 -0.20921081  0.85033684]  [ 0.68939746 -0.33211255 -0.5284494  -0.36765965]  [ 0.7076003   0.49506309  0.38781562  0.32220086]  [-0.14188662  0.64448183 -0.7256522   0.19478256]]</p> <p>As before, we can verify that this matrix generated is a valid unitary matrix.</p> <pre><code>from toqito.matrix_props import is_unitary\n\nprint(is_unitary(mat))\n</code></pre> <p>True</p> <p>It is also possible to pass a seed to this function for reproducibility.</p> <pre><code>from toqito.rand import random_unitary\n\nseeded = random_unitary(2, seed=42)\n\nprint(seeded)\n</code></pre> <p>[[ 0.14398279-0.92188954j -0.05864249+0.35489392j]  [ 0.35459797+0.06040626j  0.91839541+0.16480666j]]</p> <p>And once again, we can verify that this matrix generated is a valid unitary matrix.</p> <pre><code>from toqito.matrix_props import is_unitary\n\nprint(is_unitary(seeded))\n</code></pre> <p>True</p> <p>Parameters:</p> <ul> <li> <code>dim</code>               (<code>list[int] | int</code>)           \u2013            <p>The number of rows (and columns) of the unitary matrix.</p> </li> <li> <code>is_real</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Boolean denoting whether the returned matrix has real entries or not. Default is <code>False</code>.</p> </li> <li> <code>seed</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>A seed used to instantiate numpy's random number generator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>A <code>dim</code>-by-<code>dim</code> random unitary matrix.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Ozols, Maris. How to generate a random unitary matrix. (2009). link.</p> Source code in <code>toqito/rand/random_unitary.py</code> <pre><code>def random_unitary(dim: list[int] | int, is_real: bool = False, seed: int | None = None) -&gt; np.ndarray:\n    r\"\"\"Generate a random unitary or orthogonal matrix [@Ozols_2009_RandU].\n\n    Calculates a random unitary matrix (if `is_real = False`) or a random real orthogonal\n    matrix (if `is_real = True`), uniformly distributed according to the Haar measure.\n\n    Examples:\n        We may generate a random unitary matrix. Here is an example of how we may be able to generate a\n        random \\(2\\)-dimensional random unitary matrix with complex entries.\n\n        ```python exec=\"1\" source=\"above\" session=\"complex_dm\"\n        from toqito.rand import random_unitary\n\n        complex_dm = random_unitary(2)\n\n        print(complex_dm)\n        ```\n\n\n        We can verify that this is in fact a valid unitary matrix using the `is_unitary` function\n        from `|toqito\u27e9` as follows\n\n        ```python exec=\"1\" source=\"above\" session=\"complex_dm\"\n        from toqito.matrix_props import is_unitary\n\n        print(is_unitary(complex_dm))\n        ```\n\n        We can also generate random unitary matrices that are real-valued as follows.\n\n        ```python exec=\"1\" source=\"above\" session=\"real_dm\"\n        from toqito.rand import random_unitary\n\n        real_dm = random_unitary(2, True)\n\n        print(real_dm)\n        ```\n\n\n        Again, verifying that this is a valid unitary matrix can be done as follows.\n\n        ```python exec=\"1\" source=\"above\" session=\"real_dm\"\n        from toqito.matrix_props import is_unitary\n\n        print(is_unitary(real_dm))\n        ```\n\n        We may also generate unitaries such that the dimension argument provided is a `list` as\n        opposed to an `int`. Here is an example of a random unitary matrix of dimension \\(4\\).\n\n        ```python exec=\"1\" source=\"above\" session=\"mat\"\n        from toqito.rand import random_unitary\n\n        mat = random_unitary([4, 4], True)\n\n        print(mat)\n        ```\n\n\n        As before, we can verify that this matrix generated is a valid unitary matrix.\n\n        ```python exec=\"1\" source=\"above\" session=\"mat\"\n        from toqito.matrix_props import is_unitary\n\n        print(is_unitary(mat))\n        ```\n\n        It is also possible to pass a seed to this function for reproducibility.\n\n        ```python exec=\"1\" source=\"above\" session=\"seeded\"\n        from toqito.rand import random_unitary\n\n        seeded = random_unitary(2, seed=42)\n\n        print(seeded)\n        ```\n\n        And once again, we can verify that this matrix generated is a valid unitary matrix.\n\n        ```python exec=\"1\" source=\"above\" session=\"seeded\"\n        from toqito.matrix_props import is_unitary\n\n        print(is_unitary(seeded))\n        ```\n\n    Args:\n        dim: The number of rows (and columns) of the unitary matrix.\n        is_real: Boolean denoting whether the returned matrix has real entries or not. Default is `False`.\n        seed: A seed used to instantiate numpy's random number generator.\n\n    Returns:\n        A `dim`-by-`dim` random unitary matrix.\n\n    \"\"\"\n    gen = np.random.default_rng(seed=seed)\n\n    if isinstance(dim, int):\n        dim = [dim, dim]\n\n    if dim[0] != dim[1]:\n        raise ValueError(\"Unitary matrix must be square.\")\n\n    # Construct the Ginibre ensemble.\n    gin = gen.standard_normal((dim[0], dim[1]))\n\n    if not is_real:\n        gin = gin + 1j * gen.standard_normal((dim[0], dim[1]))\n\n    # QR decomposition of the Ginibre ensemble.\n    q_mat, r_mat = np.linalg.qr(gin)\n\n    # Compute U from QR decomposition.\n    r_mat = np.sign(np.diag(r_mat))\n\n    # Protect against potentially zero diagonal entries.\n    r_mat[r_mat == 0] = 1\n\n    return q_mat @ np.diag(r_mat)\n</code></pre>"},{"location":"reference/toqito/state_metrics/","title":"state_metrics","text":""},{"location":"reference/toqito/state_metrics/#toqito.state_metrics","title":"state_metrics","text":"<p>State metrics is a set of modules that are used to calculate various distance metrics for quantum states.</p>"},{"location":"reference/toqito/state_metrics/bures_angle/","title":"bures_angle","text":""},{"location":"reference/toqito/state_metrics/bures_angle/#toqito.state_metrics.bures_angle","title":"bures_angle","text":"<p>Bures angle, also known as Bures arc, Bures length or quantum angle is a distance metric.</p> <p>The Bures angle metric is a measure of the statistical distance between quantum states.</p>"},{"location":"reference/toqito/state_metrics/bures_angle/#toqito.state_metrics.bures_angle.bures_angle","title":"bures_angle","text":"<pre><code>bures_angle(rho_1: ndarray, rho_2: ndarray, decimals: int = 10) -&gt; float\n</code></pre> <p>Compute the Bures angle of two density matrices <sup>1</sup>.</p> <p>Calculate the Bures angle between two density matrices <code>rho_1</code> and <code>rho_2</code> defined by:</p> \\[     \\arccos{\\sqrt{F (\\rho_1, \\rho_2)}} \\] <p>where \\(F(\\cdot)\\) denotes the fidelity between \\(\\rho_1\\) and \\(\\rho_2\\). The return is a value between \\(0\\) and \\(\\pi / 2\\), with \\(0\\) corresponding to matrices <code>rho_1 = rho_2</code> and \\(\\pi / 2\\) corresponding to the case <code>rho_1</code> and <code>rho_2</code> with orthogonal support.</p> <p>Examples:</p> <p>Consider the following Bell state</p> \\[     u = \\frac{1}{\\sqrt{2}} \\left( |00 \\rangle + |11 \\rangle \\right) \\in \\mathcal{X}. \\] <p>The corresponding density matrix of \\(u\\) may be calculated by:</p> \\[     \\rho = u u^* = \\frac{1}{2} \\begin{pmatrix}                      1 &amp; 0 &amp; 0 &amp; 1 \\\\                      0 &amp; 0 &amp; 0 &amp; 0 \\\\                      0 &amp; 0 &amp; 0 &amp; 0 \\\\                      1 &amp; 0 &amp; 0 &amp; 1                    \\end{pmatrix} \\in \\text{D}(\\mathcal{X}). \\] <p>In the event where we calculate the Bures angle between states that are identical, we should obtain the value of \\(0\\). This can be observed in <code>|toqito\u27e9</code> as follows.</p> <pre><code>import numpy as np\nfrom toqito.state_metrics import bures_angle\n\nrho = 1 / 2 * np.array(\n    [[1, 0, 0, 1],\n     [0, 0, 0, 0],\n     [0, 0, 0, 0],\n     [1, 0, 0, 1]]\n)\nsigma = rho\n\nprint(bures_angle(rho, sigma))\n</code></pre> <p>0.0</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If matrices are not of equal dimension.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>rho_1</code>               (<code>ndarray</code>)           \u2013            <p>Density operator.</p> </li> <li> <code>rho_2</code>               (<code>ndarray</code>)           \u2013            <p>Density operator.</p> </li> <li> <code>decimals</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Number of decimal places to round to (default 10).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The Bures angle between <code>rho_1</code> and <code>rho_2</code>.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Bures distance. link.</p> Source code in <code>toqito/state_metrics/bures_angle.py</code> <pre><code>def bures_angle(rho_1: np.ndarray, rho_2: np.ndarray, decimals: int = 10) -&gt; float:\n    r\"\"\"Compute the Bures angle of two density matrices [@WikiBures].\n\n    Calculate the Bures angle between two density matrices `rho_1` and `rho_2` defined by:\n\n    \\[\n        \\arccos{\\sqrt{F (\\rho_1, \\rho_2)}}\n    \\]\n\n    where \\(F(\\cdot)\\) denotes the fidelity between \\(\\rho_1\\) and \\(\\rho_2\\). The return is a value between\n    \\(0\\) and \\(\\pi / 2\\), with \\(0\\) corresponding to matrices `rho_1 = rho_2` and \\(\\pi / 2\\)\n    corresponding to the case `rho_1` and `rho_2` with orthogonal support.\n\n    Examples:\n        Consider the following Bell state\n\n        \\[\n            u = \\frac{1}{\\sqrt{2}} \\left( |00 \\rangle + |11 \\rangle \\right) \\in \\mathcal{X}.\n        \\]\n\n        The corresponding density matrix of \\(u\\) may be calculated by:\n\n        \\[\n            \\rho = u u^* = \\frac{1}{2} \\begin{pmatrix}\n                             1 &amp; 0 &amp; 0 &amp; 1 \\\\\n                             0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                             0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                             1 &amp; 0 &amp; 0 &amp; 1\n                           \\end{pmatrix} \\in \\text{D}(\\mathcal{X}).\n        \\]\n\n        In the event where we calculate the Bures angle between states that are identical, we should obtain the value of\n        \\(0\\). This can be observed in `|toqito\u27e9` as follows.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.state_metrics import bures_angle\n\n        rho = 1 / 2 * np.array(\n            [[1, 0, 0, 1],\n             [0, 0, 0, 0],\n             [0, 0, 0, 0],\n             [1, 0, 0, 1]]\n        )\n        sigma = rho\n\n        print(bures_angle(rho, sigma))\n        ```\n\n    Raises:\n        ValueError: If matrices are not of equal dimension.\n\n    Args:\n        rho_1: Density operator.\n        rho_2: Density operator.\n        decimals: Number of decimal places to round to (default 10).\n\n    Returns:\n        The Bures angle between `rho_1` and `rho_2`.\n\n    \"\"\"\n    # Perform error checking.\n    if not np.all(rho_1.shape == rho_2.shape):\n        raise ValueError(\"InvalidDim: `rho_1` and `rho_2` must be matrices of the same size.\")\n    # Round fidelity to only 10 decimals to avoid error when `rho_1 = rho_2`.\n    return np.real(np.arccos(np.sqrt(np.round(fidelity(rho_1, rho_2), decimals))))\n</code></pre>"},{"location":"reference/toqito/state_metrics/bures_distance/","title":"bures_distance","text":""},{"location":"reference/toqito/state_metrics/bures_distance/#toqito.state_metrics.bures_distance","title":"bures_distance","text":"<p>Bures distance metric is a commonly used distance metric.</p> <p>It serves as an actual measure of distinguishability between two quantum states.</p>"},{"location":"reference/toqito/state_metrics/bures_distance/#toqito.state_metrics.bures_distance.bures_distance","title":"bures_distance","text":"<pre><code>bures_distance(rho_1: ndarray, rho_2: ndarray, decimals: int = 10) -&gt; float\n</code></pre> <p>Compute the Bures distance of two density matrices <sup>1</sup>.</p> <p>Calculate the Bures distance between two density matrices <code>rho_1</code> and <code>rho_2</code> defined by:</p> \\[     \\sqrt{2 (1 - F(\\rho_1, \\rho_2))}, \\] <p>where \\(F(\\cdot)\\) denotes the fidelity between \\(\\rho_1\\) and \\(\\rho_2\\). The return is a value between \\(0\\) and \\(\\sqrt{2}\\),with \\(0\\) corresponding to matrices: <code>rho_1 = rho_2</code> and \\(\\sqrt{2}\\) corresponding to the case: <code>rho_1</code> and <code>rho_2</code> with orthogonal support.</p> <p>Examples:</p> <p>Consider the following Bell state</p> \\[     u = \\frac{1}{\\sqrt{2}} \\left( |00 \\rangle + |11 \\rangle \\right) \\in \\mathcal{X}. \\] <p>The corresponding density matrix of \\(u\\) may be calculated by:</p> \\[     \\rho = u u^* = \\frac{1}{2} \\begin{pmatrix}                      1 &amp; 0 &amp; 0 &amp; 1 \\\\                      0 &amp; 0 &amp; 0 &amp; 0 \\\\                      0 &amp; 0 &amp; 0 &amp; 0 \\\\                      1 &amp; 0 &amp; 0 &amp; 1                    \\end{pmatrix} \\in \\text{D}(\\mathcal{X}). \\] <p>In the event where we calculate the Bures distance between states that are identical, we should obtain the value of \\(0\\). This can be observed in <code>|toqito\u27e9</code> as follows.</p> <pre><code>import numpy as np\nfrom toqito.state_metrics import bures_distance\n\nrho = 1 / 2 * np.array(\n    [[1, 0, 0, 1],\n     [0, 0, 0, 0],\n     [0, 0, 0, 0],\n     [1, 0, 0, 1]]\n)\nsigma = rho\n\nprint(bures_distance(rho, sigma))\n</code></pre> <p>0.0</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If matrices are not of equal dimension.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>rho_1</code>               (<code>ndarray</code>)           \u2013            <p>Density operator.</p> </li> <li> <code>rho_2</code>               (<code>ndarray</code>)           \u2013            <p>Density operator.</p> </li> <li> <code>decimals</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Number of decimal places to round to (default 10).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The Bures distance between <code>rho_1</code> and <code>rho_2</code>.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Bures distance. link.</p> Source code in <code>toqito/state_metrics/bures_distance.py</code> <pre><code>def bures_distance(rho_1: np.ndarray, rho_2: np.ndarray, decimals: int = 10) -&gt; float:\n    r\"\"\"Compute the Bures distance of two density matrices [@WikiBures].\n\n    Calculate the Bures distance between two density matrices `rho_1` and `rho_2` defined by:\n\n    \\[\n        \\sqrt{2 (1 - F(\\rho_1, \\rho_2))},\n    \\]\n\n    where \\(F(\\cdot)\\) denotes the fidelity between \\(\\rho_1\\) and \\(\\rho_2\\). The return is a value between\n    \\(0\\) and \\(\\sqrt{2}\\),with \\(0\\) corresponding to matrices: `rho_1 = rho_2` and \\(\\sqrt{2}\\)\n    corresponding to the case: `rho_1` and `rho_2` with orthogonal support.\n\n    Examples:\n        Consider the following Bell state\n\n        \\[\n            u = \\frac{1}{\\sqrt{2}} \\left( |00 \\rangle + |11 \\rangle \\right) \\in \\mathcal{X}.\n        \\]\n\n        The corresponding density matrix of \\(u\\) may be calculated by:\n\n        \\[\n            \\rho = u u^* = \\frac{1}{2} \\begin{pmatrix}\n                             1 &amp; 0 &amp; 0 &amp; 1 \\\\\n                             0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                             0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                             1 &amp; 0 &amp; 0 &amp; 1\n                           \\end{pmatrix} \\in \\text{D}(\\mathcal{X}).\n        \\]\n\n        In the event where we calculate the Bures distance between states that are identical, we should obtain\n        the value of\n        \\(0\\). This can be observed in `|toqito\u27e9` as follows.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.state_metrics import bures_distance\n\n        rho = 1 / 2 * np.array(\n            [[1, 0, 0, 1],\n             [0, 0, 0, 0],\n             [0, 0, 0, 0],\n             [1, 0, 0, 1]]\n        )\n        sigma = rho\n\n        print(bures_distance(rho, sigma))\n        ```\n\n    Raises:\n        ValueError: If matrices are not of equal dimension.\n\n    Args:\n        rho_1: Density operator.\n        rho_2: Density operator.\n        decimals: Number of decimal places to round to (default 10).\n\n    Returns:\n        The Bures distance between `rho_1` and `rho_2`.\n\n    \"\"\"\n    # Perform some error checking.\n    if not np.all(rho_1.shape == rho_2.shape):\n        raise ValueError(\"InvalidDim: `rho_1` and `rho_2` must be matrices of the same size.\")\n    # Round fidelity to only 10 decimals to avoid error when `rho_1 = rho_2`.\n    return np.sqrt(2.0 * (1.0 - np.round(fidelity(rho_1, rho_2), decimals)))\n</code></pre>"},{"location":"reference/toqito/state_metrics/fidelity/","title":"fidelity","text":""},{"location":"reference/toqito/state_metrics/fidelity/#toqito.state_metrics.fidelity","title":"fidelity","text":"<p>Fidelity is a metric that qualifies how close two quantum states are.</p>"},{"location":"reference/toqito/state_metrics/fidelity/#toqito.state_metrics.fidelity.fidelity","title":"fidelity","text":"<pre><code>fidelity(rho: ndarray, sigma: ndarray) -&gt; float\n</code></pre> <p>Compute the fidelity of two density matrices <sup>1</sup>.</p> <p>Calculate the fidelity between the two density matrices <code>rho</code> and <code>sigma</code>, defined by:</p> \\[     ||\\sqrt(\\rho) \\sqrt(\\sigma)||_1, \\] <p>where \\(|| \\cdot ||_1\\) denotes the trace norm. The return is a value between \\(0\\) and \\(1\\), with \\(0\\) corresponding to matrices <code>rho</code> and <code>sigma</code> with orthogonal support, and \\(1\\) corresponding to the case <code>rho = sigma</code>.</p> <p>Examples:</p> <p>Consider the following Bell state</p> \\[     u = \\frac{1}{\\sqrt{2}} \\left( |00 \\rangle + |11 \\rangle \\right) \\in \\mathcal{X}. \\] <p>The corresponding density matrix of \\(u\\) may be calculated by:</p> \\[     \\rho = u u^* = \\frac{1}{2} \\begin{pmatrix}                      1 &amp; 0 &amp; 0 &amp; 1 \\\\                      0 &amp; 0 &amp; 0 &amp; 0 \\\\                      0 &amp; 0 &amp; 0 &amp; 0 \\\\                      1 &amp; 0 &amp; 0 &amp; 1                    \\end{pmatrix} \\in \\text{D}(\\mathcal{X}). \\] <p>In the event where we calculate the fidelity between states that are identical, we should obtain the value of \\(1\\). This can be observed in <code>|toqito\u27e9</code> as follows.</p> <pre><code>import numpy as np\nfrom toqito.state_metrics import fidelity\n\nrho = 1 / 2 * np.array(\n    [[1, 0, 0, 1],\n     [0, 0, 0, 0],\n     [0, 0, 0, 0],\n     [1, 0, 0, 1]]\n)\nsigma = rho\n\nprint(fidelity(rho, sigma))\n</code></pre> <p>1.0000000000000002</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If matrices are not density operators.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>rho</code>               (<code>ndarray</code>)           \u2013            <p>Density operator.</p> </li> <li> <code>sigma</code>               (<code>ndarray</code>)           \u2013            <p>Density operator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The fidelity between <code>rho</code> and <code>sigma</code>.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Fidelity of quantum states. link.</p> Source code in <code>toqito/state_metrics/fidelity.py</code> <pre><code>def fidelity(rho: np.ndarray, sigma: np.ndarray) -&gt; float:\n    r\"\"\"Compute the fidelity of two density matrices [@WikiFidQuant].\n\n    Calculate the fidelity between the two density matrices `rho` and `sigma`, defined by:\n\n    \\[\n        ||\\sqrt(\\rho) \\sqrt(\\sigma)||_1,\n    \\]\n\n    where \\(|| \\cdot ||_1\\) denotes the trace norm. The return is a value between \\(0\\) and \\(1\\), with\n    \\(0\\) corresponding to matrices `rho` and `sigma` with orthogonal support, and \\(1\\)\n    corresponding to the case `rho = sigma`.\n\n    Examples:\n        Consider the following Bell state\n\n        \\[\n            u = \\frac{1}{\\sqrt{2}} \\left( |00 \\rangle + |11 \\rangle \\right) \\in \\mathcal{X}.\n        \\]\n\n        The corresponding density matrix of \\(u\\) may be calculated by:\n\n        \\[\n            \\rho = u u^* = \\frac{1}{2} \\begin{pmatrix}\n                             1 &amp; 0 &amp; 0 &amp; 1 \\\\\n                             0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                             0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                             1 &amp; 0 &amp; 0 &amp; 1\n                           \\end{pmatrix} \\in \\text{D}(\\mathcal{X}).\n        \\]\n\n        In the event where we calculate the fidelity between states that are identical, we should obtain the value of\n        \\(1\\). This can be observed in `|toqito\u27e9` as follows.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.state_metrics import fidelity\n\n        rho = 1 / 2 * np.array(\n            [[1, 0, 0, 1],\n             [0, 0, 0, 0],\n             [0, 0, 0, 0],\n             [1, 0, 0, 1]]\n        )\n        sigma = rho\n\n        print(fidelity(rho, sigma))\n        ```\n\n    Raises:\n        ValueError: If matrices are not density operators.\n\n    Args:\n        rho: Density operator.\n        sigma: Density operator.\n\n    Returns:\n        The fidelity between `rho` and `sigma`.\n\n    \"\"\"\n    # Perform some error checking.\n    if not np.all(rho.shape == sigma.shape):\n        raise ValueError(\"InvalidDim: `rho` and `sigma` must be matrices of the same size.\")\n\n    # If `rho` or `sigma` is a cvxpy variable then compute fidelity via semidefinite programming, so that this function\n    # can be used in the objective function or constraints of other cvxpy optimization problems.\n    if isinstance(rho, cvxpy.atoms.affine.vstack.Vstack) or isinstance(sigma, cvxpy.atoms.affine.vstack.Vstack):\n        z_var = cvxpy.Variable(rho.shape, complex=True)\n        objective = cvxpy.Maximize(cvxpy.real(cvxpy.trace(z_var + z_var.H)))\n        constraints = [cvxpy.bmat([[rho, z_var], [z_var.H, sigma]]) &gt;&gt; 0]\n        problem = cvxpy.Problem(objective, constraints)\n\n        return 1 / 2 * problem.solve()\n\n    if not is_density(rho) or not is_density(sigma):\n        raise ValueError(\"Fidelity is only defined for density operators.\")\n\n    # If `rho` or `sigma` are *not* cvxpy variables, compute fidelity normally, since this is much faster.\n    sq_rho = scipy.linalg.sqrtm(rho)\n    sq_fid = scipy.linalg.sqrtm(sq_rho @ sigma @ sq_rho)\n    return np.real(np.trace(sq_fid))\n</code></pre>"},{"location":"reference/toqito/state_metrics/fidelity_of_separability/","title":"fidelity_of_separability","text":""},{"location":"reference/toqito/state_metrics/fidelity_of_separability/#toqito.state_metrics.fidelity_of_separability","title":"fidelity_of_separability","text":"<p>Add function for fidelity of separability as defined in <sup>1</sup>.</p> <p>Fidelity of separability is an entanglement measure that can be approximated with semidefinite programs. The constraints for this function are positive partial transpose (PPT) &amp; k-extendible states.</p> <p>References</p> <p><sup>1</sup> Philip, Aby and Rethinasamy, Soorya and Russo, Vincent and Wilde, Mark. Schr\\\"odinger as a Quantum Programmer: Estimating Entanglement via Steering. (2023).</p>"},{"location":"reference/toqito/state_metrics/fidelity_of_separability/#toqito.state_metrics.fidelity_of_separability.fidelity_of_separability","title":"fidelity_of_separability","text":"<pre><code>fidelity_of_separability(input_state_rho: ndarray, input_state_rho_dims: list[int], k: int = 1, verbosity_option: int = 0, solver_option: str = 'cvxopt') -&gt; float\n</code></pre> <p>Define the first benchmark introduced in Appendix H of <sup>1</sup>.</p> <p>If you would like to instead use the benchmark introduced in Appendix I, go to channel_metrics.fidelity_of_separability.</p> <p>In <sup>1</sup> a variational quantum algorithm (VQA) is introduced to test the separability of a general bipartite state. The algorithm utilizes quantum steering between two separated systems such that the separability of the state is quantified.</p> <p>Due to the limitations of currently available quantum computers, two optimization semidefinite programs (SDP) benchmarks were introduced to maximize the fidelity of separability subject to some state constraints (Positive Partial Transpose (PPT), symmetric extensions (k-extendibility ) <sup>2</sup> ) This function approximites the fidelity of separability by maximizing over PPT states &amp; k-extendible states i.e. an optimization problem over states <sup>3</sup>.</p> <p>The following expression (Equation (H2) from <sup>1</sup> ) defines the constraints for approxiamting</p> <p>\\(\\sqrt{\\widetilde{F}_s^1}(\\rho_{AB}) {:}=\\)</p> \\[     \\begin{multline}     \\max_{\\substack{X_{AB} \\in\\mathcal{L}(\\mathcal{H}_{AB}),\\\\\\sigma_{AB^{k}}\\geq0}}     \\left\\{\\begin{array}             [c]{c}             \\operatorname{Re}[\\operatorname{Tr}[X_{AB}]]:\\\\%             \\begin{bmatrix}             \\rho_{AB} &amp; X_{AB}\\\\             X_{AB}^{\\dagger} &amp; \\sigma_{AB_{1}}%             \\end{bmatrix}             \\geq0,\\\\             \\operatorname{Tr}[\\sigma_{AB^{k}}]=1,\\\\             \\sigma_{AB^{k}}=\\mathcal{P}_{B^{k}}(\\sigma_{AB^{k}}),\\\\             T_{B_{1\\cdots j}}(\\sigma_{AB_{1\\cdots j}})\\geq 0 \\quad \\forall j\\leq k         \\end{array}\\right\\}     \\end{multline} \\] <p>\\(\\sqrt{\\widetilde{F}_s^1}(\\rho_{AB})\\) is the quantity to be approximated but this function returns \\(\\widetilde{F}_s^1(\\rho_{AB})\\).</p> <p>\\(\\operatorname{Re}[\\operatorname{Tr}[X_{AB}]]\\) is the maximization problem subject to PPT &amp; k-extendibile state constraints.</p> <p>Here, \\(\\mathcal{L}(\\mathcal{H}_{AB})\\) is the space of linear operators over space \\(\\mathcal{H}_{AB}\\).</p> <p>\\(\\sigma_{AB^{k}}\\) is a k-extension of \\(\\rho_{AB}\\).</p> <p>\\(\\mathcal{P}_{B^{k}}\\) is the permutation operator among systems \\(B_1, B_2,  \\ldots , B_{k}\\) which has no effect on the k-extended state \\(\\sigma_{AB^{k}}\\).</p> <p>The other constraints are due to the PPT condition <sup>4</sup>.</p> <p>Examples:</p> <p>Let's consider a density matrix of a state that we know is pure and separable; \\(|00 \\rangle = |0 \\rangle \\otimes |0 \\rangle\\).</p> <p>The expected approximation of fidelity of separability is the maximum value possible i.e. very close to 1.</p> \\[     \\rho_{AB} = |00 \\rangle \\langle 00| \\] <p><pre><code>import numpy as np\nfrom toqito.state_metrics import fidelity_of_separability\nfrom toqito.matrix_ops import tensor\nfrom toqito.states import basis\n\nstate = tensor(basis(2, 0), basis(2, 0))\nrho = state @ state.conj().T\n\nprint(np.around(fidelity_of_separability(rho, [2, 2]), decimals=2))\n</code></pre> <p>1.0</p>     is PSD with trace 1).</p> <p>Raises:</p> <ul> <li> <code>AssertionError</code>             \u2013            <p>If the provided dimensions are not for a bipartite density matrix.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If the matrix is not a density matrix (square matrix that</p> </li> <li> <code>ValueError</code>             \u2013            <p>the input state is entangled.</p> </li> <li> <code>ValueError</code>             \u2013            <p>the input state is a mixed state.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>input_state_rho</code>               (<code>ndarray</code>)           \u2013            <p>the density matrix for the bipartite state of interest.</p> </li> <li> <code>input_state_rho_dims</code>               (<code>list[int]</code>)           \u2013            <p>the dimensions of System A &amp; B respectively in the input state density matrix. It is</p> </li> <li> <code>k</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>value for k-extendibility.</p> </li> <li> <code>verbosity_option</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Parameter option for <code>picos</code>. Default value is <code>verbosity = 0</code>. For more info, visit https://picos-api.gitlab.io/picos/api/picos.modeling.options.html#option-verbosity.</p> </li> <li> <code>solver_option</code>               (<code>str</code>, default:                   <code>'cvxopt'</code> )           \u2013            <p>Optimization option for <code>picos</code> solver. Default option is <code>solver_option=\"cvxopt\"</code>. For more</p> </li> <li> <code>info, visit https</code>           \u2013            <p>//picos-api.gitlab.io/picos/api/picos.modeling.options.html#option-solver.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>Optimized value of the SDP when maximized over a set of linear operators subject to some constraints.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Philip, Aby and Rethinasamy, Soorya and Russo, Vincent and Wilde, Mark. Schr\\\"odinger as a Quantum Programmer: Estimating Entanglement via Steering. (2023). <sup>2</sup> Hayden, Patrick and Milner, Kevin and Wilde, Mark. Two-Message quantum interactive proofs and the quantum separability problem. 2013 IEEE Conference on Computational Complexity. (2013). doi:10.1109/ccc.2013.24. <sup>3</sup> Watrous, John. The Theory of Quantum Information. (2018). doi:10.1017/9781316848142. <sup>4</sup> Peres, Asher. Separability Criterion for Density Matrices. Physical Review Letters. vol. 77(8). (1996). doi:10.1103/physrevlett.77.1413.</p> Source code in <code>toqito/state_metrics/fidelity_of_separability.py</code> <pre><code>def fidelity_of_separability(\n    input_state_rho: np.ndarray,\n    input_state_rho_dims: list[int],\n    k: int = 1,\n    verbosity_option: int = 0,\n    solver_option: str = \"cvxopt\",\n) -&gt; float:\n    r\"\"\"Define the first benchmark introduced in Appendix H of [@Philip_2023_Schrodinger].\n\n    If you would like to instead use the benchmark introduced in Appendix I, go to\n    [channel_metrics.fidelity_of_separability][toqito.channel_metrics.fidelity_of_separability].\n\n    In [@Philip_2023_Schrodinger] a variational quantum algorithm (VQA) is introduced to test\n    the separability of a general bipartite state. The algorithm utilizes\n    quantum steering between two separated systems such that the separability\n    of the state is quantified.\n\n    Due to the limitations of currently available quantum computers, two\n    optimization semidefinite programs (SDP) benchmarks were introduced to\n    maximize the fidelity of separability subject to some state constraints\n    (Positive Partial Transpose (PPT), symmetric extensions (k-extendibility\n    ) [@Hayden_2013_TwoMessage] ) This function approximites the fidelity of separability by\n    maximizing over PPT states &amp; k-extendible states i.e. an optimization\n    problem over states [@Watrous_2018_TQI].\n\n    The following expression (Equation (H2) from [@Philip_2023_Schrodinger] ) defines the\n    constraints for approxiamting\n\n    \\(\\sqrt{\\widetilde{F}_s^1}(\\rho_{AB}) {:}=\\)\n\n    \\[\n        \\begin{multline}\n        \\max_{\\substack{X_{AB} \\in\\mathcal{L}(\\mathcal{H}_{AB}),\\\\\\sigma_{AB^{k}}\\geq0}}\n        \\left\\{\\begin{array}\n                [c]{c}\n                \\operatorname{Re}[\\operatorname{Tr}[X_{AB}]]:\\\\%\n                \\begin{bmatrix}\n                \\rho_{AB} &amp; X_{AB}\\\\\n                X_{AB}^{\\dagger} &amp; \\sigma_{AB_{1}}%\n                \\end{bmatrix}\n                \\geq0,\\\\\n                \\operatorname{Tr}[\\sigma_{AB^{k}}]=1,\\\\\n                \\sigma_{AB^{k}}=\\mathcal{P}_{B^{k}}(\\sigma_{AB^{k}}),\\\\\n                T_{B_{1\\cdots j}}(\\sigma_{AB_{1\\cdots j}})\\geq 0 \\quad \\forall j\\leq k\n            \\end{array}\\right\\}\n        \\end{multline}\n    \\]\n\n    \\(\\sqrt{\\widetilde{F}_s^1}(\\rho_{AB})\\) is the quantity to be\n    approximated but this function returns\n    \\(\\widetilde{F}_s^1(\\rho_{AB})\\).\n\n    \\(\\operatorname{Re}[\\operatorname{Tr}[X_{AB}]]\\) is the maximization problem subject to PPT &amp; k-extendibile\n    state constraints.\n\n    Here, \\(\\mathcal{L}(\\mathcal{H}_{AB})\\) is the space of linear operators over space \\(\\mathcal{H}_{AB}\\).\n\n    \\(\\sigma_{AB^{k}}\\) is a k-extension of \\(\\rho_{AB}\\).\n\n    \\(\\mathcal{P}_{B^{k}}\\) is the permutation operator among systems\n    \\(B_1, B_2,  \\ldots , B_{k}\\) which has no effect on the k-extended\n    state \\(\\sigma_{AB^{k}}\\).\n\n    The other constraints are due to the PPT condition [@Peres_1996_Separability].\n\n    Examples:\n        Let's consider a density matrix of a state that we know is pure and separable; \\(|00 \\rangle = |0 \\rangle\n        \\otimes |0 \\rangle\\).\n\n        The expected approximation of fidelity of separability is the maximum value possible i.e. very close to 1.\n\n        \\[\n            \\rho_{AB} = |00 \\rangle \\langle 00|\n        \\]\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.state_metrics import fidelity_of_separability\n        from toqito.matrix_ops import tensor\n        from toqito.states import basis\n\n        state = tensor(basis(2, 0), basis(2, 0))\n        rho = state @ state.conj().T\n\n        print(np.around(fidelity_of_separability(rho, [2, 2]), decimals=2))\n        ```\n            is PSD with trace 1).\n\n    Raises:\n        AssertionError: If the provided dimensions are not for a bipartite density matrix.\n        ValueError: If the matrix is not a density matrix (square matrix that\n        ValueError: the input state is entangled.\n        ValueError: the input state is a mixed state.\n\n    Args:\n        input_state_rho: the density matrix for the bipartite state of interest.\n        input_state_rho_dims: the dimensions of System A &amp; B respectively in the input state density matrix. It is\n        assumed that the first quantity in this list is the dimension of System A.\n        k: value for k-extendibility.\n        verbosity_option: Parameter option for `picos`. Default value is `verbosity = 0`. For more info, visit\n            https://picos-api.gitlab.io/picos/api/picos.modeling.options.html#option-verbosity.\n        solver_option: Optimization option for `picos` solver. Default option is `solver_option=\"cvxopt\"`. For more\n        info, visit https://picos-api.gitlab.io/picos/api/picos.modeling.options.html#option-solver.\n\n    Returns:\n        Optimized value of the SDP when maximized over a set of linear operators subject to some constraints.\n\n    \"\"\"\n    # rho is relabelled as rho_{AB} where A &gt;= B.\n    if not is_density(input_state_rho):\n        raise ValueError(\"Provided input state is not a density matrix.\")\n    if not len(input_state_rho_dims) == 2:\n        raise AssertionError(\"For State SDP: require bipartite state dims.\")\n    if not is_pure(input_state_rho):\n        raise ValueError(\"This function only works for pure states.\")\n    if not is_separable(input_state_rho):\n        raise ValueError(\"Provided input state is entangled.\")\n\n    # Infer the dimension of Alice and Bob's system. subsystem-dimensions in rho_AB\n    dim_a, dim_b = input_state_rho_dims\n\n    # Extend the number of dimensions based on the level `k`. new dims for AB with k-extendibility in subsystem B\n    dim_direct_sum_ab_k = [dim_a] + [dim_b] * (k)\n    # new dims for a linear op acting on the space of sigma_ab_k\n    dim_op_sigma_ab_k = dim_a * dim_b**k\n\n    # A list of the symmetrically extended subsystems based on the level `k`.\n    sub_sys_ext = list(range(2, 2 + k - 1))\n\n    # unitary permutation operator in B1,B2,...,Bk\n    permutation_op = symmetric_projection(dim_b, k)\n\n    # defining the problem objective: Re[Tr[X_AB]]\n    problem = picos.Problem(verbosity=verbosity_option)\n    linear_op_ab = picos.ComplexVariable(\"x_ab\", input_state_rho.shape)\n    sigma_ab_k = picos.HermitianVariable(\"s_ab_k\", (dim_op_sigma_ab_k, dim_op_sigma_ab_k))\n\n    problem.set_objective(\"max\", 0.5 * picos.trace(linear_op_ab + linear_op_ab.H))\n\n    problem.add_constraint(\n        picos.block(\n            [\n                [input_state_rho, linear_op_ab],\n                [linear_op_ab.H, picos.partial_trace(sigma_ab_k, sub_sys_ext, dim_direct_sum_ab_k)],\n            ]\n        )\n        &gt;&gt; 0\n    )\n    problem.add_constraint(sigma_ab_k &gt;&gt; 0)\n    problem.add_constraint(picos.trace(sigma_ab_k) == 1)\n\n    # k-extendible constraint:\n    problem.add_constraint(\n        (picos.I(dim_a) @ permutation_op) * sigma_ab_k * (picos.I(dim_a) @ permutation_op) == sigma_ab_k\n    )\n\n    # PPT constraint:\n    sys = []\n    for i in range(1, k):\n        sys = sys + [i]\n        problem.add_constraint(picos.partial_transpose(sigma_ab_k, sys, dim_direct_sum_ab_k) &gt;&gt; 0)\n\n    solution = problem.solve(solver=solver_option)\n    return solution.value**2\n</code></pre>"},{"location":"reference/toqito/state_metrics/helstrom_holevo/","title":"helstrom_holevo","text":""},{"location":"reference/toqito/state_metrics/helstrom_holevo/#toqito.state_metrics.helstrom_holevo","title":"helstrom_holevo","text":"<p>Helstrom-Holevo metric gives the bst success probability to distinguish two mixed states.</p>"},{"location":"reference/toqito/state_metrics/helstrom_holevo/#toqito.state_metrics.helstrom_holevo.helstrom_holevo","title":"helstrom_holevo","text":"<pre><code>helstrom_holevo(rho: ndarray, sigma: ndarray) -&gt; float | floating\n</code></pre> <p>Compute the Helstrom-Holevo distance between density matrices <sup>1</sup>.</p> <p>In general, the best success probability to discriminate two mixed states represented by \\(\\rho\\) and \\(\\sigma\\) is given by <sup>1</sup>.</p> \\[     \\frac{1}{2}+\\frac{1}{2} \\left(\\frac{1}{2} \\left|\\rho - \\sigma \\right|_1\\right). \\] <p>Examples:</p> <p>Consider the following Bell state</p> \\[     u = \\frac{1}{\\sqrt{2}} \\left( |00 \\rangle + |11 \\rangle \\right) \\in \\mathcal{X}. \\] <p>The corresponding density matrix of \\(u\\) may be calculated by:</p> \\[     \\rho = u u^* = \\begin{pmatrix}                      1 &amp; 0 &amp; 0 &amp; 1 \\\\                      0 &amp; 0 &amp; 0 &amp; 0 \\\\                      0 &amp; 0 &amp; 0 &amp; 0 \\\\                      1 &amp; 0 &amp; 0 &amp; 1                    \\end{pmatrix} \\in \\text{D}(\\mathcal{X}). \\] <p>Calculating the Helstrom-Holevo distance of states that are identical yield a value of \\(1/2\\). This can be verified in <code>|toqito\u27e9</code> as follows.</p> <pre><code>import numpy as np\nfrom toqito.states import basis\nfrom toqito.state_metrics import helstrom_holevo\n\ne_0, e_1 = basis(2, 0), basis(2, 1)\ne_00 = np.kron(e_0, e_0)\ne_11 = np.kron(e_1, e_1)\n\nu_vec = 1 / np.sqrt(2) * (e_00 + e_11)\nrho = u_vec @ u_vec.conj().T\nsigma = rho\n\nprint(helstrom_holevo(rho, sigma))\n</code></pre> <p>0.5</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If matrices are not density operators.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>rho</code>               (<code>ndarray</code>)           \u2013            <p>Density operator.</p> </li> <li> <code>sigma</code>               (<code>ndarray</code>)           \u2013            <p>Density operator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float | floating</code>           \u2013            <p>The Helstrom-Holevo distance between <code>rho</code> and <code>sigma</code>.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Holevo\\'s Theorem. link.</p> Source code in <code>toqito/state_metrics/helstrom_holevo.py</code> <pre><code>def helstrom_holevo(rho: np.ndarray, sigma: np.ndarray) -&gt; float | np.floating:\n    r\"\"\"Compute the Helstrom-Holevo distance between density matrices [@WikiHolevo].\n\n    In general, the best success probability to discriminate two mixed states represented by\n    \\(\\rho\\) and \\(\\sigma\\) is given by [@WikiHolevo].\n\n    \\[\n        \\frac{1}{2}+\\frac{1}{2} \\left(\\frac{1}{2} \\left|\\rho - \\sigma \\right|_1\\right).\n    \\]\n\n    Examples:\n        Consider the following Bell state\n\n        \\[\n            u = \\frac{1}{\\sqrt{2}} \\left( |00 \\rangle + |11 \\rangle \\right) \\in \\mathcal{X}.\n        \\]\n\n        The corresponding density matrix of \\(u\\) may be calculated by:\n\n        \\[\n            \\rho = u u^* = \\begin{pmatrix}\n                             1 &amp; 0 &amp; 0 &amp; 1 \\\\\n                             0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                             0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                             1 &amp; 0 &amp; 0 &amp; 1\n                           \\end{pmatrix} \\in \\text{D}(\\mathcal{X}).\n        \\]\n\n        Calculating the Helstrom-Holevo distance of states that are identical yield a value of\n        \\(1/2\\). This can be verified in `|toqito\u27e9` as follows.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.states import basis\n        from toqito.state_metrics import helstrom_holevo\n\n        e_0, e_1 = basis(2, 0), basis(2, 1)\n        e_00 = np.kron(e_0, e_0)\n        e_11 = np.kron(e_1, e_1)\n\n        u_vec = 1 / np.sqrt(2) * (e_00 + e_11)\n        rho = u_vec @ u_vec.conj().T\n        sigma = rho\n\n        print(helstrom_holevo(rho, sigma))\n        ```\n\n    Raises:\n        ValueError: If matrices are not density operators.\n\n    Args:\n        rho: Density operator.\n        sigma: Density operator.\n\n    Returns:\n        The Helstrom-Holevo distance between `rho` and `sigma`.\n\n    \"\"\"\n    if not is_density(rho) or not is_density(sigma):\n        raise ValueError(\"Helstrom-Holevo is only defined for density operators.\")\n    return 1 / 2 + 1 / 2 * (trace_norm(rho - sigma)) / 2\n</code></pre>"},{"location":"reference/toqito/state_metrics/hilbert_schmidt/","title":"hilbert_schmidt","text":""},{"location":"reference/toqito/state_metrics/hilbert_schmidt/#toqito.state_metrics.hilbert_schmidt","title":"hilbert_schmidt","text":"<p>Hilbert-Schmidt metric is a distance metric used to generate an entanglement measure.</p>"},{"location":"reference/toqito/state_metrics/hilbert_schmidt/#toqito.state_metrics.hilbert_schmidt.hilbert_schmidt","title":"hilbert_schmidt","text":"<pre><code>hilbert_schmidt(rho: ndarray, sigma: ndarray) -&gt; float | floating\n</code></pre> <p>Compute the Hilbert-Schmidt distance between two states <sup>1</sup>.</p> <p>The Hilbert-Schmidt distance between density operators \\(\\rho\\) and \\(\\sigma\\) is defined as</p> \\[     D_{\\text{HS}}(\\rho, \\sigma) = \\text{Tr}((\\rho - \\sigma)^2) = \\left\\lVert \\rho - \\sigma     \\right\\rVert_2^2. \\] <p>Examples:</p> <p>One may consider taking the Hilbert-Schmidt distance between two Bell states. In <code>|toqito\u27e9</code>, one may accomplish this as</p> <pre><code>import numpy as np\nfrom toqito.states import bell\nfrom toqito.state_metrics import hilbert_schmidt\n\nrho = bell(0) @ bell(0).conj().T\nsigma = bell(3) @ bell(3).conj().T\n\nprint(np.around(hilbert_schmidt(rho, sigma), decimals=2))\n</code></pre> <p>1.0</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If matrices are not density operators.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>rho</code>               (<code>ndarray</code>)           \u2013            <p>An input matrix.</p> </li> <li> <code>sigma</code>               (<code>ndarray</code>)           \u2013            <p>An input matrix.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float | floating</code>           \u2013            <p>The Hilbert-Schmidt distance between <code>rho</code> and <code>sigma</code>.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Hilbert-Schmidt operator. link.</p> Source code in <code>toqito/state_metrics/hilbert_schmidt.py</code> <pre><code>def hilbert_schmidt(rho: np.ndarray, sigma: np.ndarray) -&gt; float | np.floating:\n    r\"\"\"Compute the Hilbert-Schmidt distance between two states [@WikiHilbSchOp].\n\n    The Hilbert-Schmidt distance between density operators \\(\\rho\\) and \\(\\sigma\\) is defined as\n\n    \\[\n        D_{\\text{HS}}(\\rho, \\sigma) = \\text{Tr}((\\rho - \\sigma)^2) = \\left\\lVert \\rho - \\sigma\n        \\right\\rVert_2^2.\n    \\]\n\n    Examples:\n        One may consider taking the Hilbert-Schmidt distance between two Bell states. In `|toqito\u27e9`,\n        one may accomplish this as\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.states import bell\n        from toqito.state_metrics import hilbert_schmidt\n\n        rho = bell(0) @ bell(0).conj().T\n        sigma = bell(3) @ bell(3).conj().T\n\n        print(np.around(hilbert_schmidt(rho, sigma), decimals=2))\n        ```\n\n    Raises:\n        ValueError: If matrices are not density operators.\n\n    Args:\n        rho: An input matrix.\n        sigma: An input matrix.\n\n    Returns:\n        The Hilbert-Schmidt distance between `rho` and `sigma`.\n\n    \"\"\"\n    if not is_density(rho) or not is_density(sigma):\n        raise ValueError(\"Hilbert-Schmidt is only defined for density operators.\")\n    return np.linalg.norm(rho - sigma, ord=2) ** 2\n</code></pre>"},{"location":"reference/toqito/state_metrics/hilbert_schmidt_inner_product/","title":"hilbert_schmidt_inner_product","text":""},{"location":"reference/toqito/state_metrics/hilbert_schmidt_inner_product/#toqito.state_metrics.hilbert_schmidt_inner_product","title":"hilbert_schmidt_inner_product","text":"<p>Hilbert-Schmidt Inner Product refers to the inner product between two Hilbert-Schmidt operators.</p>"},{"location":"reference/toqito/state_metrics/hilbert_schmidt_inner_product/#toqito.state_metrics.hilbert_schmidt_inner_product.hilbert_schmidt_inner_product","title":"hilbert_schmidt_inner_product","text":"<pre><code>hilbert_schmidt_inner_product(a_mat: ndarray, b_mat: ndarray) -&gt; complex\n</code></pre> <p>Compute the Hilbert-Schmidt inner product between two matrices <sup>1</sup>.</p> <p>The Hilbert-Schmidt inner product between <code>a_mat</code> and <code>b_mat</code> is defined as</p> \\[     HS = (A|B) = Tr[A^\\dagger B] \\] <p>where \\(|B\\rangle = \\text{vec}(B)\\) and \\(\\langle A|\\) is the dual vector to \\(|A \\rangle\\).</p> <p>Note: This function has been adapted from <sup>2</sup>.</p> <p>Examples:</p> <p>One may consider taking the Hilbert-Schmidt distance between two Hadamard matrices.</p> <pre><code>import numpy as np\nfrom toqito.matrices import hadamard\nfrom toqito.state_metrics import hilbert_schmidt_inner_product\n\nh = hadamard(1)\n\nprint(np.around(hilbert_schmidt_inner_product(h, h), decimals=2))\n</code></pre> <p>2.0</p> <p>Parameters:</p> <ul> <li> <code>a_mat</code>               (<code>ndarray</code>)           \u2013            <p>An input matrix provided as a numpy array.</p> </li> <li> <code>b_mat</code>               (<code>ndarray</code>)           \u2013            <p>An input matrix provided as a numpy array.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>complex</code>           \u2013            <p>The Hilbert-Schmidt inner product between <code>a_mat</code> and <code>b_mat</code>.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Hilbert-Schmidt operator. link. <sup>2</sup> Rigetti. Forest Benchmarking. link.</p> Source code in <code>toqito/state_metrics/hilbert_schmidt_inner_product.py</code> <pre><code>def hilbert_schmidt_inner_product(a_mat: np.ndarray, b_mat: np.ndarray) -&gt; complex:\n    r\"\"\"Compute the Hilbert-Schmidt inner product between two matrices [@WikiHilbSchOp].\n\n    The Hilbert-Schmidt inner product between `a_mat` and `b_mat` is defined as\n\n    \\[\n        HS = (A|B) = Tr[A^\\dagger B]\n    \\]\n\n    where \\(|B\\rangle = \\text{vec}(B)\\) and \\(\\langle A|\\) is the dual vector to \\(|A \\rangle\\).\n\n    Note: This function has been adapted from [@Rigetti_2022_Forest].\n\n    Examples:\n        One may consider taking the Hilbert-Schmidt distance between two Hadamard matrices.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrices import hadamard\n        from toqito.state_metrics import hilbert_schmidt_inner_product\n\n        h = hadamard(1)\n\n        print(np.around(hilbert_schmidt_inner_product(h, h), decimals=2))\n        ```\n\n    Args:\n        a_mat: An input matrix provided as a numpy array.\n        b_mat: An input matrix provided as a numpy array.\n\n    Returns:\n        The Hilbert-Schmidt inner product between `a_mat` and `b_mat`.\n\n    \"\"\"\n    return np.trace(a_mat.conj().T @ b_mat)\n</code></pre>"},{"location":"reference/toqito/state_metrics/matsumoto_fidelity/","title":"matsumoto_fidelity","text":""},{"location":"reference/toqito/state_metrics/matsumoto_fidelity/#toqito.state_metrics.matsumoto_fidelity","title":"matsumoto_fidelity","text":"<p>Matsumoto fidelity is the maximum classical fidelity associated with a classical-to-quantum preparation procedure.</p>"},{"location":"reference/toqito/state_metrics/matsumoto_fidelity/#toqito.state_metrics.matsumoto_fidelity.matsumoto_fidelity","title":"matsumoto_fidelity","text":"<pre><code>matsumoto_fidelity(rho: ndarray, sigma: ndarray) -&gt; float | floating\n</code></pre> <p>Compute the Matsumoto fidelity of two density matrices <sup>1</sup>.</p> <p>Calculate the Matsumoto fidelity between the two density matrices <code>rho</code> and <code>sigma</code>, defined by:</p> \\[     \\mathrm{tr}(\\rho\\#\\sigma), \\] <p>where \\(\\#\\) denotes the matrix geometric mean, which for invertible states is</p> \\[     \\rho\\#\\sigma = \\rho^{1/2}\\sqrt{\\rho^{-1/2}\\sigma\\rho^{-1/2}}\\rho^{1/2}. \\] <p>For singular states it is defined by the limit</p> \\[     \\rho\\#\\sigma = \\lim_{\\epsilon\\to0}(\\rho+\\epsilon\\mathbb{I})\\#(+\\epsilon\\mathbb{I}). \\] <p>The return is a value between \\(0\\) and \\(1\\), with \\(0\\) corresponding to matrices <code>rho</code> and <code>sigma</code> with orthogonal support, and \\(1\\) corresponding to the case <code>rho = sigma</code>. The Matsumoto fidelity is a lower bound for the fidelity.</p> <p>Examples:</p> <p>Consider the following Bell state</p> \\[     u = \\frac{1}{\\sqrt{2}} \\left( |00 \\rangle + |11 \\rangle \\right) \\in \\mathcal{X}. \\] <p>The corresponding density matrix of \\(u\\) may be calculated by:</p> \\[     \\rho = u u^* = \\frac{1}{2} \\begin{pmatrix}                      1 &amp; 0 &amp; 0 &amp; 1 \\\\                      0 &amp; 0 &amp; 0 &amp; 0 \\\\                      0 &amp; 0 &amp; 0 &amp; 0 \\\\                      1 &amp; 0 &amp; 0 &amp; 1                    \\end{pmatrix} \\in \\text{D}(\\mathcal{X}). \\] <p>In the event where we calculate the Matsumoto fidelity between states that are identical, we should obtain the value of \\(1\\). This can be observed in <code>|toqito\u27e9</code> as follows.</p> <pre><code>import numpy as np\nfrom toqito.state_metrics import matsumoto_fidelity\n\nrho = 1 / 2 * np.array(\n    [[1, 0, 0, 1],\n     [0, 0, 0, 0],\n     [0, 0, 0, 0],\n     [1, 0, 0, 1]]\n)\nsigma = rho\n\nprint(np.around(matsumoto_fidelity(rho, sigma), decimals=2))\n</code></pre> <p>1.0</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If matrices are not of equal dimension.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>rho</code>               (<code>ndarray</code>)           \u2013            <p>Density operator.</p> </li> <li> <code>sigma</code>               (<code>ndarray</code>)           \u2013            <p>Density operator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float | floating</code>           \u2013            <p>The Matsumoto fidelity between <code>rho</code> and <code>sigma</code>.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Matsumoto, Keiji. Reverse test and quantum analogue of classical fidelity and generalized fidelity. (2010).</p> Source code in <code>toqito/state_metrics/matsumoto_fidelity.py</code> <pre><code>def matsumoto_fidelity(rho: np.ndarray, sigma: np.ndarray) -&gt; float | np.floating:\n    r\"\"\"Compute the Matsumoto fidelity of two density matrices [@Matsumoto_2010_Reverse].\n\n    Calculate the Matsumoto fidelity between the two density matrices `rho` and `sigma`, defined by:\n\n    \\[\n        \\mathrm{tr}(\\rho\\#\\sigma),\n    \\]\n\n    where \\(\\#\\) denotes the matrix geometric mean, which for invertible states is\n\n    \\[\n        \\rho\\#\\sigma = \\rho^{1/2}\\sqrt{\\rho^{-1/2}\\sigma\\rho^{-1/2}}\\rho^{1/2}.\n    \\]\n\n    For singular states it is defined by the limit\n\n    \\[\n        \\rho\\#\\sigma = \\lim_{\\epsilon\\to0}(\\rho+\\epsilon\\mathbb{I})\\#(+\\epsilon\\mathbb{I}).\n    \\]\n\n    The return is a value between \\(0\\) and \\(1\\), with \\(0\\) corresponding to matrices `rho` and\n    `sigma` with orthogonal support, and \\(1\\) corresponding to the case `rho = sigma`. The Matsumoto\n    fidelity is a lower bound for the fidelity.\n\n    Examples:\n        Consider the following Bell state\n\n        \\[\n            u = \\frac{1}{\\sqrt{2}} \\left( |00 \\rangle + |11 \\rangle \\right) \\in \\mathcal{X}.\n        \\]\n\n        The corresponding density matrix of \\(u\\) may be calculated by:\n\n        \\[\n            \\rho = u u^* = \\frac{1}{2} \\begin{pmatrix}\n                             1 &amp; 0 &amp; 0 &amp; 1 \\\\\n                             0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                             0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                             1 &amp; 0 &amp; 0 &amp; 1\n                           \\end{pmatrix} \\in \\text{D}(\\mathcal{X}).\n        \\]\n\n        In the event where we calculate the Matsumoto fidelity between states that are identical, we should obtain\n        the value\n        of \\(1\\). This can be observed in `|toqito\u27e9` as follows.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.state_metrics import matsumoto_fidelity\n\n        rho = 1 / 2 * np.array(\n            [[1, 0, 0, 1],\n             [0, 0, 0, 0],\n             [0, 0, 0, 0],\n             [1, 0, 0, 1]]\n        )\n        sigma = rho\n\n        print(np.around(matsumoto_fidelity(rho, sigma), decimals=2))\n        ```\n\n    Raises:\n        ValueError: If matrices are not of equal dimension.\n\n    Args:\n        rho: Density operator.\n        sigma: Density operator.\n\n    Returns:\n        The Matsumoto fidelity between `rho` and `sigma`.\n\n    \"\"\"\n    if not np.all(rho.shape == sigma.shape):\n        raise ValueError(\"InvalidDim: `rho` and `sigma` must be matrices of the same size.\")\n\n    # If `rho` or `sigma` is a cvxpy variable then compute Matsumoto fidelity via\n    # semidefinite programming, so that this function can be used in the\n    # objective function or constraints of other cvxpy optimization problems.\n    if isinstance(rho, cvxpy.atoms.affine.vstack.Vstack) or isinstance(sigma, cvxpy.atoms.affine.vstack.Vstack):\n        w_var = cvxpy.Variable(rho.shape, hermitian=True)\n        objective = cvxpy.Maximize(cvxpy.real(cvxpy.trace(w_var)))\n        constraints = [cvxpy.bmat([[rho, w_var], [w_var, sigma]]) &gt;&gt; 0]\n        problem = cvxpy.Problem(objective, constraints)\n\n        return problem.solve()\n\n    if not is_density(rho) or not is_density(sigma):\n        raise ValueError(\"Matsumoto fidelity is only defined for density operators.\")\n\n    # If `rho` or `sigma` are *not* cvxpy variables, compute Matsumoto fidelity directly.\n    # For numerical stability, invert the matrix with larger determinant\n    if np.abs(scipy.linalg.det(sigma)) &gt; np.abs(scipy.linalg.det(rho)):\n        rho, sigma = sigma, rho\n\n    # If rho is singular, add epsilon\n    try:\n        sq_rho = scipy.linalg.sqrtm(rho)\n        sqinv_rho = scipy.linalg.inv(sq_rho)\n    except np.linalg.LinAlgError:\n        sq_rho = scipy.linalg.sqrtm(rho + 1e-7)  # if rho is not invertible, add epsilon=1e-7 to it\n        # note if epsilon=1e-8 or smaller, it leads to test failures.\n        sqinv_rho = scipy.linalg.inv(sq_rho)\n\n    sq_mfid = sq_rho @ scipy.linalg.sqrtm(sqinv_rho @ sigma @ sqinv_rho) @ sq_rho\n    return np.real(np.trace(sq_mfid))\n</code></pre>"},{"location":"reference/toqito/state_metrics/measured_relative_entropy/","title":"measured_relative_entropy","text":""},{"location":"reference/toqito/state_metrics/measured_relative_entropy/#toqito.state_metrics.measured_relative_entropy","title":"measured_relative_entropy","text":"<p>Measured relative entropy quantifies how well two states can be distinguished by measuring individual copies.</p>"},{"location":"reference/toqito/state_metrics/measured_relative_entropy/#toqito.state_metrics.measured_relative_entropy.measured_relative_entropy","title":"measured_relative_entropy","text":"<pre><code>measured_relative_entropy(rho: ndarray, sigma: ndarray, eps: float = 1e-05) -&gt; float\n</code></pre> <p>Compute the measured relative entropy of two quantum states. <sup>1</sup>.</p> <p>Given a quantum state \\(\\rho\\) and a positive semi-definite operator \\(\\sigma\\), the measured relative entropy is defined by optimizing the relative entropy over all possible measurements:</p> \\[     D^M(\\rho \\| \\sigma) := \\sup_{\\mathcal{X}, (\\Lambda_x)_{x \\in \\mathcal{X}}}     \\sum_{x \\in \\mathcal{X}} \\operatorname{Tr}[\\Lambda_x \\rho] \\ln \\left(     \\frac{\\operatorname{Tr}[\\Lambda_x \\rho]}{\\operatorname{Tr}[\\Lambda_x \\sigma]} \\right), \\] <p>where the supremum is over every finite alphabet \\(\\mathcal{X}\\) and every positive-operator valued measure (POVM) \\((\\Lambda_x)_{x \\in \\mathcal{X}}\\) (i.e., satisfying \\(\\Lambda_x \\geq 0\\) for all \\(x \\in \\mathcal{X}\\) and \\(\\sum_{x \\in \\mathcal{X}}\\Lambda_x = I\\)).</p> <p>When \\(\\rho\\) and \\(\\sigma\\) are \\(d \\times d\\) matrices, the quantity \\(D^M(\\rho \\| \\sigma)\\) can be efficiently calculated by means of a semi-definite program up to an additive error \\(\\varepsilon\\), by means of \\(O(\\sqrt{\\ln(1/\\varepsilon)})\\) linear matrix inequalities, each of size \\(2d \\times 2d\\). Specifically, there exist \\(m, k \\in \\mathbb{N}\\) such that \\(m+k = O(\\sqrt{\\ln(1/\\varepsilon)})\\) and the following inequality holds:</p> \\[     |D^M(\\rho \\| \\sigma) - D_{m,k}^M(\\rho \\| \\sigma)| \\leq \\varepsilon, \\] <p>where</p> \\[     D_{m,k}^M(\\rho \\| \\sigma) :=     \\mathop{\\sup}\\limits_{\\substack{         \\omega &gt; 0,\\; \\theta \\in \\mathbb{H},\\\\         T_1,\\dots,T_m \\in \\mathbb{H},\\\\         Z_0,\\dots,Z_k \\in \\mathbb{H}}}     \\left\\{     \\begin{array}{c}     \\operatorname{Tr}[\\theta \\rho] - \\operatorname{Tr}[\\omega \\sigma] + 1 : \\\\[6pt]     Z_0 = \\omega, \\qquad \\sum_{j=1}^m w_j T_j = 2^{-k} \\theta, \\\\[6pt]     \\left\\{\\begin{bmatrix}     Z_i &amp; Z_{i+1}\\\\     Z_{i+1} &amp; I     \\end{bmatrix}     \\ge 0 \\right\\}_{i=0}^{k-1}, \\\\[10pt]     \\left\\{\\begin{bmatrix}     Z_k - I - T_j &amp; -\\sqrt{t_j}T_j \\\\     -\\sqrt{t_j}T_j &amp; I - t_jT_j     \\end{bmatrix}     \\ge 0     \\right\\}_{j=1}^{m} \\end{array}     \\right\\} \\] <p>and, for all \\(j \\in \\{1, \\dots, m\\}\\), \\(w_j\\) and \\(t_j\\) are the weights and nodes, respectively, for the \\(m\\)-point Gauss--Legendre quadrature on the interval \\([0, 1]\\).</p> <p>Examples:</p> <p>Consider the following quantum state \\(\\rho = \\frac{1}{2}(I + r \\cdot \\mathbf{\\sigma})\\) and the PSD operator \\(\\sigma = \\frac{1}{2}(I + s \\cdot \\mathbf{\\sigma})\\), where \\(r = (0.9, 0.05, -0.02)\\), \\(s = (-0.8, 0.1, 0.1)\\), and \\(\\mathbf{\\sigma} = (\\sigma_x, \\sigma_y, \\sigma_z)\\) are the Pauli operators.</p> <p>Calculating the measured relative entropy can be done as follows.</p> <pre><code>from toqito.matrices import pauli\nfrom toqito.state_metrics import measured_relative_entropy\nimport numpy as np\n\nr = np.array([0.9, 0.05, -0.02])\ns = np.array([-0.8, 0.1, 0.1])\nrho = 0.5 * (pauli(\"I\") + r[0] * pauli(\"X\") + r[1] * pauli(\"Y\") + r[2] * pauli(\"Z\"))\nsigma = 0.5 * (pauli(\"I\") + s[0] * pauli(\"X\") + s[1] * pauli(\"Y\") + s[2] * pauli(\"Z\"))\nprint(measured_relative_entropy(rho, sigma, 1e-5))\n</code></pre> <p>2.0275068836295302</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>rho</code> if not a density operator or if <code>sigma</code> is not positive semi-definite.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>rho</code>               (<code>ndarray</code>)           \u2013            <p>Density operator.</p> </li> <li> <code>sigma</code>               (<code>ndarray</code>)           \u2013            <p>Positive semi-definite operator.</p> </li> <li> <code>eps</code>               (<code>float</code>, default:                   <code>1e-05</code> )           \u2013            <p>Tolerance level.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The measured relative entropy between <code>rho</code> and <code>sigma</code>.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Huang, Zixin and Wilde, Mark. Semi-definite optimization of the measured relative entropies of quantum states and channels. (2025). link.</p> Source code in <code>toqito/state_metrics/measured_relative_entropy.py</code> <pre><code>def measured_relative_entropy(rho: np.ndarray, sigma: np.ndarray, eps: float = 1e-5) -&gt; float:\n    r\"\"\"Compute the measured relative entropy of two quantum states. [@Huang_2025_Msrd_Rel_Entr].\n\n    Given a quantum state \\(\\rho\\) and a positive semi-definite operator \\(\\sigma\\),\n    the measured relative entropy is defined by optimizing the relative entropy over all\n    possible measurements:\n\n    \\[\n        D^M(\\rho \\| \\sigma) := \\sup_{\\mathcal{X}, (\\Lambda_x)_{x \\in \\mathcal{X}}}\n        \\sum_{x \\in \\mathcal{X}} \\operatorname{Tr}[\\Lambda_x \\rho] \\ln \\left(\n        \\frac{\\operatorname{Tr}[\\Lambda_x \\rho]}{\\operatorname{Tr}[\\Lambda_x \\sigma]} \\right),\n    \\]\n\n    where the supremum is over every finite alphabet \\(\\mathcal{X}\\) and every\n    positive-operator valued measure (POVM) \\((\\Lambda_x)_{x \\in \\mathcal{X}}\\)\n    (i.e., satisfying \\(\\Lambda_x \\geq 0\\) for all \\(x \\in \\mathcal{X}\\) and\n    \\(\\sum_{x \\in \\mathcal{X}}\\Lambda_x = I\\)).\n\n    When \\(\\rho\\) and \\(\\sigma\\) are \\(d \\times d\\) matrices, the quantity\n    \\(D^M(\\rho \\| \\sigma)\\) can be efficiently calculated by means of a semi-definite\n    program up to an additive error \\(\\varepsilon\\), by means of\n    \\(O(\\sqrt{\\ln(1/\\varepsilon)})\\) linear matrix inequalities, each of size\n    \\(2d \\times 2d\\). Specifically, there exist \\(m, k \\in \\mathbb{N}\\) such that\n    \\(m+k = O(\\sqrt{\\ln(1/\\varepsilon)})\\) and the following inequality holds:\n\n    \\[\n        |D^M(\\rho \\| \\sigma) - D_{m,k}^M(\\rho \\| \\sigma)| \\leq \\varepsilon,\n    \\]\n\n    where\n\n    \\[\n        D_{m,k}^M(\\rho \\| \\sigma) :=\n        \\mathop{\\sup}\\limits_{\\substack{\n            \\omega &gt; 0,\\; \\theta \\in \\mathbb{H},\\\\\n            T_1,\\dots,T_m \\in \\mathbb{H},\\\\\n            Z_0,\\dots,Z_k \\in \\mathbb{H}}}\n        \\left\\{\n        \\begin{array}{c}\n        \\operatorname{Tr}[\\theta \\rho] - \\operatorname{Tr}[\\omega \\sigma] + 1 : \\\\[6pt]\n        Z_0 = \\omega, \\qquad \\sum_{j=1}^m w_j T_j = 2^{-k} \\theta, \\\\[6pt]\n        \\left\\{\\begin{bmatrix}\n        Z_i &amp; Z_{i+1}\\\\\n        Z_{i+1} &amp; I\n        \\end{bmatrix}\n        \\ge 0 \\right\\}_{i=0}^{k-1}, \\\\[10pt]\n        \\left\\{\\begin{bmatrix}\n        Z_k - I - T_j &amp; -\\sqrt{t_j}T_j \\\\\n        -\\sqrt{t_j}T_j &amp; I - t_jT_j\n        \\end{bmatrix}\n        \\ge 0\n        \\right\\}_{j=1}^{m} \\end{array}\n        \\right\\}\n    \\]\n\n\n    and, for all \\(j \\in \\{1, \\dots, m\\}\\), \\(w_j\\) and \\(t_j\\)\n    are the weights and nodes, respectively, for the \\(m\\)-point Gauss--Legendre quadrature\n    on the interval \\([0, 1]\\).\n\n    Examples:\n        Consider the following quantum state \\(\\rho = \\frac{1}{2}(I + r \\cdot \\mathbf{\\sigma})\\)\n        and the PSD operator \\(\\sigma = \\frac{1}{2}(I + s \\cdot \\mathbf{\\sigma})\\), where\n        \\(r = (0.9, 0.05, -0.02)\\), \\(s = (-0.8, 0.1, 0.1)\\), and \\(\\mathbf{\\sigma} =\n        (\\sigma_x, \\sigma_y, \\sigma_z)\\) are the Pauli operators.\n\n        Calculating the measured relative entropy can be done as follows.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.matrices import pauli\n        from toqito.state_metrics import measured_relative_entropy\n        import numpy as np\n\n        r = np.array([0.9, 0.05, -0.02])\n        s = np.array([-0.8, 0.1, 0.1])\n        rho = 0.5 * (pauli(\"I\") + r[0] * pauli(\"X\") + r[1] * pauli(\"Y\") + r[2] * pauli(\"Z\"))\n        sigma = 0.5 * (pauli(\"I\") + s[0] * pauli(\"X\") + s[1] * pauli(\"Y\") + s[2] * pauli(\"Z\"))\n        print(measured_relative_entropy(rho, sigma, 1e-5))\n        ```\n\n    Raises:\n        ValueError: If `rho` if not a density operator or if `sigma` is not positive semi-definite.\n\n    Args:\n        rho: Density operator.\n        sigma: Positive semi-definite operator.\n        eps: Tolerance level.\n\n    Returns:\n        The measured relative entropy between `rho` and `sigma`.\n\n    \"\"\"\n    if not is_density(rho):\n        raise ValueError(\"Measured relative entropy is only defined if rho is a density operator.\")\n    if not is_positive_semidefinite(sigma):\n        raise ValueError(\"Measured relative entropy is only defined if sigma is positive semi-definite.\")\n    if np.array_equal(rho, sigma):\n        return 0\n    n = len(rho)\n    m, k = _find_mk(rho, sigma, eps)\n    w, theta = cvx.Variable((n, n), complex=True), cvx.Variable((n, n), hermitian=True)\n    ts = [cvx.Variable((n, n), hermitian=True) for _ in range(m)]\n    zs = [cvx.Variable((n, n), hermitian=True) for _ in range(k + 1)]\n    nodes, weights = _gauss_legendre_on_01(m)\n\n    Id = cvx.Constant(np.eye(n))\n    zblocks = [cvx.bmat(((zs[i], zs[i + 1]), (zs[i + 1], Id))) for i in range(k)]\n    tblocks = [\n        cvx.bmat(\n            ((zs[k] - Id - ts[j], -np.sqrt(nodes[j]) * ts[j]), (-np.sqrt(nodes[j]) * ts[j], Id - nodes[j] * ts[j]))\n        )\n        for j in range(m)\n    ]\n\n    cons = (\n        [zs[0] == w, w &gt;&gt; 0]\n        + [(sum(weights[i] * ts[i] for i in range(m))) == 2 ** (-k) * theta]\n        + [zblocks[i] &gt;&gt; 0 for i in range(k)]\n        + [tblocks[j] &gt;&gt; 0 for j in range(m)]\n    )\n\n    rho = cvx.Constant(rho)\n    sigma = cvx.Constant(sigma)\n    obj = cvx.Maximize(cvx.real(cvx.trace(theta @ rho) - cvx.trace(w @ sigma) + 1))\n    problem = cvx.Problem(obj, constraints=cons)\n    problem.solve(verbose=False)\n    return obj.value\n</code></pre>"},{"location":"reference/toqito/state_metrics/sub_fidelity/","title":"sub_fidelity","text":""},{"location":"reference/toqito/state_metrics/sub_fidelity/#toqito.state_metrics.sub_fidelity","title":"sub_fidelity","text":"<p>Sub-fidelity metric is a lower bound for the fidelity.</p> <p>The sub-fidelity metric is a concave function and sub-multiplicative.</p>"},{"location":"reference/toqito/state_metrics/sub_fidelity/#toqito.state_metrics.sub_fidelity.sub_fidelity","title":"sub_fidelity","text":"<pre><code>sub_fidelity(rho: ndarray, sigma: ndarray) -&gt; float\n</code></pre> <p>Compute the sub fidelity of two density matrices <sup>1</sup>.</p> <p>The sub-fidelity is a measure of similarity between density operators. It is defined as</p> \\[     E(\\rho, \\sigma) = \\text{Tr}(\\rho \\sigma) +     \\sqrt{2 \\left[ \\text{Tr}(\\rho \\sigma)^2 - \\text{Tr}(\\rho \\sigma \\rho \\sigma) \\right]}, \\] <p>where \\(\\sigma\\) and \\(\\rho\\) are density matrices. The sub-fidelity serves as an lower bound for the fidelity.</p> <p>Examples:</p> <p>Consider the following pair of states:</p> \\[     \\rho = \\frac{3}{4}|0\\rangle \\langle 0| +            \\frac{1}{4}|1 \\rangle \\langle 1|             \\quad \\text{and} \\quad     \\sigma = \\frac{1}{8}|0 \\rangle \\langle 0| +              \\frac{7}{8}|1 \\rangle \\langle 1|. \\] <p>Calculating the fidelity between the states \\(\\rho\\) and \\(\\sigma\\) as \\(F(\\rho, \\sigma) \\approx 0.774\\). This can be observed in <code>|toqito\u27e9</code> as</p> <pre><code>from toqito.states import basis\nfrom toqito.state_metrics import fidelity\n\ne_0, e_1 = basis(2, 0), basis(2, 1)\nrho = 3 / 4 * e_0 @ e_0.conj().T + 1 / 4 * e_1 @ e_1.conj().T\nsigma = 1/8 * e_0 @ e_0.conj().T + 7/8 * e_1 @ e_1.conj().T\n\nprint(fidelity(rho, sigma))\n</code></pre> <p>0.77389339119464</p> <p>As the sub-fidelity is a lower bound on the fidelity, that is \\(E(\\rho, \\sigma) \\leq F(\\rho, \\sigma)\\), we can use <code>|toqito\u27e9</code> to observe that \\(E(\\rho, \\sigma) \\approx 0.599\\leq F(\\rho, \\sigma \\approx 0.774\\).</p> <pre><code>from toqito.states import basis\nfrom toqito.state_metrics import sub_fidelity\n\ne_0, e_1 = basis(2, 0), basis(2, 1)\nrho = 3 / 4 * e_0 @ e_0.conj().T + 1 / 4 * e_1 @ e_1.conj().T\nsigma = 1/8 * e_0 @ e_0.conj().T + 7/8 * e_1 @ e_1.conj().T\n\nprint(sub_fidelity(rho, sigma))\n</code></pre> <p>0.5989109809347399</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If matrices are not of equal dimension.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>rho</code>               (<code>ndarray</code>)           \u2013            <p>Density operator.</p> </li> <li> <code>sigma</code>               (<code>ndarray</code>)           \u2013            <p>Density operator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The sub-fidelity between <code>rho</code> and <code>sigma</code>.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Miszczak, J. and Pucha\u0142a, Z. and Horodecki, P. and Uhlmann, A. and \u017byczkowski, K.. Sub-- and super--fidelity as bounds for quantum fidelity. (2008).</p> Source code in <code>toqito/state_metrics/sub_fidelity.py</code> <pre><code>def sub_fidelity(rho: np.ndarray, sigma: np.ndarray) -&gt; float:\n    r\"\"\"Compute the sub fidelity of two density matrices [@Miszczak_2008_Sub].\n\n    The sub-fidelity is a measure of similarity between density operators. It is defined as\n\n    \\[\n        E(\\rho, \\sigma) = \\text{Tr}(\\rho \\sigma) +\n        \\sqrt{2 \\left[ \\text{Tr}(\\rho \\sigma)^2 - \\text{Tr}(\\rho \\sigma \\rho \\sigma) \\right]},\n    \\]\n\n    where \\(\\sigma\\) and \\(\\rho\\) are density matrices. The sub-fidelity serves as an lower bound for the\n    fidelity.\n\n    Examples:\n        Consider the following pair of states:\n\n        \\[\n            \\rho = \\frac{3}{4}|0\\rangle \\langle 0| +\n                   \\frac{1}{4}|1 \\rangle \\langle 1|\n                    \\quad \\text{and} \\quad\n            \\sigma = \\frac{1}{8}|0 \\rangle \\langle 0| +\n                     \\frac{7}{8}|1 \\rangle \\langle 1|.\n        \\]\n\n        Calculating the fidelity between the states \\(\\rho\\) and \\(\\sigma\\) as \\(F(\\rho, \\sigma) \\approx\n        0.774\\). This can be observed in `|toqito\u27e9` as\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import basis\n        from toqito.state_metrics import fidelity\n\n        e_0, e_1 = basis(2, 0), basis(2, 1)\n        rho = 3 / 4 * e_0 @ e_0.conj().T + 1 / 4 * e_1 @ e_1.conj().T\n        sigma = 1/8 * e_0 @ e_0.conj().T + 7/8 * e_1 @ e_1.conj().T\n\n        print(fidelity(rho, sigma))\n        ```\n\n        As the sub-fidelity is a lower bound on the fidelity, that is \\(E(\\rho, \\sigma) \\leq F(\\rho, \\sigma)\\), we can\n        use `|toqito\u27e9` to observe that \\(E(\\rho, \\sigma) \\approx 0.599\\leq F(\\rho, \\sigma \\approx 0.774\\).\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import basis\n        from toqito.state_metrics import sub_fidelity\n\n        e_0, e_1 = basis(2, 0), basis(2, 1)\n        rho = 3 / 4 * e_0 @ e_0.conj().T + 1 / 4 * e_1 @ e_1.conj().T\n        sigma = 1/8 * e_0 @ e_0.conj().T + 7/8 * e_1 @ e_1.conj().T\n\n        print(sub_fidelity(rho, sigma))\n        ```\n\n    Raises:\n        ValueError: If matrices are not of equal dimension.\n\n    Args:\n        rho: Density operator.\n        sigma: Density operator.\n\n    Returns:\n        The sub-fidelity between `rho` and `sigma`.\n\n    \"\"\"\n    # Perform some error checking.\n    if not np.all(rho.shape == sigma.shape):\n        raise ValueError(\"InvalidDim: `rho` and `sigma` must be matrices of the same size.\")\n    if not is_density(rho) or not is_density(sigma):\n        raise ValueError(\"Sub-fidelity is only defined for density operators.\")\n\n    return np.real(\n        np.trace(rho @ sigma) + np.sqrt(2 * (np.trace(rho @ sigma) ** 2 - np.trace(rho @ sigma @ rho @ sigma)))\n    )\n</code></pre>"},{"location":"reference/toqito/state_metrics/trace_distance/","title":"trace_distance","text":""},{"location":"reference/toqito/state_metrics/trace_distance/#toqito.state_metrics.trace_distance","title":"trace_distance","text":"<p>Trace distance metric gives a measure of distinguishability between two quantum states.</p> <p>The trace distance is calculated via density matrices.</p>"},{"location":"reference/toqito/state_metrics/trace_distance/#toqito.state_metrics.trace_distance.trace_distance","title":"trace_distance","text":"<pre><code>trace_distance(rho: ndarray, sigma: ndarray) -&gt; float | floating\n</code></pre> <p>Compute the trace distance between density operators <code>rho</code> and <code>sigma</code>.</p> <p>The trace distance between \\(\\rho\\) and \\(\\sigma\\) is defined as</p> \\[     \\delta(\\rho, \\sigma) = \\frac{1}{2} \\left( \\text{Tr}(\\left| \\rho - \\sigma      \\right| \\right). \\] <p>More information on the trace distance can be found in <sup>1</sup>.</p> <p>Examples:</p> <p>Consider the following Bell state</p> \\[     u = \\frac{1}{\\sqrt{2}} \\left( |00 \\rangle + |11 \\rangle \\right) \\in \\mathcal{X}. \\] <p>The corresponding density matrix of \\(u\\) may be calculated by:</p> \\[     \\rho = u u^* = \\begin{pmatrix}                      1 &amp; 0 &amp; 0 &amp; 1 \\\\                      0 &amp; 0 &amp; 0 &amp; 0 \\\\                      0 &amp; 0 &amp; 0 &amp; 0 \\\\                      1 &amp; 0 &amp; 0 &amp; 1                    \\end{pmatrix} \\in \\text{D}(\\mathcal{X}). \\] <p>The trace distance between \\(\\rho\\) and another state \\(\\sigma\\) is equal to \\(0\\) if any only if \\(\\rho = \\sigma\\). We can check this using the <code>|toqito\u27e9</code> package.</p> <pre><code>from toqito.states import bell\nfrom toqito.state_metrics import trace_distance\n\nrho = bell(0) @ bell(0).conj().T\nsigma = rho\n\nprint(trace_distance(rho, sigma))\n</code></pre> <p>0.0</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If matrices are not of density operators.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>rho</code>               (<code>ndarray</code>)           \u2013            <p>An input matrix.</p> </li> <li> <code>sigma</code>               (<code>ndarray</code>)           \u2013            <p>An input matrix.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float | floating</code>           \u2013            <p>The trace distance between <code>rho</code> and <code>sigma</code>.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Quantiki. Trace distance. link.</p> Source code in <code>toqito/state_metrics/trace_distance.py</code> <pre><code>def trace_distance(rho: np.ndarray, sigma: np.ndarray) -&gt; float | np.floating:\n    r\"\"\"Compute the trace distance between density operators `rho` and `sigma`.\n\n    The trace distance between \\(\\rho\\) and \\(\\sigma\\) is defined as\n\n    \\[\n        \\delta(\\rho, \\sigma) = \\frac{1}{2} \\left( \\text{Tr}(\\left| \\rho - \\sigma\n         \\right| \\right).\n    \\]\n\n    More information on the trace distance can be found in [@Quantiki_TrDist].\n\n    Examples:\n        Consider the following Bell state\n\n        \\[\n            u = \\frac{1}{\\sqrt{2}} \\left( |00 \\rangle + |11 \\rangle \\right) \\in \\mathcal{X}.\n        \\]\n\n        The corresponding density matrix of \\(u\\) may be calculated by:\n\n        \\[\n            \\rho = u u^* = \\begin{pmatrix}\n                             1 &amp; 0 &amp; 0 &amp; 1 \\\\\n                             0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                             0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                             1 &amp; 0 &amp; 0 &amp; 1\n                           \\end{pmatrix} \\in \\text{D}(\\mathcal{X}).\n        \\]\n\n        The trace distance between \\(\\rho\\) and another state \\(\\sigma\\) is equal to \\(0\\) if any only if\n        \\(\\rho = \\sigma\\). We can check this using the `|toqito\u27e9` package.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import bell\n        from toqito.state_metrics import trace_distance\n\n        rho = bell(0) @ bell(0).conj().T\n        sigma = rho\n\n        print(trace_distance(rho, sigma))\n        ```\n\n    Raises:\n        ValueError: If matrices are not of density operators.\n\n    Args:\n        rho: An input matrix.\n        sigma: An input matrix.\n\n    Returns:\n        The trace distance between `rho` and `sigma`.\n\n    \"\"\"\n    if not is_density(rho) or not is_density(sigma):\n        raise ValueError(\"Trace distance only defined for density matrices.\")\n    return trace_norm(np.abs(rho - sigma)) / 2\n</code></pre>"},{"location":"reference/toqito/state_ops/","title":"state_ops","text":""},{"location":"reference/toqito/state_ops/#toqito.state_ops","title":"state_ops","text":"<p>State operations is a set of modules that implements various operations on quantum states.</p>"},{"location":"reference/toqito/state_ops/normalize/","title":"normalize","text":""},{"location":"reference/toqito/state_ops/normalize/#toqito.state_ops.normalize","title":"normalize","text":"<p>Normalize quantum state vectors.</p>"},{"location":"reference/toqito/state_ops/normalize/#toqito.state_ops.normalize.normalize","title":"normalize","text":"<pre><code>normalize(vector: Sequence[complex] | ndarray, *, tol: float = 1e-08) -&gt; ndarray\n</code></pre> <p>Return a normalized copy of the input state vector.</p> <p>The input may be a one-dimensional array or a column/row vector. A zero vector raises <code>ValueError</code>.</p> <p>Examples:</p> <pre><code>import numpy as np\nfrom toqito.state_ops import normalize\n\nv = np.array([1, 1], dtype=np.complex128)\nprint(normalize(v))\n</code></pre> <p>[0.70710678+0.j 0.70710678+0.j]</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the input is not vector-shaped or has vanishing norm.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>vector</code>               (<code>Sequence[complex] | ndarray</code>)           \u2013            <p>State vector expressed as a 1D array or column/row vector.</p> </li> <li> <code>tol</code>               (<code>float</code>, default:                   <code>1e-08</code> )           \u2013            <p>Numerical tolerance used to detect zero-norm inputs.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Normalized vector as a 1D NumPy array.</p> </li> </ul> Source code in <code>toqito/state_ops/normalize.py</code> <pre><code>def normalize(vector: Sequence[complex] | np.ndarray, *, tol: float = 1e-8) -&gt; np.ndarray:\n    r\"\"\"Return a normalized copy of the input state vector.\n\n    The input may be a one-dimensional array or a column/row vector. A zero vector raises `ValueError`.\n\n    Examples:\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.state_ops import normalize\n\n        v = np.array([1, 1], dtype=np.complex128)\n        print(normalize(v))\n        ```\n\n\n    Raises:\n        ValueError: If the input is not vector-shaped or has vanishing norm.\n\n    Args:\n        vector: State vector expressed as a 1D array or column/row vector.\n        tol: Numerical tolerance used to detect zero-norm inputs.\n\n    Returns:\n        Normalized vector as a 1D NumPy array.\n\n    \"\"\"\n    array = np.asarray(vector, dtype=np.complex128)\n\n    if array.ndim == 1:\n        flattened = array\n    elif array.ndim == 2 and 1 in array.shape:\n        flattened = array.reshape(-1)\n    else:\n        raise ValueError(\"normalize expects a vector or column/row matrix input.\")\n\n    norm = np.linalg.norm(flattened)\n    if np.isclose(norm, 0.0, atol=tol):\n        raise ValueError(\"Cannot normalize a zero vector.\")\n\n    return flattened / norm\n</code></pre>"},{"location":"reference/toqito/state_ops/schmidt_decomposition/","title":"schmidt_decomposition","text":""},{"location":"reference/toqito/state_ops/schmidt_decomposition/#toqito.state_ops.schmidt_decomposition","title":"schmidt_decomposition","text":"<p>Schmidt decomposition operation computes the schmidt decomposition of a quantum state or an operator.</p>"},{"location":"reference/toqito/state_ops/schmidt_decomposition/#toqito.state_ops.schmidt_decomposition.schmidt_decomposition","title":"schmidt_decomposition","text":"<pre><code>schmidt_decomposition(rho: ndarray, dim: int | list[int] | ndarray | None = None, k_param: int = 0) -&gt; tuple[ndarray, ndarray, ndarray]\n</code></pre> <p>Compute the Schmidt decomposition of a bipartite vector <sup>1</sup>.</p> <p>Examples:</p> <p>Consider the \\(3\\)-dimensional maximally entangled state:</p> \\[     u = \\frac{1}{\\sqrt{3}} \\left( |000 \\rangle + |111 \\rangle + |222 \\rangle \\right). \\] <p>We can generate this state using the <code>|toqito\u27e9</code> module as follows.</p> <pre><code>from toqito.states import max_entangled\nprint(max_entangled(3))\n</code></pre> <p>[[0.57735027]  [0.        ]  [0.        ]  [0.        ]  [0.57735027]  [0.        ]  [0.        ]  [0.        ]  [0.57735027]]</p> <p>array([[0.57735027],     [0.        ],     [0.        ],     [0.        ],     [0.57735027],     [0.        ],     [0.        ],     [0.        ],     [0.57735027]])</p> <p>Computing the Schmidt decomposition of \\(u\\), we can obtain the corresponding singular values of \\(u\\) as</p> \\[     \\frac{1}{\\sqrt{3}} \\left[1, 1, 1 \\right]^{\\text{T}}. \\] <pre><code>from toqito.states import max_entangled\nfrom toqito.state_ops import schmidt_decomposition\n\nsingular_vals, u_mat, vt_mat = schmidt_decomposition(max_entangled(3))\n\nmatrices = {\n    \"Singular values\": singular_vals,\n    \"U matrix\": u_mat,\n    \"V^T matrix\": vt_mat,\n}\n\nfor name, mat in matrices.items():\n    print(f\"{name}:\\n{mat}\\n\")\n</code></pre> <p>Singular values: [[0.57735027]  [0.57735027]  [0.57735027]]</p> <p>U matrix: [[1. 0. 0.]  [0. 1. 0.]  [0. 0. 1.]]</p> <p>V^T matrix: [[1. 0. 0.]  [0. 1. 0.]  [0. 0. 1.]]</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If matrices are not of equal dimension.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>rho</code>               (<code>ndarray</code>)           \u2013            <p>A bipartite quantum state to compute the Schmidt decomposition of.</p> </li> <li> <code>dim</code>               (<code>int | list[int] | ndarray | None</code>, default:                   <code>None</code> )           \u2013            <p>An array consisting of the dimensions of the subsystems (default gives subsystems     equal dimensions).</p> </li> <li> <code>k_param</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>How many terms of the Schmidt decomposition should be computed (default is 0).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[ndarray, ndarray, ndarray]</code>           \u2013            <p>The Schmidt decomposition of the <code>rho</code> input.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Schmidt decomposition. link.</p> Source code in <code>toqito/state_ops/schmidt_decomposition.py</code> <pre><code>def schmidt_decomposition(\n    rho: np.ndarray, dim: int | list[int] | np.ndarray | None = None, k_param: int = 0\n) -&gt; tuple[np.ndarray, np.ndarray, np.ndarray]:\n    r\"\"\"Compute the Schmidt decomposition of a bipartite vector [@WikiScmidtDecomp].\n\n    Examples:\n        Consider the \\(3\\)-dimensional maximally entangled state:\n\n        \\[\n            u = \\frac{1}{\\sqrt{3}} \\left( |000 \\rangle + |111 \\rangle + |222 \\rangle \\right).\n        \\]\n\n        We can generate this state using the `|toqito\u27e9` module as follows.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import max_entangled\n        print(max_entangled(3))\n        ```\n\n        array([[0.57735027],\n            [0.        ],\n            [0.        ],\n            [0.        ],\n            [0.57735027],\n            [0.        ],\n            [0.        ],\n            [0.        ],\n            [0.57735027]])\n\n        Computing the Schmidt decomposition of \\(u\\), we can obtain the corresponding singular values of \\(u\\) as\n\n        \\[\n            \\frac{1}{\\sqrt{3}} \\left[1, 1, 1 \\right]^{\\text{T}}.\n        \\]\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import max_entangled\n        from toqito.state_ops import schmidt_decomposition\n\n        singular_vals, u_mat, vt_mat = schmidt_decomposition(max_entangled(3))\n\n        matrices = {\n            \"Singular values\": singular_vals,\n            \"U matrix\": u_mat,\n            \"V^T matrix\": vt_mat,\n        }\n\n        for name, mat in matrices.items():\n            print(f\"{name}:\\n{mat}\\n\")\n        ```\n\n    Raises:\n        ValueError: If matrices are not of equal dimension.\n\n    Args:\n        rho: A bipartite quantum state to compute the Schmidt decomposition of.\n        dim: An array consisting of the dimensions of the subsystems (default gives subsystems\n                equal dimensions).\n        k_param: How many terms of the Schmidt decomposition should be computed (default is 0).\n\n    Returns:\n        The Schmidt decomposition of the `rho` input.\n\n    \"\"\"\n    # If the input is provided as a matrix, compute the operator Schmidt decomposition.\n    if len(rho.shape) == 2:\n        if rho.shape[0] != 1 and rho.shape[1] != 1:\n            return _operator_schmidt_decomposition(rho, dim, k_param)\n\n    if dim is None:\n        dim = np.round(np.sqrt(len(rho)))\n    if isinstance(dim, list):\n        dim = np.array(dim)\n\n    # Allow the user to enter a single number for `dim`.\n    if isinstance(dim, float):\n        dim = np.array([dim, len(rho) / dim])\n        dim[1] = np.round(dim[1])\n\n    # Otherwise, use lots of Schmidt coefficients.\n    u_mat, singular_vals, vt_mat = np.linalg.svd(rho.reshape(dim[::-1].astype(int), order=\"F\"))\n\n    # Otherwise, use lots of Schmidt coefficients.\n    # After taking the transpose, the columns of `vt_mat` are actually the\n    # (conjugate) singular vectors.  We do not take the conjugate because the\n    # tensor product implementation does not take the conjugate either.  This is\n    # not consistent with Wikipedia, which also takes the conjugate for complex\n    # vectors.  Taking the conjugate would return right singular values that\n    # need to be conjugated to reconstruct `rho`, which would be obviously\n    # strange behavior.\n    vt_mat = vt_mat.T\n\n    if k_param &gt; 0:\n        u_mat = u_mat[:, :k_param]\n        singular_vals = singular_vals[:k_param]\n        vt_mat = vt_mat[:, :k_param]\n\n    singular_vals = singular_vals.reshape(-1, 1)\n    if k_param == 0:\n        # Schmidt rank.\n        r_param = np.sum(singular_vals &gt; np.max(dim) * np.spacing(singular_vals[0]))\n        # Schmidt coefficients.\n        singular_vals = singular_vals[:r_param]\n        u_mat = u_mat[:, :r_param]\n        vt_mat = vt_mat[:, :r_param]\n\n    return singular_vals, vt_mat, u_mat\n</code></pre>"},{"location":"reference/toqito/state_opt/","title":"state_opt","text":""},{"location":"reference/toqito/state_opt/#toqito.state_opt","title":"state_opt","text":"<p>Optimizations over quantum states refers to a set of modules that implements some optimization over quantum states.</p> <p>These optimizations over the quantum states return optimal results. They are listed below.</p>"},{"location":"reference/toqito/state_opt/bell_inequality_max/","title":"bell_inequality_max","text":""},{"location":"reference/toqito/state_opt/bell_inequality_max/#toqito.state_opt.bell_inequality_max","title":"bell_inequality_max","text":"<p>Computes max values for Bell inequalities (General and Qubit-specific).</p>"},{"location":"reference/toqito/state_opt/bell_inequality_max/#toqito.state_opt.bell_inequality_max.bell_inequality_max","title":"bell_inequality_max","text":"<pre><code>bell_inequality_max(coefficients: ndarray, desc: list[int], notation: str, mtype: str = 'classical', k: int | str = 1, tol: float = 1e-08) -&gt; float\n</code></pre> <p>Compute the maximum value of a Bell inequality.</p> <p>Calculates the maximum value achievable for a given Bell inequality under classical, quantum, or no-signalling assumptions.</p> <p>The maximum classical and no-signalling values are computed exactly. The maximum quantum value is upper bounded using the NPA (Navascu\u00e9s-Pironio-Ac\u00edn) hierarchy <code>Navascues_2008_AConvergent</code><sup>1</sup>.</p> <p>Examples:</p> <p>The CHSH inequality in Full Correlator (FC) notation. The classical maximum is 2, the quantum maximum (Tsirelson's bound) is \\(2\\sqrt{2}\\), and the no-signalling maximum is 4.</p> \\[     \\langle A_1 B_1 \\rangle + \\langle A_1 B_2 \\rangle + \\langle A_2 B_1 \\rangle - \\langle A_2 B_2 \\rangle \\le V \\] <p>Represented by the coefficient matrix:</p> \\[     M_{FC} = \\begin{pmatrix} 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 1 \\\\ 0 &amp; 1 &amp; -1 \\end{pmatrix} \\] <pre><code>import numpy as np\nfrom toqito.state_opt.bell_inequality_max import bell_inequality_max\nM_chsh_fc = np.array([[0, 0, 0], [0, 1, 1], [0, 1, -1]])\ndesc_chsh = [2, 2, 2, 2]\nbell_inequality_max(M_chsh_fc, desc_chsh, 'fc', 'classical')\nbell_inequality_max(M_chsh_fc, desc_chsh, 'fc', 'quantum', tol=1e-7)\nprint(bell_inequality_max(M_chsh_fc, desc_chsh, 'fc', 'nosignal', tol=1e-9))\n</code></pre> <p>4.000000016013076</p> <p>The CHSH inequality in Collins-Gisin (CG) notation. The classical maximum is 0, the quantum maximum is \\(1/\\sqrt{2} - 1/2\\), and the no-signalling maximum is 1/2.</p> \\[     p(00|11)+p(00|12)+p(00|21)-p(00|22)-p_A(0|1)-p_B(0|1) \\le V \\] <p>Represented by the coefficient matrix:</p> \\[     M_{CG} = \\begin{pmatrix} 0 &amp; -1 &amp; 0 \\\\ -1 &amp; 1 &amp; 1 \\\\ 0 &amp; 1 &amp; -1 \\end{pmatrix} \\] <pre><code>import numpy as np\nfrom toqito.state_opt.bell_inequality_max import bell_inequality_max\nM_chsh_cg = np.array([[0, -1, 0], [-1, 1, 1], [0, 1, -1]])\ndesc_chsh = [2, 2, 2, 2]\nbell_inequality_max(M_chsh_cg, desc_chsh, 'cg', 'classical')\nbell_inequality_max(M_chsh_cg, desc_chsh, 'cg', 'quantum', tol=1e-7)\nprint(bell_inequality_max(M_chsh_cg, desc_chsh, 'cg', 'nosignal', tol=1e-9))\n</code></pre> <p>0.5000000040079012</p> <p>The I3322 inequality in Collins-Gisin (CG) notation. Classical max = 1, No-signalling max = 2. Quantum value is between 1 and 2.</p> <pre><code>import numpy as np\nfrom toqito.state_opt.bell_inequality_max import bell_inequality_max\nM_i3322_cg = np.array([[0, 1, 0, 0], [1, -1, -1, -1], [0, -1, -1, 1], [0, -1, 1, 0]])\ndesc_i3322 = [2, 2, 3, 3]\nbell_inequality_max(M_i3322_cg, desc_i3322, 'cg', 'classical')\nbell_inequality_max(M_i3322_cg, desc_i3322, 'cg', 'quantum', k=1, tol=1e-7)\nbell_inequality_max(M_i3322_cg, desc_i3322, 'cg', 'quantum', k='1+ab', tol=1e-7)\nprint(bell_inequality_max(M_i3322_cg, desc_i3322, 'cg', 'nosignal', tol=1e-9))\n</code></pre> <p>2.000000007999568</p> <p>Parameters:</p> <ul> <li> <code>coefficients</code>               (<code>ndarray</code>)           \u2013            <p>A matrix or tensor specifying the Bell inequality coefficients in either                  full probability (FP), full correlator (FC), or Collins-Gisin (CG) notation.</p> </li> <li> <code>desc</code>               (<code>list[int]</code>)           \u2013            <p>A list [\\(oa\\), \\(ob\\), \\(ma\\), \\(mb\\)]          describing the number of outputs for Alice (\\(oa\\)) and Bob (\\(ob\\)),          and the number of inputs for Alice (\\(ma\\)) and Bob (\\(mb\\)).</p> </li> <li> <code>notation</code>               (<code>str</code>)           \u2013            <p>A string ('fp', 'fc', or 'cg') indicating the notation of the <code>coefficients</code>.</p> </li> <li> <code>mtype</code>               (<code>str</code>, default:                   <code>'classical'</code> )           \u2013            <p>The type of theory to maximize over ('classical', 'quantum', or 'nosignal').           Defaults to 'classical'. Note: 'quantum' computes an upper bound via NPA hierarchy.</p> </li> <li> <code>k</code>               (<code>int | str</code>, default:                   <code>1</code> )           \u2013            <p>The level of the NPA hierarchy to use if <code>mtype='quantum'</code>. Can be an integer (e.g., 1, 2)       or a string specifying intermediate levels (e.g., '1+ab', '1+aab'). Defaults to 1.       Higher levels yield tighter bounds but require more computation. Ignored if <code>mtype</code> is       not 'quantum'.</p> </li> <li> <code>tol</code>               (<code>float</code>, default:                   <code>1e-08</code> )           \u2013            <p>Tolerance for numerical comparisons and solver precision. Defaults to <code>1e-8</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The maximum value (or quantum upper bound) of the Bell inequality.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the input <code>notation</code> is invalid.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If the input <code>mtype</code> is invalid.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If notation conversion fails (e.g., 'fc' for non-binary outputs).</p> </li> <li> <code>ValueError</code>             \u2013            <p>If the NPA level <code>k</code> is invalid.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If generating NPA constraints fails.</p> </li> <li> <code>SolverError</code>             \u2013            <p>If the cp solver fails.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Navascu\u00e9s, Miguel and Pironio, Stefano and Ac\u00edn, Antonio. A convergent hierarchy of semidefinite programs characterizing the set of quantum correlations. New Journal of Physics. vol. 10(7). (2008). doi:10.1088/1367-2630/10/7/073013.</p> Source code in <code>toqito/state_opt/bell_inequality_max.py</code> <pre><code>def bell_inequality_max(\n    coefficients: np.ndarray,\n    desc: list[int],\n    notation: str,\n    mtype: str = \"classical\",\n    k: int | str = 1,\n    tol: float = 1e-8,\n) -&gt; float:\n    r\"\"\"Compute the maximum value of a Bell inequality.\n\n    Calculates the maximum value achievable for a given Bell inequality under classical, quantum,\n    or no-signalling assumptions.\n\n    The maximum classical and no-signalling values are computed exactly. The maximum quantum value\n    is upper bounded using the NPA (Navascu\u00e9s-Pironio-Ac\u00edn) hierarchy\n    `Navascues_2008_AConvergent`[@Navascues_2008_AConvergent].\n\n    Examples:\n        The CHSH inequality in Full Correlator (FC) notation.\n        The classical maximum is 2, the quantum maximum (Tsirelson's bound) is \\(2\\sqrt{2}\\),\n        and the no-signalling maximum is 4.\n\n        \\[\n            \\langle A_1 B_1 \\rangle + \\langle A_1 B_2 \\rangle + \\langle A_2 B_1 \\rangle - \\langle A_2 B_2 \\rangle \\le V\n        \\]\n\n        Represented by the coefficient matrix:\n\n        \\[\n            M_{FC} = \\begin{pmatrix} 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 1 \\\\ 0 &amp; 1 &amp; -1 \\end{pmatrix}\n        \\]\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.state_opt.bell_inequality_max import bell_inequality_max\n        M_chsh_fc = np.array([[0, 0, 0], [0, 1, 1], [0, 1, -1]])\n        desc_chsh = [2, 2, 2, 2]\n        bell_inequality_max(M_chsh_fc, desc_chsh, 'fc', 'classical')\n        bell_inequality_max(M_chsh_fc, desc_chsh, 'fc', 'quantum', tol=1e-7)\n        print(bell_inequality_max(M_chsh_fc, desc_chsh, 'fc', 'nosignal', tol=1e-9))\n        ```\n\n\n        The CHSH inequality in Collins-Gisin (CG) notation.\n        The classical maximum is 0, the quantum maximum is \\(1/\\sqrt{2} - 1/2\\),\n        and the no-signalling maximum is 1/2.\n\n        \\[\n            p(00|11)+p(00|12)+p(00|21)-p(00|22)-p_A(0|1)-p_B(0|1) \\le V\n        \\]\n\n        Represented by the coefficient matrix:\n\n        \\[\n            M_{CG} = \\begin{pmatrix} 0 &amp; -1 &amp; 0 \\\\ -1 &amp; 1 &amp; 1 \\\\ 0 &amp; 1 &amp; -1 \\end{pmatrix}\n        \\]\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.state_opt.bell_inequality_max import bell_inequality_max\n        M_chsh_cg = np.array([[0, -1, 0], [-1, 1, 1], [0, 1, -1]])\n        desc_chsh = [2, 2, 2, 2]\n        bell_inequality_max(M_chsh_cg, desc_chsh, 'cg', 'classical')\n        bell_inequality_max(M_chsh_cg, desc_chsh, 'cg', 'quantum', tol=1e-7)\n        print(bell_inequality_max(M_chsh_cg, desc_chsh, 'cg', 'nosignal', tol=1e-9))\n        ```\n\n        The I3322 inequality in Collins-Gisin (CG) notation.\n        Classical max = 1, No-signalling max = 2. Quantum value is between 1 and 2.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.state_opt.bell_inequality_max import bell_inequality_max\n        M_i3322_cg = np.array([[0, 1, 0, 0], [1, -1, -1, -1], [0, -1, -1, 1], [0, -1, 1, 0]])\n        desc_i3322 = [2, 2, 3, 3]\n        bell_inequality_max(M_i3322_cg, desc_i3322, 'cg', 'classical')\n        bell_inequality_max(M_i3322_cg, desc_i3322, 'cg', 'quantum', k=1, tol=1e-7)\n        bell_inequality_max(M_i3322_cg, desc_i3322, 'cg', 'quantum', k='1+ab', tol=1e-7)\n        print(bell_inequality_max(M_i3322_cg, desc_i3322, 'cg', 'nosignal', tol=1e-9))\n        ```\n\n    Args:\n        coefficients: A matrix or tensor specifying the Bell inequality coefficients in either\n                             full probability (FP), full correlator (FC), or Collins-Gisin (CG) notation.\n        desc: A list [\\(oa\\), \\(ob\\), \\(ma\\), \\(mb\\)]\n                     describing the number of outputs for Alice (\\(oa\\)) and Bob (\\(ob\\)),\n                     and the number of inputs for Alice (\\(ma\\)) and Bob (\\(mb\\)).\n        notation: A string ('fp', 'fc', or 'cg') indicating the notation of the ``coefficients``.\n        mtype: The type of theory to maximize over ('classical', 'quantum', or 'nosignal').\n                      Defaults to 'classical'. Note: 'quantum' computes an upper bound via NPA hierarchy.\n        k: The level of the NPA hierarchy to use if ``mtype='quantum'``. Can be an integer (e.g., 1, 2)\n                  or a string specifying intermediate levels (e.g., '1+ab', '1+aab'). Defaults to 1.\n                  Higher levels yield tighter bounds but require more computation. Ignored if ``mtype`` is\n                  not 'quantum'.\n        tol: Tolerance for numerical comparisons and solver precision. Defaults to ``1e-8``.\n\n    Returns:\n        The maximum value (or quantum upper bound) of the Bell inequality.\n\n    Raises:\n        ValueError: If the input ``notation`` is invalid.\n        ValueError: If the input ``mtype`` is invalid.\n        ValueError: If notation conversion fails (e.g., 'fc' for non-binary outputs).\n        ValueError: If the NPA level ``k`` is invalid.\n        ValueError: If generating NPA constraints fails.\n        cp.error.SolverError: If the cp solver fails.\n\n    \"\"\"\n    oa, ob, ma, mb = desc\n    mtype_low = mtype.lower()\n    notation_low = notation.lower()\n\n    if notation_low not in [\"fp\", \"fc\", \"cg\"]:\n        raise ValueError(f\"Invalid notation: {notation}. Must be 'fp', 'fc', or 'cg'.\")\n\n    bmax = None\n    problem = None\n\n    if mtype_low == \"nosignal\":\n        if notation_low == \"fc\" and (oa != 2 or ob != 2):\n            raise ValueError(\n                \"Notation conversion failed: 'fc' notation is only supported for binary outputs (oa=2, ob=2).\"\n            )\n        try:\n            if notation_low == \"cg\":\n                M = coefficients\n            elif notation_low == \"fp\":\n                M = fp_to_cg(coefficients, behavior=False)\n            else:\n                M = fc_to_cg(coefficients, behavior=False)\n        except ValueError as e:\n            raise ValueError(f\"Notation conversion failed: {e}\") from e\n\n        cg_dim = ((oa - 1) * ma + 1, (ob - 1) * mb + 1)\n        if M.shape != cg_dim:\n            raise ValueError(\n                f\"Coefficient shape {M.shape} incompatible with desc={desc} and CG notation (expected {cg_dim}).\"\n            )\n\n        p_cg = cp.Variable(cg_dim, name=\"p_cg\")\n\n        objective = cp.Maximize(cp.sum(cp.multiply(M, p_cg)))\n\n        constraints = [p_cg[0, 0] == 1]\n        fp_expressions = _cg_to_fp_cp(p_cg, desc)\n\n        constraints += [expr &gt;= -tol for expr in fp_expressions]\n\n        problem = cp.Problem(objective, constraints)\n\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\", category=UserWarning)\n            bmax = problem.solve(solver=cp.SCS, eps=tol, verbose=False)\n\n        if problem.status not in [cp.OPTIMAL, cp.OPTIMAL_INACCURATE]:\n            print(f\"Warning: Solver status for 'nosignal': {problem.status}\")\n            if problem.status in [cp.INFEASIBLE, cp.INFEASIBLE_INACCURATE]:\n                bmax = -np.inf\n            elif problem.status in [cp.UNBOUNDED, cp.UNBOUNDED_INACCURATE]:\n                bmax = np.inf\n\n    elif mtype_low == \"quantum\":\n        if notation_low == \"fc\" and (oa != 2 or ob != 2):\n            raise ValueError(\n                \"Notation conversion failed: 'fc' notation is only supported for binary outputs (oa=2, ob=2).\"\n            )\n\n        if not isinstance(k, (str, numbers.Integral)) or (isinstance(k, numbers.Integral) and k &lt; 0):\n            raise ValueError(f\"Invalid NPA level k={k}. Must be a non-negative integer or a valid string level.\")\n        if isinstance(k, str):\n            # Use regex to validate the string format: digits optionally followed by '+' and 'a's/'b's\n            if not re.fullmatch(r\"\\d+(\\+[ab]+)?\", k):\n                raise ValueError(\n                    f\"Invalid NPA level k='{k}'. String format must be an integer (e.g., '1', '2') \"\n                    f\"optionally followed by '+' and a sequence of 'a's and 'b's (e.g., '1+ab', '2+aab').\"\n                )\n\n        try:\n            if notation_low == \"cg\":\n                M = coefficients\n            elif notation_low == \"fp\":\n                M = fp_to_cg(coefficients, behavior=False)\n            else:\n                M = fc_to_cg(coefficients, behavior=False)\n        except ValueError as e:\n            raise ValueError(f\"Notation conversion failed: {e}\") from e\n\n        cg_dim = ((oa - 1) * ma + 1, (ob - 1) * mb + 1)\n        if M.shape != cg_dim:\n            raise ValueError(\n                f\"Coefficient shape {M.shape} incompatible with desc={desc} and CG notation (expected {cg_dim}).\"\n            )\n\n        p_var = cp.Variable(cg_dim, name=\"p_cg_quantum\")\n\n        objective = cp.Maximize(cp.sum(cp.multiply(M, p_var)))\n\n        constraints = [p_var[0, 0] == 1]\n        try:\n            npa_constraints = bell_npa_constraints(p_var, desc, k)\n            constraints += npa_constraints\n        except ValueError as e:\n            raise ValueError(f\"Error generating NPA constraints: {e}\") from e\n\n        problem = cp.Problem(objective, constraints)\n\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\", category=UserWarning)\n            bmax = problem.solve(solver=cp.SCS, eps=tol, verbose=False)\n\n        if problem.status not in [cp.OPTIMAL, cp.OPTIMAL_INACCURATE]:\n            print(f\"Warning: Solver status for 'quantum' k={k}: {problem.status}\")\n            if problem.status in [cp.INFEASIBLE, cp.INFEASIBLE_INACCURATE]:\n                bmax = -np.inf\n            elif problem.status in [cp.UNBOUNDED, cp.UNBOUNDED_INACCURATE]:\n                bmax = np.inf\n\n    elif mtype_low == \"classical\":\n        current_oa, current_ob, current_ma, current_mb = oa, ob, ma, mb\n\n        if current_oa == 2 and current_ob == 2:\n            expected_fc_shape = (ma + 1, mb + 1)\n            expected_cg_shape = (ma * (oa - 1) + 1, mb * (ob - 1) + 1)\n            expected_fp_shape = (oa, ob, ma, mb)\n\n            try:\n                if notation_low == \"fc\":\n                    if coefficients.shape != expected_fc_shape:\n                        raise ValueError(\n                            f\"FC coefficient shape {coefficients.shape} incompatible \"\n                            f\"with desc={desc} (expected {expected_fc_shape}).\"\n                        )\n                    M = coefficients\n                elif notation_low == \"fp\":\n                    if coefficients.shape != expected_fp_shape:\n                        raise ValueError(\n                            f\"FP coefficient shape {coefficients.shape} incompatible \"\n                            f\"with desc={desc} (expected {expected_fp_shape}).\"\n                        )\n                    M = fp_to_fc(coefficients, behavior=False)\n                else:  # notation_low == \"cg\"\n                    if coefficients.shape != expected_cg_shape:\n                        raise ValueError(\n                            f\"CG coefficient shape {coefficients.shape} incompatible \"\n                            f\"with desc={desc} (expected {expected_cg_shape}).\"\n                        )\n                    M = cg_to_fc(coefficients, behavior=False)\n            except ValueError as e:\n                raise ValueError(f\"Notation conversion failed for binary scenario: {e}\") from e\n\n            if current_ma == 0 or current_mb == 0:\n                if current_ma == 0:\n                    bmax = M[0, 0] + np.sum(np.abs(M[0, 1:]))\n                else:  # current_mb == 0\n                    bmax = M[0, 0] + np.sum(np.abs(M[1:, 0]))\n                return float(bmax)\n\n            if current_ma &lt; current_mb:\n                M = M.T\n                current_ma, current_mb = mb, ma\n\n            b_marginal = M[0, 1:]\n            a_marginal = M[1:, 0]\n            correlations = M[1:, 1:]\n            bmax = -np.inf\n\n            num_bob_strategies = 1 &lt;&lt; current_mb\n            for b_idx in range(num_bob_strategies):\n                b_digits = _integer_digits(b_idx, 2, current_mb)\n                b_vec = 1 - 2 * b_digits\n                temp_bmax = b_marginal @ b_vec + np.sum(np.abs(a_marginal + correlations @ b_vec))\n                bmax = max(bmax, temp_bmax)\n\n            bmax += M[0, 0]\n\n        else:\n            if notation_low == \"fc\":\n                raise ValueError(\n                    \"Notation conversion failed for non-binary scenario: \"\n                    \"'fc' notation is only supported for binary outputs (oa=2, ob=2).\"\n                )\n\n            expected_cg_shape = (ma * (oa - 1) + 1, mb * (ob - 1) + 1)\n            expected_fp_shape = (oa, ob, ma, mb)\n\n            if current_ma == 0 or current_mb == 0:\n                return 0.0\n\n            try:\n                if notation_low == \"fp\":\n                    if coefficients.shape != expected_fp_shape:\n                        raise ValueError(\n                            f\"FP coefficient shape {coefficients.shape} incompatible \"\n                            f\"with desc={desc} (expected {expected_fp_shape}).\"\n                        )\n                    M_fp = coefficients\n                elif notation_low == \"cg\":\n                    if coefficients.shape != expected_cg_shape:\n                        raise ValueError(\n                            f\"CG coefficient shape {coefficients.shape} incompatible \"\n                            f\"with desc={desc} (expected {expected_cg_shape}).\"\n                        )\n                    M_fp = cg_to_fp(coefficients, desc, behavior=False)\n            except ValueError as e:\n                raise ValueError(f\"Notation conversion failed for non-binary scenario: {e}\") from e\n\n            num_a_strats = current_oa**current_ma\n            num_b_strats = current_ob**current_mb\n\n            if num_a_strats &lt; num_b_strats:\n                M_fp = np.transpose(M_fp, (1, 0, 3, 2))\n                current_oa, current_ob = ob, oa\n                current_ma, current_mb = mb, ma\n\n            M_perm = np.transpose(M_fp, (0, 2, 1, 3))\n\n            bob_dim_size = current_ob * current_mb\n            alice_dim_size = current_oa * current_ma\n            M_reshaped = M_perm.reshape(alice_dim_size, bob_dim_size)\n\n            bmax = -np.inf\n            num_bob_strategies = current_ob**current_mb\n            bob_offset = current_ob * np.arange(current_mb)\n\n            for b_idx in range(num_bob_strategies):\n                b_digits = _integer_digits(b_idx, current_ob, current_mb)\n                bob_indices_for_sum = b_digits + bob_offset\n\n                Ma = np.sum(M_reshaped[:, bob_indices_for_sum], axis=1)\n\n                Ma_reshaped = Ma.reshape(current_oa, current_ma)\n                max_a_for_x = np.max(Ma_reshaped, axis=0)\n\n                temp_bmax = np.sum(max_a_for_x)\n                bmax = max(bmax, temp_bmax)\n\n    else:\n        raise ValueError(f\"Invalid mtype: {mtype}. Must be 'classical', 'quantum', or 'nosignal'.\")\n\n    if bmax is None or np.isnan(bmax):\n        return -np.inf\n\n    if np.isinf(bmax):\n        return float(bmax)\n\n    return float(bmax)\n</code></pre>"},{"location":"reference/toqito/state_opt/bell_inequality_max/#toqito.state_opt.bell_inequality_max.bell_inequality_max_qubits","title":"bell_inequality_max_qubits","text":"<pre><code>bell_inequality_max_qubits(joint_coe: ndarray, a_coe: ndarray, b_coe: ndarray, a_val: ndarray, b_val: ndarray, solver_name: str = 'SCS') -&gt; float\n</code></pre> <p>Return the upper bound for the maximum violation(Tsirelson Bound) for a given bipartite Bell inequality.</p> <p>This computes the upper bound for the maximum value of a given bipartite Bell inequality using an SDP. The method is from <sup>1</sup> and the implementation is based on <sup>2</sup>. This is useful for various tasks in device independent quantum information processing.</p> <p>The function formulates the problem as a SDP problem in the following format for the \\(W\\)-state.</p> \\[     \\begin{multline}     \\max \\operatorname{tr}\\!\\Bigl( W \\cdot \\sum_{a,b,x,y} B^{xy}_{ab}\\, M^x_a \\otimes N^y_b \\Bigr),\\\\[1ex]     \\text{s.t.} \\quad \\operatorname{tr}(W) = 1,\\quad W \\ge 0,\\\\[1ex]     W^{T_P} \\ge 0,\\quad \\text{for all bipartitions } P.     \\end{multline} \\] <p>Examples:</p> <p>Consider the I3322 Bell inequality from <sup>3</sup>.</p> \\[     \\begin{aligned}     I_{3322} &amp;= P(A_1 = B_1) + P(B_1 = A_2) + P(A_2 = B_2) + P(B_2 = A_3) \\\\              &amp;\\quad - P(A_1 = B_2) - P(A_2 = B_3) - P(A_3 = B_1) - P(A_3 = B_3) \\\\              &amp;\\le 2     \\end{aligned} \\] <p>The individual and joint coefficents and measurement values are encoded as matrices. The upper bound can then be found in <code>|toqito\u27e9</code> as follows.</p> <pre><code>import numpy as np\nfrom toqito.state_opt.bell_inequality_max import bell_inequality_max_qubits\n\njoint_coe = np.array([\n    [1, 1, -1],\n    [1, 1, 1],\n    [-1, 1, 0],\n])\na_coe = np.array([0, -1, 0])\nb_coe = np.array([-1, -2, 0])\na_val = np.array([0, 1])\nb_val = np.array([0, 1])\n\nresult = bell_inequality_max_qubits(joint_coe, a_coe, b_coe, a_val, b_val)\nprint(f\"Bell inequality maximum value: {result:.3f}\")\n</code></pre> <p>Bell inequality maximum value: 0.250</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>a_val</code> or <code>b_val</code> are not length 2.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>joint_coe</code>               (<code>ndarray</code>)           \u2013            <p>The coefficents for terms containing both A and B.</p> </li> <li> <code>a_coe</code>               (<code>ndarray</code>)           \u2013            <p>The coefficent for terms only containing A.</p> </li> <li> <code>b_coe</code>               (<code>ndarray</code>)           \u2013            <p>The coefficent for terms only containing B.</p> </li> <li> <code>a_val</code>               (<code>ndarray</code>)           \u2013            <p>The value of each measurement outcome for A.</p> </li> <li> <code>b_val</code>               (<code>ndarray</code>)           \u2013            <p>The value of each measurement outcome for B.</p> </li> <li> <code>solver_name</code>               (<code>str</code>, default:                   <code>'SCS'</code> )           \u2013            <p>The solver used.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The upper bound for the maximum violation of the Bell inequality.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Navascues, Miguel and Torre, Gonzalo and Vertesi, Tamas. Characterization of quantum correlations with local dimension constraints and its device-independent applications. Physical Review X. vol. 4(1). (2014). doi:10.1103/PhysRevX.4.011011. <sup>2</sup> Johnston, Nathaniel. {{QETLAB}: {A MATLAB} toolbox for quantum entanglement}. doi:10.5281/zenodo.44637. <sup>3</sup> Collins, Daniel and Gisin, Nicolas. A relevant two qubit Bell inequality inequivalent to the CHSH inequality. Journal of Physics A: Mathematical and General. vol. 37(5). (2004). doi:10.1088/0305-4470/37/5/021.</p> Source code in <code>toqito/state_opt/bell_inequality_max.py</code> <pre><code>def bell_inequality_max_qubits(\n    joint_coe: np.ndarray,\n    a_coe: np.ndarray,\n    b_coe: np.ndarray,\n    a_val: np.ndarray,\n    b_val: np.ndarray,\n    solver_name: str = \"SCS\",\n) -&gt; float:\n    r\"\"\"Return the upper bound for the maximum violation(Tsirelson Bound) for a given bipartite Bell inequality.\n\n    This computes the upper bound for the maximum value of a given bipartite Bell inequality using an SDP.\n    The method is from [@Navascues_2014_Characterization] and the implementation is based on\n    [@QETLAB_link]. This is useful for various tasks in device independent quantum information processing.\n\n    The function formulates the problem as a SDP problem in the following format for the \\(W\\)-state.\n\n    \\[\n        \\begin{multline}\n        \\max \\operatorname{tr}\\!\\Bigl( W \\cdot \\sum_{a,b,x,y} B^{xy}_{ab}\\, M^x_a \\otimes N^y_b \\Bigr),\\\\[1ex]\n        \\text{s.t.} \\quad \\operatorname{tr}(W) = 1,\\quad W \\ge 0,\\\\[1ex]\n        W^{T_P} \\ge 0,\\quad \\text{for all bipartitions } P.\n        \\end{multline}\n    \\]\n\n\n    Examples:\n        Consider the I3322 Bell inequality from [@Collins_2004].\n\n        \\[\n            \\begin{aligned}\n            I_{3322} &amp;= P(A_1 = B_1) + P(B_1 = A_2) + P(A_2 = B_2) + P(B_2 = A_3) \\\\\n                     &amp;\\quad - P(A_1 = B_2) - P(A_2 = B_3) - P(A_3 = B_1) - P(A_3 = B_3) \\\\\n                     &amp;\\le 2\n            \\end{aligned}\n        \\]\n\n        The individual and joint coefficents and measurement values are encoded as matrices.\n        The upper bound can then be found in `|toqito\u27e9` as follows.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.state_opt.bell_inequality_max import bell_inequality_max_qubits\n\n        joint_coe = np.array([\n            [1, 1, -1],\n            [1, 1, 1],\n            [-1, 1, 0],\n        ])\n        a_coe = np.array([0, -1, 0])\n        b_coe = np.array([-1, -2, 0])\n        a_val = np.array([0, 1])\n        b_val = np.array([0, 1])\n\n        result = bell_inequality_max_qubits(joint_coe, a_coe, b_coe, a_val, b_val)\n        print(f\"Bell inequality maximum value: {result:.3f}\")\n        ```\n\n    Raises:\n        ValueError: If `a_val` or `b_val` are not length 2.\n\n    Args:\n        joint_coe: The coefficents for terms containing both A and B.\n        a_coe: The coefficent for terms only containing A.\n        b_coe: The coefficent for terms only containing B.\n        a_val: The value of each measurement outcome for A.\n        b_val: The value of each measurement outcome for B.\n        solver_name: The solver used.\n\n    Returns:\n        The upper bound for the maximum violation of the Bell inequality.\n\n    \"\"\"\n    m, _ = joint_coe.shape\n\n    # Ensure the input vectors are column vectors.\n    a_val = a_val.reshape(-1, 1)\n    b_val = b_val.reshape(-1, 1)\n    a_coe = a_coe.reshape(-1, 1)\n    b_coe = b_coe.reshape(-1, 1)\n\n    # Check if vectors a_val and b_val have only two elements.\n    if len(a_val) != 2 or len(b_val) != 2:\n        raise ValueError(\"This script is only capable of handling Bell inequalities with two outcomes.\")\n\n    tot_dim = 2 ** (2 * m + 2)\n    obj_mat = np.zeros((tot_dim, tot_dim), dtype=float)\n\n    # Nested loops to compute the objective matrix.\n    for a in range(2):  # a = 0 to 1\n        for b in range(2):  # b = 0 to 1\n            # Indices below are adjusted to account for Python-MATLAB difference.\n            for x in range(1, m + 1):  # x = 1 to m (1-indexed in MATLAB, hence the range adjustment)\n                for y in range(1, m + 1):  # y = 1 to m\n                    b_coeff = joint_coe[x - 1, y - 1] * a_val[a, 0] * b_val[b, 0]\n                    if y == 1:\n                        b_coeff += a_coe[x - 1, 0] * a_val[a, 0]\n                    if x == 1:\n                        b_coeff += b_coe[y - 1, 0] * b_val[b, 0]\n\n                    # Construct Alice and Bob's extended measurement operators.\n                    perm_x = [x if i == 0 else (0 if i == x else i) for i in range(m + 1)]\n                    perm_y = [y if i == 0 else (0 if i == y else i) for i in range(m + 1)]\n                    M = a * np.eye(2 ** (m + 1)) + ((-1) ** a) * permutation_operator([2] * (m + 1), perm_x, 0, 1)\n                    N = b * np.eye(2 ** (m + 1)) + ((-1) ** b) * permutation_operator([2] * (m + 1), perm_y, 0, 1)\n\n                    # Adding the result of the tensor product to the objective matrix.\n                    obj_mat += b_coeff * np.kron(M, N)\n\n    # Symmetrize the matrix to avoid numerical issues.\n    obj_mat = (obj_mat + obj_mat.T) / 2\n    aux_mat = np.array([[1, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]])\n\n    # Construct the SDP problem.\n    W = cp.Variable((2 ** (2 * m), 2 ** (2 * m)), symmetric=True)\n\n    # Dimension boost W to the same dimension as obj_mat.\n    M = swap(W, [2, m + 1], [2] * (2 * m))\n    X = swap(cp.kron(M, aux_mat), [m + 1, 2 * m + 1], [2] * (2 * m + 2))\n    Z = swap(X, [m + 2, 2 * m + 1], [2] * (2 * m + 2))\n\n    objective = cp.Maximize(cp.trace(Z @ obj_mat))\n\n    # Define the constraints.\n    constraints = [cp.trace(W) == 1, W &gt;&gt; 0]\n\n    # Adding PPT constraints.\n    for sz in range(1, m + 1):\n        # Generate all combinations of indices from 1 to 2*m-1 of size sz.\n        for ppt_partition in combinations(range(1, 2 * m - 1), sz):\n            # Convert to 0-based indexing for Python.\n            ppt_partition_updated = [x - 1 for x in ppt_partition]\n            # Partial transpose on the partition, ensuring it's positive semidefinite.\n            pt_matrix = partial_transpose(W, ppt_partition_updated, [4] + [2] * (2 * (m - 1)))\n            constraints.append(pt_matrix &gt;&gt; 0)\n\n    prob = cp.Problem(objective, constraints)\n    prob.solve(solver=solver_name, verbose=False)\n\n    return prob.value\n</code></pre>"},{"location":"reference/toqito/state_opt/bell_notation_conversions/","title":"bell_notation_conversions","text":""},{"location":"reference/toqito/state_opt/bell_notation_conversions/#toqito.state_opt.bell_notation_conversions","title":"bell_notation_conversions","text":"<p>Conversions between Bell inequality notations.</p>"},{"location":"reference/toqito/state_opt/bell_notation_conversions/#toqito.state_opt.bell_notation_conversions.cg_to_fc","title":"cg_to_fc","text":"<pre><code>cg_to_fc(cg_mat: ndarray, behavior: bool = False) -&gt; ndarray\n</code></pre> <p>Convert a Bell functional or behavior from Collins-Gisin (CG) to Full Correlator (FC) notation.</p> <p>The Collins-Gisin (CG) notation for a Bell functional or behavior is represented by a matrix:</p> \\[ \\text{CG} = \\begin{pmatrix}     K      &amp; p_B(0|1) &amp; p_B(0|2) &amp; \\dots \\\\     p_A(0|1) &amp; p(00|11) &amp; p(00|12) &amp; \\dots \\\\     p_A(0|2) &amp; p(00|21) &amp; p(00|22) &amp; \\dots \\\\     \\vdots   &amp; \\vdots   &amp; \\vdots   &amp; \\ddots \\end{pmatrix} \\] <p>The Full Correlator (FC) notation is represented by:</p> \\[ \\text{FC} = \\begin{pmatrix}     K      &amp; \\langle B_1 \\rangle &amp; \\langle B_2 \\rangle &amp; \\dots \\\\     \\langle A_1 \\rangle &amp; \\langle A_1 B_1 \\rangle &amp; \\langle A_1 B_2 \\rangle &amp; \\dots \\\\     \\langle A_2 \\rangle &amp; \\langle A_2 B_1 \\rangle &amp; \\langle A_2 B_2 \\rangle &amp; \\dots \\\\     \\vdots   &amp; \\vdots      &amp; \\vdots      &amp; \\ddots \\end{pmatrix} \\] <p>This function converts between these two notations.</p> <p>Examples:</p> <p>Consider the CHSH inequality in CG notation for a functional:</p> \\[ \\text{CHSH}_{CG} = \\begin{pmatrix}     0 &amp; 0 &amp; 0 \\\\     0 &amp; 1 &amp; -1 \\\\     0 &amp; -1 &amp; 1 \\end{pmatrix} \\] <p>Converting to FC notation:</p> <pre><code>import numpy as np\nfrom toqito.state_opt.bell_notation_conversions import cg_to_fc\n\nchsh_cg = np.array([[0, 0, 0], [0, 1, -1], [0, -1, 1]])\nprint(cg_to_fc(chsh_cg))\n</code></pre> <p>[[ 0.    0.    0.  ]  [ 0.    0.25 -0.25]  [ 0.   -0.25  0.25]]</p> <p>Consider a behavior (probability distribution) in CG notation:</p> \\[ P_{CG} = \\begin{pmatrix}     1 &amp; 0.5 &amp; 0.5 \\\\     0.5 &amp; 0.25 &amp; 0.25 \\\\     0.5 &amp; 0.25 &amp; 0.25 \\end{pmatrix} \\] <p>Converting to FC notation:</p> <pre><code>import numpy as np\nfrom toqito.state_opt.bell_notation_conversions import cg_to_fc\np_cg = np.array([[1, 0.5, 0.5], [0.5, 0.25, 0.25], [0.5, 0.25, 0.25]])\nprint(cg_to_fc(p_cg, behavior=True))\n</code></pre> <p>[[1. 0. 0.]  [0. 0. 0.]  [0. 0. 0.]]</p> <p>Parameters:</p> <ul> <li> <code>cg_mat</code>               (<code>ndarray</code>)           \u2013            <p>The matrix in Collins-Gisin notation.</p> </li> <li> <code>behavior</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, assume input is a behavior (default: False, assume functional).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>The matrix in Full Correlator notation.</p> </li> </ul> <p>Note</p> <p>This function is adapted from the QETLAB MATLAB package function <code>CG2FC</code>.</p> Source code in <code>toqito/state_opt/bell_notation_conversions.py</code> <pre><code>def cg_to_fc(cg_mat: np.ndarray, behavior: bool = False) -&gt; np.ndarray:\n    r\"\"\"Convert a Bell functional or behavior from Collins-Gisin (CG) to Full Correlator (FC) notation.\n\n    The Collins-Gisin (CG) notation for a Bell functional or behavior is represented by a matrix:\n\n    \\[\n    \\text{CG} =\n    \\begin{pmatrix}\n        K      &amp; p_B(0|1) &amp; p_B(0|2) &amp; \\dots \\\\\n        p_A(0|1) &amp; p(00|11) &amp; p(00|12) &amp; \\dots \\\\\n        p_A(0|2) &amp; p(00|21) &amp; p(00|22) &amp; \\dots \\\\\n        \\vdots   &amp; \\vdots   &amp; \\vdots   &amp; \\ddots\n    \\end{pmatrix}\n    \\]\n\n    The Full Correlator (FC) notation is represented by:\n\n    \\[\n    \\text{FC} =\n    \\begin{pmatrix}\n        K      &amp; \\langle B_1 \\rangle &amp; \\langle B_2 \\rangle &amp; \\dots \\\\\n        \\langle A_1 \\rangle &amp; \\langle A_1 B_1 \\rangle &amp; \\langle A_1 B_2 \\rangle &amp; \\dots \\\\\n        \\langle A_2 \\rangle &amp; \\langle A_2 B_1 \\rangle &amp; \\langle A_2 B_2 \\rangle &amp; \\dots \\\\\n        \\vdots   &amp; \\vdots      &amp; \\vdots      &amp; \\ddots\n    \\end{pmatrix}\n    \\]\n\n    This function converts between these two notations.\n\n    Examples:\n        Consider the CHSH inequality in CG notation for a functional:\n\n        \\[\n        \\text{CHSH}_{CG} =\n        \\begin{pmatrix}\n            0 &amp; 0 &amp; 0 \\\\\n            0 &amp; 1 &amp; -1 \\\\\n            0 &amp; -1 &amp; 1\n        \\end{pmatrix}\n        \\]\n\n        Converting to FC notation:\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.state_opt.bell_notation_conversions import cg_to_fc\n\n        chsh_cg = np.array([[0, 0, 0], [0, 1, -1], [0, -1, 1]])\n        print(cg_to_fc(chsh_cg))\n        ```\n\n        Consider a behavior (probability distribution) in CG notation:\n\n        \\[\n        P_{CG} =\n        \\begin{pmatrix}\n            1 &amp; 0.5 &amp; 0.5 \\\\\n            0.5 &amp; 0.25 &amp; 0.25 \\\\\n            0.5 &amp; 0.25 &amp; 0.25\n        \\end{pmatrix}\n        \\]\n\n        Converting to FC notation:\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.state_opt.bell_notation_conversions import cg_to_fc\n        p_cg = np.array([[1, 0.5, 0.5], [0.5, 0.25, 0.25], [0.5, 0.25, 0.25]])\n        print(cg_to_fc(p_cg, behavior=True))\n        ```\n\n    Args:\n        cg_mat: The matrix in Collins-Gisin notation.\n        behavior: If True, assume input is a behavior (default: False, assume functional).\n\n    Returns:\n        The matrix in Full Correlator notation.\n\n    !!! Note\n        This function is adapted from the QETLAB MATLAB package function ``CG2FC``.\n\n    \"\"\"\n    ia = cg_mat.shape[0] - 1\n    ib = cg_mat.shape[1] - 1\n\n    fc_mat = np.zeros((ia + 1, ib + 1))\n\n    a_vec = cg_mat[1:, 0]\n    b_vec = cg_mat[0, 1:]\n    c_mat = cg_mat[1:, 1:]\n\n    if not behavior:\n        fc_mat[0, 0] = cg_mat[0, 0] + np.sum(a_vec) / 2 + np.sum(b_vec) / 2 + np.sum(c_mat) / 4\n        fc_mat[1:, 0] = a_vec / 2 + np.sum(c_mat, axis=1) / 4\n        fc_mat[0, 1:] = b_vec / 2 + np.sum(c_mat, axis=0) / 4\n        fc_mat[1:, 1:] = c_mat / 4\n    else:\n        fc_mat[0, 0] = 1\n        fc_mat[1:, 0] = 2 * a_vec - 1\n        fc_mat[0, 1:] = 2 * b_vec - 1\n        fc_mat[1:, 1:] = np.ones((ia, ib)) - 2 * a_vec[:, np.newaxis] - 2 * b_vec[np.newaxis, :] + 4 * c_mat\n\n    return fc_mat\n</code></pre>"},{"location":"reference/toqito/state_opt/bell_notation_conversions/#toqito.state_opt.bell_notation_conversions.fc_to_cg","title":"fc_to_cg","text":"<pre><code>fc_to_cg(fc_mat: ndarray, behavior: bool = False) -&gt; ndarray\n</code></pre> <p>Convert a Bell functional or behavior from Full Correlator (FC) to Collins-Gisin (CG) notation.</p> <p>The Full Correlator (FC) notation is represented by:</p> \\[ \\text{FC} = \\begin{pmatrix}     K      &amp; \\langle B_1 \\rangle &amp; \\langle B_2 \\rangle &amp; \\dots \\\\     \\langle A_1 \\rangle &amp; \\langle A_1 B_1 \\rangle &amp; \\langle A_1 B_2 \\rangle &amp; \\dots \\\\     \\langle A_2 \\rangle &amp; \\langle A_2 B_1 \\rangle &amp; \\langle A_2 B_2 \\rangle &amp; \\dots \\\\     \\vdots   &amp; \\vdots      &amp; \\vdots      &amp; \\ddots \\end{pmatrix} \\] <p>The Collins-Gisin (CG) notation for a Bell functional or behavior is represented by a matrix:</p> \\[ \\text{CG} = \\begin{pmatrix}     K      &amp; p_B(0|1) &amp; p_B(0|2) &amp; \\dots \\\\     p_A(0|1) &amp; p(00|11) &amp; p(00|12) &amp; \\dots \\\\     p_A(0|2) &amp; p(00|21) &amp; p(00|22) &amp; \\dots \\\\     \\vdots   &amp; \\vdots   &amp; \\vdots   &amp; \\ddots \\end{pmatrix} \\] <p>This function converts between these two notations.</p> <p>Examples:</p> <p>Consider the CHSH inequality in FC notation for a functional:</p> \\[ \\text{CHSH}_{FC} = \\begin{pmatrix}     0 &amp; 0 &amp; 0 \\\\     0 &amp; 1/4 &amp; -1/4 \\\\     0 &amp; -1/4 &amp; 1/4 \\end{pmatrix} \\] <p>Converting to CG notation:</p> <pre><code>import numpy as np\nfrom toqito.state_opt.bell_notation_conversions import fc_to_cg\nchsh_fc = np.array([[0, 0, 0], [0, 0.25, -0.25], [0, -0.25, 0.25]])\nprint(fc_to_cg(chsh_fc))\n</code></pre> <p>[[ 0.  0.  0.]  [ 0.  1. -1.]  [ 0. -1.  1.]]</p> <p>Consider a behavior (correlation matrix) in FC notation:</p> \\[ P_{FC} = \\begin{pmatrix}     1 &amp; 0 &amp; 0 \\\\     0 &amp; 0 &amp; 0 \\\\     0 &amp; 0 &amp; 0 \\end{pmatrix} \\] <p>Converting to CG notation:</p> <pre><code>import numpy as np\nfrom toqito.state_opt.bell_notation_conversions import fc_to_cg\np_fc = np.array([[1, 0, 0], [0, 0, 0], [0, 0, 0]])\nprint(fc_to_cg(p_fc, behavior=True))\n</code></pre> <p>[[1.   0.5  0.5 ]  [0.5  0.25 0.25]  [0.5  0.25 0.25]]</p> <p>Parameters:</p> <ul> <li> <code>fc_mat</code>               (<code>ndarray</code>)           \u2013            <p>The matrix in Full Correlator notation.</p> </li> <li> <code>behavior</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, assume input is a behavior (default: False, assume functional).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>The matrix in Collins-Gisin notation.</p> </li> </ul> <p>Note</p> <p>This function is adapted from the QETLAB MATLAB package function <code>FC2CG</code>.</p> Source code in <code>toqito/state_opt/bell_notation_conversions.py</code> <pre><code>def fc_to_cg(fc_mat: np.ndarray, behavior: bool = False) -&gt; np.ndarray:\n    r\"\"\"Convert a Bell functional or behavior from Full Correlator (FC) to Collins-Gisin (CG) notation.\n\n    The Full Correlator (FC) notation is represented by:\n\n    \\[\n    \\text{FC} =\n    \\begin{pmatrix}\n        K      &amp; \\langle B_1 \\rangle &amp; \\langle B_2 \\rangle &amp; \\dots \\\\\n        \\langle A_1 \\rangle &amp; \\langle A_1 B_1 \\rangle &amp; \\langle A_1 B_2 \\rangle &amp; \\dots \\\\\n        \\langle A_2 \\rangle &amp; \\langle A_2 B_1 \\rangle &amp; \\langle A_2 B_2 \\rangle &amp; \\dots \\\\\n        \\vdots   &amp; \\vdots      &amp; \\vdots      &amp; \\ddots\n    \\end{pmatrix}\n    \\]\n\n    The Collins-Gisin (CG) notation for a Bell functional or behavior is represented by a matrix:\n\n    \\[\n    \\text{CG} =\n    \\begin{pmatrix}\n        K      &amp; p_B(0|1) &amp; p_B(0|2) &amp; \\dots \\\\\n        p_A(0|1) &amp; p(00|11) &amp; p(00|12) &amp; \\dots \\\\\n        p_A(0|2) &amp; p(00|21) &amp; p(00|22) &amp; \\dots \\\\\n        \\vdots   &amp; \\vdots   &amp; \\vdots   &amp; \\ddots\n    \\end{pmatrix}\n    \\]\n\n    This function converts between these two notations.\n\n    Examples:\n        Consider the CHSH inequality in FC notation for a functional:\n\n        \\[\n        \\text{CHSH}_{FC} =\n        \\begin{pmatrix}\n            0 &amp; 0 &amp; 0 \\\\\n            0 &amp; 1/4 &amp; -1/4 \\\\\n            0 &amp; -1/4 &amp; 1/4\n        \\end{pmatrix}\n        \\]\n\n        Converting to CG notation:\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.state_opt.bell_notation_conversions import fc_to_cg\n        chsh_fc = np.array([[0, 0, 0], [0, 0.25, -0.25], [0, -0.25, 0.25]])\n        print(fc_to_cg(chsh_fc))\n        ```\n\n        Consider a behavior (correlation matrix) in FC notation:\n\n        \\[\n        P_{FC} =\n        \\begin{pmatrix}\n            1 &amp; 0 &amp; 0 \\\\\n            0 &amp; 0 &amp; 0 \\\\\n            0 &amp; 0 &amp; 0\n        \\end{pmatrix}\n        \\]\n\n        Converting to CG notation:\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.state_opt.bell_notation_conversions import fc_to_cg\n        p_fc = np.array([[1, 0, 0], [0, 0, 0], [0, 0, 0]])\n        print(fc_to_cg(p_fc, behavior=True))\n        ```\n\n    Args:\n        fc_mat: The matrix in Full Correlator notation.\n        behavior: If True, assume input is a behavior (default: False, assume functional).\n\n    Returns:\n        The matrix in Collins-Gisin notation.\n\n    !!! Note\n        This function is adapted from the QETLAB MATLAB package function ``FC2CG``.\n\n    \"\"\"\n    ia = fc_mat.shape[0] - 1\n    ib = fc_mat.shape[1] - 1\n\n    cg_mat = np.zeros((ia + 1, ib + 1))\n\n    a_vec = fc_mat[1:, 0]\n    b_vec = fc_mat[0, 1:]\n    c_mat = fc_mat[1:, 1:]\n\n    if not behavior:\n        cg_mat[0, 0] = fc_mat[0, 0] + np.sum(c_mat) - np.sum(a_vec) - np.sum(b_vec)\n        cg_mat[1:, 0] = 2 * a_vec - 2 * np.sum(c_mat, axis=1)\n        cg_mat[0, 1:] = 2 * b_vec - 2 * np.sum(c_mat, axis=0)\n        cg_mat[1:, 1:] = 4 * c_mat\n    else:\n        cg_mat[0, 0] = 1\n        cg_mat[1:, 0] = (1 + a_vec) / 2\n        cg_mat[0, 1:] = (1 + b_vec) / 2\n        cg_mat[1:, 1:] = (np.ones((ia, ib)) + a_vec[:, np.newaxis] + b_vec[np.newaxis, :] + c_mat) / 4\n\n    return cg_mat\n</code></pre>"},{"location":"reference/toqito/state_opt/bell_notation_conversions/#toqito.state_opt.bell_notation_conversions.cg_to_fp","title":"cg_to_fp","text":"<pre><code>cg_to_fp(cg_mat: ndarray, desc: list[int], behavior: bool = False) -&gt; ndarray\n</code></pre> <p>Convert a Bell functional or behavior from Collins-Gisin (CG) to Full Probability (FP) notation.</p> <p>The Collins-Gisin (CG) notation for a Bell functional or behavior is represented by a matrix (see :func:<code>cg_to_fc</code>). The Full Probability (FP) notation represents the full probability distribution \\(V(a, b, x, y) = P(a, b | x, y)\\), the probability of Alice getting outcome \\(a\\) (0 to oa-1) and Bob getting outcome \\(b\\) (0 to ob-1) given inputs \\(x\\) (0 to ia-1) and \\(y\\) (0 to ib-1). This is stored as a 4D numpy array with indices <code>V[a, b, x, y]</code>.</p> <p>This function converts from CG to FP notation.</p> <p>Examples:</p> <p>Consider the CHSH inequality functional in CG notation:</p> \\[ \\text{CHSH}_{CG} = \\begin{pmatrix}     0 &amp; 0 &amp; 0 \\\\     0 &amp; 1 &amp; -1 \\\\     0 &amp; -1 &amp; 1 \\end{pmatrix} \\] <p>Converting to FP notation (desc = [2, 2, 2, 2]):</p> <pre><code>import numpy as np\nfrom toqito.state_opt.bell_notation_conversions import cg_to_fp\nchsh_cg = np.array([[0, 0, 0], [0, 1, -1], [0, -1, 1]])\ndesc = [2, 2, 2, 2] # oa, ob, ia, ib\nprint(cg_to_fp(chsh_cg, desc))\n</code></pre> <p>[[[[ 1. -1.]    [-1.  1.]]</p> <p>[[ 0.  0.]    [ 0.  0.]]]</p> <p>[[[ 0.  0.]    [ 0.  0.]]</p> <p>[[ 0.  0.]    [ 0.  0.]]]]</p> <p>Consider a behavior (probability distribution) in CG notation (desc = [2, 2, 2, 2]):</p> \\[ P_{CG} = \\begin{pmatrix}     1 &amp; 0.5 &amp; 0.5 \\\\     0.5 &amp; 0.25 &amp; 0.25 \\\\     0.5 &amp; 0.25 &amp; 0.25 \\end{pmatrix} \\] <p>Converting to FP notation:</p> <pre><code>import numpy as np\nfrom toqito.state_opt.bell_notation_conversions import cg_to_fp\np_cg = np.array([[1, 0.5, 0.5], [0.5, 0.25, 0.25], [0.5, 0.25, 0.25]])\ndesc = [2, 2, 2, 2]\nprint(cg_to_fp(p_cg, desc, behavior=True))\n</code></pre> <p>[[[[0.25 0.25]    [0.25 0.25]]</p> <p>[[0.25 0.25]    [0.25 0.25]]]</p> <p>[[[0.25 0.25]    [0.25 0.25]]</p> <p>[[0.25 0.25]    [0.25 0.25]]]]</p> <p>Parameters:</p> <ul> <li> <code>cg_mat</code>               (<code>ndarray</code>)           \u2013            <p>The matrix in Collins-Gisin notation.</p> </li> <li> <code>desc</code>               (<code>list[int]</code>)           \u2013            <p>A list [\\(oa\\), \\(ob\\), \\(ia\\), \\(ib\\)] describing the number of outputs       (\\(oa\\), \\(ob\\)) and inputs (\\(ia\\), \\(ib\\)).</p> </li> <li> <code>behavior</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, assume input is a behavior (default: False, assume functional).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>The probability tensor \\(V[a, b, x, y]\\) in Full Probability notation.</p> </li> </ul> <p>Note</p> <p>This function is adapted from the QETLAB MATLAB package function <code>CG2FP</code>.</p> Source code in <code>toqito/state_opt/bell_notation_conversions.py</code> <pre><code>def cg_to_fp(cg_mat: np.ndarray, desc: list[int], behavior: bool = False) -&gt; np.ndarray:\n    r\"\"\"Convert a Bell functional or behavior from Collins-Gisin (CG) to Full Probability (FP) notation.\n\n    The Collins-Gisin (CG) notation for a Bell functional or behavior is represented by a matrix\n    (see :func:`cg_to_fc`). The Full Probability (FP) notation represents the full probability\n    distribution \\(V(a, b, x, y) = P(a, b | x, y)\\), the probability of Alice getting outcome\n    \\(a\\) (0 to oa-1) and Bob getting outcome \\(b\\) (0 to ob-1) given inputs \\(x\\)\n    (0 to ia-1) and \\(y\\) (0 to ib-1). This is stored as a 4D numpy array with indices\n    `V[a, b, x, y]`.\n\n    This function converts from CG to FP notation.\n\n    Examples:\n        Consider the CHSH inequality functional in CG notation:\n\n        \\[\n        \\text{CHSH}_{CG} =\n        \\begin{pmatrix}\n            0 &amp; 0 &amp; 0 \\\\\n            0 &amp; 1 &amp; -1 \\\\\n            0 &amp; -1 &amp; 1\n        \\end{pmatrix}\n        \\]\n\n        Converting to FP notation (desc = [2, 2, 2, 2]):\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.state_opt.bell_notation_conversions import cg_to_fp\n        chsh_cg = np.array([[0, 0, 0], [0, 1, -1], [0, -1, 1]])\n        desc = [2, 2, 2, 2] # oa, ob, ia, ib\n        print(cg_to_fp(chsh_cg, desc))\n        ```\n\n        Consider a behavior (probability distribution) in CG notation (desc = [2, 2, 2, 2]):\n\n        \\[\n        P_{CG} =\n        \\begin{pmatrix}\n            1 &amp; 0.5 &amp; 0.5 \\\\\n            0.5 &amp; 0.25 &amp; 0.25 \\\\\n            0.5 &amp; 0.25 &amp; 0.25\n        \\end{pmatrix}\n        \\]\n\n        Converting to FP notation:\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.state_opt.bell_notation_conversions import cg_to_fp\n        p_cg = np.array([[1, 0.5, 0.5], [0.5, 0.25, 0.25], [0.5, 0.25, 0.25]])\n        desc = [2, 2, 2, 2]\n        print(cg_to_fp(p_cg, desc, behavior=True))\n        ```\n\n    Args:\n        cg_mat: The matrix in Collins-Gisin notation.\n        desc: A list [\\(oa\\), \\(ob\\), \\(ia\\), \\(ib\\)] describing the number of outputs\n                  (\\(oa\\), \\(ob\\)) and inputs (\\(ia\\), \\(ib\\)).\n        behavior: If True, assume input is a behavior (default: False, assume functional).\n\n    Returns:\n        The probability tensor \\(V[a, b, x, y]\\) in Full Probability notation.\n\n    !!! Note\n        This function is adapted from the QETLAB MATLAB package function ``CG2FP``.\n\n    \"\"\"\n    oa, ob, ia, ib = desc\n    v_mat = np.zeros((oa, ob, ia, ib))\n\n    def aindex(a: int, x: int) -&gt; int:\n        r\"\"\"CG matrix row index for Alice's outcome \\(a\\) (0..\\(oa-2\\)) and input \\(x\\) (0..\\(ia-1\\)).\n\n        Returns 1-based index.\n        \"\"\"\n        return 1 + a + x * (oa - 1)\n\n    def bindex(b: int, y: int) -&gt; int:\n        r\"\"\"CG matrix col index for Bob's outcome \\(b\\) (0..\\(ob-2\\)) and input \\(y\\) (0..\\(ib-1\\)).\n\n        Returns 1-based index.\n        \"\"\"\n        return 1 + b + y * (ob - 1)\n\n    if not behavior:\n        # Functional case logic\n        k_term = cg_mat[0, 0] / (ia * ib) if ia &gt; 0 and ib &gt; 0 else 0\n        for x in range(ia):\n            for y in range(ib):\n                # Fill V[a, b, x, y] for a &lt; oa-1, b &lt; ob-1\n                for a in range(oa - 1):\n                    a_term = cg_mat[aindex(a, x), 0] / ib if ib &gt; 0 else 0\n                    for b in range(ob - 1):\n                        b_term = cg_mat[0, bindex(b, y)] / ia if ia &gt; 0 else 0\n                        v_mat[a, b, x, y] = k_term + a_term + b_term + cg_mat[aindex(a, x), bindex(b, y)]\n                # Fill V[a, ob-1, x, y] for a &lt; oa-1 (last column for Bob)\n                for a in range(oa - 1):\n                    a_term = cg_mat[aindex(a, x), 0] / ib if ib &gt; 0 else 0\n                    v_mat[a, ob - 1, x, y] = k_term + a_term\n                # Fill V[oa-1, b, x, y] for b &lt; ob-1 (last row for Alice)\n                for b in range(ob - 1):\n                    b_term = cg_mat[0, bindex(b, y)] / ia if ia &gt; 0 else 0\n                    v_mat[oa - 1, b, x, y] = k_term + b_term\n                # Fill V[oa-1, ob-1, x, y] (bottom-right corner)\n                v_mat[oa - 1, ob - 1, x, y] = k_term\n\n    else:\n        for x in range(ia):\n            for y in range(ib):\n                # Calculate slices for CG matrix corresponding to non-last outcomes\n                # Need 1-based indices for slicing cg_mat\n                start_row_a = aindex(0, x)\n                end_row_a = aindex(oa - 2, x) + 1 if oa &gt; 1 else start_row_a\n                slice_a = slice(start_row_a, end_row_a)\n\n                start_col_b = bindex(0, y)\n                end_col_b = bindex(ob - 2, y) + 1 if ob &gt; 1 else start_col_b\n                slice_b = slice(start_col_b, end_col_b)\n\n                # Get corresponding submatrix or default to zeros/scalars if outputs=1\n                cg_sub_mat = cg_mat[slice_a, slice_b] if oa &gt; 1 and ob &gt; 1 else np.array([[]])\n                cg_a_marg = cg_mat[slice_a, 0] if oa &gt; 1 else np.array([])\n                cg_b_marg = cg_mat[0, slice_b] if ob &gt; 1 else np.array([])\n\n                # V(0..oa-2, 0..ob-2, x, y) = p(a,b|xy)\n                if oa &gt; 1 and ob &gt; 1:\n                    v_mat[0 : oa - 1, 0 : ob - 1, x, y] = cg_sub_mat\n\n                # V(0..oa-2, ob-1, x, y) = pA(a|x) - sum_{b'=0..ob-2} p(a,b'|xy)\n                if oa &gt; 1:\n                    sum_b = np.sum(cg_sub_mat, axis=1) if ob &gt; 1 else np.zeros(oa - 1)\n                    v_mat[0 : oa - 1, ob - 1, x, y] = cg_a_marg - sum_b\n\n                # V(oa-1, 0..ob-2, x, y) = pB(b|y) - sum_{a'=0..oa-2} p(a',b|xy)\n                if ob &gt; 1:\n                    sum_a = np.sum(cg_sub_mat, axis=0) if oa &gt; 1 else np.zeros(ob - 1)\n                    v_mat[oa - 1, 0 : ob - 1, x, y] = cg_b_marg - sum_a\n\n                # V(oa-1, ob-1, x, y) = 1 - sum pA(a|x) - sum pB(b|y) + sum p(ab|xy)\n                sum_a_marg = np.sum(cg_a_marg)\n                sum_b_marg = np.sum(cg_b_marg)\n                sum_ab_joint = np.sum(cg_sub_mat)\n                v_mat[oa - 1, ob - 1, x, y] = (\n                    cg_mat[0, 0]  # Should be 1 for behavior\n                    - sum_a_marg\n                    - sum_b_marg\n                    + sum_ab_joint\n                )\n\n    return v_mat\n</code></pre>"},{"location":"reference/toqito/state_opt/bell_notation_conversions/#toqito.state_opt.bell_notation_conversions.fc_to_fp","title":"fc_to_fp","text":"<pre><code>fc_to_fp(fc_mat: ndarray, behavior: bool = False) -&gt; ndarray\n</code></pre> <p>Convert a Bell functional or behavior from Full Correlator (FC) to Full Probability (FP) notation.</p> <p>Assumes binary outcomes (\\(oa=2\\), \\(ob=2\\)) corresponding to physical values +1 and -1. The FP tensor indices \\(a, b = 0, 1\\) correspond to outcomes \\(+1, -1\\) respectively.</p> <p>The Full Correlator (FC) notation is represented by a matrix (see :func:<code>.fc_to_cg</code>). The Full Probability (FP) notation represents the full probability distribution \\(V(a, b, x, y) = P(\\text{out}_A=a', \\text{out}_B=b' | x, y)\\), where \\(a=0 \\rightarrow a'=+1\\), \\(a=1 \\rightarrow a'=-1\\) (similarly for \\(b\\)), stored as a 4D numpy array \\(V[a, b, x, y]\\).</p> <p>This function converts from FC to FP notation.</p> <p>Examples:</p> <p>Consider the CHSH inequality functional in FC notation:</p> \\[ \\text{CHSH}_{FC} = \\begin{pmatrix}     0 &amp; 0 &amp; 0 \\\\     0 &amp; 1/4 &amp; -1/4 \\\\     0 &amp; -1/4 &amp; 1/4 \\end{pmatrix} \\] <p>Converting to FP notation:</p> <pre><code>import numpy as np\nfrom toqito.state_opt.bell_notation_conversions import fc_to_fp\nchsh_fc = np.array([[0, 0, 0], [0, 0.25, -0.25], [0, -0.25, 0.25]])\nprint(fc_to_fp(chsh_fc))\n</code></pre> <p>[[[[ 0.25 -0.25]    [-0.25  0.25]]</p> <p>[[-0.25  0.25]    [ 0.25 -0.25]]]</p> <p>[[[-0.25  0.25]    [ 0.25 -0.25]]</p> <p>[[ 0.25 -0.25]    [-0.25  0.25]]]]</p> <p>Consider a behavior (correlation matrix) in FC notation (e.g., from PR box): Note: This FC matrix corresponds to the PR box after applying <code>fp_to_fc(pr_box, behavior=True)</code>, which uses the QETLAB convention of averaging marginal correlators.</p> \\[ P_{FC} = \\begin{pmatrix}     1 &amp; 0 &amp; 0 \\\\     0 &amp; 1/\\sqrt{2} &amp; 1/\\sqrt{2} \\\\     0 &amp; 1/\\sqrt{2} &amp; -1/\\sqrt{2} \\end{pmatrix} \\] <p>Converting to FP notation:</p> <pre><code>import numpy as np\nfrom toqito.state_opt.bell_notation_conversions import fc_to_fp\np_fc = np.array([[1, 0, 0], [0, 1/np.sqrt(2), 1/np.sqrt(2)], [0, 1/np.sqrt(2), -1/np.sqrt(2)]])\nprint(fc_to_fp(p_fc, behavior=True))\n</code></pre> <p>[[[[0.4267767 0.4267767]    [0.4267767 0.0732233]]</p> <p>[[0.0732233 0.0732233]    [0.0732233 0.4267767]]]</p> <p>[[[0.0732233 0.0732233]    [0.0732233 0.4267767]]</p> <p>[[0.4267767 0.4267767]    [0.4267767 0.0732233]]]]</p> <p>Parameters:</p> <ul> <li> <code>fc_mat</code>               (<code>ndarray</code>)           \u2013            <p>The matrix in Full Correlator notation.</p> </li> <li> <code>behavior</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, assume input is a behavior (default: False, assume functional).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>The probability tensor \\(V[a, b, x, y]\\) in Full Probability notation (oa=2, ob=2).</p> </li> </ul> <p>Note</p> <p>This function is adapted from the QETLAB MATLAB package function <code>FC2FP</code> <sup>1</sup>. For <code>behavior=True</code>, it applies the standard formula relating probabilities to correlators: \\(P(a', b' | x, y) = (1 + a'\\langle A_x \\rangle + b'\\langle B_y \\rangle +\\) \\(a'b'\\langle A_x B_y \\rangle) / 4\\), where \\(a', b' \\in \\{+1, -1\\}\\). Crucially, it uses the values \\(\\langle A_x \\rangle\\) and \\(\\langle B_y \\rangle\\) directly from the input <code>fc_mat</code>. If this input matrix was generated using a convention where these entries represent averaged marginal correlators (like the output of <code>fp_to_fc(..., behavior=True)</code>), the resulting FP tensor might not represent a valid probability distribution (e.g., entries could be negative).</p> <p>References</p> <p><sup>1</sup> QETLAB</p> Source code in <code>toqito/state_opt/bell_notation_conversions.py</code> <pre><code>def fc_to_fp(fc_mat: np.ndarray, behavior: bool = False) -&gt; np.ndarray:\n    r\"\"\"Convert a Bell functional or behavior from Full Correlator (FC) to Full Probability (FP) notation.\n\n    Assumes binary outcomes (\\(oa=2\\), \\(ob=2\\)) corresponding to physical values +1 and -1.\n    The FP tensor indices \\(a, b = 0, 1\\) correspond to outcomes \\(+1, -1\\) respectively.\n\n    The Full Correlator (FC) notation is represented by a matrix (see :func:`.fc_to_cg`).\n    The Full Probability (FP) notation represents the full probability distribution\n    \\(V(a, b, x, y) = P(\\text{out}_A=a', \\text{out}_B=b' | x, y)\\),\n    where \\(a=0 \\rightarrow a'=+1\\), \\(a=1 \\rightarrow a'=-1\\) (similarly for \\(b\\)),\n    stored as a 4D numpy array \\(V[a, b, x, y]\\).\n\n    This function converts from FC to FP notation.\n\n    Examples:\n        Consider the CHSH inequality functional in FC notation:\n\n        \\[\n        \\text{CHSH}_{FC} =\n        \\begin{pmatrix}\n            0 &amp; 0 &amp; 0 \\\\\n            0 &amp; 1/4 &amp; -1/4 \\\\\n            0 &amp; -1/4 &amp; 1/4\n        \\end{pmatrix}\n        \\]\n\n        Converting to FP notation:\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.state_opt.bell_notation_conversions import fc_to_fp\n        chsh_fc = np.array([[0, 0, 0], [0, 0.25, -0.25], [0, -0.25, 0.25]])\n        print(fc_to_fp(chsh_fc))\n        ```\n\n        Consider a behavior (correlation matrix) in FC notation (e.g., from PR box):\n        Note: This FC matrix corresponds to the PR box *after* applying ``fp_to_fc(pr_box, behavior=True)``,\n        which uses the QETLAB convention of averaging marginal correlators.\n\n        \\[\n        P_{FC} =\n        \\begin{pmatrix}\n            1 &amp; 0 &amp; 0 \\\\\n            0 &amp; 1/\\sqrt{2} &amp; 1/\\sqrt{2} \\\\\n            0 &amp; 1/\\sqrt{2} &amp; -1/\\sqrt{2}\n        \\end{pmatrix}\n        \\]\n\n        Converting to FP notation:\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.state_opt.bell_notation_conversions import fc_to_fp\n        p_fc = np.array([[1, 0, 0], [0, 1/np.sqrt(2), 1/np.sqrt(2)], [0, 1/np.sqrt(2), -1/np.sqrt(2)]])\n        print(fc_to_fp(p_fc, behavior=True))\n        ```\n\n    Args:\n        fc_mat: The matrix in Full Correlator notation.\n        behavior: If True, assume input is a behavior (default: False, assume functional).\n\n    Returns:\n        The probability tensor \\(V[a, b, x, y]\\) in Full Probability notation (oa=2, ob=2).\n\n    !!! Note\n        This function is adapted from the QETLAB MATLAB package function ``FC2FP`` [@QETLAB].\n        For `behavior=True`, it applies the standard formula relating probabilities to correlators:\n        \\(P(a', b' | x, y) = (1 + a'\\langle A_x \\rangle + b'\\langle B_y \\rangle +\\)\n        \\(a'b'\\langle A_x B_y \\rangle) / 4\\),\n        where \\(a', b' \\in \\{+1, -1\\}\\).\n        Crucially, it uses the values \\(\\langle A_x \\rangle\\) and \\(\\langle B_y \\rangle\\) directly\n        from the input ``fc_mat``. If this input matrix was generated using a convention where these\n        entries represent *averaged* marginal correlators (like the output of ``fp_to_fc(..., behavior=True)``),\n        the resulting FP tensor might not represent a valid probability distribution (e.g., entries could be negative).\n\n    \"\"\"\n    ia = fc_mat.shape[0] - 1\n    ib = fc_mat.shape[1] - 1\n    # Assumes oa=2, ob=2 based on FC notation structure\n    oa, ob = 2, 2\n    v_mat = np.zeros((oa, ob, ia, ib))\n\n    if not behavior:\n        # Functional case logic\n        k_term = fc_mat[0, 0] / (ia * ib) if ia &gt; 0 and ib &gt; 0 else 0\n        for x in range(ia):\n            ax_term = fc_mat[1 + x, 0] / ib if ib &gt; 0 else 0\n            for y in range(ib):\n                by_term = fc_mat[0, 1 + y] / ia if ia &gt; 0 else 0\n                axby_term = fc_mat[1 + x, 1 + y]\n                # V[0,0,x,y] = P(++,xy) coefficient\n                v_mat[0, 0, x, y] = k_term + ax_term + by_term + axby_term\n                # V[0,1,x,y] = P(+-,xy) coefficient\n                v_mat[0, 1, x, y] = k_term + ax_term - by_term - axby_term\n                # V[1,0,x,y] = P(-+,xy) coefficient\n                v_mat[1, 0, x, y] = k_term - ax_term + by_term - axby_term\n                # V[1,1,x,y] = P(--,xy) coefficient\n                v_mat[1, 1, x, y] = k_term - ax_term - by_term + axby_term\n    else:\n        for x in range(ia):\n            ax_val = fc_mat[1 + x, 0]\n            for y in range(ib):\n                by_val = fc_mat[0, 1 + y]\n                axby_val = fc_mat[1 + x, 1 + y]\n                # V[0,0,x,y] = P(++,xy) = (1 + &lt;Ax&gt; + &lt;By&gt; + &lt;AxBy&gt;)/4\n                v_mat[0, 0, x, y] = 1 + ax_val + by_val + axby_val\n                # V[0,1,x,y] = P(+-,xy) = (1 + &lt;Ax&gt; - &lt;By&gt; - &lt;AxBy&gt;)/4\n                v_mat[0, 1, x, y] = 1 + ax_val - by_val - axby_val\n                # V[1,0,x,y] = P(-+,xy) = (1 - &lt;Ax&gt; + &lt;By&gt; - &lt;AxBy&gt;)/4\n                v_mat[1, 0, x, y] = 1 - ax_val + by_val - axby_val\n                # V[1,1,x,y] = P(--,xy) = (1 - &lt;Ax&gt; - &lt;By&gt; + &lt;AxBy&gt;)/4\n                v_mat[1, 1, x, y] = 1 - ax_val - by_val + axby_val\n        v_mat = v_mat / 4\n\n    return v_mat\n</code></pre>"},{"location":"reference/toqito/state_opt/bell_notation_conversions/#toqito.state_opt.bell_notation_conversions.fp_to_cg","title":"fp_to_cg","text":"<pre><code>fp_to_cg(v_mat: ndarray, behavior: bool = False) -&gt; ndarray\n</code></pre> <p>Convert a Bell functional or behavior from Full Probability (FP) to Collins-Gisin (CG) notation.</p> <p>The Full Probability (FP) notation represents the full probability distribution \\(V(a, b, x, y) = P(a, b | x, y)\\), where \\(a\\) (0 to \\(oa-1\\)), \\(b\\) (0 to \\(ob-1\\)) are outcomes and \\(x\\) (0 to \\(ia-1\\)), \\(y\\)  (0 to \\(ib-1\\)) are inputs. It's stored as a 4D numpy array \\(V[a, b, x, y]\\). The Collins-Gisin (CG) notation for a Bell functional or behavior is represented by a matrix (see :cg_to_fc).</p> <p>This function converts from FP to CG notation.</p> <p>Examples:</p> <p>Consider the CHSH inequality functional in FP notation: (Here V represents coefficients, not probabilities)</p> <pre><code>import numpy as np\nfrom toqito.state_opt.bell_notation_conversions import fp_to_cg\nchsh_fp = np.zeros((2, 2, 2, 2))\nchsh_fp[0, 0, 0, 0] = 1\nchsh_fp[0, 0, 0, 1] = -1\nchsh_fp[0, 0, 1, 0] = -1\nchsh_fp[0, 0, 1, 1] = 1\nprint(fp_to_cg(chsh_fp))\n</code></pre> <p>[[ 0.  0.  0.]  [ 0.  1. -1.]  [ 0. -1.  1.]]</p> <p>Consider a behavior (probability distribution) in FP notation (standard PR box):</p> <pre><code>import numpy as np\nfrom toqito.state_opt.bell_notation_conversions import fp_to_cg\npr_box = np.zeros((2, 2, 2, 2))\npr_box[0, 0, 0, 0] = 0.5 # p(0,0|0,0)\npr_box[1, 1, 0, 0] = 0.5 # p(1,1|0,0)\npr_box[0, 0, 0, 1] = 0.5 # p(0,0|0,1)\npr_box[1, 1, 0, 1] = 0.5 # p(1,1|0,1)\npr_box[0, 0, 1, 0] = 0.5 # p(0,0|1,0)\npr_box[1, 1, 1, 0] = 0.5 # p(1,1|1,0)\npr_box[0, 1, 1, 1] = 0.5 # p(0,1|1,1)\npr_box[1, 0, 1, 1] = 0.5 # p(1,0|1,1)\nprint(fp_to_cg(pr_box, behavior=True))\n</code></pre> <p>[[1.  0.5 0.5]  [0.5 0.5 0.5]  [0.5 0.5 0. ]]</p> <p>Parameters:</p> <ul> <li> <code>v_mat</code>               (<code>ndarray</code>)           \u2013            <p>The probability tensor \\(V[a, b, x, y]\\) in Full Probability notation.</p> </li> <li> <code>behavior</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, assume input is a behavior (default: False, assume functional).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>The matrix in Collins-Gisin notation.</p> </li> </ul> <p>Note</p> <p>This function is adapted from the QETLAB MATLAB package function <code>FP2CG</code>. For <code>behavior=True</code>, it uses the QETLAB convention for calculating marginal probabilities, summing over the other party's outcomes for a fixed input setting of the other party (\\(y=0\\) for Alice's marginal \\(p_A(a|x)\\), \\(x=0\\) for Bob's marginal \\(p_B(b|y)\\)).</p> Source code in <code>toqito/state_opt/bell_notation_conversions.py</code> <pre><code>def fp_to_cg(v_mat: np.ndarray, behavior: bool = False) -&gt; np.ndarray:\n    r\"\"\"Convert a Bell functional or behavior from Full Probability (FP) to Collins-Gisin (CG) notation.\n\n    The Full Probability (FP) notation represents the full probability distribution\n    \\(V(a, b, x, y) = P(a, b | x, y)\\), where \\(a\\) (0 to \\(oa-1\\)), \\(b\\) (0 to \\(ob-1\\)) are\n    outcomes and \\(x\\) (0 to \\(ia-1\\)), \\(y\\)  (0 to \\(ib-1\\)) are inputs. It's stored as a 4D\n    numpy array \\(V[a, b, x, y]\\). The Collins-Gisin (CG) notation for a Bell functional or\n    behavior is represented by a matrix (see :[cg_to_fc][toqito.state_opt.bell_notation_conversions.cg_to_fc]).\n\n    This function converts from FP to CG notation.\n\n    Examples:\n        Consider the CHSH inequality functional in FP notation:\n        (Here V represents coefficients, not probabilities)\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.state_opt.bell_notation_conversions import fp_to_cg\n        chsh_fp = np.zeros((2, 2, 2, 2))\n        chsh_fp[0, 0, 0, 0] = 1\n        chsh_fp[0, 0, 0, 1] = -1\n        chsh_fp[0, 0, 1, 0] = -1\n        chsh_fp[0, 0, 1, 1] = 1\n        print(fp_to_cg(chsh_fp))\n        ```\n\n        Consider a behavior (probability distribution) in FP notation (standard PR box):\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.state_opt.bell_notation_conversions import fp_to_cg\n        pr_box = np.zeros((2, 2, 2, 2))\n        pr_box[0, 0, 0, 0] = 0.5 # p(0,0|0,0)\n        pr_box[1, 1, 0, 0] = 0.5 # p(1,1|0,0)\n        pr_box[0, 0, 0, 1] = 0.5 # p(0,0|0,1)\n        pr_box[1, 1, 0, 1] = 0.5 # p(1,1|0,1)\n        pr_box[0, 0, 1, 0] = 0.5 # p(0,0|1,0)\n        pr_box[1, 1, 1, 0] = 0.5 # p(1,1|1,0)\n        pr_box[0, 1, 1, 1] = 0.5 # p(0,1|1,1)\n        pr_box[1, 0, 1, 1] = 0.5 # p(1,0|1,1)\n        print(fp_to_cg(pr_box, behavior=True))\n        ```\n\n    Args:\n        v_mat: The probability tensor \\(V[a, b, x, y]\\) in Full Probability notation.\n        behavior: If True, assume input is a behavior (default: False, assume functional).\n\n    Returns:\n        The matrix in Collins-Gisin notation.\n\n    !!! Note\n        This function is adapted from the QETLAB MATLAB package function ``FP2CG``.\n        For ``behavior=True``, it uses the QETLAB convention for calculating marginal probabilities,\n        summing over the other party's outcomes for a *fixed* input setting of the other party\n        (\\(y=0\\) for Alice's marginal \\(p_A(a|x)\\), \\(x=0\\) for Bob's marginal \\(p_B(b|y)\\)).\n\n    \"\"\"\n    oa, ob, ia, ib = v_mat.shape\n\n    alice_pars = max(0, ia * (oa - 1)) + 1 if oa &gt; 0 else 0\n    bob_pars = max(0, ib * (ob - 1)) + 1 if ob &gt; 0 else 0\n\n    if alice_pars == 0 or bob_pars == 0:\n        if behavior:\n            raise ValueError(\"behavior case requires non-zero outputs (oa&gt;0, ob&gt;0).\")\n        cg_mat = np.zeros((alice_pars, bob_pars))\n        return cg_mat\n\n    cg_mat = np.zeros((alice_pars, bob_pars))\n\n    def _cg_row_index(a: int, x: int) -&gt; int:\n        r\"\"\"Calculate 0-based CG matrix row index for Alice.\n\n        Outcome \\(a\\) (0..\\(oa-2\\)) and input \\(x\\) (0..\\(ia-1\\)).\n        \"\"\"\n        return 1 + a + x * (oa - 1)\n\n    def _cg_col_index(b: int, y: int) -&gt; int:\n        r\"\"\"Calculate 0-based CG matrix col index for Bob.\n\n        Outcome \\(b\\) (0..\\(ob-2\\)) and input \\(y\\) (0..\\(ib-1\\)).\n        \"\"\"\n        return 1 + b + y * (ob - 1)\n\n    if not behavior:\n        # Functional case logic\n        cg_mat[0, 0] = np.sum(v_mat[oa - 1, ob - 1, :, :])\n\n        if oa &gt; 1:\n            for a in range(oa - 1):\n                for x in range(ia):\n                    cg_mat[_cg_row_index(a, x), 0] = np.sum(v_mat[a, ob - 1, x, :] - v_mat[oa - 1, ob - 1, x, :])\n\n        if ob &gt; 1:\n            for b in range(ob - 1):\n                for y in range(ib):\n                    cg_mat[0, _cg_col_index(b, y)] = np.sum(v_mat[oa - 1, b, :, y] - v_mat[oa - 1, ob - 1, :, y])\n\n        if oa &gt; 1 and ob &gt; 1:\n            for a in range(oa - 1):\n                for b in range(ob - 1):\n                    for x in range(ia):\n                        for y in range(ib):\n                            row_idx_0based = _cg_row_index(a, x)\n                            col_idx_0based = _cg_col_index(b, y)\n                            cg_mat[row_idx_0based, col_idx_0based] = (\n                                v_mat[a, b, x, y]\n                                - v_mat[a, ob - 1, x, y]\n                                - v_mat[oa - 1, b, x, y]\n                                + v_mat[oa - 1, ob - 1, x, y]\n                            )\n\n    else:\n        cg_mat[0, 0] = 1.0  # Set K=1 for behavior\n\n        if oa &gt; 1 and ib &gt; 0:\n            for x in range(ia):\n                for a in range(oa - 1):\n                    target_row_0based = _cg_row_index(a, x)\n                    cg_mat[target_row_0based, 0] = np.sum(v_mat[a, :, x, 0])\n        elif oa &gt; 1 and ib == 0:\n            pass  # Already initialized to 0\n\n        if ob &gt; 1 and ia &gt; 0:\n            for y in range(ib):\n                for b in range(ob - 1):\n                    target_col_0based = _cg_col_index(b, y)\n                    cg_mat[0, target_col_0based] = np.sum(v_mat[:, b, 0, y])\n        elif ob &gt; 1 and ia == 0:\n            pass\n\n        if oa &gt; 1 and ob &gt; 1:\n            for x in range(ia):\n                for y in range(ib):\n                    for a in range(oa - 1):\n                        target_row_0based = _cg_row_index(a, x)\n                        for b in range(ob - 1):\n                            target_col_0based = _cg_col_index(b, y)\n                            cg_mat[target_row_0based, target_col_0based] = v_mat[a, b, x, y]\n\n    return cg_mat\n</code></pre>"},{"location":"reference/toqito/state_opt/bell_notation_conversions/#toqito.state_opt.bell_notation_conversions.fp_to_fc","title":"fp_to_fc","text":"<pre><code>fp_to_fc(v_mat: ndarray, behavior: bool = False) -&gt; ndarray\n</code></pre> <p>Convert a Bell functional or behavior from Full Probability (FP) to Full Correlator (FC) notation.</p> <p>Assumes binary outcomes (\\(oa=2\\), \\(ob=2\\)). The FP tensor indices \\(a, b = 0, 1\\) correspond to physical outcomes \\(+1, -1\\) respectively.</p> <p>The Full Probability (FP) notation represents the full probability distribution \\(V(a, b, x, y) = P(\\text{out}_A=a', \\text{out}_B=b' | x, y)\\), where \\(a=0 \\rightarrow a'=+1\\), \\(a=1 \\rightarrow a'=-1\\) (similarly for \\(b\\)), stored as a 4D numpy array \\(V[a, b, x, y]\\). The Full Correlator (FC) notation is represented by a matrix (see fc_to_cg).</p> <p>This function converts from FP to FC notation.</p> <p>Examples:</p> <p>Consider the CHSH inequality functional in FP notation: (Here V represents coefficients, not probabilities)</p> <pre><code>import numpy as np\nfrom toqito.state_opt.bell_notation_conversions import fp_to_fc, fc_to_fp\nchsh_fc = np.array([[0, 0, 0], [0, 0.25, -0.25], [0, -0.25, 0.25]])\nchsh_fp = fc_to_fp(chsh_fc)\nprint(fp_to_fc(chsh_fp))\n</code></pre> <p>[[ 0.    0.    0.  ]  [ 0.    0.25 -0.25]  [ 0.   -0.25  0.25]]</p> <p>Consider a behavior (probability distribution) in FP notation (standard PR box):</p> <pre><code>import numpy as np\nfrom toqito.state_opt.bell_notation_conversions import fp_to_fc\npr_box = np.zeros((2, 2, 2, 2))\npr_box[0, 0, 0, 0] = 0.5 # p(0,0|0,0)\npr_box[1, 1, 0, 0] = 0.5 # p(1,1|0,0)\npr_box[0, 0, 0, 1] = 0.5 # p(0,0|0,1)\npr_box[1, 1, 0, 1] = 0.5 # p(1,1|0,1)\npr_box[0, 0, 1, 0] = 0.5 # p(0,0|1,0)\npr_box[1, 1, 1, 0] = 0.5 # p(1,1|1,0)\npr_box[0, 1, 1, 1] = 0.5 # p(0,1|1,1)\npr_box[1, 0, 1, 1] = 0.5 # p(1,0|1,1)\nprint(fp_to_fc(pr_box, behavior=True))\n</code></pre> <p>[[ 1.  0.  0.]  [ 0.  1.  1.]  [ 0.  1. -1.]]</p> <p>Parameters:</p> <ul> <li> <code>v_mat</code>               (<code>ndarray</code>)           \u2013            <p>The probability tensor \\(V[a, b, x, y]\\)               in Full Probability notation (:math:<code>oa=2</code>, :math:<code>ob=2</code>).</p> </li> <li> <code>behavior</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, assume input is a behavior (default: False, assume functional).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>The matrix in Full Correlator notation.</p> </li> </ul> <p>Note</p> <p>This function is adapted from the QETLAB MATLAB package function <code>FP2FC</code>. For <code>behavior=True</code>, it calculates the average marginal correlators \\(\\langle A_x \\rangle\\) and \\(\\langle B_y \\rangle\\) by summing over the other party's inputs and dividing by the number of inputs (\\(ib\\) or \\(ia\\)). The joint correlators \\(\\langle A_x B_y \\rangle\\) are calculated directly for each (\\(x\\), \\(y\\)).</p> Source code in <code>toqito/state_opt/bell_notation_conversions.py</code> <pre><code>def fp_to_fc(v_mat: np.ndarray, behavior: bool = False) -&gt; np.ndarray:\n    r\"\"\"Convert a Bell functional or behavior from Full Probability (FP) to Full Correlator (FC) notation.\n\n    Assumes binary outcomes (\\(oa=2\\), \\(ob=2\\)). The FP tensor indices \\(a, b = 0, 1\\)\n    correspond to physical outcomes \\(+1, -1\\) respectively.\n\n    The Full Probability (FP) notation represents the full probability distribution\n    \\(V(a, b, x, y) = P(\\text{out}_A=a', \\text{out}_B=b' | x, y)\\), where\n    \\(a=0 \\rightarrow a'=+1\\), \\(a=1 \\rightarrow a'=-1\\) (similarly for \\(b\\)),\n    stored as a 4D numpy array \\(V[a, b, x, y]\\).\n    The Full Correlator (FC) notation is represented by a matrix\n    (see [fc_to_cg][toqito.state_opt.bell_notation_conversions.fc_to_cg]).\n\n    This function converts from FP to FC notation.\n\n    Examples:\n        Consider the CHSH inequality functional in FP notation:\n        (Here V represents coefficients, not probabilities)\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.state_opt.bell_notation_conversions import fp_to_fc, fc_to_fp\n        chsh_fc = np.array([[0, 0, 0], [0, 0.25, -0.25], [0, -0.25, 0.25]])\n        chsh_fp = fc_to_fp(chsh_fc)\n        print(fp_to_fc(chsh_fp))\n        ```\n\n        Consider a behavior (probability distribution) in FP notation (standard PR box):\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.state_opt.bell_notation_conversions import fp_to_fc\n        pr_box = np.zeros((2, 2, 2, 2))\n        pr_box[0, 0, 0, 0] = 0.5 # p(0,0|0,0)\n        pr_box[1, 1, 0, 0] = 0.5 # p(1,1|0,0)\n        pr_box[0, 0, 0, 1] = 0.5 # p(0,0|0,1)\n        pr_box[1, 1, 0, 1] = 0.5 # p(1,1|0,1)\n        pr_box[0, 0, 1, 0] = 0.5 # p(0,0|1,0)\n        pr_box[1, 1, 1, 0] = 0.5 # p(1,1|1,0)\n        pr_box[0, 1, 1, 1] = 0.5 # p(0,1|1,1)\n        pr_box[1, 0, 1, 1] = 0.5 # p(1,0|1,1)\n        print(fp_to_fc(pr_box, behavior=True))\n        ```\n\n    Args:\n        v_mat: The probability tensor \\(V[a, b, x, y]\\)\n                          in Full Probability notation (:math:`oa=2`, :math:`ob=2`).\n        behavior: If True, assume input is a behavior (default: False, assume functional).\n\n    Returns:\n        The matrix in Full Correlator notation.\n\n    !!! Note\n        This function is adapted from the QETLAB MATLAB package function ``FP2FC``.\n        For ``behavior=True``, it calculates the *average* marginal correlators \\(\\langle A_x \\rangle\\)\n        and \\(\\langle B_y \\rangle\\) by summing over the other party's inputs\n        and dividing by the number of inputs (\\(ib\\) or \\(ia\\)).\n        The joint correlators \\(\\langle A_x B_y \\rangle\\) are calculated directly for each (\\(x\\), \\(y\\)).\n\n    \"\"\"\n    oa, ob, ia, ib = v_mat.shape\n\n    if oa != 2 or ob != 2:\n        raise ValueError(\"FP to FC conversion currently only supports binary outcomes (oa=2, ob=2).\")\n\n    fc_mat = np.zeros((1 + ia, 1 + ib))\n\n    fc_mat[0, 0] = np.sum(v_mat)  # K' = sum(V), used for functional case\n\n    for x in range(ia):\n        fc_mat[x + 1, 0] = np.sum(v_mat[0, :, x, :]) - np.sum(v_mat[1, :, x, :])\n\n    for y in range(ib):\n        fc_mat[0, 1 + y] = np.sum(v_mat[:, 0, :, y]) - np.sum(v_mat[:, 1, :, y])\n\n    # Calculate E[AxBy] for each (x,y) -&gt; FC[x+1, y+1] component\n    for x in range(ia):\n        for y in range(ib):\n            fc_mat[x + 1, y + 1] = v_mat[0, 0, x, y] - v_mat[0, 1, x, y] - v_mat[1, 0, x, y] + v_mat[1, 1, x, y]\n\n    if not behavior:\n        fc_mat = fc_mat / 4\n    else:\n        fc_mat[0, 0] = 1\n        if ib &gt; 0:\n            fc_mat[1:, 0] = fc_mat[1:, 0] / ib\n        else:\n            # If no Bob inputs, average marginal &lt;Ax&gt; is 0.\n            fc_mat[1:, 0] = 0\n        if ia &gt; 0:\n            fc_mat[0, 1:] = fc_mat[0, 1:] / ia\n        else:\n            # If no Alice inputs, average marginal &lt;By&gt; is 0.\n            fc_mat[0, 1:] = 0\n\n    return fc_mat\n</code></pre>"},{"location":"reference/toqito/state_opt/npa_hierarchy/","title":"npa_hierarchy","text":""},{"location":"reference/toqito/state_opt/npa_hierarchy/#toqito.state_opt.npa_hierarchy","title":"npa_hierarchy","text":"<p>Generates the NPA constraints.</p>"},{"location":"reference/toqito/state_opt/npa_hierarchy/#toqito.state_opt.npa_hierarchy.npa_constraints","title":"npa_constraints","text":"<pre><code>npa_constraints(assemblage: dict[tuple[int, int], Variable], k: int | str = 1, referee_dim: int = 1, no_signaling: bool = True) -&gt; list[Constraint]\n</code></pre> <p>Generate the constraints specified by the NPA hierarchy up to a finite level.</p> <p><sup>1</sup></p> <p>You can determine the level of the hierarchy by a positive integer or a string of a form like \"1+ab+aab\", which indicates that an intermediate level of the hierarchy should be used, where this example uses all products of 1 measurement, all products of one Alice and one Bob measurement, and all products of two Alice and one Bob measurement.</p> <p>The commuting measurement assemblage operator must be given as a dictionary. The keys are tuples of Alice and Bob questions \\(x, y\\) and the values are cvxpy Variables which are matrices with entries:</p> \\[     K_{xy}\\Big(i + a \\cdot dim_R, j + b \\cdot dim_R \\Big) =     \\langle i| \\text{Tr}_{\\mathcal{H}} \\Big( \\big(         I_R \\otimes A_a^x B_b^y \\big) \\sigma \\Big) |j \\rangle \\] <p>Parameters:</p> <ul> <li> <code>assemblage</code>               (<code>dict[tuple[int, int], Variable]</code>)           \u2013            <p>The commuting measurement assemblage operator.</p> </li> <li> <code>k</code>               (<code>int | str</code>, default:                   <code>1</code> )           \u2013            <p>The level of the NPA hierarchy to use (default=1).</p> </li> <li> <code>referee_dim</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The dimension of the referee's quantum system (default=1).</p> </li> <li> <code>no_signaling</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>bool</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Constraint]</code>           \u2013            <p>A list of cvxpy constraints.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Navascu\u00e9s, Miguel and Pironio, Stefano and Ac\u00edn, Antonio. A convergent hierarchy of semidefinite programs characterizing the set of quantum correlations. New Journal of Physics. vol. 10(7). (2008). doi:10.1088/1367-2630/10/7/073013.</p> Source code in <code>toqito/state_opt/npa_hierarchy.py</code> <pre><code>def npa_constraints(\n    assemblage: dict[tuple[int, int], cvxpy.Variable], k: int | str = 1, referee_dim: int = 1, no_signaling: bool = True\n) -&gt; list[cvxpy.constraints.constraint.Constraint]:\n    r\"\"\"Generate the constraints specified by the NPA hierarchy up to a finite level.\n\n    [@Navascues_2008_AConvergent]\n\n    You can determine the level of the hierarchy by a positive integer or a string\n    of a form like \"1+ab+aab\", which indicates that an intermediate level of the hierarchy\n    should be used, where this example uses all products of 1 measurement, all products of\n    one Alice and one Bob measurement, and all products of two Alice and one Bob measurement.\n\n    The commuting measurement assemblage operator must be given as a dictionary. The keys are\n    tuples of Alice and Bob questions \\(x, y\\) and the values are cvxpy Variables which\n    are matrices with entries:\n\n    \\[\n        K_{xy}\\Big(i + a \\cdot dim_R, j + b \\cdot dim_R \\Big) =\n        \\langle i| \\text{Tr}_{\\mathcal{H}} \\Big( \\big(\n            I_R \\otimes A_a^x B_b^y \\big) \\sigma \\Big) |j \\rangle\n    \\]\n\n    Args:\n        assemblage: The commuting measurement assemblage operator.\n        k: The level of the NPA hierarchy to use (default=1).\n        referee_dim: The dimension of the referee's quantum system (default=1).\n        no_signaling: bool\n\n    Returns:\n        A list of cvxpy constraints.\n\n    \"\"\"\n    a_out, a_in, b_out, b_in = _get_nonlocal_game_params(assemblage, referee_dim)\n\n    words = _gen_words(k, a_out, a_in, b_out, b_in)\n    dim = len(words)\n\n    if dim == 0:\n        # Should not happen if IDENTITY_SYMBOL is always included\n        raise ValueError(\"Generated word list is empty. Check _gen_words logic.\")\n\n    # Moment matrix (Gamma matrix in [@Navascues_2008_AConvergent])\n    # moment_matrix_R block corresponds to E[S_i^dagger S_j]\n    moment_matrix_R = cvxpy.Variable((referee_dim * dim, referee_dim * dim), hermitian=True, name=\"R\")\n\n    # Referee's effective state rho_R = E[I]\n    # This is the (0,0) block of moment_matrix_R since words[0] is Identity\n    rho_R_referee = moment_matrix_R[0:referee_dim, 0:referee_dim]\n\n    # Ensure rho_R_referee is a valid quantum state\n    constraints = [\n        cvxpy.trace(rho_R_referee) == 1,\n        moment_matrix_R &gt;&gt; 0,\n        # rho_R_referee &gt;&gt; 0 holds since it is a minor of moment_matrix_R\n    ]\n\n    # Store relations for (S_i^dagger S_j) -&gt; block_index in moment_matrix_R\n    # This helps enforce \u0393(S_i^dagger S_j) = \u0393(S_k^dagger S_l) if products are algebraically equal\n    seen_reduced_products = {}\n\n    for i in range(dim):\n        for j in range(i, dim):  # Iterate over upper triangle including diagonal\n            word_i_conj = tuple(reversed(words[i]))  # S_i^dagger\n\n            # The product S_i^dagger S_j\n            # For _reduce, ensure no IDENTITY_SYMBOL unless it's the only element.\n            # If word_i_conj is (ID,), S_i_dagger_S_j is S_j. If word_j is (ID,), it's S_i_dagger.\n            # If both are (ID,), product is (ID,).\n\n            product_unreduced = []\n            if word_i_conj != (IDENTITY_SYMBOL,):\n                product_unreduced.extend(list(word_i_conj))\n            if words[j] != (IDENTITY_SYMBOL,):\n                product_unreduced.extend(list(words[j]))\n\n            # This happens if both words[i] and words[j] were IDENTITY_SYMBOL\n            if not product_unreduced:\n                product_S_i_adj_S_j = (IDENTITY_SYMBOL,)\n            else:\n                product_S_i_adj_S_j = _reduce(tuple(product_unreduced))\n\n            # Moment matrix (Gamma matrix in NPA paper [@Navascues_2008_AConvergent] - arXiv:0803.4290)\n            # This hierarchy can be generalized, e.g., to incorporate referee systems\n            # as seen in extended nonlocal games (see, e.g., F. Speelman's thesis, [@Speelman_2016_Position]).\n            current_block = moment_matrix_R[\n                i * referee_dim : (i + 1) * referee_dim, j * referee_dim : (j + 1) * referee_dim\n            ]\n\n            if _is_zero(product_S_i_adj_S_j):  # Product is algebraically zero\n                constraints.append(current_block == 0)\n            elif _is_identity(product_S_i_adj_S_j):  # Product is identity operator\n                # This occurs for (i,j) where S_i^dagger S_j = I. e.g. S_i = S_j and S_i is unitary (proj).\n                # Or i=0, j=0 (I^dagger I = I).\n                # This means current_block should be rho_R_referee if product_S_i_adj_S_j is I\n                constraints.append(current_block == rho_R_referee)\n\n            # Product is A_a^x B_b^y\n            elif _is_meas(product_S_i_adj_S_j):\n                alice_symbol, bob_symbol = product_S_i_adj_S_j\n                constraints.append(\n                    current_block\n                    == assemblage[alice_symbol.question, bob_symbol.question][\n                        alice_symbol.answer * referee_dim : (alice_symbol.answer + 1) * referee_dim,\n                        bob_symbol.answer * referee_dim : (bob_symbol.answer + 1) * referee_dim,\n                    ]\n                )\n            # Product is A_a^x or B_b^y (i.e., only one player involved)\n            elif _is_meas_on_one_player(product_S_i_adj_S_j):  # Product is A_a^x or B_b^y\n                symbol = product_S_i_adj_S_j[0]\n                if symbol.player == \"Alice\":\n                    # Sum over Bob's outcomes for a fixed Bob question (e.g., y=0)\n                    # E[A_a^x] = sum_b K_x0(a,b)\n                    sum_over_bob_outcomes = sum(\n                        assemblage[symbol.question, 0][  # Assuming y=0 for Bob's marginal\n                            symbol.answer * referee_dim : (symbol.answer + 1) * referee_dim,\n                            b_ans * referee_dim : (b_ans + 1) * referee_dim,\n                        ]\n                        for b_ans in range(b_out)\n                    )\n                    constraints.append(current_block == sum_over_bob_outcomes)\n                else:  # elif symbol.player == \"Bob\":\n                    # Sum over Alice's outcomes for a fixed Alice question (e.g., x=0)\n                    # E[B_b^y] = sum_a K_0y(a,b)\n                    sum_over_alice_outcomes = sum(\n                        assemblage[0, symbol.question][  # Assuming x=0 for Alice's marginal\n                            a_ans * referee_dim : (a_ans + 1) * referee_dim,\n                            symbol.answer * referee_dim : (symbol.answer + 1) * referee_dim,\n                        ]\n                        for a_ans in range(a_out)\n                    )\n                    constraints.append(current_block == sum_over_alice_outcomes)\n            elif product_S_i_adj_S_j in seen_reduced_products:\n                # This product S_k has been seen before as S_p^dagger S_q\n                # So, \u0393(S_i, S_j) = \u0393(S_p, S_q)\n                prev_i, prev_j = seen_reduced_products[product_S_i_adj_S_j]\n                # Make sure to get the upper triangle element if current (i,j) is lower\n                # The prev_i, prev_j should always refer to an upper triangle element by construction.\n                previous_block = moment_matrix_R[\n                    prev_i * referee_dim : (prev_i + 1) * referee_dim, prev_j * referee_dim : (prev_j + 1) * referee_dim\n                ]\n                constraints.append(current_block == previous_block)\n            else:\n                # First time seeing this operator product S_k\n                seen_reduced_products[product_S_i_adj_S_j] = (i, j)\n\n    # Constraints on the assemblage K_xy(a,b) itself --always apply all of these constraints!\n    for x_alice_in in range(a_in):\n        for y_bob_in in range(b_in):\n            # Positivity: K_xy(a,b) &gt;= 0 (operator PSD)\n            for a_alice_out in range(a_out):\n                for b_bob_out in range(b_out):\n                    assemblage_block = assemblage[x_alice_in, y_bob_in][\n                        a_alice_out * referee_dim : (a_alice_out + 1) * referee_dim,\n                        b_bob_out * referee_dim : (b_bob_out + 1) * referee_dim,\n                    ]\n                    constraints.append(assemblage_block &gt;&gt; 0)\n\n            # Normalization: Sum_{a,b} K_xy(a,b) = rho_R\n            sum_over_outcomes_ab = sum(\n                assemblage[x_alice_in, y_bob_in][\n                    a * referee_dim : (a + 1) * referee_dim, b * referee_dim : (b + 1) * referee_dim\n                ]\n                for a in range(a_out)\n                for b in range(b_out)\n            )\n            constraints.append(sum_over_outcomes_ab == rho_R_referee)\n    if no_signaling:\n        # No-signaling constraints on assemblage - ALWAYS APPLY\n        # Bob's marginal rho_B(b|y) = Sum_a K_xy(a,b) must be independent of x\n        for y_bob_in in range(b_in):\n            for b_bob_out in range(b_out):\n                sum_over_a_for_x0 = sum(\n                    assemblage[0, y_bob_in][\n                        a * referee_dim : (a + 1) * referee_dim, b_bob_out * referee_dim : (b_bob_out + 1) * referee_dim\n                    ]\n                    for a in range(a_out)\n                )\n                for x_alice_in in range(1, a_in):\n                    sum_over_a_for_x_current = sum(\n                        assemblage[x_alice_in, y_bob_in][\n                            a * referee_dim : (a + 1) * referee_dim,\n                            b_bob_out * referee_dim : (b_bob_out + 1) * referee_dim,\n                        ]\n                        for a in range(a_out)\n                    )\n                    constraints.append(sum_over_a_for_x0 == sum_over_a_for_x_current)\n\n        # Alice's marginal rho_A(a|x) = Sum_b K_xy(a,b) must be independent of y\n        for x_alice_in in range(a_in):\n            for a_alice_out in range(a_out):  # For each Alice outcome a\n                sum_over_b_for_y0 = sum(\n                    assemblage[x_alice_in, 0][\n                        a_alice_out * referee_dim : (a_alice_out + 1) * referee_dim,\n                        b * referee_dim : (b + 1) * referee_dim,\n                    ]\n                    for b in range(b_out)\n                )\n                for y_bob_in in range(1, b_in):\n                    sum_over_b_for_y_current = sum(\n                        assemblage[x_alice_in, y_bob_in][\n                            a_alice_out * referee_dim : (a_alice_out + 1) * referee_dim,\n                            b * referee_dim : (b + 1) * referee_dim,\n                        ]\n                        for b in range(b_out)\n                    )\n                    constraints.append(sum_over_b_for_y0 == sum_over_b_for_y_current)\n\n    return constraints\n</code></pre>"},{"location":"reference/toqito/state_opt/npa_hierarchy/#toqito.state_opt.npa_hierarchy.bell_npa_constraints","title":"bell_npa_constraints","text":"<pre><code>bell_npa_constraints(p_var: Variable, desc: list[int], k: int | str = 1) -&gt; list[Constraint]\n</code></pre> <p>Generate NPA hierarchy constraints for Bell inequalities <sup>1</sup>.</p> <p>The constraints are based on the positivity of a moment matrix constructed from measurement operators. This function generates constraints for a CVXPY variable representing probabilities or correlations in the Collins-Gisin notation. <sup>2</sup></p> <p>The level of the hierarchy <code>k</code> can be an integer (standard NPA level) or a string specifying intermediate levels (e.g., \"1+ab\", \"2+aab\").</p> <p>The input <code>p_var</code> is a CVXPY variable representing the probabilities in the Collins-Gisin (CG) notation. It should have dimensions \\(((oa-1) \\times ma+1, (ob-1) \\times mb+1)\\), where \\(oa, ob\\) are the number of outputs and \\(ma, mb\\) are the number of inputs for Alice and Bob, respectively, as specified in <code>desc</code> = [\\(oa\\), \\(ob\\), \\(ma\\), \\(mb\\)]. The entries of <code>p_var</code> correspond to: - <code>p_var[0, 0]</code>: The overall probability (should be 1). - <code>p_var[i, 0]</code> (for \\(i &gt; 0\\)): Marginal probabilities/correlations for Alice. - <code>p_var[0, j]</code> (for \\(j &gt; 0\\)): Marginal probabilities/correlations for Bob. - <code>p_var[i, j]</code> (for \\(i &gt; 0, j &gt; 0\\)): Joint probabilities/correlations for Alice and Bob.</p> <p>The mapping from indices \\((i, j)\\) to specific operators depends on the ordering defined by <code>desc</code>. Specifically, if \\(i = (oa-1) \\times x + a + 1\\) and \\(j = (ob-1) \\times y + b + 1\\)</p> <ul> <li><code>p_var[i, 0]</code> corresponds to the expectation of Alice's operator                   \\(A_{a|x}\\) (using \\(0\\) to \\(oa-2\\) for \\(a\\)).</li> <li><code>p_var[0, j]</code> corresponds to the expectation of Bob's operator                   \\(B_{b|y}\\) (using \\(0\\) to \\(ob-2\\) for \\(b\\)).</li> <li><code>p_var[i, j]</code> corresponds to the expectation of the product \\(A_{a|x} B_{b|y}\\).</li> </ul> <p>Examples:</p> <p>Consider the CHSH inequality scenario with <code>desc = [2, 2, 2, 2]</code>. We want to generate the NPA level 1 constraints.</p> <pre><code>import cvxpy\nimport numpy as np\nfrom toqito.state_opt.npa_hierarchy import bell_npa_constraints\ndesc = [2, 2, 2, 2]\noa, ob, ma, mb = desc\np_var_dim = ((oa - 1) * ma + 1, (ob - 1) * mb + 1)\np_var = cvxpy.Variable(p_var_dim, name=\"p_cg\")\nconstraints = bell_npa_constraints(p_var, desc, k=1)\nprint(len(constraints))\nprint(constraints[0])\n</code></pre> <p>14 Gamma + Promote(-0.0, (5, 5)) &gt;&gt; 0</p> <p>We can also use intermediate levels, like \"1+ab\":</p> <pre><code>constraints_1ab = bell_npa_constraints(p_var, desc, k=\"1+ab\")\nprint(len(constraints_1ab))\nprint(constraints_1ab[0])\n</code></pre> <p>34 Gamma + Promote(-0.0, (9, 9)) &gt;&gt; 0</p> <p>For the CGLMP inequality with <code>dim=3</code>, <code>desc = [3, 3, 2, 2]</code>, level 1:</p> <pre><code>import cvxpy\nimport numpy as np\nfrom toqito.state_opt.npa_hierarchy import bell_npa_constraints\ndesc_cglmp = [3, 3, 2, 2]\noa_c, ob_c, ma_c, mb_c = desc_cglmp\np_var_dim_c = ((oa_c - 1) * ma_c + 1, (ob_c - 1) * mb_c + 1)\np_var_c = cvxpy.Variable(p_var_dim_c, name=\"p_cglmp\")\nconstraints_c = bell_npa_constraints(p_var_c, desc_cglmp, k=1)\nprint(len(constraints_c))\nprint(constraints_c[0])\n</code></pre> <p>38 Gamma + Promote(-0.0, (9, 9)) &gt;&gt; 0</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If internal identity mapping fails.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>p_var</code>               (<code>Variable</code>)           \u2013            <p>A CVXPY Variable representing probabilities/correlations in Collins-Gisin notation.       Shape: \\(((oa-1) \\times ma+1, (ob-1) \\times mb+1)\\).</p> </li> <li> <code>desc</code>               (<code>list[int]</code>)           \u2013            <p>A list [\\(oa\\), \\(ob\\), \\(ma\\), \\(mb\\)]         specifying outputs and inputs for Alice and Bob.</p> </li> <li> <code>k</code>               (<code>int | str</code>, default:                   <code>1</code> )           \u2013            <p>The level of the NPA hierarchy (integer or string like \"1+ab\"). Default is 1.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Constraint]</code>           \u2013            <p>A list of CVXPY constraints.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Navascu\u00e9s, Miguel and Pironio, Stefano and Ac\u00edn, Antonio. A convergent hierarchy of semidefinite programs characterizing the set of quantum correlations. New Journal of Physics. vol. 10(7). (2008). doi:10.1088/1367-2630/10/7/073013. <sup>2</sup> Collins, Daniel and Gisin, Nicolas. A relevant two qubit Bell inequality inequivalent to the CHSH inequality. Journal of Physics A: Mathematical and General. vol. 37(5). (2004). doi:10.1088/0305-4470/37/5/021.</p> Source code in <code>toqito/state_opt/npa_hierarchy.py</code> <pre><code>def bell_npa_constraints(\n    p_var: cvxpy.Variable,\n    desc: list[int],\n    k: int | str = 1,\n) -&gt; list[cvxpy.constraints.constraint.Constraint]:\n    r\"\"\"Generate NPA hierarchy constraints for Bell inequalities [@Navascues_2008_AConvergent].\n\n    The constraints are based on the positivity of a moment matrix constructed from measurement\n    operators. This function generates constraints for a CVXPY variable representing probabilities\n    or correlations in the Collins-Gisin notation. [@Collins_2004]\n\n    The level of the hierarchy ``k`` can be an integer (standard NPA level) or a string specifying\n    intermediate levels (e.g., \"1+ab\", \"2+aab\").\n\n    The input ``p_var`` is a CVXPY variable representing the probabilities in the Collins-Gisin (CG)\n    notation. It should have dimensions \\(((oa-1) \\times ma+1, (ob-1) \\times mb+1)\\),\n    where \\(oa, ob\\) are the number of outputs and \\(ma, mb\\) are the number of inputs for Alice\n    and Bob, respectively, as specified in ``desc`` = [\\(oa\\), \\(ob\\), \\(ma\\), \\(mb\\)].\n    The entries of ``p_var`` correspond to:\n    - ``p_var[0, 0]``: The overall probability (should be 1).\n    - ``p_var[i, 0]`` (for \\(i &gt; 0\\)): Marginal probabilities/correlations for Alice.\n    - ``p_var[0, j]`` (for \\(j &gt; 0\\)): Marginal probabilities/correlations for Bob.\n    - ``p_var[i, j]`` (for \\(i &gt; 0, j &gt; 0\\)): Joint probabilities/correlations for Alice and Bob.\n\n    The mapping from indices \\((i, j)\\) to specific operators depends on the ordering defined by ``desc``.\n    Specifically, if \\(i = (oa-1) \\times x + a + 1\\) and \\(j = (ob-1) \\times y + b + 1\\)\n\n    - ``p_var[i, 0]`` corresponds to the expectation of Alice's operator\n                      \\(A_{a|x}\\) (using \\(0\\) to \\(oa-2\\) for \\(a\\)).\n    - ``p_var[0, j]`` corresponds to the expectation of Bob's operator\n                      \\(B_{b|y}\\) (using \\(0\\) to \\(ob-2\\) for \\(b\\)).\n    - ``p_var[i, j]`` corresponds to the expectation of the product \\(A_{a|x} B_{b|y}\\).\n\n    Examples:\n        Consider the CHSH inequality scenario with ``desc = [2, 2, 2, 2]``. We want to generate the NPA level 1\n        constraints.\n\n        ```python exec=\"1\" source=\"above\" session=\"npa_example\"\n        import cvxpy\n        import numpy as np\n        from toqito.state_opt.npa_hierarchy import bell_npa_constraints\n        desc = [2, 2, 2, 2]\n        oa, ob, ma, mb = desc\n        p_var_dim = ((oa - 1) * ma + 1, (ob - 1) * mb + 1)\n        p_var = cvxpy.Variable(p_var_dim, name=\"p_cg\")\n        constraints = bell_npa_constraints(p_var, desc, k=1)\n        print(len(constraints))\n        print(constraints[0])\n        ```\n\n        We can also use intermediate levels, like \"1+ab\":\n\n        ```python exec=\"1\" source=\"above\" session=\"npa_example\"\n        constraints_1ab = bell_npa_constraints(p_var, desc, k=\"1+ab\")\n        print(len(constraints_1ab))\n        print(constraints_1ab[0])\n        ```\n\n        For the CGLMP inequality with ``dim=3``, ``desc = [3, 3, 2, 2]``, level 1:\n\n        ```python exec=\"1\" source=\"above\"\n        import cvxpy\n        import numpy as np\n        from toqito.state_opt.npa_hierarchy import bell_npa_constraints\n        desc_cglmp = [3, 3, 2, 2]\n        oa_c, ob_c, ma_c, mb_c = desc_cglmp\n        p_var_dim_c = ((oa_c - 1) * ma_c + 1, (ob_c - 1) * mb_c + 1)\n        p_var_c = cvxpy.Variable(p_var_dim_c, name=\"p_cglmp\")\n        constraints_c = bell_npa_constraints(p_var_c, desc_cglmp, k=1)\n        print(len(constraints_c))\n        print(constraints_c[0])\n        ```\n\n\n    Raises:\n        ValueError: If internal identity mapping fails.\n\n    Args:\n        p_var: A CVXPY Variable representing probabilities/correlations in Collins-Gisin notation.\n                  Shape: \\(((oa-1) \\times ma+1, (ob-1) \\times mb+1)\\).\n        desc: A list [\\(oa\\), \\(ob\\), \\(ma\\), \\(mb\\)]\n                    specifying outputs and inputs for Alice and Bob.\n        k: The level of the NPA hierarchy (integer or string like \"1+ab\"). Default is 1.\n\n\n    Returns:\n        A list of CVXPY constraints.\n\n    \"\"\"\n    oa, ob, ma, mb = desc\n    words = _gen_words(k, oa, ma, ob, mb)\n    dim = len(words)\n    gamma = cvxpy.Variable((dim, dim), name=\"Gamma\", symmetric=True)\n    constraints = [gamma &gt;&gt; 0]\n    p_flat = p_var.flatten(order=\"F\")\n    seen_constraints = {}\n\n    constraints.append(gamma[0, 0] == p_var[0, 0])\n\n    seen_constraints[()] = (0, 0)\n\n    for i in range(dim):\n        for j in range(i, dim):\n            if i == 0 and j == 0:\n                continue\n            word_i = words[i]\n            word_j = words[j]\n            word_i_conj = tuple(reversed(word_i))\n            combined_word = _reduce(word_i_conj + word_j)\n\n            if not combined_word:\n                constraints.append(gamma[i, j] == 0)\n                continue\n\n            constraint_key = combined_word\n            if constraint_key in seen_constraints:\n                prev_i, prev_j = seen_constraints[constraint_key]\n                constraints.append(gamma[i, j] == gamma[prev_i, prev_j])\n                continue\n\n            p_cg_index = _word_to_p_cg_index(combined_word, oa, ob, ma, mb)\n            if p_cg_index is not None:\n                constraints.append(gamma[i, j] == p_flat[p_cg_index])\n                seen_constraints[constraint_key] = (i, j)\n            else:\n                seen_constraints[constraint_key] = (i, j)\n\n    return constraints\n</code></pre>"},{"location":"reference/toqito/state_opt/optimal_clone/","title":"optimal_clone","text":""},{"location":"reference/toqito/state_opt/optimal_clone/#toqito.state_opt.optimal_clone","title":"optimal_clone","text":"<p>Calculates success probability of approximately cloning a quantum state.</p>"},{"location":"reference/toqito/state_opt/optimal_clone/#toqito.state_opt.optimal_clone.optimal_clone","title":"optimal_clone","text":"<pre><code>optimal_clone(states: list[ndarray], probs: list[float], num_reps: int = 1, strategy: bool = False) -&gt; float | ndarray\n</code></pre> <p>Compute probability of counterfeiting quantum money <sup>1</sup>.</p> <p>The primal problem for the \\(n\\)-fold parallel repetition is given as follows:</p> \\[     \\begin{equation}         \\begin{aligned}             \\text{maximize:} \\quad &amp;             \\langle W_{\\pi} \\left(Q^{\\otimes n} \\right) W_{\\pi}^*, X \\rangle \\\\             \\text{subject to:} \\quad &amp; \\text{Tr}_{\\mathcal{Y}^{\\otimes n}                                        \\otimes \\mathcal{Z}^{\\otimes n}}(X)                                        = \\mathbb{I}_{\\mathcal{X}^{\\otimes                                        n}},\\\\                                        &amp; X \\in \\text{Pos}(                                        \\mathcal{Y}^{\\otimes n}                                        \\otimes \\mathcal{Z}^{\\otimes n}                                        \\otimes \\mathcal{X}^{\\otimes n}).         \\end{aligned}     \\end{equation} \\] <p>The dual problem for the \\(n\\)-fold parallel repetition is given as follows:</p> \\[     \\begin{equation}         \\begin{aligned}             \\text{minimize:} \\quad &amp; \\text{Tr}(Y) \\\\             \\text{subject to:} \\quad &amp; \\mathbb{I}_{\\mathcal{Y}^{\\otimes n}             \\otimes \\mathcal{Z}^{\\otimes n}} \\otimes Y \\geq W_{\\pi}             \\left( Q^{\\otimes n} \\right) W_{\\pi}^*, \\\\             &amp; Y \\in \\text{Herm} \\left(\\mathcal{X}^{\\otimes n} \\right).         \\end{aligned}     \\end{equation} \\] <p>Examples:</p> <p>Wiesner's original quantum money scheme <sup>2</sup> was shown in <sup>1</sup> to have an optimal probability of 3/4 for succeeding a counterfeiting attack.</p> <p>Specifically, in the single-qubit case, Wiesner's quantum money scheme corresponds to the following ensemble:</p> \\[     \\left\\{         \\left( \\frac{1}{4}, |0\\rangle \\right),         \\left( \\frac{1}{4}, |1\\rangle \\right),         \\left( \\frac{1}{4}, |+\\rangle \\right),         \\left( \\frac{1}{4}, |-\\rangle \\right)     \\right\\}, \\] <p>which yields the operator</p> \\[     \\begin{equation}         Q = \\frac{1}{4} \\left(|000 \\rangle \\langle 000| + |111 \\rangle \\langle 111| +                               |+++ \\rangle + \\langle +++| + |--- \\rangle \\langle ---| \\right).     \\end{equation} \\] <p>We can see that the optimal value we obtain in solving the SDP is 3/4.</p> <pre><code>import numpy as np\nfrom toqito.states import basis\nfrom toqito.state_opt import optimal_clone\n\ne_0, e_1 = basis(2, 0), basis(2, 1)\ne_p = (e_0 + e_1) / np.sqrt(2)\ne_m = (e_0 - e_1) / np.sqrt(2)\n\nstates = [e_0, e_1, e_p, e_m]\nprobs = [1 / 4, 1 / 4, 1 / 4, 1 / 4]\n\nprint(np.around(optimal_clone(states, probs), decimals=2))\n</code></pre> <p>0.75</p> <p>Parameters:</p> <ul> <li> <code>states</code>               (<code>list[ndarray]</code>)           \u2013            <p>A list of states provided as either matrices or vectors.</p> </li> <li> <code>probs</code>               (<code>list[float]</code>)           \u2013            <p>Respective list of probabilities each state is selected.</p> </li> <li> <code>num_reps</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Number of parallel repetitions to perform.</p> </li> <li> <code>strategy</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Boolean that denotes whether to return strategy.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float | ndarray</code>           \u2013            <p>The optimal probability with of counterfeiting quantum money.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Molina, Abel and Vidick, Thomas and Watrous, John. Optimal counterfeiting attacks and generalizations for Wiesner's quantum money. (2012). <sup>2</sup> Wiesner, Stephen. Conjugate Coding. SIGACT News. vol. 15(1). (1983). doi:10.1145/1008908.1008920.</p> Source code in <code>toqito/state_opt/optimal_clone.py</code> <pre><code>def optimal_clone(\n    states: list[np.ndarray],\n    probs: list[float],\n    num_reps: int = 1,\n    strategy: bool = False,\n) -&gt; float | np.ndarray:\n    r\"\"\"Compute probability of counterfeiting quantum money [@Molina_2012_Optimal].\n\n    The primal problem for the \\(n\\)-fold parallel repetition is given as follows:\n\n    \\[\n        \\begin{equation}\n            \\begin{aligned}\n                \\text{maximize:} \\quad &amp;\n                \\langle W_{\\pi} \\left(Q^{\\otimes n} \\right) W_{\\pi}^*, X \\rangle \\\\\n                \\text{subject to:} \\quad &amp; \\text{Tr}_{\\mathcal{Y}^{\\otimes n}\n                                           \\otimes \\mathcal{Z}^{\\otimes n}}(X)\n                                           = \\mathbb{I}_{\\mathcal{X}^{\\otimes\n                                           n}},\\\\\n                                           &amp; X \\in \\text{Pos}(\n                                           \\mathcal{Y}^{\\otimes n}\n                                           \\otimes \\mathcal{Z}^{\\otimes n}\n                                           \\otimes \\mathcal{X}^{\\otimes n}).\n            \\end{aligned}\n        \\end{equation}\n    \\]\n\n    The dual problem for the \\(n\\)-fold parallel repetition is given as follows:\n\n    \\[\n        \\begin{equation}\n            \\begin{aligned}\n                \\text{minimize:} \\quad &amp; \\text{Tr}(Y) \\\\\n                \\text{subject to:} \\quad &amp; \\mathbb{I}_{\\mathcal{Y}^{\\otimes n}\n                \\otimes \\mathcal{Z}^{\\otimes n}} \\otimes Y \\geq W_{\\pi}\n                \\left( Q^{\\otimes n} \\right) W_{\\pi}^*, \\\\\n                &amp; Y \\in \\text{Herm} \\left(\\mathcal{X}^{\\otimes n} \\right).\n            \\end{aligned}\n        \\end{equation}\n    \\]\n\n    Examples:\n        Wiesner's original quantum money scheme [@Wiesner_1983_Conjugate] was shown in\n        [@Molina_2012_Optimal] to have an optimal probability of 3/4 for succeeding a counterfeiting attack.\n\n        Specifically, in the single-qubit case, Wiesner's quantum money scheme corresponds to the\n        following ensemble:\n\n        \\[\n            \\left\\{\n                \\left( \\frac{1}{4}, |0\\rangle \\right),\n                \\left( \\frac{1}{4}, |1\\rangle \\right),\n                \\left( \\frac{1}{4}, |+\\rangle \\right),\n                \\left( \\frac{1}{4}, |-\\rangle \\right)\n            \\right\\},\n        \\]\n\n        which yields the operator\n\n        \\[\n            \\begin{equation}\n                Q = \\frac{1}{4} \\left(|000 \\rangle \\langle 000| + |111 \\rangle \\langle 111| +\n                                      |+++ \\rangle + \\langle +++| + |--- \\rangle \\langle ---| \\right).\n            \\end{equation}\n        \\]\n\n        We can see that the optimal value we obtain in solving the SDP is 3/4.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.states import basis\n        from toqito.state_opt import optimal_clone\n\n        e_0, e_1 = basis(2, 0), basis(2, 1)\n        e_p = (e_0 + e_1) / np.sqrt(2)\n        e_m = (e_0 - e_1) / np.sqrt(2)\n\n        states = [e_0, e_1, e_p, e_m]\n        probs = [1 / 4, 1 / 4, 1 / 4, 1 / 4]\n\n        print(np.around(optimal_clone(states, probs), decimals=2))\n        ```\n\n    Args:\n        states: A list of states provided as either matrices or vectors.\n        probs: Respective list of probabilities each state is selected.\n        num_reps: Number of parallel repetitions to perform.\n        strategy: Boolean that denotes whether to return strategy.\n\n    Returns:\n        The optimal probability with of counterfeiting quantum money.\n\n    \"\"\"\n    dim = len(states[0]) ** 3\n\n    # Construct the following operator:\n    #                                ___               ___\n    # Q = \u2211_{k=1}^N p_k |\u03c8_k \u2297 \u03c8_k \u2297 \u03c8_k&gt; &lt;\u03c8_k \u2297 \u03c8_k \u2297 \u03c8_k|\n    q_a = np.zeros((dim, dim))\n    for k, state in enumerate(states):\n        q_a += probs[k] * tensor(state, state, state.conj()) @ tensor(state, state, state.conj()).conj().T\n\n    # The system is over:\n    # Y_1 \u2297 Z_1 \u2297 X_1, ... , Y_n \u2297 Z_n \u2297 X_n.\n    num_spaces = 3\n\n    # In the event of more than a single repetition, one needs to apply a\n    # permutation operator to the variables in the SDP to properly align\n    # the spaces.\n    if num_reps == 1:\n        pperm = np.array([1])\n    else:\n        # The permutation vector `perm` contains elements of the\n        # sequence from: https://oeis.org/A023123\n        q_a = tensor(q_a, num_reps)\n        perm = []\n        for i in range(num_spaces):\n            perm.append(i)\n            var = i\n            for j in range(1, num_reps):\n                perm.append(var + num_spaces * j)\n        pperm = permutation_operator(2, perm)\n\n    if strategy:\n        return primal_problem(q_a, pperm, num_reps)\n    return dual_problem(q_a, pperm, num_reps)\n</code></pre>"},{"location":"reference/toqito/state_opt/optimal_clone/#toqito.state_opt.optimal_clone.primal_problem","title":"primal_problem","text":"<pre><code>primal_problem(q_a: ndarray, pperm: ndarray, num_reps: int) -&gt; float\n</code></pre> <p>Primal problem for counterfeit attack.</p> <p>As the primal problem takes longer to solve than the dual problem (as the variables are of larger dimension), the primal problem is only here for reference.</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The optimal value of performing a counterfeit attack.</p> </li> </ul> Source code in <code>toqito/state_opt/optimal_clone.py</code> <pre><code>def primal_problem(q_a: np.ndarray, pperm: np.ndarray, num_reps: int) -&gt; float:\n    r\"\"\"Primal problem for counterfeit attack.\n\n    As the primal problem takes longer to solve than the dual problem (as\n    the variables are of larger dimension), the primal problem is only here\n    for reference.\n\n    Returns:\n        The optimal value of performing a counterfeit attack.\n\n    \"\"\"\n    num_spaces = 3\n\n    sys = list(range(1, num_spaces * num_reps))\n    sys = [elem for elem in sys if elem % num_spaces != 0]\n    sys = [elem - 1 for elem in sys]\n\n    # The dimension of each subsystem is assumed to be of dimension 2.\n    dim = 2 * np.ones((1, num_spaces * num_reps)).astype(int).flatten()\n    dim = dim.tolist()\n\n    x_var = cvxpy.Variable((8**num_reps, 8**num_reps), hermitian=True)\n    if num_reps == 1:\n        objective = cvxpy.Maximize(cvxpy.trace(cvxpy.real(q_a.conj().T @ x_var)))\n    else:\n        objective = cvxpy.Maximize(cvxpy.trace(cvxpy.real(pperm @ q_a.conj().T @ pperm.conj().T @ x_var)))\n    constraints = [\n        partial_trace(x_var, sys, dim) == np.identity(2**num_reps),\n        x_var &gt;&gt; 0,\n    ]\n    problem = cvxpy.Problem(objective, constraints)\n\n    return problem.solve()\n</code></pre>"},{"location":"reference/toqito/state_opt/optimal_clone/#toqito.state_opt.optimal_clone.dual_problem","title":"dual_problem","text":"<pre><code>dual_problem(q_a: ndarray, pperm: ndarray, num_reps: int) -&gt; float\n</code></pre> <p>Dual problem for counterfeit attack.</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The optimal value of performing a counterfeit attack.</p> </li> </ul> Source code in <code>toqito/state_opt/optimal_clone.py</code> <pre><code>def dual_problem(q_a: np.ndarray, pperm: np.ndarray, num_reps: int) -&gt; float:\n    r\"\"\"Dual problem for counterfeit attack.\n\n    Returns:\n        The optimal value of performing a counterfeit attack.\n\n    \"\"\"\n    y_var = cvxpy.Variable((2**num_reps, 2**num_reps), hermitian=True)\n    objective = cvxpy.Minimize(cvxpy.trace(cvxpy.real(y_var)))\n\n    kron_var = cvxpy.kron(cvxpy.kron(np.eye(2**num_reps), np.eye(2**num_reps)), y_var)\n\n    if num_reps == 1:\n        constraints = [cvxpy.real(kron_var) &gt;&gt; q_a]\n    else:\n        constraints = [cvxpy.real(kron_var) &gt;&gt; pperm @ q_a @ pperm.conj().T]\n    problem = cvxpy.Problem(objective, constraints)\n\n    return problem.solve()\n</code></pre>"},{"location":"reference/toqito/state_opt/ppt_distinguishability/","title":"ppt_distinguishability","text":""},{"location":"reference/toqito/state_opt/ppt_distinguishability/#toqito.state_opt.ppt_distinguishability","title":"ppt_distinguishability","text":"<p>Calculates the probability of PPT state distinguishability when done optimally.</p>"},{"location":"reference/toqito/state_opt/ppt_distinguishability/#toqito.state_opt.ppt_distinguishability.ppt_distinguishability","title":"ppt_distinguishability","text":"<pre><code>ppt_distinguishability(vectors: list[ndarray], subsystems: list[int], dimensions: list[int], probs: list[float] | None = None, strategy: str = 'min_error', solver: str = 'cvxopt', primal_dual: str = 'dual') -&gt; float\n</code></pre> <p>Compute probability of optimally distinguishing a state via PPT measurements <sup>1</sup>.</p> <p>Implements the semidefinite program (SDP) whose optimal value is equal to the maximum probability of perfectly distinguishing orthogonal maximally entangled states using any PPT measurement; a measurement whose operators are positive under partial transpose. This SDP was explicitly provided in <sup>1</sup>.</p> <p>One can specify the distinguishability method using the <code>dist_method</code> argument.</p> <p>For <code>dist_method = \"min_error\"</code>, this is the default method that yields the probability of distinguishing quantum states via PPT measurements that minimize the probability of error.</p> <p>For <code>dist_method = \"unambig\"</code>, Alice and Bob never provide an incorrect answer, although it is possible that their answer is inconclusive.</p> <p>For more background, see the <code>state_distinguishability</code> example in the quantum states gallery.</p> <p>Note</p> <p>This function supports both pure states (vectors) and mixed states (density matrices). The PPT constraints are applied to the measurement operators to restrict the class of allowed measurements.</p> <p>Examples:</p> <p>Consider the following Bell states:</p> \\[     \\begin{equation}         \\begin{aligned}         |\\psi_0 \\rangle = \\frac{|00\\rangle + |11\\rangle}{\\sqrt{2}}, &amp;\\quad         |\\psi_1 \\rangle = \\frac{|01\\rangle + |10\\rangle}{\\sqrt{2}}, \\\\         |\\psi_2 \\rangle = \\frac{|01\\rangle - |10\\rangle}{\\sqrt{2}}, &amp;\\quad         |\\psi_3 \\rangle = \\frac{|00\\rangle - |11\\rangle}{\\sqrt{2}}.         \\end{aligned}     \\end{equation} \\] <p>It was illustrated in <sup>2</sup> that for the following set of states</p> \\[     \\begin{equation}         \\begin{aligned}         \\rho_1^{(2)} &amp;= |\\psi_0 \\rangle | \\psi_0 \\rangle \\langle \\psi_0 | \\langle \\psi_0 |, \\quad         \\rho_2^{(2)} &amp;= |\\psi_1 \\rangle | \\psi_3 \\rangle \\langle \\psi_1 | \\langle \\psi_3 |, \\\\         \\rho_3^{(2)} &amp;= |\\psi_2 \\rangle | \\psi_3 \\rangle \\langle \\psi_2 | \\langle \\psi_3 |, \\quad         \\rho_4^{(2)} &amp;= |\\psi_3 \\rangle | \\psi_3 \\rangle \\langle \\psi_3 | \\langle \\psi_3 |, \\\\         \\end{aligned}     \\end{equation} \\] <p>that the optimal probability of distinguishing via a PPT measurement should yield \\(7/8 \\approx 0.875\\) as was proved in <sup>2</sup>.</p> <pre><code>import numpy as np\nfrom toqito.states import bell\nfrom toqito.state_opt import ppt_distinguishability\n\n# Bell vectors:\npsi_0 = bell(0)\npsi_1 = bell(2)\npsi_2 = bell(3)\npsi_3 = bell(1)\n\n# YDY vectors from &lt;sup&gt;&lt;a id=\"cite-toqito-state_opt-ppt_distinguishability-ppt_distinguishability-2\" href=\"#ref-toqito-state_opt-ppt_distinguishability-ppt_distinguishability-2\"&gt;2&lt;/a&gt;&lt;/sup&gt;.\nx_1 = np.kron(psi_0, psi_0)\nx_2 = np.kron(psi_1, psi_3)\nx_3 = np.kron(psi_2, psi_3)\nx_4 = np.kron(psi_3, psi_3)\n\n# YDY density matrices.\nrho_1 = x_1 @ x_1.conj().T\nrho_2 = x_2 @ x_2.conj().T\nrho_3 = x_3 @ x_3.conj().T\nrho_4 = x_4 @ x_4.conj().T\n\nstates = [rho_1, rho_2, rho_3, rho_4]\nprobs = [1 / 4, 1 / 4, 1 / 4, 1 / 4]\n\nopt_val, _ = ppt_distinguishability(vectors=states, probs=probs, dimensions=[2, 2, 2, 2], subsystems=[0, 2])\n\nprint(f\"Optimal value: {opt_val:.3f}\")\n</code></pre> <p>Optimal value: 0.875</p> <p>Parameters:</p> <ul> <li> <code>vectors</code>               (<code>list[ndarray]</code>)           \u2013            <p>A list of states provided as either matrices or vectors.</p> </li> <li> <code>probs</code>               (<code>list[float] | None</code>, default:                   <code>None</code> )           \u2013            <p>Respective list of probabilities each state is selected.</p> </li> <li> <code>subsystems</code>               (<code>list[int]</code>)           \u2013            <p>A list of integers that correspond to the complex Euclidean space dimensions.</p> </li> <li> <code>dimensions</code>               (<code>list[int]</code>)           \u2013            <p>A list of integers that correspond to the dimensions of the subsystems.</p> </li> <li> <code>strategy</code>               (<code>str</code>, default:                   <code>'min_error'</code> )           \u2013            <p>The method of distinguishing states.</p> </li> <li> <code>solver</code>               (<code>str</code>, default:                   <code>'cvxopt'</code> )           \u2013            <p>The SDP solver to use.</p> </li> <li> <code>primal_dual</code>               (<code>str</code>, default:                   <code>'dual'</code> )           \u2013            <p>Option for the optimization problem.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The optimal probability with which the states can be distinguished via PPT measurements.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Cosentino, Alessandro. Positive-partial-transpose-indistinguishable states via semidefinite programming. Physical Review A. vol. 87(1). (2013). doi:10.1103/physreva.87.012321. <sup>2</sup> Yu, Nengkun and Duan, Runyao and Ying, Mingsheng. Four Locally Indistinguishable Ququad-Ququad Orthogonal Maximally Entangled States. Physical Review Letters. vol. 109(2). (2012). doi:10.1103/physrevlett.109.020506.</p> Source code in <code>toqito/state_opt/ppt_distinguishability.py</code> <pre><code>def ppt_distinguishability(\n    vectors: list[np.ndarray],\n    subsystems: list[int],\n    dimensions: list[int],\n    probs: list[float] | None = None,\n    strategy: str = \"min_error\",\n    solver: str = \"cvxopt\",\n    primal_dual: str = \"dual\",\n) -&gt; float:\n    r\"\"\"Compute probability of optimally distinguishing a state via PPT measurements [@Cosentino_2013_PPT].\n\n    Implements the semidefinite program (SDP) whose optimal value is equal to the maximum\n    probability of perfectly distinguishing orthogonal maximally entangled states using any PPT\n    measurement; a measurement whose operators are positive under partial transpose. This SDP was\n    explicitly provided in [@Cosentino_2013_PPT].\n\n    One can specify the distinguishability method using the `dist_method` argument.\n\n    For `dist_method = \"min_error\"`, this is the default method that yields the probability of\n    distinguishing quantum states via PPT measurements that minimize the probability of error.\n\n    For `dist_method = \"unambig\"`, Alice and Bob never provide an incorrect answer,\n    although it is possible that their answer is inconclusive.\n\n    For more background, see the ``state_distinguishability`` example in the\n    quantum states gallery.\n\n    !!! Note\n        This function supports both pure states (vectors) and mixed states (density matrices).\n        The PPT constraints are applied to the measurement operators to restrict the class of\n        allowed measurements.\n\n    Examples:\n        Consider the following Bell states:\n\n        \\[\n            \\begin{equation}\n                \\begin{aligned}\n                |\\psi_0 \\rangle = \\frac{|00\\rangle + |11\\rangle}{\\sqrt{2}}, &amp;\\quad\n                |\\psi_1 \\rangle = \\frac{|01\\rangle + |10\\rangle}{\\sqrt{2}}, \\\\\n                |\\psi_2 \\rangle = \\frac{|01\\rangle - |10\\rangle}{\\sqrt{2}}, &amp;\\quad\n                |\\psi_3 \\rangle = \\frac{|00\\rangle - |11\\rangle}{\\sqrt{2}}.\n                \\end{aligned}\n            \\end{equation}\n        \\]\n\n        It was illustrated in [@Yu_2012_Four] that for the following set of states\n\n        \\[\n            \\begin{equation}\n                \\begin{aligned}\n                \\rho_1^{(2)} &amp;= |\\psi_0 \\rangle | \\psi_0 \\rangle \\langle \\psi_0 | \\langle \\psi_0 |, \\quad\n                \\rho_2^{(2)} &amp;= |\\psi_1 \\rangle | \\psi_3 \\rangle \\langle \\psi_1 | \\langle \\psi_3 |, \\\\\n                \\rho_3^{(2)} &amp;= |\\psi_2 \\rangle | \\psi_3 \\rangle \\langle \\psi_2 | \\langle \\psi_3 |, \\quad\n                \\rho_4^{(2)} &amp;= |\\psi_3 \\rangle | \\psi_3 \\rangle \\langle \\psi_3 | \\langle \\psi_3 |, \\\\\n                \\end{aligned}\n            \\end{equation}\n        \\]\n\n        that the optimal probability of distinguishing via a PPT measurement should yield\n        \\(7/8 \\approx 0.875\\) as was proved in [@Yu_2012_Four].\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.states import bell\n        from toqito.state_opt import ppt_distinguishability\n\n        # Bell vectors:\n        psi_0 = bell(0)\n        psi_1 = bell(2)\n        psi_2 = bell(3)\n        psi_3 = bell(1)\n\n        # YDY vectors from [@Yu_2012_Four].\n        x_1 = np.kron(psi_0, psi_0)\n        x_2 = np.kron(psi_1, psi_3)\n        x_3 = np.kron(psi_2, psi_3)\n        x_4 = np.kron(psi_3, psi_3)\n\n        # YDY density matrices.\n        rho_1 = x_1 @ x_1.conj().T\n        rho_2 = x_2 @ x_2.conj().T\n        rho_3 = x_3 @ x_3.conj().T\n        rho_4 = x_4 @ x_4.conj().T\n\n        states = [rho_1, rho_2, rho_3, rho_4]\n        probs = [1 / 4, 1 / 4, 1 / 4, 1 / 4]\n\n        opt_val, _ = ppt_distinguishability(vectors=states, probs=probs, dimensions=[2, 2, 2, 2], subsystems=[0, 2])\n\n        print(f\"Optimal value: {opt_val:.3f}\")\n        ```\n\n    Args:\n        vectors: A list of states provided as either matrices or vectors.\n        probs: Respective list of probabilities each state is selected.\n        subsystems: A list of integers that correspond to the complex Euclidean space dimensions.\n        dimensions: A list of integers that correspond to the dimensions of the subsystems.\n        strategy: The method of distinguishing states.\n        solver: The SDP solver to use.\n        primal_dual: Option for the optimization problem.\n\n    Returns:\n        The optimal probability with which the states can be distinguished via PPT measurements.\n\n    \"\"\"\n    if not has_same_dimension(vectors):\n        raise ValueError(\"Vectors for state distinguishability must all have the same dimension.\")\n\n    # Assumes a uniform probabilities distribution among the states if one is not explicitly provided.\n    n = len(vectors)\n    probs = [1 / n] * n if probs is None else probs\n\n    if primal_dual == \"primal\":\n        return _min_error_primal(\n            vectors=vectors, subsystems=subsystems, dimensions=dimensions, probs=probs, solver=solver, strategy=strategy\n        )\n    return _min_error_dual(\n        vectors=vectors, subsystems=subsystems, dimensions=dimensions, probs=probs, solver=solver, strategy=strategy\n    )\n</code></pre>"},{"location":"reference/toqito/state_opt/state_distinguishability/","title":"state_distinguishability","text":""},{"location":"reference/toqito/state_opt/state_distinguishability/#toqito.state_opt.state_distinguishability","title":"state_distinguishability","text":"<p>Calculates the probability of optimally distinguishing quantum states.</p>"},{"location":"reference/toqito/state_opt/state_distinguishability/#toqito.state_opt.state_distinguishability.state_distinguishability","title":"state_distinguishability","text":"<pre><code>state_distinguishability(vectors: list[ndarray], probs: list[float] | None = None, strategy: str = 'min_error', solver: str = 'cvxopt', primal_dual: str = 'dual', **kwargs) -&gt; tuple[float, list[HermitianVariable] | list[ndarray] | tuple[SymmetricVariable]]\n</code></pre> <p>Compute probability of state distinguishability <sup>1</sup>.</p> <p>The \"quantum state distinguishability\" problem involves a collection of \\(n\\) quantum states</p> \\[     \\rho = \\{ \\rho_1, \\ldots, \\rho_n \\}, \\] <p>as well as a list of corresponding probabilities</p> \\[     p = \\{ p_1, \\ldots, p_n \\}. \\] <p>Alice chooses \\(i\\) with probability \\(p_i\\) and creates the state \\(\\rho_i\\). Bob wants to guess which state he was given from the collection of states.</p> <p>For <code>strategy = \"min_error\"</code>, this is the default method that yields the minimal probability of error for Bob.</p> <p>In that case, this function implements the following semidefinite program that provides the optimal probability with which Bob can conduct quantum state distinguishability.</p> \\[     \\begin{align*}         \\text{maximize:} \\quad &amp; \\sum_{i=0}^n p_i \\langle M_i, \\rho_i \\rangle \\\\         \\text{subject to:} \\quad &amp; M_0 + \\ldots + M_n = \\mathbb{I},\\\\                                  &amp; M_0, \\ldots, M_n \\geq 0.     \\end{align*} \\] <p>For <code>strategy = \"unambiguous\"</code>, Bob never provides an incorrect answer, although it is possible that his answer is inconclusive.</p> <p>In that case, this function implements the following semidefinite program that provides the optimal probability with which Bob can conduct unambiguous quantum state distinguishability.</p> \\[     \\begin{align*}         \\text{maximize:} \\quad &amp; \\mathbf{p} \\cdot \\mathbf{q} \\\\         \\text{subject to:} \\quad &amp; \\Gamma - Q \\geq 0,\\\\                                  &amp; \\mathbf{q} \\geq 0     \\end{align*} \\] \\[     \\begin{align*}         \\text{minimize:} \\quad &amp; \\text{Tr}(\\Gamma Z) \\\\         \\text{subject to:} \\quad &amp; z_i + p_i + \\text{Tr}\\left(F_iZ\\right)=0,\\\\                                  &amp; Z, z \\geq 0     \\end{align*} \\] <p>where \\(\\mathbf{p}\\) is the vector whose \\(i\\)-th coordinate contains the probability that the state is prepared in state \\(\\left|\\psi_i\\right\\rangle\\), \\(\\Gamma\\) is the Gram matrix of \\(\\left|\\psi_1\\right\\rangle,\\cdots,\\left|\\psi_n\\right\\rangle\\) and \\(F_i\\) is \\(-|i\\rangle\\langle i|\\).</p> <p>Note</p> <p>For unambiguous discrimination, this function supports both pure states (vectors) and mixed states (density matrices). For pure states, the states should be linearly independent. For mixed states, the Gram matrix is computed as Tr(\u03c1\u1d62 \u03c1\u2c7c). If the states cannot be unambiguously distinguished, the optimal probability will be low or zero.</p> <p>Examples:</p> <p>Minimal-error state distinguishability for the Bell states (which are perfectly distinguishable).</p> <pre><code>import numpy as np\nfrom toqito.states import bell\nfrom toqito.state_opt import state_distinguishability\n\nstates = [bell(0), bell(1), bell(2), bell(3)]\nprobs = [1 / 4, 1 / 4, 1 / 4, 1 / 4]\n\nres, _ = state_distinguishability(vectors=states, probs=probs, primal_dual=\"dual\")\n\nprint(np.around(res, decimals=2))\n</code></pre> <p>1.0</p> <p>Note that if we are just interested in obtaining the optimal value, it is computationally less intensive to compute the dual problem over the primal problem. However, the primal problem does allow us to extract the explicit measurement operators which may be of interest to us.</p> <pre><code>import numpy as np\nfrom toqito.states import bell\nfrom toqito.state_opt import state_distinguishability\n\nstates = [bell(0), bell(1), bell(2), bell(3)]\nprobs = [1 / 4, 1 / 4, 1 / 4, 1 / 4]\n\nres, measurements = state_distinguishability(vectors=states, probs=probs, primal_dual=\"primal\")\n\nprint(np.around(measurements[0], decimals=5))\n</code></pre> <p>[[ 0.5+0.j  0. -0.j -0. +0.j  0.5+0.j]  [ 0. +0.j  0. +0.j  0. +0.j  0. +0.j]  [-0. -0.j  0. -0.j  0. +0.j -0. -0.j]  [ 0.5-0.j  0. -0.j -0. +0.j  0.5+0.j]]</p> <p>Unambiguous state distinguishability for unbiased pure states.</p> <pre><code>import numpy as np\nfrom toqito.state_opt import state_distinguishability\n\nstates = [np.array([[1.], [0.]]), np.array([[1.],[1.]]) / np.sqrt(2)]\nprobs = [1 / 2, 1 / 2]\n\nres, _ = state_distinguishability(vectors=states, probs=probs, primal_dual=\"primal\", strategy=\"unambiguous\")\n\nprint(np.around(res, decimals=2))\n</code></pre> <p>0.29</p> <p>Unambiguous state distinguishability for mixed states.</p> <pre><code>import numpy as np\nfrom toqito.state_opt import state_distinguishability\n\n# Two mixed states (Werner-like states)\nrho1 = 0.7 * np.array([[1., 0.], [0., 0.]]) + 0.3 * np.eye(2) / 2\nrho2 = 0.7 * np.array([[0., 0.], [0., 1.]]) + 0.3 * np.eye(2) / 2\nstates = [rho1, rho2]\nprobs = [1 / 2, 1 / 2]\n\nres, _ = state_distinguishability(vectors=states, probs=probs, primal_dual=\"primal\", strategy=\"unambiguous\")\n\nprint(np.around(res, decimals=2))\n</code></pre> <p>0.49</p> <p>Parameters:</p> <ul> <li> <code>vectors</code>               (<code>list[ndarray]</code>)           \u2013            <p>A list of states provided as vectors (for pure states) or density matrices (for mixed states).</p> </li> <li> <code>probs</code>               (<code>list[float] | None</code>, default:                   <code>None</code> )           \u2013            <p>Respective list of probabilities each state is selected. If no probabilities are provided, a uniform</p> </li> <li> <code>strategy</code>               (<code>str</code>, default:                   <code>'min_error'</code> )           \u2013            <p>Whether to perform unambiguous or minimal error discrimination task. Possible values are \"min_error\"</p> </li> <li> <code>solver</code>               (<code>str</code>, default:                   <code>'cvxopt'</code> )           \u2013            <p>Optimization option for <code>picos</code> solver. Default option is <code>solver=\"cvxopt\"</code>.</p> </li> <li> <code>primal_dual</code>               (<code>str</code>, default:                   <code>'dual'</code> )           \u2013            <p>Option for the optimization problem. Default option is <code>\"dual\"</code>.</p> </li> <li> <code>kwargs</code>           \u2013            <p>Additional arguments to pass to picos' solve method.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The optimal probability with which Bob can guess the state he was not given from <code>states</code> along with the optimal</p> </li> <li> <code>list[HermitianVariable] | list[ndarray] | tuple[SymmetricVariable]</code>           \u2013            <p>set of measurements.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Eldar, Y.C.. A semidefinite programming approach to optimal unambiguous discrimination of quantum states. IEEE Transactions on Information Theory. vol. 49(2). (2003). doi:10.1109/tit.2002.807291.</p> Source code in <code>toqito/state_opt/state_distinguishability.py</code> <pre><code>def state_distinguishability(\n    vectors: list[np.ndarray],\n    probs: list[float] | None = None,\n    strategy: str = \"min_error\",\n    solver: str = \"cvxopt\",\n    primal_dual: str = \"dual\",\n    **kwargs,\n) -&gt; tuple[float, list[picos.HermitianVariable] | list[np.ndarray] | tuple[picos.SymmetricVariable]]:\n    r\"\"\"Compute probability of state distinguishability [@Eldar_2003_SDPApproach].\n\n    The \"quantum state distinguishability\" problem involves a collection of \\(n\\) quantum states\n\n    \\[\n        \\rho = \\{ \\rho_1, \\ldots, \\rho_n \\},\n    \\]\n\n    as well as a list of corresponding probabilities\n\n    \\[\n        p = \\{ p_1, \\ldots, p_n \\}.\n    \\]\n\n    Alice chooses \\(i\\) with probability \\(p_i\\) and creates the state \\(\\rho_i\\). Bob\n    wants to guess which state he was given from the collection of states.\n\n    For `strategy = \"min_error\"`, this is the default method that yields the minimal\n    probability of error for Bob.\n\n    In that case, this function implements the following semidefinite program that provides the\n    optimal probability with which Bob can conduct quantum state distinguishability.\n\n    \\[\n        \\begin{align*}\n            \\text{maximize:} \\quad &amp; \\sum_{i=0}^n p_i \\langle M_i, \\rho_i \\rangle \\\\\n            \\text{subject to:} \\quad &amp; M_0 + \\ldots + M_n = \\mathbb{I},\\\\\n                                     &amp; M_0, \\ldots, M_n \\geq 0.\n        \\end{align*}\n    \\]\n\n    For `strategy = \"unambiguous\"`, Bob never provides an incorrect answer, although it is\n    possible that his answer is inconclusive.\n\n    In that case, this function implements the following semidefinite program that provides the\n    optimal probability with which Bob can conduct unambiguous quantum state distinguishability.\n\n    \\[\n        \\begin{align*}\n            \\text{maximize:} \\quad &amp; \\mathbf{p} \\cdot \\mathbf{q} \\\\\n            \\text{subject to:} \\quad &amp; \\Gamma - Q \\geq 0,\\\\\n                                     &amp; \\mathbf{q} \\geq 0\n        \\end{align*}\n    \\]\n\n    \\[\n        \\begin{align*}\n            \\text{minimize:} \\quad &amp; \\text{Tr}(\\Gamma Z) \\\\\n            \\text{subject to:} \\quad &amp; z_i + p_i + \\text{Tr}\\left(F_iZ\\right)=0,\\\\\n                                     &amp; Z, z \\geq 0\n        \\end{align*}\n    \\]\n\n    where \\(\\mathbf{p}\\) is the vector whose \\(i\\)-th coordinate contains the probability\n    that the state is prepared in state \\(\\left|\\psi_i\\right\\rangle\\), \\(\\Gamma\\) is\n    the Gram matrix of \\(\\left|\\psi_1\\right\\rangle,\\cdots,\\left|\\psi_n\\right\\rangle\\) and \\(F_i\\) is\n    \\(-|i\\rangle\\langle i|\\).\n\n    !!! Note\n        For unambiguous discrimination, this function supports both pure states (vectors) and mixed states\n        (density matrices). For pure states, the states should be linearly independent. For mixed states,\n        the Gram matrix is computed as Tr(\u03c1\u1d62 \u03c1\u2c7c). If the states cannot be unambiguously distinguished,\n        the optimal probability will be low or zero.\n\n    Examples:\n        Minimal-error state distinguishability for the Bell states (which are perfectly distinguishable).\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.states import bell\n        from toqito.state_opt import state_distinguishability\n\n        states = [bell(0), bell(1), bell(2), bell(3)]\n        probs = [1 / 4, 1 / 4, 1 / 4, 1 / 4]\n\n        res, _ = state_distinguishability(vectors=states, probs=probs, primal_dual=\"dual\")\n\n        print(np.around(res, decimals=2))\n        ```\n\n        Note that if we are just interested in obtaining the optimal value, it is computationally less intensive\n        to compute\n        the dual problem over the primal problem. However, the primal problem does allow us to extract the explicit\n        measurement operators which may be of interest to us.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.states import bell\n        from toqito.state_opt import state_distinguishability\n\n        states = [bell(0), bell(1), bell(2), bell(3)]\n        probs = [1 / 4, 1 / 4, 1 / 4, 1 / 4]\n\n        res, measurements = state_distinguishability(vectors=states, probs=probs, primal_dual=\"primal\")\n\n        print(np.around(measurements[0], decimals=5))\n        ```\n\n        Unambiguous state distinguishability for unbiased pure states.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.state_opt import state_distinguishability\n\n        states = [np.array([[1.], [0.]]), np.array([[1.],[1.]]) / np.sqrt(2)]\n        probs = [1 / 2, 1 / 2]\n\n        res, _ = state_distinguishability(vectors=states, probs=probs, primal_dual=\"primal\", strategy=\"unambiguous\")\n\n        print(np.around(res, decimals=2))\n        ```\n\n        Unambiguous state distinguishability for mixed states.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.state_opt import state_distinguishability\n\n        # Two mixed states (Werner-like states)\n        rho1 = 0.7 * np.array([[1., 0.], [0., 0.]]) + 0.3 * np.eye(2) / 2\n        rho2 = 0.7 * np.array([[0., 0.], [0., 1.]]) + 0.3 * np.eye(2) / 2\n        states = [rho1, rho2]\n        probs = [1 / 2, 1 / 2]\n\n        res, _ = state_distinguishability(vectors=states, probs=probs, primal_dual=\"primal\", strategy=\"unambiguous\")\n\n        print(np.around(res, decimals=2))\n        ```\n\n    Args:\n        vectors: A list of states provided as vectors (for pure states) or density matrices (for mixed states).\n        probs: Respective list of probabilities each state is selected. If no probabilities are provided, a uniform\n        probability distribution is assumed.\n        strategy: Whether to perform unambiguous or minimal error discrimination task. Possible values are \"min_error\"\n        and \"unambiguous\". Default option is `strategy=\"min_error\"`. Both strategies support pure and mixed states.\n        solver: Optimization option for `picos` solver. Default option is `solver=\"cvxopt\"`.\n        primal_dual: Option for the optimization problem. Default option is `\"dual\"`.\n        kwargs: Additional arguments to pass to picos' solve method.\n\n    Returns:\n        The optimal probability with which Bob can guess the state he was not given from `states` along with the optimal\n        set of measurements.\n\n    \"\"\"\n    if not has_same_dimension(vectors):\n        raise ValueError(\"Vectors for state distinguishability must all have the same dimension.\")\n\n    # Assumes a uniform probabilities distribution among the states if one is not explicitly provided.\n    n = len(vectors)\n    probs = [1 / n] * n if probs is None else probs\n    dim = calculate_vector_matrix_dimension(vectors[0])\n\n    if strategy == \"min_error\":\n        if primal_dual == \"primal\":\n            return _min_error_primal(vectors=vectors, dim=dim, probs=probs, solver=solver, **kwargs)\n        return _min_error_dual(vectors=vectors, dim=dim, probs=probs, solver=solver, **kwargs)\n\n    if primal_dual == \"primal\":\n        return _unambiguous_primal(vectors=vectors, dim=dim, probs=probs, solver=solver, **kwargs)\n\n    return _unambiguous_dual(vectors=vectors, probs=probs, solver=solver, **kwargs)\n</code></pre>"},{"location":"reference/toqito/state_opt/state_exclusion/","title":"state_exclusion","text":""},{"location":"reference/toqito/state_opt/state_exclusion/#toqito.state_opt.state_exclusion","title":"state_exclusion","text":"<p>Calculates the probability of error of single state conclusive state exclusion.</p>"},{"location":"reference/toqito/state_opt/state_exclusion/#toqito.state_opt.state_exclusion.state_exclusion","title":"state_exclusion","text":"<pre><code>state_exclusion(vectors: list[ndarray], probs: list[float] | None = None, strategy: str = 'min_error', solver: str = 'cvxopt', primal_dual: str = 'dual', **kwargs) -&gt; tuple[float, list[HermitianVariable] | tuple[HermitianVariable, RealVariable]]\n</code></pre> <p>Compute probability of error of single state conclusive state exclusion.</p> <p>The quantum state exclusion problem involves a collection of \\(n\\) quantum states</p> \\[     \\rho = \\{ \\rho_0, \\ldots, \\rho_n \\}, \\] <p>as well as a list of corresponding probabilities</p> \\[     p = \\{ p_0, \\ldots, p_n \\}. \\] <p>Alice chooses \\(i\\) with probability \\(p_i\\) and creates the state \\(\\rho_i\\).</p> <p>Bob wants to guess which state he was not given from the collection of states. State exclusion implies that ability to discard at least one out of the \"n\" possible quantum states by applying a measurement.</p> <p>For <code>strategy = \"min_error\"</code>, this is the default method that yields the minimal probability of error for Bob.</p> <p>In that case, this function implements the following semidefinite program that provides the optimal probability with which Bob can conduct quantum state exclusion.</p> \\[     \\begin{equation}         \\begin{aligned}             \\text{minimize:} \\quad &amp; \\sum_{i=1}^n p_i \\langle M_i, \\rho_i \\rangle \\\\             \\text{subject to:} \\quad &amp; \\sum_{i=1}^n M_i = \\mathbb{I}_{\\mathcal{X}}, \\\\                                         &amp; M_0, \\ldots, M_n \\in \\text{Pos}(\\mathcal{X}).         \\end{aligned}     \\end{equation} \\] \\[     \\begin{equation}         \\begin{aligned}             \\text{maximize:} \\quad &amp; \\text{Tr}(Y) \\\\             \\text{subject to:} \\quad &amp; Y \\preceq p_1\\rho_1, \\\\                                         &amp; Y \\preceq p_2\\rho_2, \\\\                                         &amp; \\vdots \\\\                                         &amp; Y \\preceq p_n\\rho_n, \\\\                                         &amp; Y \\in\\text{Herm}(\\mathcal{X}).         \\end{aligned}     \\end{equation} \\] <p>For <code>strategy = \"unambiguous\"</code>, Bob never provides an incorrect answer, although it is possible that his answer is inconclusive. This function then yields the probability of an inconclusive outcome.</p> <p>In that case, this function implements the following semidefinite program that provides the optimal probability with which Bob can conduct unambiguous quantum state distinguishability.</p> \\[     \\begin{align*}         \\text{minimize:} \\quad &amp; \\text{Tr}\\left(             \\left(\\sum_{i=1}^n p_i\\rho_i\\right)\\left(\\mathbb{I}-\\sum_{i=1}^nM_i\\right)             \\right) \\\\         \\text{subject to:} \\quad &amp; \\sum_{i=1}^nM_i \\preceq \\mathbb{I},\\\\                                  &amp; M_1, \\ldots, M_n \\succeq 0, \\\\                                  &amp; \\langle M_1, \\rho_1 \\rangle, \\ldots, \\langle M_n, \\rho_n \\rangle =0     \\end{align*} \\] \\[     \\begin{align*}         \\text{maximize:} \\quad &amp; 1 - \\text{Tr}(N) \\\\         \\text{subject to:} \\quad &amp; a_1p_1\\rho_1, \\ldots, a_np_n\\rho_n \\succeq \\sum_{i=1}^np_i\\rho_i - N,\\\\                                  &amp; N \\succeq 0,\\\\                                  &amp; a_1, \\ldots, a_n \\in\\mathbb{R}     \\end{align*} \\] <p>Note</p> <p>This function supports both pure states (vectors) and mixed states (density matrices). It is known that it is always possible to perfectly exclude pure states that are linearly dependent. Thus, calling this function on a set of states with this property will return 0.</p> <p>The conclusive state exclusion SDP is written explicitly in <sup>1</sup>. The problem of conclusive state exclusion was also thought about under a different guise in <sup>2</sup>.</p> <p>Examples:</p> <p>Consider the following two Bell states</p> \\[     \\begin{equation}         \\begin{aligned}             u_0 &amp;= \\frac{1}{\\sqrt{2}} \\left( |00 \\rangle + |11 \\rangle \\right), \\\\             u_1 &amp;= \\frac{1}{\\sqrt{2}} \\left( |00 \\rangle - |11 \\rangle \\right).         \\end{aligned}     \\end{equation} \\] <p>It is not possible to conclusively exclude either of the two states. We can see that the result of the function in <code>|toqito\u27e9</code> yields a value of \\(0\\) as the probability for this to occur.</p> <pre><code>import numpy as np\nfrom toqito.states import bell\nfrom toqito.state_opt import state_exclusion\n\nvectors = [bell(0), bell(1)]\nprobs = [1/2, 1/2]\n\nprint(np.around(state_exclusion(vectors, probs)[0], decimals=2))\n</code></pre> <p>0.0</p> <p>Unambiguous state exclusion for unbiased pure states.</p> <pre><code>import numpy as np\nfrom toqito.state_opt import state_exclusion\n\nstates = [np.array([[1.], [0.]]), np.array([[1.],[1.]]) / np.sqrt(2)]\n\nres, _ = state_exclusion(states, primal_dual=\"primal\", strategy=\"unambiguous\", abs_ipm_opt_tol=1e-7)\n\nprint(np.around(res, decimals=2))\n</code></pre> <p>0.71</p> <p>State exclusion for mixed states.</p> <pre><code>import numpy as np\nfrom toqito.state_opt import state_exclusion\n\n# Two mixed states\nrho1 = 0.7 * np.array([[1., 0.], [0., 0.]]) + 0.3 * np.eye(2) / 2\nrho2 = 0.7 * np.array([[0., 0.], [0., 1.]]) + 0.3 * np.eye(2) / 2\nstates = [rho1, rho2]\n\nres, _ = state_exclusion(states, primal_dual=\"dual\")\n\nprint(np.around(res, decimals=2))\n</code></pre> <p>0.15</p> <p>Note</p> <p>If you encounter a <code>ZeroDivisionError</code> or an <code>ArithmeticError</code> when using cvxopt as a solver (which is the default), you might want to set the <code>abs_ipm_opt_tol</code> option to a lower value (the default being <code>1e-8</code>) or to set the <code>cvxopt_kktsolver</code> option to <code>ldl</code>.</p> <p>See https://gitlab.com/picos-api/picos/-/issues/341</p> <p>Parameters:</p> <ul> <li> <code>vectors</code>               (<code>list[ndarray]</code>)           \u2013            <p>A list of states provided as vectors (for pure states) or density matrices (for mixed states).</p> </li> <li> <code>probs</code>               (<code>list[float] | None</code>, default:                   <code>None</code> )           \u2013            <p>Respective list of probabilities each state is selected. If no probabilities are provided, a uniform</p> </li> <li> <code>strategy</code>               (<code>str</code>, default:                   <code>'min_error'</code> )           \u2013            <p>Whether to perform minimal error or unambiguous discrimination task. Possible values are \"min_error\"</p> </li> <li> <code>solver</code>               (<code>str</code>, default:                   <code>'cvxopt'</code> )           \u2013            <p>Optimization option for <code>picos</code> solver. Default option is <code>solver_option=\"cvxopt\"</code>.</p> </li> <li> <code>primal_dual</code>               (<code>str</code>, default:                   <code>'dual'</code> )           \u2013            <p>Option for the optimization problem.</p> </li> <li> <code>kwargs</code>           \u2013            <p>Additional arguments to pass to picos' solve method.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The optimal probability with which Bob can guess the state he was not given from <code>states</code> along with the optimal</p> </li> <li> <code>list[HermitianVariable] | tuple[HermitianVariable, RealVariable]</code>           \u2013            <p>set of measurements.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Bandyopadhyay, Somshubhro and Jain, Rahul and Oppenheim, Jonathan and Perry, Christopher. Conclusive exclusion of quantum states. Physical Review A. vol. 89(2). (2014). doi:10.1103/physreva.89.022336. <sup>2</sup> Pusey, Matthew and Barrett, Jonathan and Rudolph, Terry. On the reality of the quantum state. Nature Physics. vol. 8(6). (2012). doi:10.1038/nphys2309.</p> Source code in <code>toqito/state_opt/state_exclusion.py</code> <pre><code>def state_exclusion(\n    vectors: list[np.ndarray],\n    probs: list[float] | None = None,\n    strategy: str = \"min_error\",\n    solver: str = \"cvxopt\",\n    primal_dual: str = \"dual\",\n    **kwargs,\n) -&gt; tuple[float, list[picos.HermitianVariable] | tuple[picos.HermitianVariable, picos.RealVariable]]:\n    r\"\"\"Compute probability of error of single state conclusive state exclusion.\n\n    The *quantum state exclusion* problem involves a collection of \\(n\\) quantum states\n\n    \\[\n        \\rho = \\{ \\rho_0, \\ldots, \\rho_n \\},\n    \\]\n\n    as well as a list of corresponding probabilities\n\n    \\[\n        p = \\{ p_0, \\ldots, p_n \\}.\n    \\]\n\n    Alice chooses \\(i\\) with probability \\(p_i\\) and creates the state \\(\\rho_i\\).\n\n    Bob wants to guess which state he was *not* given from the collection of states. State exclusion implies that\n    ability to discard at least one out of the \"n\" possible quantum states by applying a measurement.\n\n    For `strategy = \"min_error\"`, this is the default method that yields the minimal probability of error for Bob.\n\n    In that case, this function implements the following semidefinite program that provides the optimal probability\n    with which Bob can conduct quantum state exclusion.\n\n    \\[\n        \\begin{equation}\n            \\begin{aligned}\n                \\text{minimize:} \\quad &amp; \\sum_{i=1}^n p_i \\langle M_i, \\rho_i \\rangle \\\\\n                \\text{subject to:} \\quad &amp; \\sum_{i=1}^n M_i = \\mathbb{I}_{\\mathcal{X}}, \\\\\n                                            &amp; M_0, \\ldots, M_n \\in \\text{Pos}(\\mathcal{X}).\n            \\end{aligned}\n        \\end{equation}\n    \\]\n\n    \\[\n        \\begin{equation}\n            \\begin{aligned}\n                \\text{maximize:} \\quad &amp; \\text{Tr}(Y) \\\\\n                \\text{subject to:} \\quad &amp; Y \\preceq p_1\\rho_1, \\\\\n                                            &amp; Y \\preceq p_2\\rho_2, \\\\\n                                            &amp; \\vdots \\\\\n                                            &amp; Y \\preceq p_n\\rho_n, \\\\\n                                            &amp; Y \\in\\text{Herm}(\\mathcal{X}).\n            \\end{aligned}\n        \\end{equation}\n    \\]\n\n    For `strategy = \"unambiguous\"`, Bob never provides an incorrect answer, although it is\n    possible that his answer is inconclusive. This function then yields the probability of an inconclusive outcome.\n\n    In that case, this function implements the following semidefinite program that provides the\n    optimal probability with which Bob can conduct unambiguous quantum state distinguishability.\n\n    \\[\n        \\begin{align*}\n            \\text{minimize:} \\quad &amp; \\text{Tr}\\left(\n                \\left(\\sum_{i=1}^n p_i\\rho_i\\right)\\left(\\mathbb{I}-\\sum_{i=1}^nM_i\\right)\n                \\right) \\\\\n            \\text{subject to:} \\quad &amp; \\sum_{i=1}^nM_i \\preceq \\mathbb{I},\\\\\n                                     &amp; M_1, \\ldots, M_n \\succeq 0, \\\\\n                                     &amp; \\langle M_1, \\rho_1 \\rangle, \\ldots, \\langle M_n, \\rho_n \\rangle =0\n        \\end{align*}\n    \\]\n\n    \\[\n        \\begin{align*}\n            \\text{maximize:} \\quad &amp; 1 - \\text{Tr}(N) \\\\\n            \\text{subject to:} \\quad &amp; a_1p_1\\rho_1, \\ldots, a_np_n\\rho_n \\succeq \\sum_{i=1}^np_i\\rho_i - N,\\\\\n                                     &amp; N \\succeq 0,\\\\\n                                     &amp; a_1, \\ldots, a_n \\in\\mathbb{R}\n        \\end{align*}\n    \\]\n\n\n    !!! Note\n        This function supports both pure states (vectors) and mixed states (density matrices).\n        It is known that it is always possible to perfectly exclude pure states that are linearly dependent.\n        Thus, calling this function on a set of states with this property will return 0.\n\n    The conclusive state exclusion SDP is written explicitly in [@Bandyopadhyay_2014_Conclusive]. The problem\n    of conclusive state exclusion was also thought about under a different guise in [@Pusey_2012_On].\n\n    Examples:\n        Consider the following two Bell states\n\n        \\[\n            \\begin{equation}\n                \\begin{aligned}\n                    u_0 &amp;= \\frac{1}{\\sqrt{2}} \\left( |00 \\rangle + |11 \\rangle \\right), \\\\\n                    u_1 &amp;= \\frac{1}{\\sqrt{2}} \\left( |00 \\rangle - |11 \\rangle \\right).\n                \\end{aligned}\n            \\end{equation}\n        \\]\n\n        It is not possible to conclusively exclude either of the two states. We can see that the result of the\n        function in\n        `|toqito\u27e9` yields a value of \\(0\\) as the probability for this to occur.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.states import bell\n        from toqito.state_opt import state_exclusion\n\n        vectors = [bell(0), bell(1)]\n        probs = [1/2, 1/2]\n\n        print(np.around(state_exclusion(vectors, probs)[0], decimals=2))\n        ```\n\n        Unambiguous state exclusion for unbiased pure states.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.state_opt import state_exclusion\n\n        states = [np.array([[1.], [0.]]), np.array([[1.],[1.]]) / np.sqrt(2)]\n\n        res, _ = state_exclusion(states, primal_dual=\"primal\", strategy=\"unambiguous\", abs_ipm_opt_tol=1e-7)\n\n        print(np.around(res, decimals=2))\n        ```\n\n        State exclusion for mixed states.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.state_opt import state_exclusion\n\n        # Two mixed states\n        rho1 = 0.7 * np.array([[1., 0.], [0., 0.]]) + 0.3 * np.eye(2) / 2\n        rho2 = 0.7 * np.array([[0., 0.], [0., 1.]]) + 0.3 * np.eye(2) / 2\n        states = [rho1, rho2]\n\n        res, _ = state_exclusion(states, primal_dual=\"dual\")\n\n        print(np.around(res, decimals=2))\n        ```\n\n        !!! Note\n            If you encounter a `ZeroDivisionError` or an `ArithmeticError` when using cvxopt as a solver (which is the\n            default), you might want to set the `abs_ipm_opt_tol` option to a lower value (the default being `1e-8`) or\n            to set the `cvxopt_kktsolver` option to `ldl`.\n\n            See https://gitlab.com/picos-api/picos/-/issues/341\n\n    Args:\n        vectors: A list of states provided as vectors (for pure states) or density matrices (for mixed states).\n        probs: Respective list of probabilities each state is selected. If no probabilities are provided, a uniform\n        probability distribution is assumed.\n        strategy: Whether to perform minimal error or unambiguous discrimination task. Possible values are \"min_error\"\n        and \"unambiguous\". Both strategies support pure and mixed states.\n        solver: Optimization option for `picos` solver. Default option is `solver_option=\"cvxopt\"`.\n        primal_dual: Option for the optimization problem.\n        kwargs: Additional arguments to pass to picos' solve method.\n\n    Returns:\n        The optimal probability with which Bob can guess the state he was not given from `states` along with the optimal\n        set of measurements.\n\n    \"\"\"\n    if not has_same_dimension(vectors):\n        raise ValueError(\"Vectors for state distinguishability must all have the same dimension.\")\n\n    # Assumes a uniform probabilities distribution among the states if one is not explicitly provided.\n    n = len(vectors)\n    probs = [1 / n] * n if probs is None else probs\n    dim = calculate_vector_matrix_dimension(vectors[0])\n\n    if strategy == \"min_error\":\n        if primal_dual == \"primal\":\n            return _min_error_primal(vectors=vectors, dim=dim, probs=probs, solver=solver, **kwargs)\n        return _min_error_dual(vectors=vectors, dim=dim, probs=probs, solver=solver, **kwargs)\n\n    if primal_dual == \"primal\":\n        return _unambiguous_primal(vectors=vectors, dim=dim, probs=probs, solver=solver, **kwargs)\n\n    return _unambiguous_dual(vectors=vectors, dim=dim, probs=probs, solver=solver, **kwargs)\n</code></pre>"},{"location":"reference/toqito/state_opt/state_helper/","title":"state_helper","text":""},{"location":"reference/toqito/state_opt/state_helper/#toqito.state_opt.state_helper","title":"state_helper","text":"<p>Helper functions for checking validity of states and probability vectors.</p>"},{"location":"reference/toqito/state_opt/state_helper/#toqito.state_opt.state_helper.__is_states_valid","title":"__is_states_valid","text":"<pre><code>__is_states_valid(states: list[ndarray]) -&gt; bool\n</code></pre> <p>Check if states provided are valid.</p> Source code in <code>toqito/state_opt/state_helper.py</code> <pre><code>def __is_states_valid(states: list[np.ndarray]) -&gt; bool:\n    \"\"\"Check if states provided are valid.\"\"\"\n    # Assume that at least one state is provided.\n    if states is None or states == []:\n        raise ValueError(\"InvalidStates: There must be at least one state provided.\")\n    return True\n</code></pre>"},{"location":"reference/toqito/state_opt/state_helper/#toqito.state_opt.state_helper.__is_probs_valid","title":"__is_probs_valid","text":"<pre><code>__is_probs_valid(probs: list[float]) -&gt; bool\n</code></pre> <p>Check if probabilities provided are valid.</p> Source code in <code>toqito/state_opt/state_helper.py</code> <pre><code>def __is_probs_valid(probs: list[float]) -&gt; bool:\n    \"\"\"Check if probabilities provided are valid.\"\"\"\n    if not np.isclose(sum(probs), 1):\n        raise ValueError(\"InvalidProbabilities: Probabilities must sum to 1.\")\n    return True\n</code></pre>"},{"location":"reference/toqito/state_opt/symmetric_extension_hierarchy/","title":"symmetric_extension_hierarchy","text":""},{"location":"reference/toqito/state_opt/symmetric_extension_hierarchy/#toqito.state_opt.symmetric_extension_hierarchy","title":"symmetric_extension_hierarchy","text":"<p>Calculates the optimal value of symmetric extension hierarchy SDP (semi definite programs).</p>"},{"location":"reference/toqito/state_opt/symmetric_extension_hierarchy/#toqito.state_opt.symmetric_extension_hierarchy.symmetric_extension_hierarchy","title":"symmetric_extension_hierarchy","text":"<pre><code>symmetric_extension_hierarchy(states: list[ndarray], probs: list[float] | None = None, level: int = 2, dim: int | list[int] | None = None) -&gt; float\n</code></pre> <p>Compute optimal value of the symmetric extension hierarchy SDP <sup>1</sup>.</p> <p>The probability of distinguishing a given set of states via PPT measurements serves as a natural upper bound to the value of obtaining via separable measurements. Due to the nature of separable measurements, it is not possible to optimize directly over these objects via semidefinite programming techniques.</p> <p>We can, however, construct a hierarchy of semidefinite programs that attains closer and closer approximations at the separable value via the techniques described in <sup>1</sup>.</p> <p>The mathematical form of this hierarchy implemented here is explicitly given from equation 4.55 in <sup>2</sup>.</p> \\[     \\begin{equation}         \\begin{aligned}             \\text{maximize:} \\quad &amp; \\sum_{k=1}^N p_k \\langle \\rho_k, \\mu(k) \\rangle, \\\\             \\text{subject to:} \\quad &amp; \\sum_{k=1}^N \\mu(k) =                                        \\mathbb{I}_{\\mathcal{X} \\otimes \\mathcal{Y}}, \\\\                                     &amp; \\text{Tr}_{\\mathcal{Y}_2 \\otimes \\ldots \\otimes                                       \\mathcal{Y}_s}(X_k) = \\mu(k), \\\\                                     &amp; \\left( \\mathbb{I}_{\\mathcal{X}} \\otimes                                       \\Pi_{\\mathcal{Y} \\circledvee \\mathcal{Y}_2 \\circledvee \\ldots \\circledvee                                       \\mathcal{Y}_s} \\right) X_k                                       \\left(\\mathbb{I}_{\\mathcal{X}} \\otimes                                       \\Pi_{\\mathcal{Y} \\circledvee \\mathcal{Y}_2 \\circledvee \\ldots \\circledvee                                       \\mathcal{Y}_s} \\right)                                       = X_k \\\\                                     &amp; \\text{T}_{\\mathcal{X}}(X_k) \\in \\text{Pos}\\left(                                         \\mathcal{X} \\otimes \\mathcal{Y} \\otimes \\mathcal{Y}_2                                         \\otimes \\ldots \\otimes \\mathcal{Y}_s \\right), \\\\                                     &amp; \\text{T}_{\\mathcal{Y}_2 \\otimes \\ldots \\otimes                                         \\mathcal{Y}_s}(X_k) \\in \\text{Pos}\\left(                                         \\mathcal{X} \\otimes \\mathcal{Y} \\otimes \\mathcal{Y}_2                                         \\otimes \\ldots \\otimes \\mathcal{Y}_s \\right), \\\\                                     &amp; X_1, \\ldots, X_N \\in                                       \\text{Pos}\\left(\\mathcal{X} \\otimes \\mathcal{Y} \\otimes                                       \\mathcal{Y}_2 \\otimes \\ldots \\otimes \\mathcal{Y}_s                                       \\right).         \\end{aligned}     \\end{equation} \\] <p>Examples:</p> <p>It is known from <sup>2</sup> that distinguishing three Bell states along with a resource state \\(|\\tau_{\\epsilon}\\rangle\\) via separable measurements has the following closed form</p> \\[     \\frac{1}{3} \\left(2 + \\sqrt{1 - \\epsilon^2} \\right) \\] <p>where the resource state is defined as</p> \\[     |\\tau_{\\epsilon} \\rangle = \\sqrt{\\frac{1+\\epsilon}{2}} |00\\rangle +                                \\sqrt{\\frac{1-\\epsilon}{2}} |11\\rangle. \\] <p>The value of optimally distinguishing these states via PPT measurements is strictly larger than the value one obtains from separable measurements. Calculating the first level of the hierarchy provides for us the optimal value of PPT measurements.</p> <p>Consider a fixed value of \\(\\epsilon = 0.5\\).</p> <pre><code>from toqito.states import basis, bell\nfrom toqito.perms import swap\nfrom toqito.state_opt import symmetric_extension_hierarchy\nimport numpy as np\n\n# Create standard basis vectors.\ne_0, e_1 = basis(2, 0), basis(2, 1)\ne_00, e_11 = np.kron(e_0, e_0), np.kron(e_1, e_1)\n\n# Define the resource state.\neps = 0.5\neps_state = np.sqrt((1 + eps) / 2) * e_00 + np.sqrt((1 - eps) / 2) * e_11\neps_dm = eps_state @ eps_state.conj().T\n\n# Define the ensemble of Bell states tensored with the resource state.\nstates = [\n    np.kron(bell(0) @ bell(0).conj().T, eps_dm),\n    np.kron(bell(1) @ bell(1).conj().T, eps_dm),\n    np.kron(bell(2) @ bell(2).conj().T, eps_dm),\n    np.kron(bell(3) @ bell(3).conj().T, eps_dm),\n]\n\n# Ensure correct ordering of subsystems.\nstates = [\n    swap(states[0], [2, 3], [2, 2, 2, 2]),\n    swap(states[1], [2, 3], [2, 2, 2, 2]),\n    swap(states[2], [2, 3], [2, 2, 2, 2]),\n]\n\n# Calculate the first and second levels of the symmetric extension hierarchy.\nval_lvl_1 = symmetric_extension_hierarchy(states=states, probs=None, level=1)\nval_lvl_2 = symmetric_extension_hierarchy(states=states, probs=None, level=2)\n\n# Compute the true separable value as proven in literature.\ntrue_sep_val = (1/3) * (2 + np.sqrt(1 - eps**2))\n\nprint(f\"Level 1 symmetric extension value: {np.around(val_lvl_1, decimals=2)}\")\nprint(f\"Level 2 symmetric extension value: {np.around(val_lvl_2, decimals=2)}\")\nprint(f\"True separable value: {np.around(true_sep_val, decimals=2)}\")\n</code></pre> <p>Level 1 symmetric extension value: 0.99 Level 2 symmetric extension value: 0.96 True separable value: 0.96</p> <p>Parameters:</p> <ul> <li> <code>states</code>               (<code>list[ndarray]</code>)           \u2013            <p>A list of states provided as either matrices or vectors.</p> </li> <li> <code>probs</code>               (<code>list[float] | None</code>, default:                   <code>None</code> )           \u2013            <p>Respective list of probabilities each state is selected.</p> </li> <li> <code>level</code>               (<code>int</code>, default:                   <code>2</code> )           \u2013            <p>Level of the hierarchy to compute.</p> </li> <li> <code>dim</code>               (<code>int | list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The default has both subsystems of equal dimension.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The optimal probability of the symmetric extension hierarchy SDP for level <code>level</code>.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Navascu\u00e9s, Miguel. Pure State Estimation and the Characterization of Entanglement. Physical Review Letters. vol. 100(7). (2008). doi:10.1103/physrevlett.100.070503. <sup>2</sup> Cosentino, Alessandro. Quantum State Local Distinguishability via Convex Optimization. (2015). link.</p> Source code in <code>toqito/state_opt/symmetric_extension_hierarchy.py</code> <pre><code>def symmetric_extension_hierarchy(\n    states: list[np.ndarray],\n    probs: list[float] | None = None,\n    level: int = 2,\n    dim: int | list[int] | None = None,\n) -&gt; float:\n    r\"\"\"Compute optimal value of the symmetric extension hierarchy SDP [@Navascues_2008_Pure].\n\n    The probability of distinguishing a given set of states via PPT measurements serves as a natural\n    upper bound to the value of obtaining via separable measurements. Due to the nature of separable\n    measurements, it is not possible to optimize directly over these objects via semidefinite\n    programming techniques.\n\n    We can, however, construct a hierarchy of semidefinite programs that attains closer and closer\n    approximations at the separable value via the techniques described in [@Navascues_2008_Pure].\n\n    The mathematical form of this hierarchy implemented here is explicitly given from equation 4.55\n    in [@Cosentino_2015_QuantumState].\n\n    \\[\n        \\begin{equation}\n            \\begin{aligned}\n                \\text{maximize:} \\quad &amp; \\sum_{k=1}^N p_k \\langle \\rho_k, \\mu(k) \\rangle, \\\\\n                \\text{subject to:} \\quad &amp; \\sum_{k=1}^N \\mu(k) =\n                                           \\mathbb{I}_{\\mathcal{X} \\otimes \\mathcal{Y}}, \\\\\n                                        &amp; \\text{Tr}_{\\mathcal{Y}_2 \\otimes \\ldots \\otimes\n                                          \\mathcal{Y}_s}(X_k) = \\mu(k), \\\\\n                                        &amp; \\left( \\mathbb{I}_{\\mathcal{X}} \\otimes\n                                          \\Pi_{\\mathcal{Y} \\circledvee \\mathcal{Y}_2 \\circledvee \\ldots \\circledvee\n                                          \\mathcal{Y}_s} \\right) X_k\n                                          \\left(\\mathbb{I}_{\\mathcal{X}} \\otimes\n                                          \\Pi_{\\mathcal{Y} \\circledvee \\mathcal{Y}_2 \\circledvee \\ldots \\circledvee\n                                          \\mathcal{Y}_s} \\right)\n                                          = X_k \\\\\n                                        &amp; \\text{T}_{\\mathcal{X}}(X_k) \\in \\text{Pos}\\left(\n                                            \\mathcal{X} \\otimes \\mathcal{Y} \\otimes \\mathcal{Y}_2\n                                            \\otimes \\ldots \\otimes \\mathcal{Y}_s \\right), \\\\\n                                        &amp; \\text{T}_{\\mathcal{Y}_2 \\otimes \\ldots \\otimes\n                                            \\mathcal{Y}_s}(X_k) \\in \\text{Pos}\\left(\n                                            \\mathcal{X} \\otimes \\mathcal{Y} \\otimes \\mathcal{Y}_2\n                                            \\otimes \\ldots \\otimes \\mathcal{Y}_s \\right), \\\\\n                                        &amp; X_1, \\ldots, X_N \\in\n                                          \\text{Pos}\\left(\\mathcal{X} \\otimes \\mathcal{Y} \\otimes\n                                          \\mathcal{Y}_2 \\otimes \\ldots \\otimes \\mathcal{Y}_s\n                                          \\right).\n            \\end{aligned}\n        \\end{equation}\n    \\]\n\n    Examples:\n        It is known from [@Cosentino_2015_QuantumState] that distinguishing three Bell states along with a resource\n        state \\(|\\tau_{\\epsilon}\\rangle\\) via separable measurements has the following closed form\n\n        \\[\n            \\frac{1}{3} \\left(2 + \\sqrt{1 - \\epsilon^2} \\right)\n        \\]\n\n        where the resource state is defined as\n\n        \\[\n            |\\tau_{\\epsilon} \\rangle = \\sqrt{\\frac{1+\\epsilon}{2}} |00\\rangle +\n                                       \\sqrt{\\frac{1-\\epsilon}{2}} |11\\rangle.\n        \\]\n\n        The value of optimally distinguishing these states via PPT measurements is strictly larger than\n        the value one obtains from separable measurements. Calculating the first level of the hierarchy\n        provides for us the optimal value of PPT measurements.\n\n        Consider a fixed value of \\(\\epsilon = 0.5\\).\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import basis, bell\n        from toqito.perms import swap\n        from toqito.state_opt import symmetric_extension_hierarchy\n        import numpy as np\n\n        # Create standard basis vectors.\n        e_0, e_1 = basis(2, 0), basis(2, 1)\n        e_00, e_11 = np.kron(e_0, e_0), np.kron(e_1, e_1)\n\n        # Define the resource state.\n        eps = 0.5\n        eps_state = np.sqrt((1 + eps) / 2) * e_00 + np.sqrt((1 - eps) / 2) * e_11\n        eps_dm = eps_state @ eps_state.conj().T\n\n        # Define the ensemble of Bell states tensored with the resource state.\n        states = [\n            np.kron(bell(0) @ bell(0).conj().T, eps_dm),\n            np.kron(bell(1) @ bell(1).conj().T, eps_dm),\n            np.kron(bell(2) @ bell(2).conj().T, eps_dm),\n            np.kron(bell(3) @ bell(3).conj().T, eps_dm),\n        ]\n\n        # Ensure correct ordering of subsystems.\n        states = [\n            swap(states[0], [2, 3], [2, 2, 2, 2]),\n            swap(states[1], [2, 3], [2, 2, 2, 2]),\n            swap(states[2], [2, 3], [2, 2, 2, 2]),\n        ]\n\n        # Calculate the first and second levels of the symmetric extension hierarchy.\n        val_lvl_1 = symmetric_extension_hierarchy(states=states, probs=None, level=1)\n        val_lvl_2 = symmetric_extension_hierarchy(states=states, probs=None, level=2)\n\n        # Compute the true separable value as proven in literature.\n        true_sep_val = (1/3) * (2 + np.sqrt(1 - eps**2))\n\n        print(f\"Level 1 symmetric extension value: {np.around(val_lvl_1, decimals=2)}\")\n        print(f\"Level 2 symmetric extension value: {np.around(val_lvl_2, decimals=2)}\")\n        print(f\"True separable value: {np.around(true_sep_val, decimals=2)}\")\n        ```\n\n    Args:\n        states: A list of states provided as either matrices or vectors.\n        probs: Respective list of probabilities each state is selected.\n        level: Level of the hierarchy to compute.\n        dim: The default has both subsystems of equal dimension.\n\n    Returns:\n        The optimal probability of the symmetric extension hierarchy SDP for level `level`.\n\n    \"\"\"\n    obj_func = []\n    meas = []\n    x_var = []\n    constraints = []\n\n    __is_states_valid(states)\n    if probs is None:\n        probs = [1 / len(states)] * len(states)\n    __is_probs_valid(probs)\n\n    dim_xy, n_cols = states[0].shape\n\n    # The variable `states` is provided as a list of vectors. Transform them\n    # into density matrices.\n    if n_cols == 1:\n        for i, state_ket in enumerate(states):\n            states[i] = state_ket @ state_ket.conj().T\n\n    # Set default dimension if none was provided.\n    if dim is None:\n        dim = int(np.round(np.sqrt(dim_xy)))\n\n    # Allow the user to enter in a single integer for dimension.\n    if isinstance(dim, int):\n        dim = np.array([dim, dim_xy / dim])\n        if np.abs(dim[1] - np.round(dim[1])) &gt;= 2 * dim_xy * np.finfo(float).eps:\n            raise ValueError(\"If `dim` is a scalar, it must evenly divide the length of the state.\")\n        dim[1] = int(np.round(dim[1]))\n\n    dim_x, dim_y = int(dim[0]), int(dim[1])\n\n    dim_list = [dim_x] + [dim_y] * level\n    dim_list = np.int_(dim_list)\n    # The `sys_list` variable contains the numbering pertaining to the symmetrically extended\n    # spaces.\n    sys_list = list(range(2, 2 + level - 1))\n    sym = symmetric_projection(dim_y, level)\n\n    dim_xyy = np.prod(dim_list)\n    for k, item in enumerate(states):\n        meas.append(cvxpy.Variable((dim_xy, dim_xy), hermitian=True))\n        x_var.append(cvxpy.Variable((dim_xyy, dim_xyy), hermitian=True))\n        constraints.append(partial_trace(x_var[k], sys_list, dim_list) == meas[k])\n        constraints.append(x_var[k] &gt;&gt; 0)\n        constraints.append(meas[k] &gt;&gt; 0)\n        constraints.append(np.kron(np.identity(dim_x), sym) @ x_var[k] @ np.kron(np.identity(dim_x), sym) == x_var[k])\n        constraints.append(partial_transpose(x_var[k], [0], dim_list) &gt;&gt; 0)\n        for sys in range(level - 1):\n            constraints.append(partial_transpose(x_var[k], [sys + 2], dim_list) &gt;&gt; 0)\n\n        obj_func.append(probs[k] * cvxpy.trace(item.conj().T @ meas[k]))\n\n    constraints.append(sum(meas) == np.identity(dim_xy))\n\n    objective = cvxpy.Maximize(cvxpy.real(sum(obj_func)))\n    problem = cvxpy.Problem(objective, constraints)\n    sol_default = problem.solve()\n\n    return sol_default\n</code></pre>"},{"location":"reference/toqito/state_props/","title":"state_props","text":""},{"location":"reference/toqito/state_props/#toqito.state_props","title":"state_props","text":"<p>State Properties is a set of modules that implements some common properties of quantum states.</p>"},{"location":"reference/toqito/state_props/abs_ppt_constraints/","title":"abs_ppt_constraints","text":""},{"location":"reference/toqito/state_props/abs_ppt_constraints/#toqito.state_props.abs_ppt_constraints","title":"abs_ppt_constraints","text":"<p>Compute the constraints on a spectrum for it to be absolutely PPT.</p>"},{"location":"reference/toqito/state_props/abs_ppt_constraints/#toqito.state_props.abs_ppt_constraints.abs_ppt_constraints","title":"abs_ppt_constraints","text":"<pre><code>abs_ppt_constraints(eigs: ndarray | Variable, p: int, max_constraints: int = 33592, use_check: bool = False) -&gt; list[ndarray | Expression]\n</code></pre> <p>Return the constraint matrices for the spectrum to be absolutely PPT <sup>1</sup>.</p> <p>The returned matrices are constructed from the provided eigenvalues <code>eigs</code>, and they must all be positive semidefinite for the spectrum to be absolutely PPT.</p> <p>Note</p> <p>The function does not always return the optimal number of constraint matrices. There are some redundant constraint matrices <sup>2</sup>.</p> <ul> <li>With <code>use_checks=False</code>, the number of matrices returned starting from \\(p=1\\) is   \\([0, 1, 2, 12, 286, 33592, 23178480, \\ldots]\\).</li> <li>With <code>use_checks=True</code>, the number of matrices returned starting from \\(p=1\\) is   \\([0, 1, 2, 10, 114, 2612, 108664, \\ldots]\\).</li> </ul> <p>However, the optimal number of matrices starting from \\(p=1\\) is given by \\([0, 1, 2, 10, 114, 2608, 107498]\\).</p> <p>Note</p> <p>This function accepts a <code>cvxpy</code> Variable as input for <code>eigs</code>. The function will return the assembled constraint matrices as a list of <code>cvxpy</code> Expressions. These can be used with <code>cvxpy</code> to optimize over the space of absolutely PPT matrices.</p> <p>The user must impose the condition <code>eigs[0] \u2265 eigs[1] \u2265 ... \u2265 eigs[-1] \u2265 0</code> and the positive semidefinite constraint on each returned matrix separately.</p> <p>It is recommended to set <code>use_check=True</code> for this use case to minimize the number of constraint equations in the problem.</p> <p>This function is adapted from QETLAB <sup>3</sup>.</p> <p>Examples:</p> <p>We can compute the constraint matrices for a random density matrix:</p> <pre><code>import numpy as np\nfrom toqito.rand import random_density_matrix\nfrom toqito.state_props import abs_ppt_constraints\n\nrho = random_density_matrix(9)  # assumed to act on a 3 x 3 bipartite system\neigs = np.linalg.eigvalsh(rho)\nconstraints = abs_ppt_constraints(eigs, 3)\nfor i, cons in enumerate(constraints, 1):\n    print(f\"Constraint {i}:\")\n    print(cons)\n</code></pre> <p>Constraint 1: [[ 0.00504561 -0.38859093 -0.22868512]  [-0.38859093  0.06905425 -0.07065228]  [-0.22868512 -0.07065228  0.2098964 ]] Constraint 2: [[ 0.00504561 -0.38859093 -0.20919014]  [-0.38859093  0.0300643  -0.07065228]  [-0.20919014 -0.07065228  0.2098964 ]]</p> <p>Raises:     TypeError: If <code>eigs</code> is not a <code>numpy</code> ndarray or a <code>cvxpy</code> Variable.</p> <p>Parameters:</p> <ul> <li> <code>eigs</code>               (<code>ndarray | Variable</code>)           \u2013            <p>A list of eigenvalues.</p> </li> <li> <code>p</code>               (<code>int</code>)           \u2013            <p>The dimension of the smaller subsystem in the bipartite system.</p> </li> <li> <code>max_constraints</code>               (<code>int</code>, default:                   <code>33592</code> )           \u2013            <p>The maximum number of constraint matrices to compute. (default: 33,592)</p> </li> <li> <code>use_check</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Use the \"criss-cross\" ordering check described in <sup>2</sup> to reduce the number of</p> </li> <li> <code>constraint matrices. (default</code>           \u2013            <p><code>False</code>)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[ndarray | Expression]</code>           \u2013            <p>A list of <code>max_constraints</code> constraint matrices which must be positive semidefinite for an absolutely PPT</p> </li> <li> <code>list[ndarray | Expression]</code>           \u2013            <p>spectrum.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Hildebrand, Roland. Positive partial transpose from spectra. Phys. Rev. A. vol. 76. (2007). doi:10.1103/PhysRevA.76.052325. <sup>2</sup> Johnston, Nathaniel. Counting the Possible Orderings of Pairwise Multiplication. (2014). link. <sup>3</sup> Johnston, Nathaniel. {{QETLAB}: {A MATLAB} toolbox for quantum entanglement}. doi:10.5281/zenodo.44637.</p> Source code in <code>toqito/state_props/abs_ppt_constraints.py</code> <pre><code>def abs_ppt_constraints(\n    eigs: np.ndarray | cp.Variable, p: int, max_constraints: int = 33_592, use_check: bool = False\n) -&gt; list[np.ndarray | cp.Expression]:\n    r\"\"\"Return the constraint matrices for the spectrum to be absolutely PPT [@Hildebrand_2007_AbsPPT].\n\n    The returned matrices are constructed from the provided eigenvalues `eigs`, and they must all be positive\n    semidefinite for the spectrum to be absolutely PPT.\n\n\n    !!! Note\n        The function does not always return the optimal number of constraint matrices.\n        There are some redundant constraint matrices [@Johnston_2014_Orderings].\n\n        * With `use_checks=False`, the number of matrices returned starting from \\(p=1\\) is\n          \\([0, 1, 2, 12, 286, 33592, 23178480, \\ldots]\\).\n        * With `use_checks=True`, the number of matrices returned starting from \\(p=1\\) is\n          \\([0, 1, 2, 10, 114, 2612, 108664, \\ldots]\\).\n\n        However, the optimal number of matrices starting from \\(p=1\\) is given by\n        \\([0, 1, 2, 10, 114, 2608, 107498]\\).\n\n    !!! Note\n        This function accepts a `cvxpy` Variable as input for `eigs`. The function\n        will return the assembled constraint matrices as a list of `cvxpy` Expressions.\n        These can be used with `cvxpy` to optimize over the space of absolutely PPT matrices.\n\n        The user must impose the condition `eigs[0] \u2265 eigs[1] \u2265 ... \u2265 eigs[-1] \u2265 0` and the\n        positive semidefinite constraint on each returned matrix separately.\n\n        It is recommended to set `use_check=True` for this use case to minimize the number of\n        constraint equations in the problem.\n\n    This function is adapted from QETLAB [@QETLAB_link].\n\n    Examples:\n        We can compute the constraint matrices for a random density matrix:\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.rand import random_density_matrix\n        from toqito.state_props import abs_ppt_constraints\n\n        rho = random_density_matrix(9)  # assumed to act on a 3 x 3 bipartite system\n        eigs = np.linalg.eigvalsh(rho)\n        constraints = abs_ppt_constraints(eigs, 3)\n        for i, cons in enumerate(constraints, 1):\n            print(f\"Constraint {i}:\")\n            print(cons)\n        ```\n    Raises:\n        TypeError: If `eigs` is not a `numpy` ndarray or a `cvxpy` Variable.\n\n    Args:\n        eigs: A list of eigenvalues.\n        p: The dimension of the smaller subsystem in the bipartite system.\n        max_constraints: The maximum number of constraint matrices to compute. (default: 33,592)\n        use_check: Use the \"criss-cross\" ordering check described in [@Johnston_2014_Orderings] to reduce the number of\n        constraint matrices. (default: `False`)\n\n    Returns:\n        A list of `max_constraints` constraint matrices which must be positive semidefinite for an absolutely PPT\n        spectrum.\n\n    \"\"\"\n    if isinstance(eigs, np.ndarray):\n        eigs = np.sort(eigs)[::-1]\n    elif isinstance(eigs, cp.Variable):\n        pass\n    else:\n        raise TypeError(\"mat must be a numpy ndarray or a cvxpy Variable\")\n\n    # Hard-code matrices for p = 1, 2.\n    if p == 1:\n        return []\n    if p == 2:\n        add_index = np.array([[-1, -2], [-2, -3]], dtype=np.int32)\n        sub_index = np.array([[-1, 0], [0, -3]], dtype=np.int32)\n        diag = np.diag if isinstance(eigs, np.ndarray) else cp.diag\n        return [eigs[add_index] - eigs[sub_index] + 2 * diag(eigs[np.diag(add_index)])]\n\n    p_plus = p * (p + 1) // 2\n    order_matrix = np.zeros((p, p), dtype=np.int32)\n    available = np.ones(p_plus, dtype=bool)\n    constraints = []\n\n    # The first two elements of the first row and the last two elements of the last column are fixed.\n    order_matrix[0, 0] = 1\n    order_matrix[0, 1] = 2\n    order_matrix[-1, -1] = p_plus\n    order_matrix[-2, -1] = p_plus - 1\n\n    def _fill_matrix(row: int, col: int, l_lim: int) -&gt; None:\n        r\"\"\"Construct all valid orderings by backtracking. Processes order matrix in row major order.\n\n        A valid ordering has rows and columns of the upper triangle + diagonal in ascending order.\n        \"\"\"\n        # If we already constructed enough constraints, exit.\n        if len(constraints) == max_constraints:\n            return\n        col_plus = col * (col + 1) // 2\n        # We check numbers in [l_lim, u_lim].\n        # u_lim is calculated by considering how many numbers are definitely not admissible for\n        # the current location, which is the number of locations to the lower-right of the\n        # current position (directly below and directly to the right included).\n        u_lim = min(row * (p - col) + col_plus + 1, p_plus - 2)\n        for k in range(l_lim, u_lim + 1):\n            # If k is available, try it.\n            if available[k]:\n                order_matrix[row, col] = k\n                available[k] = False\n                # If placing this k was valid, then we proceed.\n                # We only check the ascending column condition because the rows are\n                # ascending by construction.\n                # A simple explanation: We set l_lim to be greater than the last set number\n                # and we are setting elements in row major order.\n                if row == 0 or order_matrix[row - 1, col] &lt; order_matrix[row, col]:\n                    if row == p - 2 and col == p - 2:\n                        # We already placed the last two elements of the last column, so\n                        # we have completed the matrix.\n                        # Now we create a constraint matrix out of this order matrix.\n                        if not use_check or _check_cross(order_matrix, p):\n                            constraints.append(_create_constraint(eigs, order_matrix, p))\n                    elif col == p - 1:\n                        # We finished the current row, so head to the next row.\n                        # Also reset l_lim: It will automatically be set to a valid value\n                        # by the column ordering check.\n                        _fill_matrix(row + 1, row + 1, 3)\n                    else:\n                        # We are not done with the current row, so head to the next column.\n                        # Set l_lim to be greater than the current number to maintain the\n                        # row ordering condition.\n                        _fill_matrix(row, col + 1, k + 1)\n                available[k] = True\n\n    def _check_cross(order_matrix: np.ndarray, p: int) -&gt; bool:\n        r\"\"\"Check if the order matrix satisfies the \"criss-cross\" check in [@Johnston_2014_Orderings].\"\"\"\n        for j in range(p - 3):\n            for k in range(2, p):\n                for m in range(p - 2):\n                    for n in range(1, p):\n                        for x in range(p - 1):\n                            for g in range(1, p):\n                                if (\n                                    order_matrix[min(j, k)][max(j, k)] &gt; order_matrix[min(m, n)][max(m, n)]\n                                    and order_matrix[min(n, g)][max(n, g)] &gt; order_matrix[min(k, x)][max(k, x)]\n                                    and order_matrix[min(j, g)][max(j, g)] &lt; order_matrix[min(m, x)][max(m, x)]\n                                ):\n                                    return False\n        return True\n\n    def _create_constraint(eigs: np.ndarray, order_matrix: np.ndarray, p: int) -&gt; np.ndarray:\n        r\"\"\"Return constraint matrix from order matrix.\"\"\"\n        add_index = -np.where(order_matrix, order_matrix, order_matrix.T)\n        renum_su_tri = np.unique(order_matrix - np.diag(np.diag(order_matrix)), return_inverse=True)[1].reshape(p, p)\n        sub_index = renum_su_tri + renum_su_tri.T - 1 + np.diag(np.diag(add_index) + 1)\n        diag = np.diag if isinstance(eigs, np.ndarray) else cp.diag\n        return eigs[add_index] - eigs[sub_index] + 2 * diag(eigs[np.diag(add_index)])\n\n    # We already set the first two elements of the first row, so start from the third element.\n    # We also used 1 and 2 already in order_matrix, so we start checking numbers from 3.\n    _fill_matrix(0, 2, 3)\n\n    return constraints\n</code></pre>"},{"location":"reference/toqito/state_props/common_quantum_overlap/","title":"common_quantum_overlap","text":""},{"location":"reference/toqito/state_props/common_quantum_overlap/#toqito.state_props.common_quantum_overlap","title":"common_quantum_overlap","text":"<p>Computes the common quantum overlap quantum states.</p>"},{"location":"reference/toqito/state_props/common_quantum_overlap/#toqito.state_props.common_quantum_overlap.common_quantum_overlap","title":"common_quantum_overlap","text":"<pre><code>common_quantum_overlap(states: list[ndarray]) -&gt; float\n</code></pre> <p>Calculate the common quantum overlap of a collection of quantum states.</p> <p>For more information, see <sup>1</sup>.</p> <p>The common quantum overlap \\(\\omega_Q[n]\\) quantifies the \"overlap\" between \\(n\\) quantum states based on their antidistinguishability properties. It is related to the antidistinguishability probability \\(A_Q[n]\\) by the formula:</p> \\[     \\omega_Q[n] = n(1 - A_Q[n]) \\] <p>For two pure states with inner product \\(|\\langle\\psi|\\phi\\rangle| = p\\), the common quantum overlap is:</p> \\[     \\omega_Q = 1 - \\sqrt{1 - p^2} \\] <p>The common quantum overlap is a key concept in analyzing epistemic models of quantum mechanics and understanding quantum state preparation contextuality.</p> <p>Examples:</p> <p>Consider the Bell states:</p> <pre><code>from toqito.states import bell\nfrom toqito.state_props import common_quantum_overlap\nbell_states = [bell(0), bell(1), bell(2), bell(3)]\nprint(common_quantum_overlap(bell_states))\n</code></pre> <p>3.3910878549647805e-09</p> <p>For maximally mixed states in any dimension:</p> <pre><code>import numpy as np\nfrom toqito.state_props import common_quantum_overlap\ndim = 2\nstates = [np.eye(dim) / dim, np.eye(dim) / dim, np.eye(dim) / dim]\nprint(common_quantum_overlap(states))\n</code></pre> <p>0.9999999999999998</p> <p>The common quantum overlap \\(\\omega_Q\\) for two pure states with inner product \\(|\\langle \\psi | \\phi \\rangle| = \\cos(\\theta)\\) is given by:</p> \\[     \\omega_Q = 1 - \\sqrt{1 - \\cos(\\theta)^2} \\] <p>where \\(\\theta\\) represents the angle between the two states in Hilbert space. For two pure states with a known inner product:</p> <pre><code>import numpy as np\nfrom toqito.state_props import common_quantum_overlap\ntheta = np.pi/4\nstates = [np.array([1, 0]), np.array([np.cos(theta), np.sin(theta)])]\nprint(common_quantum_overlap(states)) # Should approximate (1-sqrt(1-cos\u00b2(\u03c0/4)))\n</code></pre> <p>0.29289321883356556</p> <p>Parameters:</p> <ul> <li> <code>states</code>               (<code>list[ndarray]</code>)           \u2013            <p>A list of quantum states represented as numpy arrays. States can be pure states</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The common quantum overlap value.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Campos, A. and Schmid, D. and Mamani, L. and Spekkens, R. and Sainz, I.. No epistemic model can explain anti-distinguishability of quantum mixed preparations. (2024). link.</p> Source code in <code>toqito/state_props/common_quantum_overlap.py</code> <pre><code>def common_quantum_overlap(states: list[np.ndarray]) -&gt; float:\n    r\"\"\"Calculate the common quantum overlap of a collection of quantum states.\n\n    For more information, see [@Campos_2024_Epistemic].\n\n    The common quantum overlap \\(\\omega_Q[n]\\) quantifies the \"overlap\" between \\(n\\) quantum states\n    based on their antidistinguishability properties. It is related to the\n    antidistinguishability probability \\(A_Q[n]\\) by the formula:\n\n    \\[\n        \\omega_Q[n] = n(1 - A_Q[n])\n    \\]\n\n    For two pure states with inner product \\(|\\langle\\psi|\\phi\\rangle| = p\\), the common quantum overlap is:\n\n    \\[\n        \\omega_Q = 1 - \\sqrt{1 - p^2}\n    \\]\n\n    The common quantum overlap is a key concept in analyzing epistemic models of quantum\n    mechanics and understanding quantum state preparation contextuality.\n\n    Examples:\n        Consider the Bell states:\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import bell\n        from toqito.state_props import common_quantum_overlap\n        bell_states = [bell(0), bell(1), bell(2), bell(3)]\n        print(common_quantum_overlap(bell_states))\n        ```\n\n        For maximally mixed states in any dimension:\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.state_props import common_quantum_overlap\n        dim = 2\n        states = [np.eye(dim) / dim, np.eye(dim) / dim, np.eye(dim) / dim]\n        print(common_quantum_overlap(states))\n        ```\n\n        The common quantum overlap \\(\\omega_Q\\) for two pure states\n        with inner product \\(|\\langle \\psi | \\phi \\rangle| = \\cos(\\theta)\\) is given by:\n\n        \\[\n            \\omega_Q = 1 - \\sqrt{1 - \\cos(\\theta)^2}\n        \\]\n\n        where \\(\\theta\\) represents the angle between the two states in Hilbert space.\n        For two pure states with a known inner product:\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.state_props import common_quantum_overlap\n        theta = np.pi/4\n        states = [np.array([1, 0]), np.array([np.cos(theta), np.sin(theta)])]\n        print(common_quantum_overlap(states)) # Should approximate (1-sqrt(1-cos\u00b2(\u03c0/4)))\n        ```\n\n    Args:\n        states: A list of quantum states represented as numpy arrays. States can be pure states\n        (represented as state vectors) or mixed states (represented as density matrices).\n\n    Returns:\n        The common quantum overlap value.\n\n    \"\"\"\n    n = len(states)\n    opt_val, _ = state_exclusion(vectors=states, probs=[1] * n, primal_dual=\"dual\")\n    return n * (1 - (1 - opt_val / n))\n</code></pre>"},{"location":"reference/toqito/state_props/concurrence/","title":"concurrence","text":""},{"location":"reference/toqito/state_props/concurrence/#toqito.state_props.concurrence","title":"concurrence","text":"<p>Concurrence property calculates the concurrence of a bipartite state.</p> <p>The concurrence property is an entanglement measure defined for the product states of two qubits.</p>"},{"location":"reference/toqito/state_props/concurrence/#toqito.state_props.concurrence.concurrence","title":"concurrence","text":"<pre><code>concurrence(rho: ndarray) -&gt; float\n</code></pre> <p>Calculate the concurrence of a bipartite state <sup>1</sup>.</p> <p>The concurrence of a bipartite state \\(\\rho\\) is defined as</p> \\[     \\max(0, \\lambda_1 - \\lambda_2 - \\lambda_3 - \\lambda_4), \\] <p>where \\(\\lambda_1, \\ldots, \\lambda_4\\) are the square roots of the eigenvalues in decreasing order of the matrix</p> \\[     \\rho\\tilde{\\rho} = \\rho \\sigma_y \\otimes \\sigma_y \\rho^* \\sigma_y \\otimes \\sigma_y. \\] <p>Concurrence can serve as a measure of entanglement.</p> <p>Examples:</p> <p>Consider the following Bell state:</p> \\[     u = \\frac{1}{\\sqrt{2}} \\left( |00 \\rangle + |11 \\rangle \\right). \\] <p>The concurrence of the density matrix \\(\\rho = u u^*\\) defined by the vector \\(u\\) is given as</p> \\[     \\mathcal{C}(\\rho) \\approx 1. \\] <p>The following example calculates this quantity using the <code>|toqito\u27e9</code> package.</p> <pre><code>import numpy as np\nfrom toqito.matrices import standard_basis\nfrom toqito.state_props import concurrence\ne_0, e_1 = standard_basis(2)\ne_00, e_11 = np.kron(e_0, e_0), np.kron(e_1, e_1)\nu_vec = 1 / np.sqrt(2) * (e_00 + e_11)\nrho = u_vec @ u_vec.conj().T\nprint(concurrence(rho))\n</code></pre> <p>0.9999999999999993</p> <p>Consider the concurrence of the following product state</p> \\[     v = |0\\rangle \\otimes |1 \\rangle. \\] <p>As this state has no entanglement, the concurrence is zero.</p> <pre><code>import numpy as np\nfrom toqito.states import basis\nfrom toqito.state_props import concurrence\ne_0, e_1 = basis(2, 0), basis(2, 1)\nv_vec = np.kron(e_0, e_1)\nsigma = v_vec @ v_vec.conj().T\nprint(concurrence(sigma))\n</code></pre> <p>0</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If system is not bipartite.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>rho</code>               (<code>ndarray</code>)           \u2013            <p>The bipartite system specified as a matrix.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The concurrence of the bipartite state \\(\\rho\\).</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Concurrence (quantum computing). link.</p> Source code in <code>toqito/state_props/concurrence.py</code> <pre><code>def concurrence(rho: np.ndarray) -&gt; float:\n    r\"\"\"Calculate the concurrence of a bipartite state [@WikiConcurrence].\n\n    The concurrence of a bipartite state \\(\\rho\\) is defined as\n\n    \\[\n        \\max(0, \\lambda_1 - \\lambda_2 - \\lambda_3 - \\lambda_4),\n    \\]\n\n    where \\(\\lambda_1, \\ldots, \\lambda_4\\) are the square roots of the\n    eigenvalues in decreasing order of the matrix\n\n    \\[\n        \\rho\\tilde{\\rho} = \\rho \\sigma_y \\otimes \\sigma_y \\rho^* \\sigma_y \\otimes \\sigma_y.\n    \\]\n\n    Concurrence can serve as a measure of entanglement.\n\n    Examples:\n        Consider the following Bell state:\n\n        \\[\n            u = \\frac{1}{\\sqrt{2}} \\left( |00 \\rangle + |11 \\rangle \\right).\n        \\]\n\n        The concurrence of the density matrix \\(\\rho = u u^*\\) defined by the vector \\(u\\) is\n        given as\n\n        \\[\n            \\mathcal{C}(\\rho) \\approx 1.\n        \\]\n\n        The following example calculates this quantity using the `|toqito\u27e9` package.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.matrices import standard_basis\n        from toqito.state_props import concurrence\n        e_0, e_1 = standard_basis(2)\n        e_00, e_11 = np.kron(e_0, e_0), np.kron(e_1, e_1)\n        u_vec = 1 / np.sqrt(2) * (e_00 + e_11)\n        rho = u_vec @ u_vec.conj().T\n        print(concurrence(rho))\n        ```\n\n        Consider the concurrence of the following product state\n\n        \\[\n            v = |0\\rangle \\otimes |1 \\rangle.\n        \\]\n\n        As this state has no entanglement, the concurrence is zero.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.states import basis\n        from toqito.state_props import concurrence\n        e_0, e_1 = basis(2, 0), basis(2, 1)\n        v_vec = np.kron(e_0, e_1)\n        sigma = v_vec @ v_vec.conj().T\n        print(concurrence(sigma))\n        ```\n\n    Raises:\n        ValueError: If system is not bipartite.\n\n    Args:\n        rho: The bipartite system specified as a matrix.\n\n    Returns:\n        The concurrence of the bipartite state \\(\\rho\\).\n\n    \"\"\"\n    if rho.shape != (4, 4):\n        raise ValueError(\"InvalidDim: Concurrence is only defined for bipartite systems.\")\n\n    sigma_y = pauli(\"Y\", False)\n    sigma_y_y = np.kron(sigma_y, sigma_y)\n\n    rho_tilde = sigma_y_y @ rho.conj() @ sigma_y_y\n\n    eig_vals = np.linalg.eigvals(rho @ rho_tilde)\n    eig_vals = np.sort(np.abs(np.sqrt(eig_vals)))[::-1]\n    return max(0, eig_vals[0] - eig_vals[1] - eig_vals[2] - eig_vals[3])\n</code></pre>"},{"location":"reference/toqito/state_props/entanglement_of_formation/","title":"entanglement_of_formation","text":""},{"location":"reference/toqito/state_props/entanglement_of_formation/#toqito.state_props.entanglement_of_formation","title":"entanglement_of_formation","text":"<p>Computes the entanglement of formation of a bipartite quantum state.</p>"},{"location":"reference/toqito/state_props/entanglement_of_formation/#toqito.state_props.entanglement_of_formation.entanglement_of_formation","title":"entanglement_of_formation","text":"<pre><code>entanglement_of_formation(rho: ndarray, dim: list[int] | int | None = None) -&gt; float\n</code></pre> <p>Compute entanglement-of-formation of a bipartite quantum state <sup>1</sup>.</p> <p>Entanglement-of-formation is the entropy of formation of the bipartite quantum state <code>rho</code>. Note that this function currently only supports <code>rho</code> being a pure state or a 2-qubit state: it is not known how to compute the entanglement-of-formation of higher-dimensional mixed states.</p> <p>This function was adapted from QETLAB.</p> <p>Examples:</p> <p>Compute the entanglement-of-formation of a Bell state.</p> <p>Let \\(u = \\frac{1}{\\sqrt{2}} \\left(|00\\rangle + |11\\rangle \\right)\\) and let</p> \\[     \\rho = uu^* = \\frac{1}{2}\\begin{pmatrix}                                 1 &amp; 0 &amp; 0 &amp; 1 \\\\                                 0 &amp; 0 &amp; 0 &amp; 0 \\\\                                 0 &amp; 0 &amp; 0 &amp; 0 \\\\                                 1 &amp; 0 &amp; 0 &amp; 1                              \\end{pmatrix}. \\] <p>The entanglement-of-formation of \\(\\rho\\) is equal to 1.</p> <pre><code>import numpy as np\nfrom toqito.state_props import entanglement_of_formation\nfrom toqito.states import bell\nu_vec = bell(0)\nrho = u_vec @ u_vec.conj().T\nprint(entanglement_of_formation(rho))\n</code></pre> <p>0.9999999999999998</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If matrices have improper dimension.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>rho</code>               (<code>ndarray</code>)           \u2013            <p>A matrix or vector.</p> </li> <li> <code>dim</code>               (<code>list[int] | int | None</code>, default:                   <code>None</code> )           \u2013            <p>The default has both subsystems of equal dimension.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>A value between 0 and 1 that corresponds to the entanglement-of-formation of <code>rho</code>.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Quantiki. Entanglement of Formation. link.</p> Source code in <code>toqito/state_props/entanglement_of_formation.py</code> <pre><code>def entanglement_of_formation(rho: np.ndarray, dim: list[int] | int | None = None) -&gt; float:\n    r\"\"\"Compute entanglement-of-formation of a bipartite quantum state [@Quantiki_EOF].\n\n    Entanglement-of-formation is the entropy of formation of the bipartite\n    quantum state `rho`. Note that this function currently only supports\n    `rho` being a pure state or a 2-qubit state: it is not known how to\n    compute the entanglement-of-formation of higher-dimensional mixed states.\n\n    This function was adapted from QETLAB.\n\n    Examples:\n        Compute the entanglement-of-formation of a Bell state.\n\n        Let \\(u = \\frac{1}{\\sqrt{2}} \\left(|00\\rangle + |11\\rangle \\right)\\)\n        and let\n\n        \\[\n            \\rho = uu^* = \\frac{1}{2}\\begin{pmatrix}\n                                        1 &amp; 0 &amp; 0 &amp; 1 \\\\\n                                        0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                                        0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                                        1 &amp; 0 &amp; 0 &amp; 1\n                                     \\end{pmatrix}.\n        \\]\n\n        The entanglement-of-formation of \\(\\rho\\) is equal to 1.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.state_props import entanglement_of_formation\n        from toqito.states import bell\n        u_vec = bell(0)\n        rho = u_vec @ u_vec.conj().T\n        print(entanglement_of_formation(rho))\n        ```\n\n    Raises:\n        ValueError: If matrices have improper dimension.\n\n    Args:\n        rho: A matrix or vector.\n        dim: The default has both subsystems of equal dimension.\n\n    Returns:\n        A value between 0 and 1 that corresponds to the entanglement-of-formation of `rho`.\n\n    \"\"\"\n    dim_x, dim_y = rho.shape\n    round_dim = int(np.round(np.sqrt(max(dim_x, dim_y))))\n\n    if dim is None:\n        dim_int = round_dim\n    elif isinstance(dim, int):\n        dim_int = dim\n    else:\n        dim_int = None\n\n    # User can specify dimension as integer.\n    if dim_int is not None:\n        dim_arr = np.array([dim_int, max(dim_x, dim_y) / dim_int], dtype=int)\n        dim_arr[1] = np.round(dim_arr[1])\n    else:\n        dim_arr = np.array(dim)\n\n    if np.prod(dim_arr) != max(dim_x, dim_y):\n        raise ValueError(\"Invalid dimension: Please provide local dimensions that match the size of `rho`.\")\n    # If `rho` is a rank-1 density matrix, turn it into a vector instead\n    # so we can compute the entanglement-of-formation easily.\n    tmp_rho = scipy.linalg.orth(rho)\n    if dim_x == dim_y and tmp_rho.shape[1] == 1:\n        rho = tmp_rho\n        dim_y = 1\n\n    # Start computing entanglement-of-formation.\n    if min(dim_x, dim_y) == 1:\n        rho = rho[:]\n        dim_list = [int(x) for x in dim_arr]\n        return von_neumann_entropy(partial_trace(rho @ rho.conj().T, [1], dim_list))\n\n    # Case: `rho` is a density matrix.\n    if dim_x == dim_y:\n        # In the two-qubit case, we know how to compute the\n        # entanglement-of-formation exactly.\n        if dim_x == 4:\n            rho_c = concurrence(rho)\n\n            rho_c1 = (1 + np.sqrt(1 - rho_c**2)) / 2\n            rho_c2 = (1 - np.sqrt(1 - rho_c**2)) / 2\n\n            rho_c1_log2 = 0 if rho_c1 == 0 else np.log2(rho_c1)\n            rho_c2_log2 = 0 if rho_c2 == 0 else np.log2(rho_c2)\n\n            return -rho_c1 * rho_c1_log2 - rho_c2 * rho_c2_log2\n        raise ValueError(\n            \"Invalid input: It is presently only known how to compute \"\n            \"the entanglement-of-formation for two-qubit states and pure \"\n            \"states.\"\n        )\n    raise ValueError(\"Invalid dimension: `rho` must be either a vector or square matrix.\")\n</code></pre>"},{"location":"reference/toqito/state_props/has_symmetric_extension/","title":"has_symmetric_extension","text":""},{"location":"reference/toqito/state_props/has_symmetric_extension/#toqito.state_props.has_symmetric_extension","title":"has_symmetric_extension","text":"<p>Determine whether there exists a symmetric extension for a given quantum state.</p>"},{"location":"reference/toqito/state_props/has_symmetric_extension/#toqito.state_props.has_symmetric_extension.has_symmetric_extension","title":"has_symmetric_extension","text":"<pre><code>has_symmetric_extension(rho: ndarray, level: int = 2, dim: ndarray | int | None = None, ppt: bool = True, tol: float = 0.0001) -&gt; bool\n</code></pre> <p>Determine whether there exists a symmetric extension for a given quantum state.</p> <p>For more information, see <sup>1</sup>.</p> <p>Determining whether an operator possesses a symmetric extension at some level <code>level</code> can be used as a check to determine if the operator is entangled or not.</p> <p>This function was adapted from QETLAB.</p> <p>Examples:</p> <p>2-qubit symmetric extension:</p> <p>In <sup>2</sup>, it was shown that a 2-qubit state \\(\\rho_{AB}\\) has a symmetric extension if and only if</p> \\[     \\text{Tr}(\\rho_B^2) \\geq \\text{Tr}(\\rho_{AB}^2) - 4 \\sqrt{\\text{det}(\\rho_{AB})}. \\] <p>This closed-form equation is much quicker to check than running the semidefinite program.</p> <pre><code>import numpy as np\nfrom toqito.state_props import has_symmetric_extension\nfrom toqito.matrix_ops import partial_trace\nrho = np.array([[1, 0, 0, -1], [0, 1, 1/2, 0], [0, 1/2, 1, 0], [-1, 0, 0, 1]])\n# Show the closed-form equation holds\nprint(\nnp.trace(np.linalg.matrix_power(partial_trace(rho, 1), 2))\n&gt;= np.trace(rho**2) - 4 * np.sqrt(np.linalg.det(rho)))\n</code></pre> <p>True</p> <pre><code># Now show that the `has_symmetric_extension` function recognizes this case.\nprint(has_symmetric_extension(rho))\n</code></pre> <p>True</p> <p>Higher qubit systems:</p> <p>Consider a density operator corresponding to one of the Bell states.</p> \\[     \\rho = \\frac{1}{2} \\begin{pmatrix}                         1 &amp; 0 &amp; 0 &amp; 1 \\\\                         0 &amp; 0 &amp; 0 &amp; 0 \\\\                         0 &amp; 0 &amp; 0 &amp; 0 \\\\                         1 &amp; 0 &amp; 0 &amp; 1                        \\end{pmatrix} \\] <p>To make this state over more than just two qubits, let's construct the following state</p> \\[     \\sigma = \\rho \\otimes \\rho. \\] <p>As the state \\(\\sigma\\) is entangled, there should not exist a symmetric extension at some level. We see this being the case for a relatively low level of the hierarchy.</p> <pre><code>import numpy as np\nfrom toqito.states import bell\nfrom toqito.state_props import has_symmetric_extension\nrho = bell(0) @ bell(0).conj().T\nsigma = np.kron(rho, rho)\nprint(has_symmetric_extension(sigma))\n</code></pre> <p>True</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If dimension does not evenly divide matrix length.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>rho</code>               (<code>ndarray</code>)           \u2013            <p>A matrix or vector.</p> </li> <li> <code>level</code>               (<code>int</code>, default:                   <code>2</code> )           \u2013            <p>Level of the hierarchy to compute.</p> </li> <li> <code>dim</code>               (<code>ndarray | int | None</code>, default:                   <code>None</code> )           \u2013            <p>The default has both subsystems of equal dimension.</p> </li> <li> <code>ppt</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If <code>True</code>, this enforces that the symmetric extension must be PPT.</p> </li> <li> <code>tol</code>               (<code>float</code>, default:                   <code>0.0001</code> )           \u2013            <p>Tolerance when determining whether a symmetric extension exists.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if <code>mat</code> has a symmetric extension; <code>False</code> otherwise.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Doherty, A. and Parrilo, Pablo and Spedalieri, Federico. Distinguishing Separable and Entangled States. Physical Review Letters. vol. 88(18). (2002). doi:10.1103/physrevlett.88.187904. <sup>2</sup> Chen, Jianxin and Ji, Zhengfeng and Kribs, David and L\u00fctkenhaus, Norbert and Zeng, Bei. Symmetric extension of two-qubit states. Physical Review A. vol. 90(3). (2014). doi:10.1103/physreva.90.032318.</p> Source code in <code>toqito/state_props/has_symmetric_extension.py</code> <pre><code>def has_symmetric_extension(\n    rho: np.ndarray,\n    level: int = 2,\n    dim: np.ndarray | int | None = None,\n    ppt: bool = True,\n    tol: float = 1e-4,\n) -&gt; bool:\n    r\"\"\"Determine whether there exists a symmetric extension for a given quantum state.\n\n    For more information, see [@Doherty_2002_Distinguishing].\n\n    Determining whether an operator possesses a symmetric extension at some level `level`\n    can be used as a check to determine if the operator is entangled or not.\n\n    This function was adapted from QETLAB.\n\n    Examples:\n        2-qubit symmetric extension:\n\n        In [@Chen_2014_Symmetric], it was shown that a 2-qubit state \\(\\rho_{AB}\\) has a\n        symmetric extension if and only if\n\n        \\[\n            \\text{Tr}(\\rho_B^2) \\geq \\text{Tr}(\\rho_{AB}^2) - 4 \\sqrt{\\text{det}(\\rho_{AB})}.\n        \\]\n\n        This closed-form equation is much quicker to check than running the semidefinite program.\n\n        ```python exec=\"1\" source=\"above\" session=\"has_symmetric_example\"\n        import numpy as np\n        from toqito.state_props import has_symmetric_extension\n        from toqito.matrix_ops import partial_trace\n        rho = np.array([[1, 0, 0, -1], [0, 1, 1/2, 0], [0, 1/2, 1, 0], [-1, 0, 0, 1]])\n        # Show the closed-form equation holds\n        print(\n        np.trace(np.linalg.matrix_power(partial_trace(rho, 1), 2))\n        &gt;= np.trace(rho**2) - 4 * np.sqrt(np.linalg.det(rho)))\n        ```\n\n        ```python exec=\"1\" source=\"above\" session=\"has_symmetric_example\"\n        # Now show that the `has_symmetric_extension` function recognizes this case.\n        print(has_symmetric_extension(rho))\n        ```\n\n        Higher qubit systems:\n\n        Consider a density operator corresponding to one of the Bell states.\n\n        \\[\n            \\rho = \\frac{1}{2} \\begin{pmatrix}\n                                1 &amp; 0 &amp; 0 &amp; 1 \\\\\n                                0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                                0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                                1 &amp; 0 &amp; 0 &amp; 1\n                               \\end{pmatrix}\n        \\]\n\n        To make this state over more than just two qubits, let's construct the following state\n\n        \\[\n            \\sigma = \\rho \\otimes \\rho.\n        \\]\n\n        As the state \\(\\sigma\\) is entangled, there should not exist a symmetric extension at some\n        level. We see this being the case for a relatively low level of the hierarchy.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.states import bell\n        from toqito.state_props import has_symmetric_extension\n        rho = bell(0) @ bell(0).conj().T\n        sigma = np.kron(rho, rho)\n        print(has_symmetric_extension(sigma))\n        ```\n\n    Raises:\n        ValueError: If dimension does not evenly divide matrix length.\n\n    Args:\n        rho: A matrix or vector.\n        level: Level of the hierarchy to compute.\n        dim: The default has both subsystems of equal dimension.\n        ppt: If `True`, this enforces that the symmetric extension must be PPT.\n        tol: Tolerance when determining whether a symmetric extension exists.\n\n    Returns:\n        `True` if `mat` has a symmetric extension; `False` otherwise.\n\n    \"\"\"\n    len_mat = rho.shape[1]\n\n    # Set default dimension if none was provided.\n    if dim is None:\n        dim_val = int(np.round(np.sqrt(len_mat)))\n    elif isinstance(dim, int):\n        dim_val = dim\n    else:\n        dim_val = None\n\n    # Allow the user to enter in a single integer for dimension.\n    if dim_val is not None:\n        dim_arr = np.array([dim_val, len_mat / dim_val])\n        if np.abs(dim_arr[1] - np.round(dim_arr[1])) &gt;= 2 * len_mat * np.finfo(float).eps:\n            raise ValueError(\"If `dim` is a scalar, it must evenly divide the length of the matrix.\")\n        dim_arr[1] = int(np.round(dim_arr[1]))\n    else:\n        dim_arr = np.array(dim)\n\n    dim_arr = np.int_(dim_arr)\n\n    dim_x, dim_y = int(dim_arr[0]), int(dim_arr[1])\n    # In certain situations, we don't need semidefinite programming.\n    if level == 1 or len_mat &lt;= 6 and ppt:\n        if not ppt:\n            # In some cases, the problem is *really* trivial.\n            return is_positive_semidefinite(rho)\n\n        # In this case, all they asked for is a 1-copy PPT symmetric extension\n        # (i.e., they're asking if the state is PPT).\n        return is_ppt(rho, 2, dim_arr) and is_positive_semidefinite(rho)\n\n    # In the 2-qubit case, an analytic formula is known for whether or not a state has a\n    # (2-copy, non-PPT) symmetric extension that is much faster to use than semidefinite\n    # programming [CJKLZB14]_.\n    if level == 2 and not ppt and dim_x == 2 and dim_y == 2:\n        return np.trace(np.linalg.matrix_power(partial_trace(rho, [0], [dim_x, dim_y]), 2)) &gt;= np.trace(\n            np.linalg.matrix_power(rho, 2)\n        ) - 4 * np.sqrt(np.linalg.det(rho))\n\n    # Otherwise, use semidefinite programming to find a symmetric extension.\n    # We solve a feasibility SDP: find sigma on X \u2297 Y^\u2297level such that\n    # tr_{Y_2,...,Y_level}(sigma) = rho, sigma &gt;= 0, sigma is symmetric\n    # under permutations of Y copies, and (optionally) PPT constraints hold.\n    dim_list = np.int_([dim_x] + [dim_y] * level)\n    sys_list = list(range(2, 2 + level - 1))\n    sym = symmetric_projection(dim_y, level)\n    dim_total = int(np.prod(dim_list))\n\n    sigma = cvxpy.Variable((dim_total, dim_total), hermitian=True)\n\n    constraints = [\n        partial_trace(sigma, sys_list, dim_list) == rho,\n        sigma &gt;&gt; 0,\n        np.kron(np.identity(dim_x), sym) @ sigma @ np.kron(np.identity(dim_x), sym) == sigma,\n    ]\n\n    if ppt:\n        constraints.append(partial_transpose(sigma, [0], dim_list) &gt;&gt; 0)\n        for sys in range(level - 1):\n            constraints.append(partial_transpose(sigma, [sys + 2], dim_list) &gt;&gt; 0)\n\n    problem = cvxpy.Problem(cvxpy.Minimize(0), constraints)\n    problem.solve()\n\n    return problem.status == \"optimal\"\n</code></pre>"},{"location":"reference/toqito/state_props/in_separable_ball/","title":"in_separable_ball","text":""},{"location":"reference/toqito/state_props/in_separable_ball/#toqito.state_props.in_separable_ball","title":"in_separable_ball","text":"<p>Checks whether operator is in the ball of separability centered at the maximally-mixed state.</p>"},{"location":"reference/toqito/state_props/in_separable_ball/#toqito.state_props.in_separable_ball.in_separable_ball","title":"in_separable_ball","text":"<pre><code>in_separable_ball(mat: ndarray) -&gt; bool | bool_\n</code></pre> <p>Check whether an operator is contained in ball of separability <sup>1</sup>.</p> <p>Determines whether <code>mat</code> is contained within the ball of separable operators centered at the identity matrix (i.e. the maximally-mixed state). The size of this ball was derived in <sup>1</sup>.</p> <p>This function can be used as a method for separability testing of states in certain scenarios.</p> <p>This function is adapted from QETLAB.</p> <p>Examples:</p> <p>The only states acting on \\(\\mathbb{C}^m \\otimes \\mathbb{C}^n\\) in the separable ball that do not have full rank are those with exactly 1 zero eigenvalue, and the \\(mn - 1\\) non-zero eigenvalues equal to each other.</p> <p>The following is an example of generating a random density matrix with eigenvalues <code>[1, 1, 1, 0]/3</code>. This example yields a matrix that is contained within the separable ball.</p> <pre><code>from toqito.rand import random_unitary\nfrom toqito.state_props import in_separable_ball\nimport numpy as np\nU = random_unitary(4)\nlam = np.array([1, 1, 1, 0]) / 3\nrho = U @ np.diag(lam) @ U.conj().T\nprint(in_separable_ball(rho))\n</code></pre> <p>True</p> <p>The following is an example of generating a random density matrix with eigenvalues <code>[1.01, 1, 0.99, 0]/3</code>. This example yields a matrix that is not contained within the separable ball.</p> <pre><code>from toqito.rand import random_unitary\nfrom toqito.state_props import in_separable_ball\nimport numpy as np\nU = random_unitary(4)\nlam = np.array([1.01, 1, 0.99, 0]) / 3\nrho = U @ np.diag(lam) @ U.conj().T\nprint(in_separable_ball(rho))\n</code></pre> <p>False</p> <p>Parameters:</p> <ul> <li> <code>mat</code>               (<code>ndarray</code>)           \u2013            <p>A positive semidefinite matrix or a vector of the eigenvalues of a positive semidefinite matrix.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool | bool_</code>           \u2013            <p><code>True</code> if the matrix <code>mat</code> is contained within the separable ball, and <code>False</code> otherwise.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Gurvits, Leonid and Barnum, Howard. Largest separable balls around the maximally mixed bipartite quantum state. Physical Review A. vol. 66(6). (2002). doi:10.1103/physreva.66.062311.</p> Source code in <code>toqito/state_props/in_separable_ball.py</code> <pre><code>def in_separable_ball(mat: np.ndarray) -&gt; bool | np.bool_:\n    r\"\"\"Check whether an operator is contained in ball of separability [@Gurvits_2002_Largest].\n\n    Determines whether `mat` is contained within the ball of separable operators centered\n    at the identity matrix (i.e. the maximally-mixed state). The size of this ball was derived in\n    [@Gurvits_2002_Largest].\n\n    This function can be used as a method for separability testing of states in certain scenarios.\n\n    This function is adapted from QETLAB.\n\n    Examples:\n        The only states acting on \\(\\mathbb{C}^m \\otimes \\mathbb{C}^n\\) in the\n        separable ball that do not have full rank are those with exactly 1 zero\n        eigenvalue, and the \\(mn - 1\\) non-zero eigenvalues equal to each\n        other.\n\n        The following is an example of generating a random density matrix with eigenvalues\n        `[1, 1, 1, 0]/3`. This example yields a matrix that is contained within the separable\n        ball.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.rand import random_unitary\n        from toqito.state_props import in_separable_ball\n        import numpy as np\n        U = random_unitary(4)\n        lam = np.array([1, 1, 1, 0]) / 3\n        rho = U @ np.diag(lam) @ U.conj().T\n        print(in_separable_ball(rho))\n        ```\n\n        The following is an example of generating a random density matrix with eigenvalues\n        `[1.01, 1, 0.99, 0]/3`. This example yields a matrix that is not contained within the\n        separable ball.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.rand import random_unitary\n        from toqito.state_props import in_separable_ball\n        import numpy as np\n        U = random_unitary(4)\n        lam = np.array([1.01, 1, 0.99, 0]) / 3\n        rho = U @ np.diag(lam) @ U.conj().T\n        print(in_separable_ball(rho))\n        ```\n\n    Args:\n        mat: A positive semidefinite matrix or a vector of the eigenvalues of a positive semidefinite matrix.\n\n    Returns:\n        `True` if the matrix `mat` is contained within the separable ball, and `False` otherwise.\n\n    \"\"\"\n    mat_dims = mat.shape\n    max_dim = max(mat_dims)\n\n    # If the matrix is a vector, turn it into a matrix. We could instead turn every matrix into a\n    # vector of eigenvalues, but that would make the computation take O(n^3) time instead of the\n    # current method which is O(n^2).\n\n    # Case: Vector of eigenvalues.\n    if len(mat_dims) == 1 or min(mat_dims) == 1:\n        mat = np.diag(mat)\n\n    # If the matrix has trace equal to 0 or less, it cannot be in the separable ball.\n    if np.trace(mat) &lt; max_dim * np.finfo(float).eps:\n        return False\n\n    mat = mat / np.trace(mat)\n\n    # The following check relies on the fact that we scaled the matrix so that trace(mat) = 1.\n    # The following condition is then exactly the condition mentioned in [@Gurvits_2002_Largest].\n    return np.linalg.norm(mat / np.linalg.norm(mat, \"fro\") ** 2 - np.eye(max_dim), \"fro\") &lt;= 1\n</code></pre>"},{"location":"reference/toqito/state_props/is_abs_ppt/","title":"is_abs_ppt","text":""},{"location":"reference/toqito/state_props/is_abs_ppt/#toqito.state_props.is_abs_ppt","title":"is_abs_ppt","text":"<p>Checks if a quantum state is absolutely PPT.</p>"},{"location":"reference/toqito/state_props/is_abs_ppt/#toqito.state_props.is_abs_ppt.is_abs_ppt","title":"is_abs_ppt","text":"<pre><code>is_abs_ppt(mat: ndarray | Variable, dim: int | None = None, rtol: float = 1e-05, atol: float = 1e-08) -&gt; bool | None | list[Constraint]\n</code></pre> <p>Determine whether or not a matrix is absolutely PPT <sup>1</sup>.</p> <p>A Hermitian positive semidefinite matrix is absolutely PPT iff it is PPT under all unitary transformations. Equivalently, if the matrix operates on a Hilbert space \\(H_{nm}\\) of dimension \\(nm\\), then it is PPT under all possible decompositions of \\(H_{nm}\\) as \\(H_{n} \\otimes H_{m}\\). Being absolutely PPT is a spectral condition (i.e. it is a condition on the eigenvalues of the matrix).</p> <p>The function allows passing a <code>numpy</code> ndarray or a <code>cvxpy</code> Variable for <code>mat</code>:</p> <ul> <li>If <code>mat</code> is a <code>numpy</code> ndarray, the function first checks if <code>mat</code> is Hermitian positive     semidefinite. Then, it checks if its eigenvalues satisfy the Gerschgorin circle property (see Theorem 7.2 of     <sup>2</sup>). Then it checks if the matrix belongs to the separable ball by calling     <code>in_separable_ball</code>. Finally, if all the above checks fail to return a definite result, it determines if     the matrix is absolutely PPT by checking if all the constraint matrices returned by     <code>abs_ppt_constraints</code> are positive semidefinite.</li> <li>If <code>mat</code> is a <code>cvxpy</code> Variable, <code>mat</code> must be a 1D vector representing the eigenvalues of     a matrix. The function then returns the list of <code>cvxpy</code> Constraints required for optimizing over the     space of absolutely PPT matrices. This includes the positive semidefinite constraint on each constraint matrix     as well as <code>mat[0] \u2265 mat[1] \u2265 ... \u2265 mat[-1] \u2265 0</code>.</li> </ul> <p>This function is adapted from QETLAB <sup>3</sup>.</p> <p>Note</p> <p>If <code>min(dim)</code> \\(\\leq 6\\), this function checks all constraints and therefore returns <code>True</code> or <code>False</code> in all cases. However, if <code>min(dim)</code> \\(\\geq 7\\), only the first \\(33592\\) constraints are checked, since there are over \\(23178480\\) constraints in this case <sup>4</sup>. Therefore the function returns either <code>False</code> if at least one constraint was not satisfied, or <code>None</code> if all checked constraints were satisfied.</p> <p>Examples:</p> <p>A random density matrix will likely not be absolutely PPT:</p> <pre><code>import numpy as np\nfrom toqito.rand import random_density_matrix\nfrom toqito.state_props import is_abs_ppt\nrho = random_density_matrix(9) # assumed to act on a 3 x 3 bipartite system\nprint(f\"\u03c1 is absolutely PPT: {is_abs_ppt(rho, 3)}\")\n</code></pre> <p>\u03c1 is absolutely PPT: False</p> <p>The maximally-mixed state is an example of an absolutely PPT state:</p> <pre><code>import numpy as np\nfrom toqito.states import max_mixed\nfrom toqito.state_props import is_abs_ppt\nrho = max_mixed(9) # assumed to act on a 3 x 3 bipartite system\nprint(f\"\u03c1 is absolutely PPT: {is_abs_ppt(rho, 3)}\")\n</code></pre> <p>\u03c1 is absolutely PPT: True</p> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If <code>mat</code> is not a <code>numpy</code> ndarray or a <code>cvxpy</code> Variable.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If <code>mat</code> is a <code>numpy</code> ndarray but is not square.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If <code>mat</code> is a <code>cvxpy</code> Variable but is not 1D.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If <code>dim</code> does not divide the dimensions of <code>mat</code>.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>mat</code>               (<code>ndarray | Variable</code>)           \u2013            <p>A square matrix.</p> </li> <li> <code>dim</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The dimension of any one subsystem on which <code>mat</code> acts. If <code>None</code>, <code>dim</code> is selected such that</p> </li> <li> <code>rtol</code>               (<code>float</code>, default:                   <code>1e-05</code> )           \u2013            <p>The relative tolerance parameter (default 1e-05).</p> </li> <li> <code>atol</code>               (<code>float</code>, default:                   <code>1e-08</code> )           \u2013            <p>The absolute tolerance parameter (default 1e-08).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool | None | list[Constraint]</code>           \u2013            <p>If <code>mat</code> is a 1D <code>cvxpy</code> Variable, return a list of <code>cvxpy</code> Constraints required for optimizing over the space</p> </li> <li> <code>bool | None | list[Constraint]</code>           \u2013            <p>of absolutely PPT matrices.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Hildebrand, Roland. Positive partial transpose from spectra. Phys. Rev. A. vol. 76. (2007). doi:10.1103/PhysRevA.76.052325. <sup>2</sup> Jivulescu, Maria and Lupa, Nicolae and Nechita, Ion and Reeb, David. Positive reduction from spectra. Linear Algebra and its Applications. vol. 469. (2015). doi:https://doi.org/10.1016/j.laa.2014.11.031. <sup>3</sup> Johnston, Nathaniel. {{QETLAB}: {A MATLAB} toolbox for quantum entanglement}. doi:10.5281/zenodo.44637. <sup>4</sup> Johnston, Nathaniel. Counting the Possible Orderings of Pairwise Multiplication. (2014). link.</p> Source code in <code>toqito/state_props/is_abs_ppt.py</code> <pre><code>def is_abs_ppt(\n    mat: np.ndarray | cp.Variable, dim: int | None = None, rtol: float = 1e-05, atol: float = 1e-08\n) -&gt; bool | None | list[cp.Constraint]:\n    r\"\"\"Determine whether or not a matrix is absolutely PPT [@Hildebrand_2007_AbsPPT].\n\n    A Hermitian positive semidefinite matrix is absolutely PPT iff it is PPT under all unitary transformations.\n    Equivalently, if the matrix operates on a Hilbert space \\(H_{nm}\\) of dimension \\(nm\\), then it is\n    PPT under *all* possible decompositions of \\(H_{nm}\\) as \\(H_{n} \\otimes H_{m}\\). Being absolutely\n    PPT is a spectral condition (i.e. it is a condition on the eigenvalues of the matrix).\n\n    The function allows passing a `numpy` ndarray or a `cvxpy` Variable for `mat`:\n\n    - If `mat` is a `numpy` ndarray, the function first checks if `mat` is Hermitian positive\n        semidefinite. Then, it checks if its eigenvalues satisfy the Gerschgorin circle property (see Theorem 7.2 of\n        [@Jivulescu_2015_Reduction]). Then it checks if the matrix belongs to the separable ball by calling\n        `in_separable_ball`. Finally, if all the above checks fail to return a definite result, it determines if\n        the matrix is absolutely PPT by checking if all the constraint matrices returned by\n        `abs_ppt_constraints` are positive semidefinite.\n    - If `mat` is a `cvxpy` Variable, `mat` must be a 1D vector representing the eigenvalues of\n        a matrix. The function then returns the list of `cvxpy` Constraints required for optimizing over the\n        space of absolutely PPT matrices. This includes the positive semidefinite constraint on each constraint matrix\n        as well as `mat[0] \u2265 mat[1] \u2265 ... \u2265 mat[-1] \u2265 0`.\n\n    This function is adapted from QETLAB [@QETLAB_link].\n\n    !!! Note\n        If `min(dim)` \\(\\leq 6\\), this function checks all constraints\n        and therefore returns `True` or `False` in all cases. However, if\n        `min(dim)` \\(\\geq 7\\), only the first \\(33592\\) constraints are\n        checked, since there are over \\(23178480\\) constraints in this case\n        [@Johnston_2014_Orderings]. Therefore the function returns either\n        `False` if at least one constraint was not satisfied, or `None`\n        if all checked constraints were satisfied.\n\n    Examples:\n        A random density matrix will likely not be absolutely PPT:\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.rand import random_density_matrix\n        from toqito.state_props import is_abs_ppt\n        rho = random_density_matrix(9) # assumed to act on a 3 x 3 bipartite system\n        print(f\"\u03c1 is absolutely PPT: {is_abs_ppt(rho, 3)}\")\n        ```\n\n        The maximally-mixed state is an example of an absolutely PPT state:\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.states import max_mixed\n        from toqito.state_props import is_abs_ppt\n        rho = max_mixed(9) # assumed to act on a 3 x 3 bipartite system\n        print(f\"\u03c1 is absolutely PPT: {is_abs_ppt(rho, 3)}\")\n        ```\n\n    Raises:\n        TypeError: If `mat` is not a `numpy` ndarray or a `cvxpy` Variable.\n        ValueError: If `mat` is a `numpy` ndarray but is not square.\n        ValueError: If `mat` is a `cvxpy` Variable but is not 1D.\n        ValueError: If `dim` does not divide the dimensions of `mat`.\n\n    Args:\n        mat: A square matrix.\n        dim: The dimension of any one subsystem on which `mat` acts. If `None`, `dim` is selected such that\n        `min(dim, mat.shape[0] // dim)` is maximised, since this gives the strongest conditions on being absolutely PPT\n        (see Theorem 2 of [@Hildebrand_2007_AbsPPT]).\n        rtol: The relative tolerance parameter (default 1e-05).\n        atol: The absolute tolerance parameter (default 1e-08).\n\n    Returns:\n        If `mat` is a 1D `cvxpy` Variable, return a list of `cvxpy` Constraints required for optimizing over the space\n        of absolutely PPT matrices.\n\n    \"\"\"\n    if isinstance(mat, np.ndarray):\n        if not is_square(mat):\n            raise ValueError(f\"Expected mat to be square: however mat.shape was {mat.shape}\")\n    elif isinstance(mat, cp.Variable):\n        if mat.ndim != 1:\n            raise ValueError(f\"Expected mat to be 1D: however mat had {mat.ndim} dimensions\")\n    else:\n        raise TypeError(\"mat must be a square numpy ndarray or a 1D cvxpy Variable\")\n\n    nm = mat.shape[0]\n\n    if dim is None:\n        # Find the largest divisor d of nm such that d ** 2 &lt;= nm.\n        # nm won't be too large, so let's just use a for-loop.\n        # Floating-point arithmetic is risky.\n        dim, j = 1, 1\n        while True:\n            if j**2 &gt; nm:\n                break\n            if nm % j == 0:\n                dim = j\n            j += 1\n\n    if nm % dim != 0:\n        raise ValueError(\"Calculated subsystem dimensions and provided matrix dimensions are incompatible\")\n\n    n, m = dim, nm // dim\n    p = min(n, m)\n\n    if isinstance(mat, np.ndarray):\n        # Quick checks:\n        # 1. Check if mat is Hermitian.\n        if not is_hermitian(mat, rtol, atol):\n            return False\n        # Compute eigenvalues (in descending order).\n        # np.linalg.eigsvalsh normally returns eigenvalues in ascending order,\n        # but it is risky to assume this will remain the default behaviour in the future.\n        eigs = np.sort(np.linalg.eigvalsh(mat))[::-1]\n        # 2. Check if mat is PSD.\n        if eigs[-1] &lt; -abs(atol):\n            return False\n        # 3. Check Theorem 7.2 of [@Jivulescu_2015_Reduction].\n        if sum(eigs[: p - 1]) &lt;= eigs[-1] + sum(eigs[-p:]):\n            return True\n        # 4. Check if mat is in separable ball.\n        if in_separable_ball(mat):\n            return True\n        # All quick checks failed, so construct constraint matrices and check if all are PSD.\n        constraints = abs_ppt_constraints(eigs, p)\n        for constraint in constraints:\n            if not is_positive_semidefinite(constraint, rtol, atol):\n                return False\n        # We checked all constraints for p &lt;= 6, but not for p &gt;= 7.\n        return True if p &lt;= 6 else None\n    else:\n        constraints = abs_ppt_constraints(mat, p, use_check=True)\n        return [mat[-1] &gt;= 0] + [mat[i] &gt;= mat[i + 1] for i in range(nm - 1)] + [c_mat &gt;&gt; 0 for c_mat in constraints]\n</code></pre>"},{"location":"reference/toqito/state_props/is_antidistinguishable/","title":"is_antidistinguishable","text":""},{"location":"reference/toqito/state_props/is_antidistinguishable/#toqito.state_props.is_antidistinguishable","title":"is_antidistinguishable","text":"<p>Check if set of states are antidistinguishable.</p>"},{"location":"reference/toqito/state_props/is_antidistinguishable/#toqito.state_props.is_antidistinguishable.is_antidistinguishable","title":"is_antidistinguishable","text":"<pre><code>is_antidistinguishable(states: list[ndarray]) -&gt; bool | bool_\n</code></pre> <p>Check whether a collection of vectors are antidistinguishable or not.</p> <p>For more information, see <sup>1</sup>.</p> <p>The ability to determine whether a set of quantum states are antidistinguishable can be obtained via the state exclusion SDP <sup>2</sup> such that we ignore the associated probabilities with which the states are chosen from the set of vectors.</p> <p>Examples:</p> <p>The set of Bell states are an example of antidistinguishable states. Recall that the Bell states are defined as:</p> \\[ \\begin{aligned} u_1 &amp;= \\frac{1}{\\sqrt{2}} \\left(|00\\rangle + |11\\rangle\\right), \\quad u_2 = \\frac{1}{\\sqrt{2}} \\left(|00\\rangle - |11\\rangle\\right), \\\\ u_3 &amp;= \\frac{1}{\\sqrt{2}} \\left(|01\\rangle + |10\\rangle\\right), \\quad u_4 = \\frac{1}{\\sqrt{2}} \\left(|01\\rangle - |10\\rangle\\right). \\end{aligned} \\] <p>It can be checked in <code>toqito</code> that the Bell states are antidistinguishable:</p> <pre><code>from toqito.states import bell\nfrom toqito.state_props import is_antidistinguishable\nbell_states = [bell(0), bell(1), bell(2), bell(3)]\nprint(is_antidistinguishable(bell_states))\n</code></pre> <p>True</p> <p>Consider the following measurement operators</p> \\[ M_i = \\frac{1}{3}\\left(\\mathbb{I}_{\\mathcal{X}} - u_i u_i^*\\right) \\] <p>for all \\(1 \\leq i \\leq 4\\). It can be verified that these constitute a valid set of POVMs, that is \\(\\sum_{i=1}^4 M_i = \\mathbb{I}_{\\mathcal{X}}\\) and \\(M_i \\in \\text{Pos}(\\mathcal{X})\\) for all \\(1 leq i \\leq 4\\). It may also be verified that</p> \\[     \\sum_{i=1}^4 \\langle M_i, u_i u_i^* \\rangle = 0, \\] <p>and hence, the Bell states are antidistinguishable.</p> <p>Parameters:</p> <ul> <li> <code>states</code>               (<code>list[ndarray]</code>)           \u2013            <p>A set of vectors consisting of quantum states to determine the antidistinguishability of.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool | bool_</code>           \u2013            <p><code>True</code> if the vectors are antidistinguishable; <code>False</code> otherwise.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Heinosaari, Teiko and Kerppo, Oskari. Antidistinguishability of pure quantum states. Journal of Physics A: Mathematical and Theoretical. vol. 51(36). (2018). doi:10.1088/1751-8121/aad1fc. <sup>2</sup> Bandyopadhyay, Somshubhro and Jain, Rahul and Oppenheim, Jonathan and Perry, Christopher. Conclusive exclusion of quantum states. Physical Review A. vol. 89(2). (2014). doi:10.1103/physreva.89.022336.</p> Source code in <code>toqito/state_props/is_antidistinguishable.py</code> <pre><code>def is_antidistinguishable(states: list[np.ndarray]) -&gt; bool | np.bool_:\n    r\"\"\"Check whether a collection of vectors are antidistinguishable or not.\n\n    For more information, see [@Heinosaari_2018_Antidistinguishability].\n\n    The ability to determine whether a set of quantum states are antidistinguishable can be obtained via the state\n    exclusion SDP [@Bandyopadhyay_2014_Conclusive] such that we ignore the associated probabilities with which\n    the states are chosen from the set of vectors.\n\n    Examples:\n        The set of Bell states are an example of antidistinguishable states. Recall that the Bell states are defined as:\n\n        \\[\n        \\begin{aligned}\n        u_1 &amp;= \\frac{1}{\\sqrt{2}} \\left(|00\\rangle + |11\\rangle\\right), \\quad\n        u_2 = \\frac{1}{\\sqrt{2}} \\left(|00\\rangle - |11\\rangle\\right), \\\\\n        u_3 &amp;= \\frac{1}{\\sqrt{2}} \\left(|01\\rangle + |10\\rangle\\right), \\quad\n        u_4 = \\frac{1}{\\sqrt{2}} \\left(|01\\rangle - |10\\rangle\\right).\n        \\end{aligned}\n        \\]\n\n        It can be checked in `toqito` that the Bell states are antidistinguishable:\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import bell\n        from toqito.state_props import is_antidistinguishable\n        bell_states = [bell(0), bell(1), bell(2), bell(3)]\n        print(is_antidistinguishable(bell_states))\n        ```\n\n        Consider the following measurement operators\n\n        \\[\n        M_i = \\frac{1}{3}\\left(\\mathbb{I}_{\\mathcal{X}} - u_i u_i^*\\right)\n        \\]\n\n        for all \\(1 \\leq i \\leq 4\\). It can be verified that these constitute a valid set of POVMs, that is\n        \\(\\sum_{i=1}^4 M_i = \\mathbb{I}_{\\mathcal{X}}\\) and \\(M_i \\in \\text{Pos}(\\mathcal{X})\\) for all \\(1\n        leq i \\leq 4\\). It may also be verified that\n\n        \\[\n            \\sum_{i=1}^4 \\langle M_i, u_i u_i^* \\rangle = 0,\n        \\]\n\n        and hence, the Bell states are antidistinguishable.\n\n    Args:\n        states: A set of vectors consisting of quantum states to determine the antidistinguishability of.\n\n    Returns:\n        `True` if the vectors are antidistinguishable; `False` otherwise.\n\n    \"\"\"\n    probs = [1] * len(states)\n\n    # The dual problem is less computationally intensive to compute in comparison to primal.\n    opt_val, _ = state_exclusion(vectors=states, probs=probs, primal_dual=\"dual\")\n    return np.isclose(opt_val, 0)\n</code></pre>"},{"location":"reference/toqito/state_props/is_distinguishable/","title":"is_distinguishable","text":""},{"location":"reference/toqito/state_props/is_distinguishable/#toqito.state_props.is_distinguishable","title":"is_distinguishable","text":"<p>Checks if a set of quantum states are distinguishable.</p>"},{"location":"reference/toqito/state_props/is_distinguishable/#toqito.state_props.is_distinguishable.is_distinguishable","title":"is_distinguishable","text":"<pre><code>is_distinguishable(states: list[ndarray], probs: list[float] | None = None) -&gt; bool | bool_\n</code></pre> <p>Check whether a collection of vectors are (perfectly) distinguishable or not.</p> <p>The ability to determine whether a set of quantum states are distinguishable can be obtained via the state distinguishability SDP as defined in <code>state_distinguishability</code></p> <p>Examples:</p> <p>The set of Bell states are an example of distinguishable states. Recall that the Bell states are defined as:</p> \\[ \\begin{aligned} u_1 &amp;= \\frac{1}{\\sqrt{2}} \\left(|00\\rangle + |11\\rangle\\right), \\quad u_2 = \\frac{1}{\\sqrt{2}} \\left(|00\\rangle - |11\\rangle\\right), \\\\ u_3 &amp;= \\frac{1}{\\sqrt{2}} \\left(|01\\rangle + |10\\rangle\\right), \\quad u_4 = \\frac{1}{\\sqrt{2}} \\left(|01\\rangle - |10\\rangle\\right). \\end{aligned} \\] <p>It can be checked in <code>toqito</code> that the Bell states are distinguishable:</p> <pre><code>from toqito.states import bell\nfrom toqito.state_props import is_distinguishable\nbell_states = [bell(0), bell(1), bell(2), bell(3)]\nprint(is_distinguishable(bell_states))\n</code></pre> <p>True</p> <p>Parameters:</p> <ul> <li> <code>states</code>               (<code>list[ndarray]</code>)           \u2013            <p>A set of vectors consisting of quantum states to determine the distinguishability of.</p> </li> <li> <code>probs</code>               (<code>list[float] | None</code>, default:                   <code>None</code> )           \u2013            <p>Respective list of probabilities each state is selected. If no probabilities are provided, a uniform</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool | bool_</code>           \u2013            <p><code>True</code> if the vectors are distinguishable; <code>False</code> otherwise.</p> </li> </ul> Source code in <code>toqito/state_props/is_distinguishable.py</code> <pre><code>def is_distinguishable(states: list[np.ndarray], probs: list[float] | None = None) -&gt; bool | np.bool_:\n    r\"\"\"Check whether a collection of vectors are (perfectly) distinguishable or not.\n\n    The ability to determine whether a set of quantum states are distinguishable can be obtained via the state\n    distinguishability SDP as defined in `state_distinguishability`\n\n    Examples:\n        The set of Bell states are an example of distinguishable states. Recall that the Bell states are defined as:\n\n        \\[\n        \\begin{aligned}\n        u_1 &amp;= \\frac{1}{\\sqrt{2}} \\left(|00\\rangle + |11\\rangle\\right), \\quad\n        u_2 = \\frac{1}{\\sqrt{2}} \\left(|00\\rangle - |11\\rangle\\right), \\\\\n        u_3 &amp;= \\frac{1}{\\sqrt{2}} \\left(|01\\rangle + |10\\rangle\\right), \\quad\n        u_4 = \\frac{1}{\\sqrt{2}} \\left(|01\\rangle - |10\\rangle\\right).\n        \\end{aligned}\n        \\]\n\n        It can be checked in `toqito` that the Bell states are distinguishable:\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import bell\n        from toqito.state_props import is_distinguishable\n        bell_states = [bell(0), bell(1), bell(2), bell(3)]\n        print(is_distinguishable(bell_states))\n        ```\n\n    Args:\n        states: A set of vectors consisting of quantum states to determine the distinguishability of.\n        probs: Respective list of probabilities each state is selected. If no probabilities are provided, a uniform\n        probability distribution is assumed.\n\n    Returns:\n        `True` if the vectors are distinguishable; `False` otherwise.\n\n    \"\"\"\n    # The dual problem is less computationally intensive to compute in comparison to primal.\n    opt_val, _ = state_distinguishability(vectors=states, probs=probs, primal_dual=\"dual\")\n    return np.isclose(opt_val, 1)\n</code></pre>"},{"location":"reference/toqito/state_props/is_ensemble/","title":"is_ensemble","text":""},{"location":"reference/toqito/state_props/is_ensemble/#toqito.state_props.is_ensemble","title":"is_ensemble","text":"<p>Checks if a set of quantum states form an ensemble.</p>"},{"location":"reference/toqito/state_props/is_ensemble/#toqito.state_props.is_ensemble.is_ensemble","title":"is_ensemble","text":"<pre><code>is_ensemble(states: list[ndarray]) -&gt; bool\n</code></pre> <p>Determine if a set of states constitute an ensemble.</p> <p>For more info, see Section: Ensemble Of Quantum States from <sup>1</sup>.</p> <p>An ensemble of quantum states is defined by a function</p> \\[     \\eta : \\Gamma \\rightarrow \\text{Pos}(\\mathcal{X}) \\] <p>that satisfies</p> \\[     \\text{Tr}\\left( \\sum_{a \\in \\Gamma} \\eta(a) \\right) = 1. \\] <p>Examples:</p> <p>Consider the following set of matrices</p> \\[     \\eta = \\left\\{ \\rho_0, \\rho_1 \\right\\} \\] <p>where</p> \\[     \\rho_0 = \\frac{1}{2} \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; 0 \\end{pmatrix}, \\quad     \\rho_1 = \\frac{1}{2} \\begin{pmatrix} 0 &amp; 0 \\\\ 0 &amp; 1 \\end{pmatrix}. \\] <p>The set \\(\\eta\\) constitutes a valid ensemble.</p> <pre><code>from toqito.state_props import is_ensemble\nimport numpy as np\nrho_0 = np.array([[0.5, 0], [0, 0]])\nrho_1 = np.array([[0, 0], [0, 0.5]])\nstates = [rho_0, rho_1]\nprint(is_ensemble(states))\n</code></pre> <p>True</p> <p>Parameters:</p> <ul> <li> <code>states</code>               (<code>list[ndarray]</code>)           \u2013            <p>The list of states to check.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if states form an ensemble and <code>False</code> otherwise.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Watrous, John. The Theory of Quantum Information. (2018). doi:10.1017/9781316848142.</p> Source code in <code>toqito/state_props/is_ensemble.py</code> <pre><code>def is_ensemble(states: list[np.ndarray]) -&gt; bool:\n    r\"\"\"Determine if a set of states constitute an ensemble.\n\n    For more info, see Section: Ensemble Of Quantum States from [@Watrous_2018_TQI].\n\n    An ensemble of quantum states is defined by a function\n\n    \\[\n        \\eta : \\Gamma \\rightarrow \\text{Pos}(\\mathcal{X})\n    \\]\n\n    that satisfies\n\n    \\[\n        \\text{Tr}\\left( \\sum_{a \\in \\Gamma} \\eta(a) \\right) = 1.\n    \\]\n\n    Examples:\n        Consider the following set of matrices\n\n        \\[\n            \\eta = \\left\\{ \\rho_0, \\rho_1 \\right\\}\n        \\]\n\n        where\n\n        \\[\n            \\rho_0 = \\frac{1}{2} \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; 0 \\end{pmatrix}, \\quad\n            \\rho_1 = \\frac{1}{2} \\begin{pmatrix} 0 &amp; 0 \\\\ 0 &amp; 1 \\end{pmatrix}.\n        \\]\n\n        The set \\(\\eta\\) constitutes a valid ensemble.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.state_props import is_ensemble\n        import numpy as np\n        rho_0 = np.array([[0.5, 0], [0, 0]])\n        rho_1 = np.array([[0, 0], [0, 0.5]])\n        states = [rho_0, rho_1]\n        print(is_ensemble(states))\n        ```\n\n    Args:\n        states: The list of states to check.\n\n    Returns:\n        `True` if states form an ensemble and `False` otherwise.\n\n    \"\"\"\n    trace_sum = 0\n    for state in states:\n        trace_sum += np.trace(state)\n        # Constraint: All states in ensemble must be positive semidefinite.\n        if not is_positive_semidefinite(state):\n            return False\n    # Constraint: The sum of the traces of all states within the ensemble must\n    # be equal to 1.\n    return np.allclose(trace_sum, 1)\n</code></pre>"},{"location":"reference/toqito/state_props/is_mixed/","title":"is_mixed","text":""},{"location":"reference/toqito/state_props/is_mixed/#toqito.state_props.is_mixed","title":"is_mixed","text":"<p>Checks if a quantum state is mixed.</p>"},{"location":"reference/toqito/state_props/is_mixed/#toqito.state_props.is_mixed.is_mixed","title":"is_mixed","text":"<pre><code>is_mixed(state: ndarray) -&gt; bool\n</code></pre> <p>Determine if a given quantum state is mixed <sup>1</sup>.</p> <p>A mixed state by definition is a state that is not pure.</p> <p>Examples:</p> <p>Consider the following density matrix:</p> \\[     \\rho =  \\begin{pmatrix}                 \\frac{3}{4} &amp; 0 \\\\                 0 &amp; \\frac{1}{4}             \\end{pmatrix} \\in \\text{D}(\\mathcal{X}). \\] <p>Calculating the rank of \\(\\rho\\) yields that the \\(\\rho\\) is a mixed state. This can be confirmed in <code>|toqito\u27e9</code> as follows:</p> <pre><code>from toqito.states import basis\nfrom toqito.state_props import is_mixed\ne_0, e_1 = basis(2, 0), basis(2, 1)\nrho = 3 / 4 * e_0 @ e_0.conj().T + 1 / 4 * e_1 @ e_1.conj().T\nprint(is_mixed(rho))\n</code></pre> <p>True</p> <p>Parameters:</p> <ul> <li> <code>state</code>               (<code>ndarray</code>)           \u2013            <p>The density matrix representing the quantum state.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if state is mixed and <code>False</code> otherwise.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Quantum State - Mixed States. link.</p> Source code in <code>toqito/state_props/is_mixed.py</code> <pre><code>def is_mixed(state: np.ndarray) -&gt; bool:\n    r\"\"\"Determine if a given quantum state is mixed [@WikiMixedSt].\n\n    A mixed state by definition is a state that is not pure.\n\n    Examples:\n        Consider the following density matrix:\n\n        \\[\n            \\rho =  \\begin{pmatrix}\n                        \\frac{3}{4} &amp; 0 \\\\\n                        0 &amp; \\frac{1}{4}\n                    \\end{pmatrix} \\in \\text{D}(\\mathcal{X}).\n        \\]\n\n        Calculating the rank of \\(\\rho\\) yields that the \\(\\rho\\) is a mixed state. This can be\n        confirmed in `|toqito\u27e9` as follows:\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import basis\n        from toqito.state_props import is_mixed\n        e_0, e_1 = basis(2, 0), basis(2, 1)\n        rho = 3 / 4 * e_0 @ e_0.conj().T + 1 / 4 * e_1 @ e_1.conj().T\n        print(is_mixed(rho))\n        ```\n\n    Args:\n        state: The density matrix representing the quantum state.\n\n    Returns:\n        `True` if state is mixed and `False` otherwise.\n\n    \"\"\"\n    return not is_pure(state)\n</code></pre>"},{"location":"reference/toqito/state_props/is_mutually_orthogonal/","title":"is_mutually_orthogonal","text":""},{"location":"reference/toqito/state_props/is_mutually_orthogonal/#toqito.state_props.is_mutually_orthogonal","title":"is_mutually_orthogonal","text":"<p>Checks if quantum states are mutually orthogonal.</p>"},{"location":"reference/toqito/state_props/is_mutually_orthogonal/#toqito.state_props.is_mutually_orthogonal.is_mutually_orthogonal","title":"is_mutually_orthogonal","text":"<pre><code>is_mutually_orthogonal(vec_list: list[ndarray | list[float | Any]]) -&gt; bool\n</code></pre> <p>Check if list of vectors are mutually orthogonal <sup>1</sup>.</p> <p>We say that two bases</p> \\[     \\begin{equation}         \\mathcal{B}_0 = \\left\\{u_a: a \\in \\Sigma \\right\\} \\subset \\mathbb{C}^{\\Sigma}         \\quad \\text{and} \\quad         \\mathcal{B}_1 = \\left\\{v_a: a \\in \\Sigma \\right\\} \\subset \\mathbb{C}^{\\Sigma}     \\end{equation} \\] <p>are mutually orthogonal if and only if \\(\\left|\\langle u_a, v_b \\rangle\\right| = 0\\) for all \\(a, b \\in \\Sigma\\).</p> <p>For \\(n \\in \\mathbb{N}\\), a set of bases \\(\\left\\{ \\mathcal{B}_0, \\ldots, \\mathcal{B}_{n-1} \\right\\}\\) are mutually orthogonal if and only if every basis is orthogonal with every other basis in the set, i.e. \\(\\mathcal{B}_x\\) is orthogonal with \\(\\mathcal{B}_x^{\\prime}\\) for all \\(x \\not= x^{\\prime}\\) with \\(x, x^{\\prime} \\in \\Sigma\\).</p> <p>Examples:</p> <p>The Bell states constitute a set of mutually orthogonal vectors.</p> <pre><code>from toqito.states import bell\nfrom toqito.state_props import is_mutually_orthogonal\nstates = [bell(0), bell(1), bell(2), bell(3)]\nprint(is_mutually_orthogonal(states))\n</code></pre> <p>True</p> <p>The following is an example of a list of vectors that are not mutually orthogonal.</p> <pre><code>import numpy as np\nfrom toqito.states import bell\nfrom toqito.state_props import is_mutually_orthogonal\nstates = [np.array([1, 0]), np.array([1, 1])]\nprint(is_mutually_orthogonal(states))\n</code></pre> <p>False</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If at least two vectors are not provided.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>vec_list</code>               (<code>list[ndarray | list[float | Any]]</code>)           \u2013            <p>The list of vectors to check.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if <code>vec_list</code> are mutually orthogonal, and <code>False</code> otherwise.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Orthogonality. link.</p> Source code in <code>toqito/state_props/is_mutually_orthogonal.py</code> <pre><code>def is_mutually_orthogonal(vec_list: list[np.ndarray | list[float | Any]]) -&gt; bool:\n    r\"\"\"Check if list of vectors are mutually orthogonal [@WikiOrthog].\n\n    We say that two bases\n\n    \\[\n        \\begin{equation}\n            \\mathcal{B}_0 = \\left\\{u_a: a \\in \\Sigma \\right\\} \\subset \\mathbb{C}^{\\Sigma}\n            \\quad \\text{and} \\quad\n            \\mathcal{B}_1 = \\left\\{v_a: a \\in \\Sigma \\right\\} \\subset \\mathbb{C}^{\\Sigma}\n        \\end{equation}\n    \\]\n\n    are *mutually orthogonal* if and only if\n    \\(\\left|\\langle u_a, v_b \\rangle\\right| = 0\\) for all \\(a, b \\in \\Sigma\\).\n\n    For \\(n \\in \\mathbb{N}\\), a set of bases \\(\\left\\{\n    \\mathcal{B}_0, \\ldots, \\mathcal{B}_{n-1} \\right\\}\\) are mutually orthogonal if and only if\n    every basis is orthogonal with every other basis in the set, i.e. \\(\\mathcal{B}_x\\)\n    is orthogonal with \\(\\mathcal{B}_x^{\\prime}\\) for all \\(x \\not= x^{\\prime}\\) with\n    \\(x, x^{\\prime} \\in \\Sigma\\).\n\n    Examples:\n        The Bell states constitute a set of mutually orthogonal vectors.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import bell\n        from toqito.state_props import is_mutually_orthogonal\n        states = [bell(0), bell(1), bell(2), bell(3)]\n        print(is_mutually_orthogonal(states))\n        ```\n\n\n        The following is an example of a list of vectors that are not mutually orthogonal.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.states import bell\n        from toqito.state_props import is_mutually_orthogonal\n        states = [np.array([1, 0]), np.array([1, 1])]\n        print(is_mutually_orthogonal(states))\n        ```\n\n    Raises:\n        ValueError: If at least two vectors are not provided.\n\n    Args:\n        vec_list: The list of vectors to check.\n\n    Returns:\n        `True` if `vec_list` are mutually orthogonal, and `False` otherwise.\n\n    \"\"\"\n    if len(vec_list) &lt;= 1:\n        raise ValueError(\"There must be at least two vectors provided as input.\")\n\n    # Convert list of vectors to a 2D array (each vector is a column)\n    mat = np.column_stack(vec_list)\n\n    # Compute the matrix of inner products\n    inner_product_matrix = np.dot(mat.T.conj(), mat)\n\n    # The diagonal elements will be non-zero (norm of each vector)\n    # Set the diagonal elements to zero for the comparison\n    np.fill_diagonal(inner_product_matrix, 0)\n\n    # Check if all off-diagonal elements are close to zero\n    return np.allclose(inner_product_matrix, 0)\n</code></pre>"},{"location":"reference/toqito/state_props/is_mutually_unbiased_basis/","title":"is_mutually_unbiased_basis","text":""},{"location":"reference/toqito/state_props/is_mutually_unbiased_basis/#toqito.state_props.is_mutually_unbiased_basis","title":"is_mutually_unbiased_basis","text":"<p>Checks if the quantum states form a mutually unbiased basis.</p>"},{"location":"reference/toqito/state_props/is_mutually_unbiased_basis/#toqito.state_props.is_mutually_unbiased_basis.is_mutually_unbiased_basis","title":"is_mutually_unbiased_basis","text":"<pre><code>is_mutually_unbiased_basis(vectors: list[ndarray | list[float | Any]]) -&gt; bool\n</code></pre> <p>Check if list of vectors constitute a mutually unbiased basis <sup>1</sup>.</p> <p>We say that two orthonormal bases</p> \\[     \\begin{equation}         \\mathcal{B}_0 = \\left\\{u_a: a \\in \\Sigma \\right\\} \\subset \\mathbb{C}^{\\Sigma}         \\quad \\text{and} \\quad         \\mathcal{B}_1 = \\left\\{v_a: a \\in \\Sigma \\right\\} \\subset \\mathbb{C}^{\\Sigma}     \\end{equation} \\] <p>are mutually unbiased if and only if \\(\\left|\\langle u_a, v_b \\rangle\\right| = 1/\\sqrt{\\Sigma}\\) for all \\(a, b \\in \\Sigma\\).</p> <p>For \\(n \\in \\mathbb{N}\\), a set of orthonormal bases \\(\\left\\{ \\mathcal{B}_0, \\ldots, \\mathcal{B}_{n-1} \\right\\}\\) are mutually unbiased bases if and only if every basis is mutually unbiased with every other basis in the set, i.e. \\(\\mathcal{B}_x\\) is mutually unbiased with \\(\\mathcal{B}_x^{\\prime}\\) for all \\(x \\not= x^{\\prime}\\) with \\(x, x^{\\prime} \\in \\Sigma\\).</p> <p>Examples:</p> <p>MUB of dimension \\(2\\).</p> <p>For \\(d=2\\), the following constitutes a mutually unbiased basis:</p> \\[     \\begin{equation}         \\begin{aligned}             M_0 &amp;= \\left\\{ |0 \\rangle, |1 \\rangle \\right\\}, \\\\             M_1 &amp;= \\left\\{ \\frac{|0 \\rangle + |1 \\rangle}{\\sqrt{2}},             \\frac{|0 \\rangle - |1 \\rangle}{\\sqrt{2}} \\right\\}, \\\\             M_2 &amp;= \\left\\{ \\frac{|0 \\rangle i|1 \\rangle}{\\sqrt{2}},             \\frac{|0 \\rangle - i|1 \\rangle}{\\sqrt{2}} \\right\\}. \\\\         \\end{aligned}     \\end{equation} \\] <pre><code>import numpy as np\nfrom toqito.states import basis\nfrom toqito.state_props import is_mutually_unbiased_basis\ne_0, e_1 = basis(2, 0), basis(2, 1)\nmub_1 = [e_0, e_1]\nmub_2 = [1 / np.sqrt(2) * (e_0 + e_1), 1 / np.sqrt(2) * (e_0 - e_1)]\nmub_3 = [1 / np.sqrt(2) * (e_0 + 1j * e_1), 1 / np.sqrt(2) * (e_0 - 1j * e_1)]\nnested_mubs = [mub_1, mub_2, mub_3]\nmubs = sum(nested_mubs, [])\nprint(is_mutually_unbiased_basis(mubs))\n</code></pre> <p>True</p> <p>Non-MUB of dimension \\(2\\).</p> <pre><code>import numpy as np\nfrom toqito.states import basis\nfrom toqito.state_props import is_mutually_unbiased_basis\ne_0, e_1 = basis(2, 0), basis(2, 1)\nmub_1 = [e_0, e_1]\nmub_2 = [1 / np.sqrt(2) * (e_0 + e_1), e_1]\nmub_3 = [1 / np.sqrt(2) * (e_0 + 1j * e_1), e_0]\nmubs = [mub_1, mub_2, mub_3]\nprint(is_mutually_unbiased_basis(mubs))\n</code></pre> <p>False</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If at least two vectors are not provided.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>vectors</code>               (<code>list[ndarray | list[float | Any]]</code>)           \u2013            <p>The list of vectors to check.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if <code>vec_list</code> constitutes a mutually unbiased basis, and <code>False</code> otherwise.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Mutually unbiased bases. link.</p> Source code in <code>toqito/state_props/is_mutually_unbiased_basis.py</code> <pre><code>def is_mutually_unbiased_basis(vectors: list[np.ndarray | list[float | Any]]) -&gt; bool:\n    r\"\"\"Check if list of vectors constitute a mutually unbiased basis [@WikiMUB].\n\n    We say that two orthonormal bases\n\n    \\[\n        \\begin{equation}\n            \\mathcal{B}_0 = \\left\\{u_a: a \\in \\Sigma \\right\\} \\subset \\mathbb{C}^{\\Sigma}\n            \\quad \\text{and} \\quad\n            \\mathcal{B}_1 = \\left\\{v_a: a \\in \\Sigma \\right\\} \\subset \\mathbb{C}^{\\Sigma}\n        \\end{equation}\n    \\]\n\n    are *mutually unbiased* if and only if\n    \\(\\left|\\langle u_a, v_b \\rangle\\right| = 1/\\sqrt{\\Sigma}\\) for all \\(a, b \\in \\Sigma\\).\n\n    For \\(n \\in \\mathbb{N}\\), a set of orthonormal bases \\(\\left\\{\n    \\mathcal{B}_0, \\ldots, \\mathcal{B}_{n-1} \\right\\}\\) are mutually unbiased bases if and only if\n    every basis is mutually unbiased with every other basis in the set, i.e. \\(\\mathcal{B}_x\\)\n    is mutually unbiased with \\(\\mathcal{B}_x^{\\prime}\\) for all \\(x \\not= x^{\\prime}\\) with\n    \\(x, x^{\\prime} \\in \\Sigma\\).\n\n    Examples:\n        MUB of dimension \\(2\\).\n\n        For \\(d=2\\), the following constitutes a mutually unbiased basis:\n\n        \\[\n            \\begin{equation}\n                \\begin{aligned}\n                    M_0 &amp;= \\left\\{ |0 \\rangle, |1 \\rangle \\right\\}, \\\\\n                    M_1 &amp;= \\left\\{ \\frac{|0 \\rangle + |1 \\rangle}{\\sqrt{2}},\n                    \\frac{|0 \\rangle - |1 \\rangle}{\\sqrt{2}} \\right\\}, \\\\\n                    M_2 &amp;= \\left\\{ \\frac{|0 \\rangle i|1 \\rangle}{\\sqrt{2}},\n                    \\frac{|0 \\rangle - i|1 \\rangle}{\\sqrt{2}} \\right\\}. \\\\\n                \\end{aligned}\n            \\end{equation}\n        \\]\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.states import basis\n        from toqito.state_props import is_mutually_unbiased_basis\n        e_0, e_1 = basis(2, 0), basis(2, 1)\n        mub_1 = [e_0, e_1]\n        mub_2 = [1 / np.sqrt(2) * (e_0 + e_1), 1 / np.sqrt(2) * (e_0 - e_1)]\n        mub_3 = [1 / np.sqrt(2) * (e_0 + 1j * e_1), 1 / np.sqrt(2) * (e_0 - 1j * e_1)]\n        nested_mubs = [mub_1, mub_2, mub_3]\n        mubs = sum(nested_mubs, [])\n        print(is_mutually_unbiased_basis(mubs))\n        ```\n\n        Non-MUB of dimension \\(2\\).\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.states import basis\n        from toqito.state_props import is_mutually_unbiased_basis\n        e_0, e_1 = basis(2, 0), basis(2, 1)\n        mub_1 = [e_0, e_1]\n        mub_2 = [1 / np.sqrt(2) * (e_0 + e_1), e_1]\n        mub_3 = [1 / np.sqrt(2) * (e_0 + 1j * e_1), e_0]\n        mubs = [mub_1, mub_2, mub_3]\n        print(is_mutually_unbiased_basis(mubs))\n        ```\n\n    Raises:\n        ValueError: If at least two vectors are not provided.\n\n    Args:\n        vectors: The list of vectors to check.\n\n    Returns:\n        `True` if `vec_list` constitutes a mutually unbiased basis, and `False` otherwise.\n\n    \"\"\"\n    num_vectors = len(vectors)\n    dim_full = np.shape(vectors[0])\n    dim = dim_full[0]\n\n    # We expect the number of vectors to be a multiple of the dimension.\n    if num_vectors % dim != 0:\n        return False\n\n    num_bases = num_vectors // dim\n\n    # Check the inner product between vectors from different bases.\n    for i in range(num_bases):\n        for j in range(i + 1, num_bases):\n            for k in range(dim):\n                for litem in range(dim):\n                    # Compute inner product between vectors from different bases.\n                    inner_product = np.abs(np.vdot(vectors[i * dim + k], vectors[j * dim + litem])) ** 2\n                    if not np.isclose(inner_product, 1 / dim):\n                        return False\n    return True\n</code></pre>"},{"location":"reference/toqito/state_props/is_npt/","title":"is_npt","text":""},{"location":"reference/toqito/state_props/is_npt/#toqito.state_props.is_npt","title":"is_npt","text":"<p>Checks if the quantum state has NPT (negative partial transpose) criterion.</p>"},{"location":"reference/toqito/state_props/is_npt/#toqito.state_props.is_npt.is_npt","title":"is_npt","text":"<pre><code>is_npt(mat: ndarray, sys: int = 2, dim: int | list[int] | None = None, tol: float | None = None) -&gt; bool\n</code></pre> <p>Determine whether or not a matrix has negative partial transpose <sup>1</sup>.</p> <p>Yields either <code>True</code> or <code>False</code>, indicating that <code>mat</code> does or does not have negative partial transpose (within numerical error). The variable <code>mat</code> is assumed to act on bipartite space. <sup>2</sup></p> <p>A state has negative partial transpose if it does not have positive partial transpose.</p> <p>Examples:</p> <p>To check if a matrix has negative partial transpose</p> <pre><code>import numpy as np\nfrom toqito.state_props import is_npt\nfrom toqito.states import bell\nprint(is_npt(bell(2) @ bell(2).conj().T, 2))\n</code></pre> <p>True</p> <p>Parameters:</p> <ul> <li> <code>mat</code>               (<code>ndarray</code>)           \u2013            <p>A square matrix.</p> </li> <li> <code>sys</code>               (<code>int</code>, default:                   <code>2</code> )           \u2013            <p>Scalar or vector indicating which subsystems the transpose should be applied on. Default value is <code>2</code>.</p> </li> <li> <code>dim</code>               (<code>int | list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The dimension is a vector containing the dimensions of the subsystems on which <code>mat</code> acts.</p> </li> <li> <code>tol</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Tolerance with which to check whether <code>mat</code> is PPT.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Returns <code>True</code> if <code>mat</code> is NPT and <code>False</code> if not.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Peres-Horodecki criterion. link. <sup>2</sup> DiVincenzo, David and Shor, Peter and Smolin, John and Terhal, Barbara and Thapliyal, Ashish. Evidence for bound entangled states with negative partial transpose. Physical Review A. vol. 61(6). (2000). doi:10.1103/physreva.61.062312.</p> Source code in <code>toqito/state_props/is_npt.py</code> <pre><code>def is_npt(mat: np.ndarray, sys: int = 2, dim: int | list[int] | None = None, tol: float | None = None) -&gt; bool:\n    r\"\"\"Determine whether or not a matrix has negative partial transpose [@WikiPeresHorodecki].\n\n    Yields either `True` or `False`, indicating that `mat` does or does not have\n    negative partial transpose (within numerical error). The variable `mat` is assumed to act\n    on bipartite space. [@DiVincenzo_2000_Evidence]\n\n    A state has negative partial transpose if it does not have positive partial transpose.\n\n    Examples:\n        To check if a matrix has negative partial transpose\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.state_props import is_npt\n        from toqito.states import bell\n        print(is_npt(bell(2) @ bell(2).conj().T, 2))\n        ```\n\n    Args:\n        mat: A square matrix.\n        sys: Scalar or vector indicating which subsystems the transpose should be applied on. Default value is `2`.\n        dim: The dimension is a vector containing the dimensions of the subsystems on which `mat` acts.\n        tol: Tolerance with which to check whether `mat` is PPT.\n\n    Returns:\n        Returns `True` if `mat` is NPT and `False` if not.\n\n    \"\"\"\n    return not is_ppt(mat, sys, dim, tol)\n</code></pre>"},{"location":"reference/toqito/state_props/is_ppt/","title":"is_ppt","text":""},{"location":"reference/toqito/state_props/is_ppt/#toqito.state_props.is_ppt","title":"is_ppt","text":"<p>Checks if a quantum state violates the PPT criterion.</p>"},{"location":"reference/toqito/state_props/is_ppt/#toqito.state_props.is_ppt.is_ppt","title":"is_ppt","text":"<pre><code>is_ppt(mat: ndarray, sys: int = 2, dim: int | list[int] | ndarray | None = None, tol: float | None = None) -&gt; bool\n</code></pre> <p>Determine whether or not a matrix has positive partial transpose <sup>1</sup>.</p> <p>Yields either <code>True</code> or <code>False</code>, indicating that <code>mat</code> does or does not have positive partial transpose (within numerical error). The variable <code>mat</code> is assumed to act on bipartite space.</p> <p>For shared systems of \\(2 \\otimes 2\\) or \\(2 \\otimes 3\\), the PPT criterion serves as a method to determine whether a given state is entangled or separable. Therefore, for systems of this size, the return value <code>True</code> would indicate that the state is separable and a value of <code>False</code> would indicate the state is entangled.</p> <p>Examples:</p> <p>Consider the following matrix</p> \\[     X =     \\begin{pmatrix}         1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\\\     \\end{pmatrix}. \\] <p>This matrix trivially satisfies the PPT criterion as can be seen using the <code>|toqito\u27e9</code> package.</p> <pre><code>from toqito.state_props import is_ppt\nimport numpy as np\nmat = np.identity(9)\nprint(is_ppt(mat))\n</code></pre> <p>True</p> <p>Consider the following Bell state:</p> \\[     u = \\frac{1}{\\sqrt{2}}\\left( |01 \\rangle + |10 \\rangle \\right). \\] <p>For the density matrix \\(\\rho = u u^*\\), as this is an entangled state of dimension \\(2\\), it will violate the PPT criterion, which can be seen using the <code>|toqito\u27e9</code> package.</p> <pre><code>from toqito.states import bell\nfrom toqito.state_props import is_ppt\nrho = bell(2) @ bell(2).conj().T\nprint(is_ppt(rho))\n</code></pre> <p>False</p> <p>Parameters:</p> <ul> <li> <code>mat</code>               (<code>ndarray</code>)           \u2013            <p>A square matrix.</p> </li> <li> <code>sys</code>               (<code>int</code>, default:                   <code>2</code> )           \u2013            <p>Scalar or vector indicating which subsystems the transpose should be applied on.</p> </li> <li> <code>dim</code>               (<code>int | list[int] | ndarray | None</code>, default:                   <code>None</code> )           \u2013            <p>The dimension is a vector containing the dimensions of the subsystems on which <code>mat</code> acts.</p> </li> <li> <code>tol</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Tolerance with which to check whether <code>mat</code> is PPT.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Returns <code>True</code> if <code>mat</code> is PPT and <code>False</code> if not.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Peres-Horodecki criterion. link.</p> Source code in <code>toqito/state_props/is_ppt.py</code> <pre><code>def is_ppt(\n    mat: np.ndarray, sys: int = 2, dim: int | list[int] | np.ndarray | None = None, tol: float | None = None\n) -&gt; bool:\n    r\"\"\"Determine whether or not a matrix has positive partial transpose [@WikiPeresHorodecki].\n\n    Yields either `True` or `False`, indicating that `mat` does or does not have\n    positive partial transpose (within numerical error). The variable `mat` is assumed to act\n    on bipartite space.\n\n    For shared systems of \\(2 \\otimes 2\\) or \\(2 \\otimes 3\\), the PPT criterion serves as a\n    method to determine whether a given state is entangled or separable. Therefore, for systems of\n    this size, the return value `True` would indicate that the state is separable and a value\n    of `False` would indicate the state is entangled.\n\n    Examples:\n        Consider the following matrix\n\n        \\[\n            X =\n            \\begin{pmatrix}\n                1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\\\\n                0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\\\\n                0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\\\\n                0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\\\\n            \\end{pmatrix}.\n        \\]\n\n        This matrix trivially satisfies the PPT criterion as can be seen using the\n        `|toqito\u27e9` package.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.state_props import is_ppt\n        import numpy as np\n        mat = np.identity(9)\n        print(is_ppt(mat))\n        ```\n\n        Consider the following Bell state:\n\n        \\[\n            u = \\frac{1}{\\sqrt{2}}\\left( |01 \\rangle + |10 \\rangle \\right).\n        \\]\n\n        For the density matrix \\(\\rho = u u^*\\), as this is an entangled state\n        of dimension \\(2\\), it will violate the PPT criterion, which can be seen\n        using the `|toqito\u27e9` package.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import bell\n        from toqito.state_props import is_ppt\n        rho = bell(2) @ bell(2).conj().T\n        print(is_ppt(rho))\n        ```\n\n    Args:\n        mat: A square matrix.\n        sys: Scalar or vector indicating which subsystems the transpose should be applied on.\n        dim: The dimension is a vector containing the dimensions of the subsystems on which `mat` acts.\n        tol: Tolerance with which to check whether `mat` is PPT.\n\n    Returns:\n        Returns `True` if `mat` is PPT and `False` if not.\n\n    \"\"\"\n    eps = np.finfo(float).eps\n\n    sqrt_rho_dims = np.round(np.sqrt(list(mat.shape)))\n    sqrt_rho_dims = np.int_(sqrt_rho_dims)\n\n    if dim is None:\n        dim = [\n            [sqrt_rho_dims[0], sqrt_rho_dims[0]],\n            [sqrt_rho_dims[1], sqrt_rho_dims[1]],\n        ]\n    if tol is None:\n        tol = np.sqrt(eps)\n    return is_positive_semidefinite(partial_transpose(mat, [sys - 1], dim), tol)\n</code></pre>"},{"location":"reference/toqito/state_props/is_product/","title":"is_product","text":""},{"location":"reference/toqito/state_props/is_product/#toqito.state_props.is_product","title":"is_product","text":"<p>Checks if a quantum state is product state.</p>"},{"location":"reference/toqito/state_props/is_product/#toqito.state_props.is_product.is_product","title":"is_product","text":"<pre><code>is_product(rho: ndarray, dim: int | list[int] | ndarray | None = None) -&gt; tuple\n</code></pre> <p>Determine if a given vector is a product state <sup>1</sup>.</p> <p>If the input is deemed to be product, then the product decomposition is also returned.</p> <p>Examples:</p> <p>Consider the following Bell state</p> \\[     u = \\frac{1}{\\sqrt{2}} \\left( |00 \\rangle + |11 \\rangle \\right) \\in \\mathcal{X}. \\] <p>The corresponding density matrix of \\(u\\) may be calculated by:</p> \\[     \\rho = u u^* = \\frac{1}{2} \\begin{pmatrix}                      1 &amp; 0 &amp; 0 &amp; 1 \\\\                      0 &amp; 0 &amp; 0 &amp; 0 \\\\                      0 &amp; 0 &amp; 0 &amp; 0 \\\\                      1 &amp; 0 &amp; 0 &amp; 1                    \\end{pmatrix} \\in \\text{D}(\\mathcal{X}). \\] <p>We can provide the input as either the vector \\(u\\) or the denisty matrix \\(\\rho\\). In either case, this represents an entangled state (and hence a non-product state).</p> <pre><code>from toqito.state_props import is_product\nfrom toqito.states import bell\nrho = bell(0) @ bell(0).conj().T\nu_vec = bell(0)\nprint(is_product(rho))\n</code></pre> <p>(array([False]), None)</p> <pre><code>print(is_product(u_vec))\n</code></pre> <p>(array([False]), None)</p> <p>Parameters:</p> <ul> <li> <code>rho</code>               (<code>ndarray</code>)           \u2013            <p>The vector or matrix to check.</p> </li> <li> <code>dim</code>               (<code>int | list[int] | ndarray | None</code>, default:                   <code>None</code> )           \u2013            <p>The dimension of the input.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple</code>           \u2013            <p><code>True</code> if <code>rho</code> is a product vector and <code>False</code> otherwise.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Separable state. link.</p> Source code in <code>toqito/state_props/is_product.py</code> <pre><code>def is_product(rho: np.ndarray, dim: int | list[int] | np.ndarray | None = None) -&gt; tuple:\n    r\"\"\"Determine if a given vector is a product state [@WikiSepSt].\n\n    If the input is deemed to be product, then the product decomposition is also\n    returned.\n\n    Examples:\n        Consider the following Bell state\n\n        \\[\n            u = \\frac{1}{\\sqrt{2}} \\left( |00 \\rangle + |11 \\rangle \\right) \\in \\mathcal{X}.\n        \\]\n\n        The corresponding density matrix of \\(u\\) may be calculated by:\n\n        \\[\n            \\rho = u u^* = \\frac{1}{2} \\begin{pmatrix}\n                             1 &amp; 0 &amp; 0 &amp; 1 \\\\\n                             0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                             0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                             1 &amp; 0 &amp; 0 &amp; 1\n                           \\end{pmatrix} \\in \\text{D}(\\mathcal{X}).\n        \\]\n\n        We can provide the input as either the vector \\(u\\) or the denisty matrix \\(\\rho\\).\n        In either case, this represents an entangled state (and hence a non-product state).\n\n        ```python exec=\"1\" source=\"above\" session=\"is_product_example\"\n        from toqito.state_props import is_product\n        from toqito.states import bell\n        rho = bell(0) @ bell(0).conj().T\n        u_vec = bell(0)\n        print(is_product(rho))\n        ```\n\n        ```python exec=\"1\" source=\"above\" session=\"is_product_example\"\n        print(is_product(u_vec))\n        ```\n\n    Args:\n        rho: The vector or matrix to check.\n        dim: The dimension of the input.\n\n    Returns:\n        `True` if `rho` is a product vector and `False` otherwise.\n\n    \"\"\"\n    return _is_product(rho, dim)\n</code></pre>"},{"location":"reference/toqito/state_props/is_pure/","title":"is_pure","text":""},{"location":"reference/toqito/state_props/is_pure/#toqito.state_props.is_pure","title":"is_pure","text":"<p>Checks if a quantum state is a pure state.</p>"},{"location":"reference/toqito/state_props/is_pure/#toqito.state_props.is_pure.is_pure","title":"is_pure","text":"<pre><code>is_pure(state: list[ndarray] | ndarray) -&gt; bool\n</code></pre> <p>Determine if a given state is pure or list of states are pure <sup>1</sup>.</p> <p>A state is said to be pure if it is a density matrix with rank equal to 1. Equivalently, the state \\(\\rho\\) is pure if there exists a unit vector \\(u\\) such that:</p> \\[     \\rho = u u^*. \\] <p>Examples:</p> <p>Consider the following Bell state:</p> \\[     u = \\frac{1}{\\sqrt{2}} \\left( |00 \\rangle + |11 \\rangle \\right) \\in \\mathcal{X}. \\] <p>The corresponding density matrix of \\(u\\) may be calculated by:</p> \\[     \\rho = u u^* = \\frac{1}{2} \\begin{pmatrix}                      1 &amp; 0 &amp; 0 &amp; 1 \\\\                      0 &amp; 0 &amp; 0 &amp; 0 \\\\                      0 &amp; 0 &amp; 0 &amp; 0 \\\\                      1 &amp; 0 &amp; 0 &amp; 1                    \\end{pmatrix} \\in \\text{D}(\\mathcal{X}). \\] <p>Calculating the rank of \\(\\rho\\) yields that the \\(\\rho\\) is a pure state. This can be confirmed in <code>|toqito\u27e9</code> as follows:</p> <pre><code>from toqito.states import bell\nfrom toqito.state_props import is_pure\nu = bell(0)\nrho = u @ u.conj().T\nprint(is_pure(rho))\n</code></pre> <p>True</p> <p>It is also possible to determine whether a set of density matrices are pure. For instance, we can see that the density matrices corresponding to the four Bell states yield a result of <code>True</code> indicating that all states provided to the function are pure.</p> <pre><code>from toqito.states import bell\nfrom toqito.state_props import is_pure\nu0, u1, u2, u3 = bell(0), bell(1), bell(2), bell(3)\nrho0 = u0 @ u0.conj().T\nrho1 = u1 @ u1.conj().T\nrho2 = u2 @ u2.conj().T\nrho3 = u3 @ u3.conj().T\nprint(is_pure([rho0, rho1, rho2, rho3]))\n</code></pre> <p>True</p> <p>Parameters:</p> <ul> <li> <code>state</code>               (<code>list[ndarray] | ndarray</code>)           \u2013            <p>The density matrix representing the quantum state or a list of density matrices representing quantum</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if state is pure and <code>False</code> otherwise.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Quantum State - Pure States. link.</p> Source code in <code>toqito/state_props/is_pure.py</code> <pre><code>def is_pure(state: list[np.ndarray] | np.ndarray) -&gt; bool:\n    r\"\"\"Determine if a given state is pure or list of states are pure [@WikiPureSt].\n\n    A state is said to be pure if it is a density matrix with rank equal to 1. Equivalently, the\n    state \\(\\rho\\) is pure if there exists a unit vector \\(u\\) such that:\n\n    \\[\n        \\rho = u u^*.\n    \\]\n\n    Examples:\n        Consider the following Bell state:\n\n        \\[\n            u = \\frac{1}{\\sqrt{2}} \\left( |00 \\rangle + |11 \\rangle \\right) \\in \\mathcal{X}.\n        \\]\n\n        The corresponding density matrix of \\(u\\) may be calculated by:\n\n        \\[\n            \\rho = u u^* = \\frac{1}{2} \\begin{pmatrix}\n                             1 &amp; 0 &amp; 0 &amp; 1 \\\\\n                             0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                             0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                             1 &amp; 0 &amp; 0 &amp; 1\n                           \\end{pmatrix} \\in \\text{D}(\\mathcal{X}).\n        \\]\n\n        Calculating the rank of \\(\\rho\\) yields that the \\(\\rho\\) is a pure state. This can be\n        confirmed in `|toqito\u27e9` as follows:\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import bell\n        from toqito.state_props import is_pure\n        u = bell(0)\n        rho = u @ u.conj().T\n        print(is_pure(rho))\n        ```\n\n        It is also possible to determine whether a set of density matrices are pure. For instance, we\n        can see that the density matrices corresponding to the four Bell states yield a result of\n        `True` indicating that all states provided to the function are pure.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import bell\n        from toqito.state_props import is_pure\n        u0, u1, u2, u3 = bell(0), bell(1), bell(2), bell(3)\n        rho0 = u0 @ u0.conj().T\n        rho1 = u1 @ u1.conj().T\n        rho2 = u2 @ u2.conj().T\n        rho3 = u3 @ u3.conj().T\n        print(is_pure([rho0, rho1, rho2, rho3]))\n        ```\n\n    Args:\n        state: The density matrix representing the quantum state or a list of density matrices representing quantum\n        states.\n\n    Returns:\n        `True` if state is pure and `False` otherwise.\n\n    \"\"\"\n    # Allow the user to enter a list of states to check.\n    if isinstance(state, list):\n        for rho in state:\n            eigs, _ = np.linalg.eig(rho)\n            if not np.allclose(np.max(np.diag(eigs)), 1):\n                return False\n        return True\n\n    # Otherwise, if the user just put in a single state, check that.\n    eigs, _ = np.linalg.eig(state)\n    return np.allclose(np.max(np.diag(eigs)), 1)\n</code></pre>"},{"location":"reference/toqito/state_props/is_separable/","title":"is_separable","text":""},{"location":"reference/toqito/state_props/is_separable/#toqito.state_props.is_separable","title":"is_separable","text":"<p>Checks if a quantum state is a separable state.</p>"},{"location":"reference/toqito/state_props/is_separable/#toqito.state_props.is_separable.is_separable","title":"is_separable","text":"<pre><code>is_separable(state: ndarray, dim: None | int | list[int] = None, level: int = 2, tol: float = 1e-08) -&gt; bool\n</code></pre> <p>Determine if a given state (given as a density matrix) is a separable state <sup>1</sup>.</p> <p>A multipartite quantum state: \\(\\rho \\in \\text{D}(\\mathcal{H}_1 \\otimes \\mathcal{H}_2 \\otimes \\dots \\otimes \\mathcal{H}_N)\\) is defined as fully separable if it can be written as a convex combination of product states.</p>"},{"location":"reference/toqito/state_props/is_separable/#toqito.state_props.is_separable.is_separable--overview","title":"Overview","text":"<p>This function implements several criteria to determine separability, broadly following a similar order of checks as seen in tools like QETLAB's <code>IsSeparable</code> function <sup>2</sup>.</p> <ol> <li> <p>Input Validation: Checks if the input <code>state</code> is a square, positive semidefinite (PSD)     NumPy array. Normalizes the trace to 1 if necessary. The <code>dim</code> parameter specifying     subsystem dimensions \\(d_A, d_B\\) is processed or inferred.</p> </li> <li> <p>Trivial Cases for Separability:</p> <ul> <li>If either subsystem dimension \\(d_A\\) or \\(d_B\\) is 1   (i.e., <code>min_dim_val == 1</code>), the state is always separable.</li> </ul> </li> <li> <p>Pure State Check (Schmidt Rank):</p> <ul> <li>If the input state has rank 1 (i.e., it's a pure state), its Schmidt rank is computed.   A pure state is separable if and only if its Schmidt rank is 1 <sup>3</sup>.</li> </ul> <p>Note</p> <p>QETLAB also considers a more general Operator Schmidt Rank condition from <sup>4</sup> for weak irreducible matrices. This is not explicitly separated in this function but might be covered if such matrices are rank 1 (see issue #1245).</p> </li> <li> <p>Gurvits-Barnum Separable Ball:</p> <ul> <li>Checks if the state lies within the \"separable ball\" around the maximally mixed state,   as defined by Gurvits and Barnum <sup>5</sup>. States within this ball are   guaranteed to be separable.</li> </ul> </li> <li> <p>PPT Criterion (Peres-Horodecki) <sup>6</sup>, <sup>7</sup>:</p> <ul> <li>The Positive Partial Transpose (PPT) criterion is a necessary condition for separability.</li> <li>If the state is NPT (Not PPT), it is definitively entangled.</li> <li>If the state is PPT and the total dimension \\(d_A d_B \\le 6\\),   then PPT is also a sufficient condition for separability   <sup>7</sup>.</li> </ul> </li> <li> <p>3x3 Rank-4 PPT N&amp;S Check (Pl\u00fccker Coordinates / Breuer / Chen &amp; Djokovic):</p> <ul> <li>For 3x3 systems, if a PPT state has rank 4, there are known necessary and sufficient conditions   for separability. These are often related to the vanishing of the \"Chow form\" or determinants   of matrices constructed from Pl\u00fccker coordinates of the state's range   (e.g., <sup>8</sup>, <sup>9</sup>).   The implementation checks if a specific determinant, derived from Pl\u00fccker coordinates of the state's   range, is close to zero.</li> </ul> </li> <li> <p>Operational Criteria for Low-Rank PPT States (Horodecki et al. 2000) <sup>10</sup>:</p> <p>For PPT states (especially when \\(d_A d_B &gt; 6\\)):</p> <ul> <li>If \\(\\text{rank}(\\rho) \\le \\max(d_A, d_B)\\), the state is separable.</li> <li>If \\(\\text{rank}(\\rho) + \\text{rank}(\\rho^{T_A}) \\le 2 d_A d_B - d_A - d_B + 2\\),   the state is separable.</li> </ul> </li> <li> <p>Reduction Criterion (Horodecki &amp; Horodecki 1999) <sup>11</sup>:</p> <ul> <li>The state is entangled if \\(I_A \\otimes \\rho_B - \\rho \\not\\succeq 0\\) or   \\(\\rho_A \\otimes I_B - \\rho \\not\\succeq 0\\). This is a check for positive semidefiniteness   based on the Loewner partial order, not a check for majorization.</li> <li>For PPT states (which is the case if this part of the function is reached),   this criterion is always satisfied, so its primary strength is for NPT states (already handled).</li> </ul> </li> <li> <p>Realignment/CCNR Criteria:</p> <ul> <li>Basic Realignment (Chen &amp; Wu 2003) <sup>12</sup>:   If the trace norm of the realigned matrix is greater than 1, the state is entangled.</li> </ul> </li> <li> <p>Rank-1 Perturbation of Identity for PPT States (Vidal &amp; Tarrach 1999) <sup>13</sup>:</p> <ul> <li>PPT states that are very close to a specific type of rank-1 perturbation   of the identity matrix are separable. This is checked by examining the eigenvalue spectrum:   if the gap between the second largest and smallest eigenvalues is small,   the state is determined to be separable.</li> </ul> </li> <li> <p>2xN Specific Checks for PPT States:     For bipartite systems where one subsystem is a qubit (\\(d_A=2\\)) and the     other is N-dimensional (\\(d_B=N\\)), several specific conditions apply:</p> <ul> <li>Johnston's Spectral Condition (2013) <sup>14</sup>:   An inequality involving the largest and smallest eigenvalues of a 2xN PPT state that is sufficient   for separability.</li> <li> <p>Hildebrand's Conditions (2005, 2007, 2008) <sup>15</sup>,     <sup>16</sup>,     <sup>17</sup>:</p> <ul> <li>For a 2xN state written in block form \\(\\rho = [[A, B], [B^\\dagger, C]]\\),   a check is performed based on the rank of the anti-Hermitian part of the off-diagonal block   \\(B\\) (i.e., \\(\\text{rank}(B - B^\\dagger) \\le 1\\)).   (Note: QETLAB refers to this property in relation to \"perturbed block Hankel\" matrices).</li> <li>A check involving a transformed matrix \\(X_{2n\\_ppt\\_check}\\)   derived from blocks A, B, C, requiring it and its partial transpose   to be PSD (related to homothetic images).</li> <li>A condition based on the Frobenius norm of block \\(B\\) compared to   eigenvalues of blocks \\(A\\) and \\(C\\).</li> </ul> </li> </ul> </li> <li> <p>Decomposable Maps / Entanglement Witnesses:     These tests apply positive but not completely positive (NCP) maps. If the resulting state is not PSD,     the original state is entangled.</p> <ul> <li>Ha-Kye Maps (3x3 systems) <sup>18</sup>: Specific maps   for qutrit-qutrit systems.</li> <li>Breuer-Hall Maps (even dimensions) <sup>19</sup>, <sup>20</sup>:   Maps based on antisymmetric unitary matrices, applicable when a subsystem   has even dimension.</li> </ul> </li> <li> <p>Symmetric Extension Hierarchy (DPS) <sup>21</sup>:</p> <ul> <li>A state is separable if and only if it has a k-symmetric extension for all \\(k \\ge 1\\).</li> <li>This function checks for k-extendibility up to the specified <code>level</code>.</li> <li>If <code>level=1</code> and the state is PPT (which it is at this stage),   it's 1-extendible and thus considered separable by this specific test level.</li> <li>For <code>level &gt;= 2</code>, if a k-symmetric extension exists for all k up   to <code>level</code> (specifically, if <code>has_symmetric_extension</code> returns   <code>True</code> for the highest <code>k_actual_level_check</code> in the loop, which is   <code>level</code>), the current implementation returns <code>True</code>.</li> </ul> <p>Note</p> <p>The symmetric extension check requires CVXPY and a suitable solver. If these are not installed, or if the solver fails, a warning is printed to the console and this check is skipped.</p> <p>Note</p> <p>QETLAB's <code>SymmetricExtension</code> typically tests k-PPT-extendibility, where failure means entangled. It also has <code>SymmetricInnerExtension</code>, which can prove separability.</p> </li> </ol> <p>Examples:</p> <p>Consider the following separable (by construction) state:</p> \\[     \\rho = \\rho_1 \\otimes \\rho_2, \\] \\[ \\begin{aligned}     \\rho_1 &amp;= \\frac{1}{2} \\left(|0 \\rangle \\langle 0| + |0 \\rangle \\langle 1|             + |1 \\rangle \\langle 0| + |1 \\rangle \\langle 1| \\right), \\\\     \\rho_2 &amp;= \\frac{1}{2} \\left( |0 \\rangle \\langle 0| + |1 \\rangle \\langle 1| \\right). \\end{aligned} \\] <p>The resulting density matrix will be:</p> \\[     \\rho =  \\frac{1}{4} \\begin{pmatrix}             1 &amp; 0 &amp; 1 &amp; 0 \\\\             0 &amp; 1 &amp; 0 &amp; 1 \\\\             1 &amp; 0 &amp; 1 &amp; 0 \\\\             0 &amp; 1 &amp; 0 &amp; 1             \\end{pmatrix} \\in \\text{D}(\\mathcal{X}). \\] <p>We provide the input as a density matrix \\(\\rho\\).</p> <p>On the other hand, a random density matrix will be an entangled state (a separable state).</p> <pre><code>import numpy as np\nfrom toqito.rand.random_density_matrix import random_density_matrix\nfrom toqito.state_props.is_separable import is_separable\nrho_separable = np.array([[1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1]])\nprint(is_separable(rho_separable))\n</code></pre> <p>True</p> <pre><code>rho_not_separable = np.array([[ 0.13407875+0.j        , -0.08263926-0.17760437j,\n        -0.0135111 -0.12352182j,  0.0368423 -0.05563985j],\n    [-0.08263926+0.17760437j,  0.53338542+0.j        ,\n        0.19782968-0.04549732j,  0.11287093+0.17024249j],\n    [-0.0135111 +0.12352182j,  0.19782968+0.04549732j,\n        0.21254612+0.j        , -0.00875865+0.11144344j],\n    [ 0.0368423 +0.05563985j,  0.11287093-0.17024249j,\n        -0.00875865-0.11144344j,  0.11998971+0.j        ]])\nprint(is_separable(rho_not_separable))\n</code></pre> <p>False</p> <p>We can also detect certain PPT-entangled states. For example, a state constructed from a Breuer-Hall map is entangled but PPT.</p> <pre><code>from toqito.state_props.is_ppt import is_ppt\n\n# Construct a 2x3 separable PPT state of rank 2\n# |\u03c8\u2081\u27e9 = |0\u27e9\u2297|0\u27e9, |\u03c8\u2082\u27e9 = |1\u27e9\u2297|1\u27e9\npsi1 = np.kron([1, 0], [1, 0, 0])\npsi2 = np.kron([0, 1], [0, 1, 0])\nrho = 0.5 * (np.outer(psi1, psi1.conj()) + np.outer(psi2, psi2.conj()))\n\nprint(\"Is the state PPT?\", is_ppt(rho, dim=[2, 3]))         # True\nprint(\"Is the state separable?\", is_separable(rho, dim=[2, 3]))  # True\n</code></pre> <p>Is the state PPT? True Is the state separable? True</p> <p>Raises:</p> <ul> <li> <code>Warning</code>             \u2013            <p>If the symmetric extension check is attempted but CVXPY or a suitable solver is not available.</p> </li> <li> <code>TypeError</code>             \u2013            <p>If the input <code>state</code> is not a NumPy array.</p> </li> <li> <code>RuntimeError</code>             \u2013            <p>If the symmetric extension check is attempted but fails due to CVXPY solver issues.</p> </li> <li> <code>NotImplementedError</code>             \u2013            <p>If the symmetric extension check is attempted but the level is not implemented</p> </li> <li> <code>ValueError</code>             \u2013            <ul> <li>If the input <code>state</code> is not a square matrix.</li> <li>If the input <code>state</code> is not positive semidefinite.</li> <li>If the input <code>state</code> has a trace close to zero but contains significant non-zero elements.</li> <li>If the input <code>state</code> has a numerically insignificant trace but significant elements;     cannot normalize reliably.</li> <li>If the <code>dim</code> parameter has an invalid type (not None, int, or list).</li> <li>If <code>dim</code> is provided as an integer that does not evenly divide the state's dimension.</li> <li>If <code>dim</code> is provided as a list with a number of elements other than two.</li> <li>If <code>dim</code> is provided as a list with non-integer or negative elements.</li> <li>If the product of the dimensions in the <code>dim</code> list does not match the state's dimension.</li> <li>If a dimension of zero is provided for a non-empty state (or vice-versa).</li> </ul> </li> </ul> <p>Parameters:</p> <ul> <li> <code>state</code>               (<code>ndarray</code>)           \u2013            <p>The density matrix to check.</p> </li> <li> <code>dim</code>               (<code>None | int | list[int]</code>, default:                   <code>None</code> )           \u2013            <p>The dimension of the input state, e.g., [dim_A, dim_B]. Optional; inferred if None.</p> </li> <li> <code>level</code>               (<code>int</code>, default:                   <code>2</code> )           \u2013            <ul> <li>The level for symmetric extension (DPS) hierarchy (default: 2)</li> <li>If 1, only PPT is checked.</li> <li>If &gt;=2, checks for k-symmetric extension up to this level.</li> <li>If -1, attempts all implemented checks exhaustively (not all possible checks are implemented).</li> </ul> </li> <li> <code>tol</code>               (<code>float</code>, default:                   <code>1e-08</code> )           \u2013            <p>Numerical tolerance (default: 1e-8).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if separable, <code>False</code> if entangled or inconclusive by implemented checks.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Separable state. link. <sup>2</sup> Johnston, Nathaniel. {{QETLAB}: {A MATLAB} toolbox for quantum entanglement}. doi:10.5281/zenodo.44637. <sup>3</sup> Wikipedia. Schmidt decomposition. link. <sup>4</sup> Cariello, Daniel. Separability for Weak Irreducible matrices. (2013). <sup>5</sup> Gurvits, Leonid and Barnum, Howard. Largest separable balls around the maximally mixed bipartite quantum state. Phys. Rev. A. vol. 66. (2002). doi:10.1103/PhysRevA.66.062311. <sup>6</sup> Peres, Asher. Separability Criterion for Density Matrices. Physical Review Letters. vol. 77(8). (1996). doi:10.1103/physrevlett.77.1413. <sup>7</sup> Horodecki, Micha\u0142 and Horodecki, Pawe\u0142 and Horodecki, Ryszard. Separability of mixed states: necessary and sufficient conditions. Physics Letters A. vol. 223(1). (1996). doi:https://doi.org/10.1016/S0375-9601(96)00706-2. <sup>8</sup> Breuer, Heinz-Peter. Optimal Entanglement Criterion for Mixed Quantum States. Physical Review Letters. vol. 97(8). (2006). doi:10.1103/physrevlett.97.080501. <sup>9</sup> Chen, Lin and \u0110okovi\u0107, Dragomir. Separability problem for multipartite states of rank at most 4. Journal of Physics A: Mathematical and Theoretical. vol. 46(27). (2013). doi:10.1088/1751-8113/46/27/275304. <sup>10</sup> Horodecki, Pawe\\l{} and Lewenstein, Maciej and Vidal, Guifr\\'e and Cirac, Ignacio. Operational criterion and constructive checks for the separability of low-rank density matrices. Phys. Rev. A. vol. 62. (2000). doi:10.1103/PhysRevA.62.032310. <sup>11</sup> Horodecki, Michal and Horodecki, Pawel. Reduction criterion of separability and limits for a class of protocols of entanglement distillation. (1998). <sup>12</sup> Chen, Kai and Wu, Ling-An. A matrix realignment method for recognizing entanglement. (2003). <sup>13</sup> Vidal, Guifr\\'e and Tarrach, Rolf. Robustness of entanglement. Phys. Rev. A. vol. 59. (1999). doi:10.1103/PhysRevA.59.141. <sup>14</sup> Johnston, Nathaniel. Separability from spectrum for qubit-qudit states. Phys. Rev. A. vol. 88. (2013). doi:10.1103/PhysRevA.88.062330. <sup>15</sup> Hildebrand, Roland. Positive partial transpose from spectra. Phys. Rev. A. vol. 76. (2007). doi:10.1103/PhysRevA.76.052325. <sup>16</sup> Hildebrand, Roland. Semidefinite descriptions of low-dimensional separable matrix cones. Linear Algebra and its Applications. vol. 429(4). (2008). doi:https://doi.org/10.1016/j.laa.2008.04.018. <sup>17</sup> Hildebrand, Roland. Comparison of the PPT cone and the separable cone for 2-by-n systems.. (2005). link. <sup>18</sup> Ha, Kwang-Chang and Kye, Seung-Hyeok. Positive maps and entanglement in qudits. Physical Review A. vol. 84(2). (2011). doi:10.1103/PhysRevA.84.022314. <sup>19</sup> Breuer, Heinz-Peter. Optimal Entanglement Criterion for Mixed Quantum States. Phys. Rev. Lett.. vol. 97. (2006). doi:10.1103/PhysRevLett.97.080501. <sup>20</sup> Hall, William. A new criterion for indecomposability of positive maps. Journal of Physics A: Mathematical and General. vol. 39(46). (2006). doi:10.1088/0305-4470/39/45/020. <sup>21</sup> Doherty, Andrew and Parrilo, Pablo and Spedalieri, Federico. Complete family of separability criteria. Physical Review A. vol. 69(2). (2004). doi:10.1103/PhysRevA.69.022308.</p> Source code in <code>toqito/state_props/is_separable.py</code> <pre><code>def is_separable(state: np.ndarray, dim: None | int | list[int] = None, level: int = 2, tol: float = 1e-8) -&gt; bool:\n    r\"\"\"Determine if a given state (given as a density matrix) is a separable state [@WikiSepSt].\n\n    A multipartite quantum state:\n    \\(\\rho \\in \\text{D}(\\mathcal{H}_1 \\otimes \\mathcal{H}_2 \\otimes \\dots \\otimes \\mathcal{H}_N)\\)\n    is defined as fully separable if it can be written as a convex combination of product states.\n\n    Overview\n    ==========\n    This function implements several criteria to determine separability, broadly following a similar\n    order of checks as seen in tools like QETLAB's `IsSeparable` function [@QETLAB_link].\n\n    1.  **Input Validation**: Checks if the input `state` is a square, positive semidefinite (PSD)\n        NumPy array. Normalizes the trace to 1 if necessary. The `dim` parameter specifying\n        subsystem dimensions \\(d_A, d_B\\) is processed or inferred.\n\n    2.  **Trivial Cases for Separability**:\n\n        - If either subsystem dimension \\(d_A\\) or \\(d_B\\) is 1\n          (i.e., `min_dim_val == 1`), the state is always separable.\n\n    3.  **Pure State Check (Schmidt Rank)**:\n\n        - If the input state has rank 1 (i.e., it's a pure state), its Schmidt rank is computed.\n          A pure state is separable if and only if its Schmidt rank is 1 [@WikiScmidtDecomp].\n\n        !!! Note\n            QETLAB also considers a more general Operator Schmidt Rank condition from\n            [@Cariello_2013_Weak_irreducible] for weak irreducible matrices. This\n            is not explicitly separated in this function but might be covered if such\n            matrices are rank 1 (see issue #1245).\n\n\n    4.  **Gurvits-Barnum Separable Ball**:\n\n        - Checks if the state lies within the \"separable ball\" around the maximally mixed state,\n          as defined by Gurvits and Barnum [@Gurvits_2002_Ball]. States within this ball are\n          guaranteed to be separable.\n\n    5.  **PPT Criterion (Peres-Horodecki)**\n        [@Peres_1996_Separability], [@Horodecki_1996_PPT_small_dimensions]:\n\n        - The Positive Partial Transpose (PPT) criterion is a necessary condition for separability.\n        - If the state is NPT (Not PPT), it is definitively entangled.\n        - If the state is PPT and the total dimension \\(d_A d_B \\le 6\\),\n          then PPT is also a *sufficient* condition for separability\n          [@Horodecki_1996_PPT_small_dimensions].\n\n    6.  **3x3 Rank-4 PPT N&amp;S Check (Pl\u00fccker Coordinates / Breuer / Chen &amp; Djokovic)**:\n\n        - For 3x3 systems, if a PPT state has rank 4, there are known necessary and sufficient conditions\n          for separability. These are often related to the vanishing of the \"Chow form\" or determinants\n          of matrices constructed from Pl\u00fccker coordinates of the state's range\n          (e.g., [@Breuer_2006_Optimal], [@Chen_2013_MultipartiteRank4]).\n          The implementation checks if a specific determinant, derived from Pl\u00fccker coordinates of the state's\n          range, is close to zero.\n\n    7.  **Operational Criteria for Low-Rank PPT States (Horodecki et al. 2000)**\n        [@Horodecki_2000_PPT_low_rank]:\n\n        For PPT states (especially when \\(d_A d_B &gt; 6\\)):\n\n        - If \\(\\text{rank}(\\rho) \\le \\max(d_A, d_B)\\), the state is separable.\n        - If \\(\\text{rank}(\\rho) + \\text{rank}(\\rho^{T_A}) \\le 2 d_A d_B - d_A - d_B + 2\\),\n          the state is separable.\n\n    8.  **Reduction Criterion (Horodecki &amp; Horodecki 1999)** [@Horodecki_1998_Reduction]:\n\n        - The state is entangled if \\(I_A \\otimes \\rho_B - \\rho \\not\\succeq 0\\) or\n          \\(\\rho_A \\otimes I_B - \\rho \\not\\succeq 0\\). This is a check for positive semidefiniteness\n          based on the Loewner partial order, not a check for majorization.\n        - For PPT states (which is the case if this part of the function is reached),\n          this criterion is always satisfied, so its primary strength is for NPT states (already handled).\n\n    9.  **Realignment/CCNR Criteria**:\n\n        - **Basic Realignment (Chen &amp; Wu 2003)** [@Chen_2003_Matrix]:\n          If the trace norm of the realigned matrix is greater than 1, the state is entangled.\n\n    10. **Rank-1 Perturbation of Identity for PPT States (Vidal &amp; Tarrach 1999)** [@Vidal_1999_Robust]:\n\n        - PPT states that are very close to a specific type of rank-1 perturbation\n          of the identity matrix are separable. This is checked by examining the eigenvalue spectrum:\n          if the gap between the second largest and smallest eigenvalues is small,\n          the state is determined to be separable.\n\n    11. **2xN Specific Checks for PPT States**:\n        For bipartite systems where one subsystem is a qubit (\\(d_A=2\\)) and the\n        other is N-dimensional (\\(d_B=N\\)), several specific conditions apply:\n\n        - **Johnston's Spectral Condition (2013)** [@Johnston_2013_Spectrum]:\n          An inequality involving the largest and smallest eigenvalues of a 2xN PPT state that is sufficient\n          for separability.\n        - **Hildebrand's Conditions (2005, 2007, 2008)**\n            [@Hildebrand_2007_AbsPPT],\n            [@Hildebrand_2008_Semidefinite],\n            [@Hildebrand_2005_Cone]:\n\n            - For a 2xN state written in block form \\(\\rho = [[A, B], [B^\\dagger, C]]\\),\n              a check is performed based on the rank of the anti-Hermitian part of the off-diagonal block\n              \\(B\\) (i.e., \\(\\text{rank}(B - B^\\dagger) \\le 1\\)).\n              (Note: QETLAB refers to this property in relation to \"perturbed block Hankel\" matrices).\n            - A check involving a transformed matrix \\(X_{2n\\_ppt\\_check}\\)\n              derived from blocks A, B, C, requiring it and its partial transpose\n              to be PSD (related to homothetic images).\n            - A condition based on the Frobenius norm of block \\(B\\) compared to\n              eigenvalues of blocks \\(A\\) and \\(C\\).\n\n    12. **Decomposable Maps / Entanglement Witnesses**:\n        These tests apply positive but not completely positive (NCP) maps. If the resulting state is not PSD,\n        the original state is entangled.\n\n        - **Ha-Kye Maps (3x3 systems)** [@HaKye_2011_Positive]: Specific maps\n          for qutrit-qutrit systems.\n        - **Breuer-Hall Maps (even dimensions)** [@Breuer_2006_Mixed], [@Hall_2006_Indecomposable]:\n          Maps based on antisymmetric unitary matrices, applicable when a subsystem\n          has even dimension.\n\n    13. **Symmetric Extension Hierarchy (DPS)** [@Doherty_2004_CompleteFamily]:\n\n        - A state is separable if and only if it has a k-symmetric extension for all \\(k \\ge 1\\).\n        - This function checks for k-extendibility up to the specified `level`.\n        - If `level=1` and the state is PPT (which it is at this stage),\n          it's 1-extendible and thus considered separable by this specific test level.\n        - For `level &gt;= 2`, if a k-symmetric extension exists for all k up\n          to `level` (specifically, if `has_symmetric_extension` returns\n          `True` for the highest `k_actual_level_check` in the loop, which is\n          `level`), the current implementation returns `True`.\n\n        !!! Note\n            The symmetric extension check requires CVXPY and a suitable solver. If these are not installed,\n            or if the solver fails, a warning is printed to the console and this check is skipped.\n\n        !!! Note\n            QETLAB's `SymmetricExtension` typically tests k-PPT-extendibility, where failure means entangled.\n            It also has `SymmetricInnerExtension`, which can prove separability.\n\n\n    Examples:\n        Consider the following separable (by construction) state:\n\n        \\[\n            \\rho = \\rho_1 \\otimes \\rho_2,\n        \\]\n\n        \\[\n        \\begin{aligned}\n            \\rho_1 &amp;= \\frac{1}{2} \\left(|0 \\rangle \\langle 0| + |0 \\rangle \\langle 1|\n                    + |1 \\rangle \\langle 0| + |1 \\rangle \\langle 1| \\right), \\\\\n            \\rho_2 &amp;= \\frac{1}{2} \\left( |0 \\rangle \\langle 0| + |1 \\rangle \\langle 1| \\right).\n        \\end{aligned}\n        \\]\n\n        The resulting density matrix will be:\n\n        \\[\n            \\rho =  \\frac{1}{4} \\begin{pmatrix}\n                    1 &amp; 0 &amp; 1 &amp; 0 \\\\\n                    0 &amp; 1 &amp; 0 &amp; 1 \\\\\n                    1 &amp; 0 &amp; 1 &amp; 0 \\\\\n                    0 &amp; 1 &amp; 0 &amp; 1\n                    \\end{pmatrix} \\in \\text{D}(\\mathcal{X}).\n        \\]\n\n        We provide the input as a density matrix \\(\\rho\\).\n\n        On the other hand, a random density matrix will be an entangled state (a separable state).\n\n        ```python exec=\"1\" source=\"above\" session=\"is_separable_example\"\n        import numpy as np\n        from toqito.rand.random_density_matrix import random_density_matrix\n        from toqito.state_props.is_separable import is_separable\n        rho_separable = np.array([[1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1]])\n        print(is_separable(rho_separable))\n        ```\n\n        ```python exec=\"1\" source=\"above\" session=\"is_separable_example\"\n        rho_not_separable = np.array([[ 0.13407875+0.j        , -0.08263926-0.17760437j,\n                -0.0135111 -0.12352182j,  0.0368423 -0.05563985j],\n            [-0.08263926+0.17760437j,  0.53338542+0.j        ,\n                0.19782968-0.04549732j,  0.11287093+0.17024249j],\n            [-0.0135111 +0.12352182j,  0.19782968+0.04549732j,\n                0.21254612+0.j        , -0.00875865+0.11144344j],\n            [ 0.0368423 +0.05563985j,  0.11287093-0.17024249j,\n                -0.00875865-0.11144344j,  0.11998971+0.j        ]])\n        print(is_separable(rho_not_separable))\n        ```\n\n        We can also detect certain PPT-entangled states. For example, a state constructed from a Breuer-Hall map\n        is entangled but PPT.\n\n        ```python exec=\"1\" source=\"above\" session=\"is_separable_example\"\n        from toqito.state_props.is_ppt import is_ppt\n\n        # Construct a 2x3 separable PPT state of rank 2\n        # |\u03c8\u2081\u27e9 = |0\u27e9\u2297|0\u27e9, |\u03c8\u2082\u27e9 = |1\u27e9\u2297|1\u27e9\n        psi1 = np.kron([1, 0], [1, 0, 0])\n        psi2 = np.kron([0, 1], [0, 1, 0])\n        rho = 0.5 * (np.outer(psi1, psi1.conj()) + np.outer(psi2, psi2.conj()))\n\n        print(\"Is the state PPT?\", is_ppt(rho, dim=[2, 3]))         # True\n        print(\"Is the state separable?\", is_separable(rho, dim=[2, 3]))  # True\n        ```\n\n    Raises:\n        Warning: If the symmetric extension check is attempted but CVXPY or a suitable solver is not available.\n        TypeError: If the input `state` is not a NumPy array.\n        RuntimeError: If the symmetric extension check is attempted but fails due to CVXPY solver issues.\n        NotImplementedError: If the symmetric extension check is attempted but the level is not implemented\n        (e.g., level &lt; 1).\n        ValueError:\n            - If the input `state` is not a square matrix.\n            - If the input `state` is not positive semidefinite.\n            - If the input `state` has a trace close to zero but contains significant non-zero elements.\n            - If the input `state` has a numerically insignificant trace but significant elements;\n                cannot normalize reliably.\n            - If the `dim` parameter has an invalid type (not None, int, or list).\n            - If `dim` is provided as an integer that does not evenly divide the state's dimension.\n            - If `dim` is provided as a list with a number of elements other than two.\n            - If `dim` is provided as a list with non-integer or negative elements.\n            - If the product of the dimensions in the `dim` list does not match the state's dimension.\n            - If a dimension of zero is provided for a non-empty state (or vice-versa).\n\n\n    Args:\n        state: The density matrix to check.\n        dim: The dimension of the input state, e.g., [dim_A, dim_B]. Optional; inferred if None.\n        level:\n            - The level for symmetric extension (DPS) hierarchy (default: 2)\n            - If 1, only PPT is checked.\n            - If &gt;=2, checks for k-symmetric extension up to this level.\n            - If -1, attempts all implemented checks exhaustively (not all possible checks are implemented).\n        tol: Numerical tolerance (default: 1e-8).\n\n    Returns:\n        `True` if separable, `False` if entangled or inconclusive by implemented checks.\n\n    \"\"\"\n    # --- 1. Input Validation, Normalization, Dimension Setup ---\n    if not isinstance(state, np.ndarray):\n        raise TypeError(\"Input state must be a NumPy array.\")\n    if state.ndim != 2 or state.shape[0] != state.shape[1]:\n        raise ValueError(\"Input state must be a square matrix.\")\n\n    # Define the smallest number computer can represent to avoid numerical issues.\n    # This is used to determine the machine epsilon for numerical significance checks.\n    if np.issubdtype(state.dtype, np.complexfloating):\n        machine_eps = np.finfo(state.real.dtype).eps\n    elif np.issubdtype(state.dtype, np.floating):\n        machine_eps = np.finfo(state.dtype).eps\n    else:\n        machine_eps = np.finfo(float).eps\n\n    state_len = state.shape[0]\n\n    if not is_positive_semidefinite(state, atol=tol, rtol=tol):\n        raise ValueError(\"Checking separability of non-positive semidefinite matrix is invalid.\")\n\n    trace_state_val = np.trace(state)\n    current_state = state.copy()\n\n    # Define a heuristic factor to determine when a floating-point value is\n    # significant enough to be considered non-zero. A value is deemed\n    # significant if it's larger than this factor multiplied by the machine\n    # epsilon and the scale of the data. A factor of 100 provides a robust\n    # safety margin against accumulated round-off errors.\n    nsf = 100  # NUMERICAL_SIGNIFICANCE_FACTOR\n    tolerance = nsf * machine_eps * max(1, np.max(np.abs(current_state)) if current_state.size &gt; 0 else 1)\n    if state_len &gt; 0 and abs(trace_state_val) &lt; tol:\n        if np.any(\n            np.abs(current_state) &gt; tolerance  # Check if any element is significantly non-zero\n        ):\n            raise ValueError(\"Trace of the input state is close to zero, but state is not zero matrix.\")\n\n    if abs(trace_state_val - 1) &gt; tol:\n        if abs(trace_state_val) &gt; 100 * machine_eps:\n            current_state = current_state / trace_state_val\n        elif state_len &gt; 0 and np.any(np.abs(current_state) &gt; tol):  #  (Hard to hit with PSD)\n            raise ValueError(\n                \"State has numerically insignificant trace but significant elements; cannot normalize reliably.\"\n            )\n\n    # Dimension processing\n    if dim is None:\n        if state_len == 0:\n            dims_list = [0, 0]\n        elif state_len == 1:\n            dims_list = [1, 1]\n        else:\n            sqrt_len = int(np.round(np.sqrt(state_len)))\n            if sqrt_len * sqrt_len == state_len:\n                dims_list = [sqrt_len, sqrt_len]\n            else:\n                found_factor = False\n                for dA_try in range(2, int(np.sqrt(state_len)) + 1):\n                    if state_len % dA_try == 0:\n                        dims_list = [dA_try, state_len // dA_try]\n                        found_factor = True\n                        break\n                if not found_factor:\n                    dims_list = [1, state_len]\n    elif isinstance(dim, int):\n        if dim &lt;= 0:\n            if state_len == 0 and dim == 0:\n                dims_list = [0, 0]\n            else:\n                raise ValueError(\n                    \"Integer `dim` (interpreted as dim_A) must be positive \"\n                    + \"for non-empty states or zero for empty states.\"\n                )\n        elif state_len == 0 and dim != 0:\n            raise ValueError(f\"Cannot apply positive dimension {dim} to zero-sized state.\")\n        elif state_len &gt; 0 and dim &gt; 0 and state_len % dim != 0:\n            raise ValueError(\"The parameter `dim` must evenly divide the length of the state.\")\n        else:\n            dims_list = [int(dim), int(np.round(state_len / dim))]\n    elif isinstance(dim, list) and len(dim) == 2:\n        if not all(isinstance(d, (int, np.integer)) and d &gt;= 0 for d in dim):\n            raise ValueError(\"Dimensions in list must be non-negative integers.\")\n        if dim[0] * dim[1] != state_len:\n            if (dim[0] == 0 or dim[1] == 0) and state_len != 0:\n                raise ValueError(\"Non-zero state with zero-dim subsystem is inconsistent.\")\n            raise ValueError(\"Product of list dimensions must equal state length.\")\n        dims_list = [int(d) for d in dim]\n    else:\n        raise ValueError(\"`dim` must be None, an int, or a list of two non-negative integers.\")\n\n    dA, dB = dims_list[0], dims_list[1]\n    if (dA == 0 or dB == 0) and state_len != 0:\n        raise ValueError(\"Non-zero state with zero-dim subsystem is inconsistent.\")\n\n    if state_len == 0:\n        return True\n\n    state_rank = np.linalg.matrix_rank(current_state, tol=tol)\n    min_dim_val, max_dim_val = min(dA, dB), max(dA, dB)\n    prod_dim_val = dA * dB\n\n    if prod_dim_val == 0 and state_len &gt; 0:\n        raise ValueError(\"Zero product dimension for non-empty state is inconsistent.\")\n    if prod_dim_val &gt; 0 and prod_dim_val != state_len:\n        raise ValueError(f\"Internal dimension calculation error: prod_dim {prod_dim_val} != state_len {state_len}\")\n\n    # --- 2. Trivial Cases for Separability ---\n    if min_dim_val == 1:\n        # Every positive semidefinite matrix is separable when one of the local dimensions is 1.\n        return True\n\n    # --- 3. Pure State Check (Schmidt Rank) ---\n    # A pure state (rank 1) is separable if and only if its Schmidt rank is 1.\n    # (The condition `s_rank &lt;= 2` was previously here, referencing Cariello for weak irreducible matrices;\n    # however, for general pure states, s_rank=1 is the N&amp;S condition.\n    # TODO: look at #1245 Consider adding a separate check for OperatorSchmidtRank &lt;= 2 for general mixed states\n    # if they are determined to be \"weakly irreducible\", as per Cariello [@Cariello_2013_Weak_irreducible]\n    # and QETLAB's implementation. This is distinct from this pure state check.)\n    if state_rank == 1:\n        s_rank = schmidt_rank(current_state, dims_list)\n        return bool(s_rank == 1)\n\n    # --- 4. Gurvits-Barnum Separable Ball ---\n    if in_separable_ball(current_state):\n        # Determined to be separable by closeness to the maximally mixed state [@Gurvits_2002_Ball].\n        return True\n\n    # --- 5. PPT (Peres-Horodecki) Criterion ---\n    is_state_ppt = is_ppt(state, 2, dim, tol)  # sys=2 implies partial transpose on the second system by default\n    if not is_state_ppt:\n        # Determined to be entangled via the PPT criterion [@Peres_1996_Separability].\n        # Also, see Horodecki Theorem in [@G\u00fchne_2009_Horodecki].\n        return False\n\n    # ----- From here on, the state is known to be PPT -----\n\n    # --- 5a. PPT and dim &lt;= 6 implies separable ---\n    if prod_dim_val &lt;= 6:  # e.g., 2x2 or 2x3 systems\n        # For dA * dB &lt;= 6, PPT is necessary and sufficient for separability\n        # [@Horodecki_1996_PPT_small_dimensions].\n        return True\n\n    # --- 6. 3x3 Rank-4 PPT N&amp;S Check (Plucker/Breuer/Chen&amp;Djokovic) ---\n    # This checks if a 3x3 PPT state of rank 4 is separable.\n    # The condition involves the determinant of a matrix F constructed from Pl\u00fccker coordinates.\n    # Separability is linked to det(F) being (close to) zero [@Breuer_2006_Optimal],\n    # [@Chen_2013_MultipartiteRank4].\n    # (Note: Breuer's original PRL also relates it to F being indefinite or zero).\n    if dA == 3 and dB == 3 and state_rank == 4:\n        q_orth_basis = orth(current_state)  # Orthonormal basis for the range of rho\n        if q_orth_basis.shape[1] &lt; 4:  # Should not happen if rank is indeed 4\n            pass  # Proceed, as condition for this check is not strictly met\n        else:\n            # Code for calculating Plucker coordinates p_np_arr and F_det_matrix_elements\n            p_np_arr = np.zeros((6, 7, 8, 9), dtype=complex)  # Stores Plucker coordinates\n            for j_breuer in range(6, 0, -1):\n                for k_breuer in range(7, 0, -1):\n                    for n_breuer in range(8, 0, -1):\n                        for m_breuer in range(9, 0, -1):\n                            if j_breuer &lt; k_breuer &lt; n_breuer &lt; m_breuer:\n                                selected_rows = [idx - 1 for idx in [j_breuer, k_breuer, n_breuer, m_breuer]]\n                                if all(0 &lt;= r_idx &lt; q_orth_basis.shape[0] for r_idx in selected_rows):\n                                    sub_matrix = q_orth_basis[selected_rows, :]\n                                    if sub_matrix.shape[0] == 4 and sub_matrix.shape[1] == 4:\n                                        try:\n                                            p_np_arr[j_breuer - 1, k_breuer - 1, n_breuer - 1, m_breuer - 1] = (\n                                                np.linalg.det(sub_matrix)\n                                            )\n                                        except np.linalg.LinAlgError:  # Should be rare with orth basis\n                                            p_np_arr[j_breuer - 1, k_breuer - 1, n_breuer - 1, m_breuer - 1] = np.nan\n\n            def get_p(t_tuple):\n                # Ensure indices are within bounds of p_np_arr before accessing\n                if not (\n                    0 &lt;= t_tuple[0] - 1 &lt; p_np_arr.shape[0]\n                    and 0 &lt;= t_tuple[1] - 1 &lt; p_np_arr.shape[1]\n                    and 0 &lt;= t_tuple[2] - 1 &lt; p_np_arr.shape[2]\n                    and 0 &lt;= t_tuple[3] - 1 &lt; p_np_arr.shape[3]\n                ):\n                    # This case should ideally not happen if t_tuple values are\n                    # from the F_det_matrix_elements construction\n                    # and p_np_arr is sized for 1-based indices up to 9.\n                    # However, being defensive:\n                    return 0.0  # Or handle as an error/warning #\n                val = p_np_arr[t_tuple[0] - 1, t_tuple[1] - 1, t_tuple[2] - 1, t_tuple[3] - 1]\n                return val if not np.isnan(val) else 0.0\n\n            F_det_matrix_elements = [\n                [\n                    get_p((1, 2, 4, 5)),\n                    get_p((1, 3, 4, 6)),\n                    get_p((2, 3, 5, 6)),\n                    get_p((1, 2, 4, 6)) + get_p((1, 3, 4, 5)),\n                    get_p((1, 2, 5, 6)) + get_p((2, 3, 4, 5)),\n                    get_p((1, 3, 5, 6)) + get_p((2, 3, 4, 6)),\n                ],\n                [\n                    get_p((1, 2, 7, 8)),\n                    get_p((1, 3, 7, 9)),\n                    get_p((2, 3, 8, 9)),\n                    get_p((1, 2, 7, 9)) + get_p((1, 3, 7, 8)),\n                    get_p((1, 2, 8, 9)) + get_p((2, 3, 7, 8)),\n                    get_p((1, 3, 8, 9)) + get_p((2, 3, 7, 9)),\n                ],\n                [\n                    get_p((4, 5, 7, 8)),\n                    get_p((4, 6, 7, 9)),\n                    get_p((5, 6, 8, 9)),\n                    get_p((4, 5, 7, 9)) + get_p((4, 6, 7, 8)),\n                    get_p((4, 5, 8, 9)) + get_p((5, 6, 7, 8)),\n                    get_p((4, 6, 8, 9)) + get_p((5, 6, 7, 9)),\n                ],\n                [\n                    get_p((1, 2, 4, 8)) - get_p((1, 2, 5, 7)),\n                    get_p((1, 3, 4, 9)) - get_p((1, 3, 6, 7)),\n                    get_p((2, 3, 5, 9)) - get_p((2, 3, 6, 8)),\n                    get_p((1, 2, 4, 9)) - get_p((1, 2, 6, 7)) + get_p((1, 3, 4, 8)) - get_p((1, 3, 5, 7)),\n                    get_p((1, 2, 5, 9)) - get_p((1, 2, 6, 8)) + get_p((2, 3, 4, 8)) - get_p((2, 3, 5, 7)),\n                    get_p((1, 3, 5, 9)) - get_p((1, 3, 6, 8)) + get_p((2, 3, 4, 9)) - get_p((2, 3, 6, 7)),\n                ],\n                [\n                    get_p((1, 4, 5, 8)) - get_p((2, 4, 5, 7)),\n                    get_p((1, 4, 6, 9)) - get_p((3, 4, 6, 7)),\n                    get_p((2, 5, 6, 9)) - get_p((3, 5, 6, 8)),\n                    get_p((1, 4, 5, 9)) - get_p((2, 4, 6, 7)) + get_p((1, 4, 6, 8)) - get_p((3, 4, 5, 7)),\n                    get_p((1, 5, 6, 8)) - get_p((2, 5, 6, 7)) + get_p((2, 4, 5, 9)) - get_p((3, 4, 5, 8)),\n                    get_p((1, 5, 6, 9)) - get_p((3, 4, 6, 8)) + get_p((2, 4, 6, 9)) - get_p((3, 5, 6, 7)),\n                ],\n                [\n                    get_p((1, 5, 7, 8)) - get_p((2, 4, 7, 8)),\n                    get_p((1, 6, 7, 9)) - get_p((3, 4, 7, 9)),\n                    get_p((2, 6, 8, 9)) - get_p((3, 5, 8, 9)),\n                    get_p((1, 5, 7, 9)) - get_p((2, 4, 7, 9)) + get_p((1, 6, 7, 8)) - get_p((3, 4, 7, 8)),\n                    get_p((1, 5, 8, 9)) - get_p((2, 4, 8, 9)) + get_p((2, 6, 7, 8)) - get_p((3, 5, 7, 8)),\n                    get_p((1, 6, 8, 9)) - get_p((3, 4, 8, 9)) + get_p((2, 6, 7, 9)) - get_p((3, 5, 7, 9)),\n                ],\n            ]\n            try:\n                F_det_val = np.linalg.det(np.array(F_det_matrix_elements, dtype=complex))\n                # This condition (abs(det(F)) ~ 0 for separability) is used by QETLAB for this specific test.\n                return bool(\n                    abs(F_det_val) &lt; max(tol**2, machine_eps ** (3 / 4))\n                )  # Separable by this 3x3 rank-4 condition\n                # Proceeding from 3x3 rank 4 block.\")\n                # If det(F) is not close to zero, the state is entangled by this criterion.\n                # TODO: #1251 Breuer's PRL indicates separability if F is indefinite or zero. Entangled if F is\n                # definite (and det(F) real).\n                # The current check `abs(F_det_val) &lt; tol_check` might only capture the `F=0` part or if\n                # F is singular due to indefiniteness.\n                # If this F_det_val is not small, it implies entangled.\n                # However, your original code structure implies if this `return True` is not hit, it just proceeds.\n                # For consistency with QETLAB for this specific test: if abs(F_det_val) is NOT small, it\n                # implies entangled.\n                # This function would need to return False here if abs(F_det_val) is NOT small.\n                # Current structure: if det is small, sep=T. If det is not small, or LinAlgError, proceeds.\n                # For UPB tile states (3x3, rank 4, PPT entangled), det(F) is typically non-zero. So this\n                # `return True` isn't hit.\n            except np.linalg.LinAlgError:  # If determinant calculation fails\n                pass  # Proceed to other tests\n\n    # --- 7. Operational Criteria for Low-Rank PPT States (Horodecki et al. 2000) ---\n    # These are sufficient conditions for separability of PPT states [@Horodecki_2000_PPT_low_rank].\n    if state_rank &lt;= max_dim_val:  # rank(rho) &lt;= max(dA, dB)\n        return True\n\n    rho_pt_A = partial_transpose(current_state, sys=0, dim=dims_list)  # Partial transpose on system A\n    rank_pt_A = np.linalg.matrix_rank(rho_pt_A, tol=tol)\n    threshold_horodecki = 2 * prod_dim_val - dA - dB + 2  # Threshold for sum of ranks\n\n    if state_rank + rank_pt_A &lt;= threshold_horodecki:  # rank(rho) + rank(rho^T_A) &lt;= threshold\n        return True\n    # TODO: #1251 Add check for rank(rho) &lt;= rank(marginal_A) or rank(rho) &lt;= rank(marginal_B) as in QETLAB.\n\n    # --- 8. Reduction Criterion (Horodecki &amp; Horodecki 1999) ---\n    # If state is PPT (which it is at this point), this criterion is always satisfied.\n    # Its main use is for NPT states. Included for completeness of listed criteria.\n    rho_A_marginal = partial_trace(current_state, sys=[1], dim=dims_list)\n    rho_B_marginal = partial_trace(current_state, sys=[0], dim=dims_list)\n    op_reduct1 = np.kron(np.eye(dA), rho_B_marginal) - current_state\n    op_reduct2 = np.kron(rho_A_marginal, np.eye(dB)) - current_state\n    if not (\n        is_positive_semidefinite(op_reduct1, atol=tol, rtol=tol)\n        and is_positive_semidefinite(op_reduct2, atol=tol, rtol=tol)\n    ):  #  (should not be hit for PPT states)\n        return False  # Entangled by reduction criterion\n\n    # --- 9. Realignment/CCNR Criteria ---\n    # Basic Realignment Criterion [@Chen_2003_Matrix]. If &gt; 1, entangled.\n    if trace_norm(realignment(current_state, dims_list)) &gt; 1 + tol:\n        return False\n\n    # Zhang et al. 2008 Variant [@Zhang_2008_Beyond_realignment].\n    # If ||R(rho - rho_A \\otimes rho_B)||_1 &gt; sqrt((1-Tr(rho_A^2))(1-Tr(rho_B^2))), entangled.\n    tr_rho_A_sq = np.real(np.trace(rho_A_marginal @ rho_A_marginal))\n    tr_rho_B_sq = np.real(np.trace(rho_B_marginal @ rho_B_marginal))\n    val_A = max(0, 1 - tr_rho_A_sq)  # Ensure non-negativity from (1 - purity)\n    val_B = max(0, 1 - tr_rho_B_sq)\n    bound_zhang = np.sqrt(val_A * val_B) if (val_A * val_B &gt;= 0) else 0\n    if trace_norm(realignment(current_state - np.kron(rho_A_marginal, rho_B_marginal), dims_list)) &gt; bound_zhang + tol:\n        return False\n    # TODO: #1246 Consider adding Filter CMC criterion from Gittsovich et al. 2008, which is stronger.\n\n    # --- 10. Rank-1 Perturbation of Identity for PPT States (Vidal &amp; Tarrach 1999) ---\n    # PPT states close to identity are separable [@Vidal_1999_Robust].\n    try:\n        try:\n            lam = np.linalg.eigvalsh(current_state)[::-1]  # Eigenvalues sorted descending\n        except np.linalg.LinAlgError:  # Fallback if eigvalsh fails\n            lam = np.sort(np.real(np.linalg.eigvals(current_state)))[::-1]\n\n        if len(lam) == prod_dim_val and prod_dim_val &gt; 1:\n            # If (lambda_2 - lambda_d) is very small for a PPT state.\n            diff_pert = lam[1] - lam[prod_dim_val - 1]\n            threshold_pert = tol**2 + 2 * machine_eps\n            if diff_pert &lt; threshold_pert:\n                return True\n    except np.linalg.LinAlgError:  # If all eigenvalue computations fail #\n        pass  # Proceed to other tests\n\n    # --- 11. 2xN Specific Checks for PPT States ---\n    if min_dim_val == 2 and prod_dim_val &gt; 0:  # One system is a qubit\n        state_t_2xn = current_state\n        d_N_val = max_dim_val  # Dimension of the N-level system\n        # Ensure the qubit system is the first one for consistent block matrix decomposition\n        # sys_to_pt_for_hildebrand_map = 1 (PT on system B, the N-level one)\n        # dim_for_hildebrand_map = [2, d_N_val]\n        dim_for_hildebrand_map = [2, d_N_val]\n\n        if dA != 2 and dB == 2:  # If system A is N-level and B is qubit, swap them\n            state_t_2xn = swap(current_state, sys=[0, 1], dim=dims_list)\n            # d_N_val remains max_dim_val. Dimensions for map are now [qubit_dim, N_dim]\n            dim_for_hildebrand_map = [dB, dA]\n        elif dA == 2:  # System A is already the qubit\n            pass  # state_t_2xn and d_N_val are correctly set\n        else:  # This case should not be reached if min_dim_val == 2\n            state_t_2xn = None  # Defensive #\n\n        if state_t_2xn is not None:\n            current_lam_2xn = lam  # Use eigenvalues of original state if no swap\n            if state_t_2xn is not current_state:  # If swap occurred, recompute eigenvalues\n                try:\n                    current_lam_2xn = np.linalg.eigvalsh(state_t_2xn)[::-1]\n                except np.linalg.LinAlgError:\n                    current_lam_2xn = np.sort(np.real(np.linalg.eigvals(state_t_2xn)))[::-1]\n\n            # Johnston's Spectral Condition [@Johnston_2013_Spectrum]\n            if (\n                len(current_lam_2xn) &gt;= 2 * d_N_val  # Check if enough eigenvalues exist\n                and (2 * d_N_val - 1) &lt; len(current_lam_2xn)  # Index validity\n                and (2 * d_N_val - 2) &gt;= 0\n                and (2 * d_N_val - 3) &gt;= 0\n            ):\n                # Condition: (lambda_1 - lambda_{2N-1})^2 &lt;= 4 * lambda_{2N-2} * lambda_{2N}\n                # (Using 0-based indexing: (lam[0]-lam[2N-2])^2 &lt;= 4*lam[2N-3]*lam[2N-1])\n                if (current_lam_2xn[0] - current_lam_2xn[2 * d_N_val - 2]) ** 2 &lt;= 4 * current_lam_2xn[\n                    2 * d_N_val - 3\n                ] * current_lam_2xn[2 * d_N_val - 1] + tol**2:  # Added tolerance\n                    return True\n\n            # Hildebrand's Conditions for 2xN PPT states (various papers, e.g.,\n            # [@Hildebrand_2005_Cone], [@Hildebrand_2008_Semidefinite])\n            # Block matrix form: rho_2xn = [[A, B], [B^dagger, C]]\n            A_block = state_t_2xn[:d_N_val, :d_N_val]\n            B_block = state_t_2xn[:d_N_val, d_N_val : 2 * d_N_val]\n            C_block = state_t_2xn[d_N_val : 2 * d_N_val, d_N_val : 2 * d_N_val]\n\n            # If rank of anti-Hermitian part of B is small (related to \"perturbed block Hankel\" in QETLAB)\n            if B_block.size &gt; 0 and np.linalg.matrix_rank(B_block - B_block.conj().T, tol=tol) &lt;= 1:\n                return True\n\n            # Hildebrand's homothetic images approach / X_2n_ppt_check\n            if A_block.size &gt; 0 and B_block.size &gt; 0 and C_block.size &gt; 0:  # Ensure blocks are not empty #\n                X_2n_ppt_check = np.vstack(\n                    (\n                        np.hstack(((5 / 6) * A_block - C_block / 6, B_block)),\n                        np.hstack((B_block.conj().T, (5 / 6) * C_block - A_block / 6)),\n                    )\n                )\n                # The dimensions for partial_transpose of X_2n_ppt_check should be [2, d_N_val]\n                # if the map is applied on the \"qubit part\" of this transformed 2N x 2N space.\n                # QETLAB uses IsPPT(X_2n_ppt_check,2,[2,xD]), implying PT on 2nd system of a 2xD structure.\n                # Here, sys_to_pt_for_hildebrand_map=1 and dim_for_hildebrand_map=[2,d_N_val] seems correct.\n                if is_positive_semidefinite(X_2n_ppt_check, atol=tol, rtol=tol) and is_ppt(\n                    X_2n_ppt_check,\n                    sys=1,\n                    dim=dim_for_hildebrand_map,\n                    tol=tol,\n                ):  # Check PPT of this map's Choi matrix basically\n                    return True\n\n                # Johnston Lemma 1 variant / norm B condition\n                try:\n                    eig_A_real, eig_C_real = np.real(np.linalg.eigvals(A_block)), np.real(np.linalg.eigvals(C_block))\n                    if eig_A_real.size &gt; 0 and eig_C_real.size &gt; 0 and B_block.size &gt; 0:\n                        if np.linalg.norm(B_block) ** 2 &lt;= np.min(eig_A_real) * np.min(eig_C_real) + tol**2:\n                            return True\n                except np.linalg.LinAlgError:\n                    pass  # Eigenvalue computation failed\n\n    # --- 12. Decomposable Maps (Positive but not Completely Positive Maps as Witnesses) ---\n    # Ha-Kye Maps for 3x3 systems [@HaKye_2011_Positive]\n    if dA == 3 and dB == 3:\n        phi_me3 = max_entangled(3, False, False)  # Maximally entangled state vector in C^3 x C^3\n        phi_proj3 = phi_me3 @ phi_me3.conj().T  # Projector onto it\n        for t_raw_ha in np.arange(0.1, 1.0, 0.1):  # Parameter 't' for map construction\n            t_iter_ha = t_raw_ha\n            for j_ha_loop in range(2):  # Iterate for t and 1/t (common symmetry in these maps)\n                if j_ha_loop == 1:\n                    # if abs(t_raw_ha) &lt; machine_eps: #  (t_raw_ha always &gt;= 0.1)\n                    #     break  # Should not happen with arange\n                    t_iter_ha = 1 / t_raw_ha\n\n                denom_ha = 1 - t_iter_ha + t_iter_ha**2  # Denominator from Ha-Kye map parameters\n                if abs(denom_ha) &lt; machine_eps:\n                    continue  #  (denom_ha = 1-t+t^2 &gt; 0 for t&gt;0)\n\n                a_hk = (1 - t_iter_ha) ** 2 / denom_ha\n                b_hk = t_iter_ha**2 / denom_ha\n                c_hk = 1 / denom_ha\n                # Choi matrix of a generalized Choi map (related to Ha-Kye constructions)\n                Phi_map_ha = np.diag([a_hk + 1, c_hk, b_hk, b_hk, a_hk + 1, c_hk, c_hk, b_hk, a_hk + 1]) - phi_proj3\n                if not is_positive_semidefinite(\n                    partial_channel(current_state, Phi_map_ha, sys=1, dim=dims_list), atol=tol, rtol=tol\n                ):\n                    return False  # Entangled if map application results in non-PSD state #\n\n    # Breuer-Hall Maps (for even dimensional subsystems) [@Breuer_2006_Mixed],\n    # [@Hall_2006_Indecomposable]\n    for p_idx_bh in range(2):  # Apply map to subsystem 0 (A), then subsystem 1 (B)\n        current_dim_bh = dims_list[p_idx_bh]  # Dimension of the subsystem map acts on\n        if current_dim_bh &gt; 0 and current_dim_bh % 2 == 0:  # Map defined for even dimensions\n            phi_me_bh = max_entangled(current_dim_bh, False, False)\n            phi_proj_bh = phi_me_bh @ phi_me_bh.conj().T\n            half_dim_bh = current_dim_bh // 2\n            # Construct an antisymmetric unitary U_bh_kron_part\n            diag_U_elems_bh = np.concatenate([np.ones(half_dim_bh), -np.ones(half_dim_bh)])\n            U_bh_kron_part = np.fliplr(np.diag(diag_U_elems_bh))  # U = -U^T\n            # Choi matrix of the Breuer-Hall witness map W_U(X) = Tr(X)I - X - U X^T U^dagger\n            # The Choi matrix used here is I - P_max_ent - (I kron U) SWAP (I kron U^dagger)\n            U_for_phi_constr = np.kron(np.eye(current_dim_bh), U_bh_kron_part)\n            Phi_bh_map_choi = (  # This is Choi(W_U)\n                np.eye(current_dim_bh**2)\n                - phi_proj_bh\n                - U_for_phi_constr @ swap_operator(current_dim_bh) @ U_for_phi_constr.conj().T\n            )\n            mapped_state_bh = partial_channel(current_state, Phi_bh_map_choi, sys=p_idx_bh, dim=dims_list)\n            if not is_positive_semidefinite(mapped_state_bh, atol=tol, rtol=tol):\n                return False  # Entangled if map application results in non-PSD state\n\n    # --- 13. Symmetric Extension Hierarchy (DPS) ---\n    # A state is separable iff it has a k-symmetric extension for all k [@Doherty_2004_CompleteFamily].\n    # We check up to the specified `level`.\n    if level &gt;= 2:  # Level 1 (PPT) is already confirmed if we reach here.\n        # Loop for k from 2 up to `level` specified by user.\n        # If `has_symmetric_extension` returns True for any k in this loop,\n        # it means the state *is* k-extendible. This implementation interprets this as\n        # passing the DPS test up to that level, and thus returns True (separable).\n        # TODO: #1247 A stricter interpretation for proving entanglement would be: if for *any* k in this loop,\n        # `has_symmetric_extension` returns False, then it's entangled.\n        # QETLAB's `SymmetricExtension` returns 0 if *not* k-PPT-extendible (entangled).\n        # QETLAB's `SymmetricInnerExtension` returns 1 if separable by that method.\n        # The current Python loop `if has_symmetric_extension(...): return True` means if it passes\n        # for k=2 (and level &gt;=2), it declares separable.\n        for k_actual_level_check in range(2, int(level) + 1):  # Ensure level is int for range\n            try:\n                if has_symmetric_extension(rho=current_state, level=k_actual_level_check, dim=dims_list, tol=tol):\n                    # State has a k-symmetric extension, considered separable by this test level.\n                    return True\n                # If it does NOT have a k-symmetric extension, it is entangled.\n                # The current loop structure means if has_symmetric_extension for k=2 is False,\n                # it will continue to k=3 (if level &gt;=3), etc. It only returns True if an extension is found.\n                # To match \"if not extendible -&gt; entangled\":\n                # if not has_symmetric_extension(...): return False; # This would be a change.\n                # The current logic is: \"if extendible at any k up to level, then separable\".\n            except ImportError:\n                print(\"Warning: CVXPY or a solver is not installed; cannot perform symmetric extension check.\")\n                break  # Stop trying symmetric extensions if dependencies are missing\n            except Exception as e:\n                print(f\"Warning: Symmetric extension check failed at level {k_actual_level_check} with an error: {e}\")\n                # Decide whether to break or continue to next k_level if solver fails for one.\n                # Current: proceeds to next k or finishes loop.\n                pass  # Proceed, may not be able to determine via this method.\n    elif level == 1 and is_state_ppt:  # is_state_ppt is True at this point\n        # 1-extendibility is equivalent to PPT.\n        return True\n\n    # If all implemented checks are inconclusive, and the state passed PPT (the most basic necessary condition checked),\n    # it implies that the state is either separable but not caught by the simpler sufficient conditions,\n    # or it's a PPT entangled state that also wasn't caught by other implemented witnesses\n    # or the DPS hierarchy up to `level`.\n    # Defaulting to False implies we couldn't definitively prove separability with the implemented tests.\n    return False\n</code></pre>"},{"location":"reference/toqito/state_props/is_sic_povm/","title":"is_sic_povm","text":""},{"location":"reference/toqito/state_props/is_sic_povm/#toqito.state_props.is_sic_povm","title":"is_sic_povm","text":"<p>Determine whether a collection of vectors forms a SIC POVM.</p>"},{"location":"reference/toqito/state_props/is_sic_povm/#toqito.state_props.is_sic_povm.is_sic_povm","title":"is_sic_povm","text":"<pre><code>is_sic_povm(states: Sequence[ndarray], *, tol: float = 1e-06) -&gt; bool\n</code></pre> <p>Check if the provided vectors yield a symmetric informationally complete POVM.</p> <p>A set of \\(d^2\\) unit vectors \\(\\{\\ket{\\psi_j}\\}\\) in \\(\\mathbb{C}^d\\) forms a symmetric informationally complete POVM (SIC POVM) when</p> \\[     \\left| \\langle \\psi_j, \\psi_k \\rangle \\right|^2 = \\frac{1}{d + 1}     \\quad \\text{for all } j \\neq k, \\] <p>and the projectors satisfy \\(\\sum_j \\ket{\\psi_j}\\!\\bra{\\psi_j} = d \\mathbb{I}\\).</p> <p>Examples:</p> <p>Qubit tetrahedron SIC.</p> <pre><code>import numpy as np\nfrom toqito.state_props import is_sic_povm\n\nomega = np.exp(2j * np.pi / 3)\nsic_vectors = [\n    np.array([0, 1], dtype=np.complex128),\n    np.array([np.sqrt(2/3), 1/np.sqrt(3)], dtype=np.complex128),\n    np.array([np.sqrt(2/3), omega / np.sqrt(3)], dtype=np.complex128),\n    np.array([np.sqrt(2/3), (omega**2) / np.sqrt(3)], dtype=np.complex128),\n]\nprint(is_sic_povm(sic_vectors))\n</code></pre> <p>True</p> <p>Non-SIC vector family.</p> <pre><code>import numpy as np\nfrom toqito.state_props import is_sic_povm\nfrom toqito.states import basis\n\ne0, e1 = basis(2, 0), basis(2, 1)\nnon_sic = [e0, e1, (e0 + e1) / np.sqrt(2), (e0 - e1) / np.sqrt(2)]\nprint(is_sic_povm(non_sic))\n</code></pre> <p>False</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the vectors cannot represent valid quantum states.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>states</code>               (<code>Sequence[ndarray]</code>)           \u2013            <p>Collection of vectors to test.</p> </li> <li> <code>tol</code>               (<code>float</code>, default:                   <code>1e-06</code> )           \u2013            <p>Numerical tolerance used for equality comparisons.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> when the vectors form a SIC POVM and <code>False</code> otherwise.</p> </li> </ul> Source code in <code>toqito/state_props/is_sic_povm.py</code> <pre><code>def is_sic_povm(states: Sequence[np.ndarray], *, tol: float = 1e-6) -&gt; bool:\n    r\"\"\"Check if the provided vectors yield a symmetric informationally complete POVM.\n\n    A set of \\(d^2\\) unit vectors \\(\\{\\ket{\\psi_j}\\}\\) in \\(\\mathbb{C}^d\\) forms a\n    symmetric informationally complete POVM (SIC POVM) when\n\n    \\[\n        \\left| \\langle \\psi_j, \\psi_k \\rangle \\right|^2 = \\frac{1}{d + 1}\n        \\quad \\text{for all } j \\neq k,\n    \\]\n\n    and the projectors satisfy \\(\\sum_j \\ket{\\psi_j}\\!\\bra{\\psi_j} = d \\mathbb{I}\\).\n\n    Examples:\n        Qubit tetrahedron SIC.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.state_props import is_sic_povm\n\n        omega = np.exp(2j * np.pi / 3)\n        sic_vectors = [\n            np.array([0, 1], dtype=np.complex128),\n            np.array([np.sqrt(2/3), 1/np.sqrt(3)], dtype=np.complex128),\n            np.array([np.sqrt(2/3), omega / np.sqrt(3)], dtype=np.complex128),\n            np.array([np.sqrt(2/3), (omega**2) / np.sqrt(3)], dtype=np.complex128),\n        ]\n        print(is_sic_povm(sic_vectors))\n        ```\n\n        Non-SIC vector family.\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.state_props import is_sic_povm\n        from toqito.states import basis\n\n        e0, e1 = basis(2, 0), basis(2, 1)\n        non_sic = [e0, e1, (e0 + e1) / np.sqrt(2), (e0 - e1) / np.sqrt(2)]\n        print(is_sic_povm(non_sic))\n        ```\n\n    Raises:\n        ValueError: If the vectors cannot represent valid quantum states.\n\n    Args:\n        states: Collection of vectors to test.\n        tol: Numerical tolerance used for equality comparisons.\n\n    Returns:\n        `True` when the vectors form a SIC POVM and `False` otherwise.\n\n    \"\"\"\n    if not states:\n        raise ValueError(\"At least one vector must be provided.\")\n\n    normalized_states = [normalize(state, tol=tol) for state in states]\n\n    dimension = normalized_states[0].size\n    if any(state.size != dimension for state in normalized_states):\n        raise ValueError(\"All SIC vectors must have the same dimension.\")\n\n    if dimension == 0:\n        raise ValueError(\"States must have non-zero dimension.\")\n\n    num_states = len(normalized_states)\n    if dimension**2 != num_states:\n        return False\n\n    gram = vectors_to_gram_matrix(normalized_states)\n\n    if not np.allclose(np.diag(gram), 1.0, atol=tol):\n        return False\n\n    target_overlap = 1.0 / (dimension + 1.0)\n    off_diag_mask = ~np.eye(num_states, dtype=bool)\n    off_diag_values = np.abs(gram) ** 2\n\n    if not np.allclose(off_diag_values[off_diag_mask], target_overlap, atol=tol):\n        return False\n\n    frame_operator = np.zeros((dimension, dimension), dtype=np.complex128)\n    for state in normalized_states:\n        frame_operator += np.outer(state, state.conj())\n\n    if not np.allclose(frame_operator, dimension * np.eye(dimension, dtype=np.complex128), atol=tol):\n        return False\n\n    return True\n</code></pre>"},{"location":"reference/toqito/state_props/is_unextendible_product_basis/","title":"is_unextendible_product_basis","text":""},{"location":"reference/toqito/state_props/is_unextendible_product_basis/#toqito.state_props.is_unextendible_product_basis","title":"is_unextendible_product_basis","text":"<p>Check if a set of states form an unextendible product basis.</p>"},{"location":"reference/toqito/state_props/is_unextendible_product_basis/#toqito.state_props.is_unextendible_product_basis.is_unextendible_product_basis","title":"is_unextendible_product_basis","text":"<pre><code>is_unextendible_product_basis(vecs: list[ndarray], dims: list[int]) -&gt; tuple[bool, ndarray | None]\n</code></pre> <p>Check if a set of vectors form an unextendible product basis (UPB) <sup>1</sup>.</p> <p>Consider a multipartite quantum system \\(\\mathcal{H} = \\bigotimes_{i=1}^{m} \\mathcal{H}_{i}\\) with \\(m\\) parties with respective dimensions \\(d_i, i = 1, 2, ..., m\\). An (incomplete orthogonal) product basis (PB) is a set \\(S\\) of pure orthogonal product states spanning a proper subspace \\(\\mathcal{H}_S\\) of \\(\\mathcal{H}\\).  An unextendible product basis (UPB) is a PB whose complementary subspace \\(\\mathcal{H}_S-\\mathcal{H}\\) contains no product state.  This function is inspired from <code>IsUPB</code> in <sup>2</sup>.</p> <p>Examples:</p> <p>See tile(). All the states together form a UPB:</p> <pre><code>import numpy as np\nfrom toqito.states import tile\nfrom toqito.state_props import is_unextendible_product_basis\nupb_tiles = np.array([tile(i) for i in range(5)])\ndims = np.array([3, 3])\nprint(is_unextendible_product_basis(upb_tiles, dims))\n</code></pre> <p>(True, None)</p> <p>However, the first 4 do not:</p> <pre><code>import numpy as np\nfrom toqito.states import tile\nfrom toqito.state_props import is_unextendible_product_basis\nnon_upb_tiles = np.array([tile(i) for i in range(4)])\ndims = np.array([3, 3])\nprint(is_unextendible_product_basis(non_upb_tiles, dims))\n</code></pre> <p>(False, array([-0.00000000e+00,  0.00000000e+00,  0.00000000e+00, -0.00000000e+00,  0.00000000e+00,  0.00000000e+00, -1.11022302e-16,  7.07106781e-01,         7.07106781e-01]))</p> <p>The orthogonal state is given by</p> \\[     \\frac{1}{\\sqrt{2}} |2\\rangle \\left( |1\\rangle + |2\\rangle \\right) \\] <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If product of dimensions does not match the size of a vector.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If at least one vector is not a product state.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>vecs</code>               (<code>list[ndarray]</code>)           \u2013            <p>The list of states.</p> </li> <li> <code>dims</code>               (<code>list[int]</code>)           \u2013            <p>The list of dimensions.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Returns a tuple. The first element is <code>True</code> if input is a UPB and <code>False</code> otherwise. The second element is a</p> </li> <li> <code>ndarray | None</code>           \u2013            <p>witness (a product state orthogonal to all the input vectors) if the input is a PB and <code>None</code> otherwise.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Bennett, Charles and DiVincenzo, David and Mor, Tal and Shor, Peter and Smolin, John and Terhal, Barbara. Unextendible Product Bases and Bound Entanglement. Physical Review Letters. vol. 82(26). (1999). doi:10.1103/physrevlett.82.5385. <sup>2</sup> Johnston, Nathaniel. {{QETLAB}: {A MATLAB} toolbox for quantum entanglement}. doi:10.5281/zenodo.44637.</p> Source code in <code>toqito/state_props/is_unextendible_product_basis.py</code> <pre><code>def is_unextendible_product_basis(vecs: list[np.ndarray], dims: list[int]) -&gt; tuple[bool, np.ndarray | None]:\n    r\"\"\"Check if a set of vectors form an unextendible product basis (UPB) [@Bennett_1999_UPB].\n\n    Consider a multipartite quantum system \\(\\mathcal{H} = \\bigotimes_{i=1}^{m} \\mathcal{H}_{i}\\) with \\(m\\)\n    parties with respective dimensions \\(d_i, i = 1, 2, ..., m\\). An (incomplete orthogonal) product basis (PB) is a\n    set \\(S\\) of pure orthogonal product states spanning a proper subspace \\(\\mathcal{H}_S\\) of\n    \\(\\mathcal{H}\\).  An unextendible product basis (UPB) is a PB whose complementary subspace\n    \\(\\mathcal{H}_S-\\mathcal{H}\\) contains no product state.  This function is inspired from `IsUPB` in\n    [@QETLAB_link].\n\n    Examples:\n        See [tile()][toqito.states.tile.tile]. All the states together form a UPB:\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.states import tile\n        from toqito.state_props import is_unextendible_product_basis\n        upb_tiles = np.array([tile(i) for i in range(5)])\n        dims = np.array([3, 3])\n        print(is_unextendible_product_basis(upb_tiles, dims))\n        ```\n\n        However, the first 4 do not:\n\n        ```python exec=\"1\" source=\"above\"\n        import numpy as np\n        from toqito.states import tile\n        from toqito.state_props import is_unextendible_product_basis\n        non_upb_tiles = np.array([tile(i) for i in range(4)])\n        dims = np.array([3, 3])\n        print(is_unextendible_product_basis(non_upb_tiles, dims))\n        ```\n\n        The orthogonal state is given by\n\n        \\[\n            \\frac{1}{\\sqrt{2}} |2\\rangle \\left( |1\\rangle + |2\\rangle \\right)\n        \\]\n\n    Raises:\n        ValueError: If product of dimensions does not match the size of a vector.\n        ValueError: If at least one vector is not a product state.\n\n    Args:\n        vecs: The list of states.\n        dims: The list of dimensions.\n\n    Returns:\n        Returns a tuple. The first element is `True` if input is a UPB and `False` otherwise. The second element is a\n        witness (a product state orthogonal to all the input vectors) if the input is a PB and `None` otherwise.\n\n    \"\"\"\n    vecs = np.array(vecs)\n    dims = np.array(dims)\n\n    if np.prod(dims) != vecs.shape[1]:\n        raise ValueError(\"Product of dimensions does not equal the size of each vector\")\n\n    if not all(is_product(vec, dims)[0] for vec in vecs):\n        raise ValueError(\"At least one vector is not a product state\")\n\n    # Number of parties (m).\n    num_parties = dims.shape[0]\n\n    # Number of vectors (n).\n    num_vecs = vecs.shape[0]\n\n    # If n &lt; m vectors are provided, then we cannot generate set partitions, so it is not a UPB. We will extend the set\n    # with m-n null vectors and run the same algorithm.\n    if (num_vecs := vecs.shape[0]) &lt; num_parties:\n        vecs = np.append(vecs, np.zeros(shape=(num_parties - num_vecs, *vecs.shape[1:])), axis=0)\n        num_vecs = vecs.shape[0]\n\n    # Split products.\n    vecs_split = np.array([is_product(vec, dims)[1] for vec in vecs])\n\n    # Acquire generator to m-partitions of [0, n-1].\n    parts_unordered = set_partitions(list(range(num_vecs)), num_parties)\n\n    for part_unordered in parts_unordered:\n        for part_ordered in permutations(part_unordered):\n            # Witness vectors.\n            wit = []\n            witness_found = True\n            for i in range(num_parties):\n                # For the i-th party, acquire the matrix.\n                mat = np.stack([vecs_split[col, i, :] for col in part_ordered[i]])\n                # Find the basis of the null space.\n                null_basis = null_space(mat)\n                # If null space is empty then break.\n                if null_basis.shape[1] == 0:\n                    witness_found = False\n                    break\n                # If null space is non-empty, add a basis vector of null space to witness.\n                wit.append(null_basis[:, 0])\n            # If witness was found, then it is not a UPB, return tensor product of witness vectors.\n            if witness_found:\n                # If wit is empty, tensor returns None.\n                return False, tensor(wit)\n\n    # If no witness was found, it is a UPB.\n    return True, None\n</code></pre>"},{"location":"reference/toqito/state_props/l1_norm_coherence/","title":"l1_norm_coherence","text":""},{"location":"reference/toqito/state_props/l1_norm_coherence/#toqito.state_props.l1_norm_coherence","title":"l1_norm_coherence","text":"<p>Computes the l1-norm of coherence of a quantum state.</p>"},{"location":"reference/toqito/state_props/l1_norm_coherence/#toqito.state_props.l1_norm_coherence.l1_norm_coherence","title":"l1_norm_coherence","text":"<pre><code>l1_norm_coherence(rho: ndarray) -&gt; float\n</code></pre> <p>Compute the l1-norm of coherence of a quantum state <sup>1</sup>.</p> <p>The \\(\\ell_1\\)-norm of coherence of a quantum state \\(\\rho\\) is defined as</p> \\[     C_{\\ell_1}(\\rho) = \\sum_{i \\not= j} \\left|\\rho_{i,j}\\right|, \\] <p>where \\(\\rho_{i,j}\\) is the \\((i,j)^{th}\\)-entry of \\(\\rho\\) in the standard basis.</p> <p>The \\(\\ell_1\\)-norm of coherence is the sum of the absolute values of the sum of the absolute values of the off-diagonal entries of the density matrix <code>rho</code> in the standard basis.</p> <p>This function was adapted from QETLAB.</p> <p>Examples:</p> <p>The largest possible value of the \\(\\ell_1\\)-norm of coherence on \\(d\\)-dimensional states is \\(d-1\\), and is attained exactly by the \"maximally coherent states\": pure states whose entries all have the same absolute value.</p> <pre><code>from toqito.state_props import l1_norm_coherence\nimport numpy as np\n# Maximally coherent state.\nv = np.ones((3,1))/np.sqrt(3)\nprint(l1_norm_coherence(v))\n</code></pre> <p>2.000000000000001</p> <p>Parameters:</p> <ul> <li> <code>rho</code>               (<code>ndarray</code>)           \u2013            <p>A matrix or vector.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The l1-norm coherence of <code>rho</code>.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Rana, Swapan and Parashar, Preeti and Winter, Andreas and Lewenstein, Maciej. Logarithmic coherence: Operational interpretation of \\({\\ensuremath{ \\ell}}_{1}\\)-norm coherence. Phys. Rev. A. vol. 96. (2017). doi:10.1103/PhysRevA.96.052336.</p> Source code in <code>toqito/state_props/l1_norm_coherence.py</code> <pre><code>def l1_norm_coherence(rho: np.ndarray) -&gt; float:\n    r\"\"\"Compute the l1-norm of coherence of a quantum state [@Rana_2017_Log].\n\n    The \\(\\ell_1\\)-norm of coherence of a quantum state \\(\\rho\\) is\n    defined as\n\n    \\[\n        C_{\\ell_1}(\\rho) = \\sum_{i \\not= j} \\left|\\rho_{i,j}\\right|,\n    \\]\n\n    where \\(\\rho_{i,j}\\) is the \\((i,j)^{th}\\)-entry of \\(\\rho\\)\n    in the standard basis.\n\n    The \\(\\ell_1\\)-norm of coherence is the sum of the absolute values of\n    the sum of the absolute values of the off-diagonal entries of the density\n    matrix `rho` in the standard basis.\n\n    This function was adapted from QETLAB.\n\n    Examples:\n        The largest possible value of the \\(\\ell_1\\)-norm of coherence on\n        \\(d\\)-dimensional states is \\(d-1\\), and is attained exactly by\n        the \"maximally coherent states\": pure states whose entries all have the\n        same absolute value.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.state_props import l1_norm_coherence\n        import numpy as np\n        # Maximally coherent state.\n        v = np.ones((3,1))/np.sqrt(3)\n        print(l1_norm_coherence(v))\n        ```\n\n    Args:\n        rho: A matrix or vector.\n\n    Returns:\n        The l1-norm coherence of `rho`.\n\n    \"\"\"\n    rho = to_density_matrix(rho)\n    return np.sum(np.sum(np.abs(rho))) - np.trace(rho)\n</code></pre>"},{"location":"reference/toqito/state_props/learnability/","title":"learnability","text":""},{"location":"reference/toqito/state_props/learnability/#toqito.state_props.learnability","title":"learnability","text":"<p>Evaluate the quantum learnability semidefinite programs.</p>"},{"location":"reference/toqito/state_props/learnability/#toqito.state_props.learnability.learnability","title":"learnability","text":"<pre><code>learnability(states: Sequence[ndarray], k: int, *, solver: str | None = 'SCS', solver_kwargs: dict[str, Any] | None = None, verify_reduced: bool = True, verify_tolerance: float = 0.0001, tol: float = 1e-08) -&gt; dict[str, float | str | None | dict]\n</code></pre> <p>Compute the average error value of the learnability semidefinite program.</p> <p>This routine minimizes</p> \\[     \\frac{1}{n} \\sum_{i = 1}^n \\left\\langle \\rho_i,     \\sum_{S: i \\notin S} M_S \\right\\rangle. \\] <p>over POVM elements \\((M_S)\\) indexed by <code>k</code>-element subsets, subject to \\(\\sum_S M_S = \\mathbb{I}\\) and \\(M_S \\succeq 0\\).  When all inputs are pure, the reduced Gram-matrix SDP</p> \\[     \\sum_{i = 1}^n \\bra{i} \\sum_{S: i \\notin S} W_S \\ket{i}. \\] <p>with constraint \\(\\sum_S W_S = G\\) (Gram matrix) and \\(W_S \\succeq 0\\) is also solved as a consistency check.</p> <p>Examples:</p> <pre><code>from toqito.state_props import learnability\nfrom toqito.states import basis\n\ne0, e1 = basis(2, 0), basis(2, 1)\nprint(learnability(\n    [e0, e1],\n    k=1,\n    solver=\"SCS\",\n    solver_kwargs={\"eps\": 1e-6, \"max_iters\": 5_000},\n))\n</code></pre> <p>{'value': -1.1495747540306813e-06, 'status': 'optimal', 'reduced_value': -1.1495747540306813e-06, 'reduced_status': 'optimal', 'measurement_operators': {(0,): array([[ 1.00000115e+00+0.j,  0.00000000e+00+0.j],        [ 0.00000000e+00+0.j, -1.14957476e-06+0.j]]), (1,): array([[-1.14957475e-06+0.j,  0.00000000e+00+0.j],        [ 0.00000000e+00+0.j,  1.00000115e+00+0.j]])}, 'reduced_operators': {(0,): array([[ 1.00000115e+00+0.j,  0.00000000e+00+0.j],        [ 0.00000000e+00+0.j, -1.14957476e-06+0.j]]), (1,): array([[-1.14957475e-06+0.j,  0.00000000e+00+0.j],        [ 0.00000000e+00+0.j,  1.00000115e+00+0.j]])}, 'total_value': -2.2991495080613626e-06, 'reduced_total_value': -2.2991495080613626e-06}</p> <p>Parameters:</p> <ul> <li> <code>states</code>               (<code>Sequence[ndarray]</code>)           \u2013            <p>Sequence of state vectors or density matrices acting on the same space.</p> </li> <li> <code>k</code>               (<code>int</code>)           \u2013            <p>Subset size for the POVM outcomes; must satisfy <code>1 &lt;= k &lt;= len(states)</code>.</p> </li> <li> <code>solver</code>               (<code>str | None</code>, default:                   <code>'SCS'</code> )           \u2013            <p>Optional CVXPY solver name. Defaults to <code>\"SCS\"</code>.</p> </li> <li> <code>solver_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Extra keyword arguments forwarded to :meth:<code>cvxpy.Problem.solve</code>.</p> </li> <li> <code>verify_reduced</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If <code>True</code> and the states are pure, also solve the reduced SDP.</p> </li> <li> <code>verify_tolerance</code>               (<code>float</code>, default:                   <code>0.0001</code> )           \u2013            <p>Absolute tolerance used when comparing the two optimal values.</p> </li> <li> <code>tol</code>               (<code>float</code>, default:                   <code>1e-08</code> )           \u2013            <p>Numerical tolerance used when validating positivity and rank-one states.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, float | str | None | dict]</code>           \u2013            <p>Dictionary with keys <code>value</code>, <code>total_value</code>, <code>status</code>, <code>measurement_operators</code>, and optionally <code>reduced_value</code>,</p> </li> <li> <code>dict[str, float | str | None | dict]</code>           \u2013            <p><code>reduced_total_value</code>, <code>reduced_status</code>, <code>reduced_operators</code>.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the data are inconsistent with valid quantum states or if <code>k</code> lies outside the permissible range.</p> </li> <li> <code>SolverError</code>             \u2013            <p>If the selected solver reports a failure.</p> </li> </ul> Source code in <code>toqito/state_props/learnability.py</code> <pre><code>def learnability(\n    states: Sequence[np.ndarray],\n    k: int,\n    *,\n    solver: str | None = \"SCS\",\n    solver_kwargs: dict[str, Any] | None = None,\n    verify_reduced: bool = True,\n    verify_tolerance: float = 1e-4,\n    tol: float = 1e-8,\n) -&gt; dict[str, float | str | None | dict]:\n    r\"\"\"Compute the average error value of the learnability semidefinite program.\n\n    This routine minimizes\n\n    \\[\n        \\frac{1}{n} \\sum_{i = 1}^n \\left\\langle \\rho_i,\n        \\sum_{S: i \\notin S} M_S \\right\\rangle.\n    \\]\n\n    over POVM elements \\((M_S)\\) indexed by ``k``-element subsets, subject to\n    \\(\\sum_S M_S = \\mathbb{I}\\) and \\(M_S \\succeq 0\\).  When all inputs are pure, the\n    reduced Gram-matrix SDP\n\n    \\[\n        \\sum_{i = 1}^n \\bra{i} \\sum_{S: i \\notin S} W_S \\ket{i}.\n    \\]\n\n    with constraint \\(\\sum_S W_S = G\\) (Gram matrix) and \\(W_S \\succeq 0\\)\n    is also solved as a consistency check.\n\n    Examples:\n        ```python exec=\"1\" source=\"above\"\n        from toqito.state_props import learnability\n        from toqito.states import basis\n\n        e0, e1 = basis(2, 0), basis(2, 1)\n        print(learnability(\n            [e0, e1],\n            k=1,\n            solver=\"SCS\",\n            solver_kwargs={\"eps\": 1e-6, \"max_iters\": 5_000},\n        ))\n        ```\n\n    Args:\n        states: Sequence of state vectors or density matrices acting on the same space.\n        k: Subset size for the POVM outcomes; must satisfy `1 &lt;= k &lt;= len(states)`.\n        solver: Optional CVXPY solver name. Defaults to `\"SCS\"`.\n        solver_kwargs: Extra keyword arguments forwarded to :meth:`cvxpy.Problem.solve`.\n        verify_reduced: If `True` and the states are pure, also solve the reduced SDP.\n        verify_tolerance: Absolute tolerance used when comparing the two optimal values.\n        tol: Numerical tolerance used when validating positivity and rank-one states.\n\n    Returns:\n        Dictionary with keys `value`, `total_value`, `status`, `measurement_operators`, and optionally `reduced_value`,\n        `reduced_total_value`, `reduced_status`, `reduced_operators`.\n\n    Raises:\n        ValueError: If the data are inconsistent with valid quantum states or if `k` lies outside the permissible range.\n        cvxpy.error.SolverError: If the selected solver reports a failure.\n\n    \"\"\"\n    if not states:\n        raise ValueError(\"The list of states must be non-empty.\")\n\n    density_matrices, candidate_vectors = _convert_states(states, tol=tol)\n    general_value, general_status, measurement_variables = _solve_learnability_general(\n        density_matrices,\n        k,\n        solver=solver,\n        solver_kwargs=solver_kwargs,\n    )\n\n    operator_values = {combo: measurement_variables[combo].value for combo in measurement_variables}\n\n    result: dict[str, float | str | None | dict] = {\n        \"value\": float(np.real(general_value)),\n        \"status\": general_status,\n        \"reduced_value\": None,\n        \"reduced_status\": None,\n        \"measurement_operators\": operator_values,\n        \"reduced_operators\": None,\n        \"total_value\": float(np.real(general_value)) * len(density_matrices),\n    }\n    result[\"reduced_total_value\"] = None\n\n    if verify_reduced and candidate_vectors is not None:\n        gram = vectors_to_gram_matrix(candidate_vectors)\n        reduced_value, reduced_status, reduced_variables = _solve_learnability_reduced(\n            gram,\n            k,\n            solver=solver,\n            solver_kwargs=solver_kwargs,\n        )\n        reduced_operator_values = {combo: var.value for combo, var in reduced_variables.items()}\n        result[\"reduced_value\"] = float(np.real(reduced_value))\n        result[\"reduced_status\"] = reduced_status\n        result[\"reduced_operators\"] = reduced_operator_values\n        result[\"reduced_total_value\"] = float(np.real(reduced_value)) * len(density_matrices)\n\n        if abs(result[\"value\"] - result[\"reduced_value\"]) &gt; verify_tolerance:\n            warnings.warn(\n                (\n                    \"General and reduced SDP optimal values differ by more than \"\n                    f\"{verify_tolerance}. General value: {result['value']}, \"\n                    f\"reduced value: {result['reduced_value']}.\"\n                ),\n                RuntimeWarning,\n            )\n\n    return result\n</code></pre>"},{"location":"reference/toqito/state_props/log_negativity/","title":"log_negativity","text":""},{"location":"reference/toqito/state_props/log_negativity/#toqito.state_props.log_negativity","title":"log_negativity","text":"<p>Calculates the logarithmic negativity property of a quantum state.</p>"},{"location":"reference/toqito/state_props/log_negativity/#toqito.state_props.log_negativity.log_negativity","title":"log_negativity","text":"<pre><code>log_negativity(rho: ndarray, dim: list[int] | int | None = None) -&gt; float\n</code></pre> <p>Compute the log-negativity of a bipartite quantum state <sup>1</sup>.</p> <p>The log-negativity of a subsystem can be defined in terms of a density matrix \\(\\rho\\):</p> \\[     E_\\mathcal{N}(\\rho) \\equiv \\text{log}_2\\left( ||\\rho^{\\Gamma_A}||_1 \\right). \\] <p>Calculate the log-negativity of the quantum state \\(\\rho\\), assuming that the two subsystems on which \\(\\rho\\) acts are of equal dimension (if the local dimensions are unequal, specify them in the optional <code>dim</code> argument).</p> <p>Examples:</p> <p>Example of the log-negativity of density matrix of Bell state.</p> <pre><code>from toqito.states import bell\nfrom toqito.state_props import log_negativity\nrho = bell(0) @ bell(0).conj().T\nprint(log_negativity(rho))\n</code></pre> <p>0.9999999999999997</p> <p>See</p> <p>negativity()</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the input matrix is not a density matrix.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>rho</code>               (<code>ndarray</code>)           \u2013            <p>A density matrix of a pure state vector.</p> </li> <li> <code>dim</code>               (<code>list[int] | int | None</code>, default:                   <code>None</code> )           \u2013            <p>The default has both subsystems of equal dimension.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>A positive value that corresponds to the logarithmic negativity of \\(\\rho\\).</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Negativity. link.</p> Source code in <code>toqito/state_props/log_negativity.py</code> <pre><code>def log_negativity(rho: np.ndarray, dim: list[int] | int | None = None) -&gt; float:\n    r\"\"\"Compute the log-negativity of a bipartite quantum state [@WikiNeg].\n\n    The log-negativity of a subsystem can be defined in terms of a density matrix \\(\\rho\\):\n\n    \\[\n        E_\\mathcal{N}(\\rho) \\equiv \\text{log}_2\\left( ||\\rho^{\\Gamma_A}||_1 \\right).\n    \\]\n\n    Calculate the log-negativity of the quantum state \\(\\rho\\), assuming that the two subsystems\n    on which \\(\\rho\\) acts are of equal dimension (if the local dimensions are unequal, specify\n    them in the optional `dim` argument).\n\n    Examples:\n        Example of the log-negativity of density matrix of Bell state.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import bell\n        from toqito.state_props import log_negativity\n        rho = bell(0) @ bell(0).conj().T\n        print(log_negativity(rho))\n        ```\n\n        !!!See Also\n            [negativity()][toqito.state_props.negativity.negativity]\n\n    Raises:\n        ValueError: If the input matrix is not a density matrix.\n\n    Args:\n        rho: A density matrix of a pure state vector.\n        dim: The default has both subsystems of equal dimension.\n\n    Returns:\n        A positive value that corresponds to the logarithmic negativity of \\(\\rho\\).\n\n    \"\"\"\n    # Allow the user to input either a pure state vector or a density matrix.\n    rho = to_density_matrix(rho)\n    rho_dims = rho.shape\n    round_dim = np.round(np.sqrt(rho_dims))\n\n    if dim is None:\n        dim = np.array([round_dim])\n        dim = dim.T\n    if isinstance(dim, list):\n        dim = np.array(dim)\n\n    # Allow the user to enter a single number for dim.\n    if isinstance(dim, int):\n        dim = np.array([dim, rho_dims[0] / dim])\n        if abs(dim[1] - np.round(dim[1])) &gt;= 2 * rho_dims[0] * np.finfo(float).eps:\n            raise ValueError(\n                \"InvalidDim: If `dim` is a scalar, `rho` must be \"\n                \"square and `dim` must evenly divide `len(rho)`. \"\n                \"Please provide the `dim` array containing the \"\n                \"dimensions of the subsystems.\"\n            )\n        dim[1] = np.round(dim[1])\n\n    if np.prod(dim) != rho_dims[0]:\n        raise ValueError(\n            \"InvalidDim: Please provide local dimensions in the argument `dim` that match the size of `rho`.\"\n        )\n\n    dim = [int(x.item()) for x in dim]\n\n    # Compute the log-negativity.\n    return np.log2(np.linalg.norm(partial_transpose(rho, [1], dim), ord=\"nuc\"))\n</code></pre>"},{"location":"reference/toqito/state_props/negativity/","title":"negativity","text":""},{"location":"reference/toqito/state_props/negativity/#toqito.state_props.negativity","title":"negativity","text":"<p>Calculates the negativity property of a quantum state.</p>"},{"location":"reference/toqito/state_props/negativity/#toqito.state_props.negativity.negativity","title":"negativity","text":"<pre><code>negativity(rho: ndarray, dim: list[int] | int | None = None) -&gt; float | floating\n</code></pre> <p>Compute the negativity of a bipartite quantum state <sup>1</sup>.</p> <p>The negativity of a subsystem can be defined in terms of a density matrix \\(\\rho\\):</p> \\[     \\mathcal{N}(\\rho) \\equiv \\frac{||\\rho^{\\Gamma_A}||_1-1}{2}. \\] <p>Calculate the negativity of the quantum state \\(\\rho\\), assuming that the two subsystems on which \\(\\rho\\) acts are of equal dimension (if the local dimensions are unequal, specify them in the optional <code>dim</code> argument). The negativity of \\(\\rho\\) is the sum of the absolute value of the negative eigenvalues of the partial transpose of \\(\\rho\\).</p> <p>Examples:</p> <p>Example of the negativity of density matrix of Bell state.</p> <pre><code>from toqito.states import bell\nfrom toqito.state_props import negativity\nrho = bell(0) @ bell(0).conj().T\nprint(negativity(rho))\n</code></pre> <p>0.4999999999999998</p> <p>See</p> <p>log_negativity()</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If dimension of matrix is invalid.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>rho</code>               (<code>ndarray</code>)           \u2013            <p>A density matrix of a pure state vector.</p> </li> <li> <code>dim</code>               (<code>list[int] | int | None</code>, default:                   <code>None</code> )           \u2013            <p>The default has both subsystems of equal dimension.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float | floating</code>           \u2013            <p>A value between 0 and 1 that corresponds to the negativity of \\(\\rho\\).</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Negativity. link.</p> Source code in <code>toqito/state_props/negativity.py</code> <pre><code>def negativity(rho: np.ndarray, dim: list[int] | int | None = None) -&gt; float | np.floating:\n    r\"\"\"Compute the negativity of a bipartite quantum state [@WikiNeg].\n\n    The negativity of a subsystem can be defined in terms of a density matrix \\(\\rho\\):\n\n    \\[\n        \\mathcal{N}(\\rho) \\equiv \\frac{||\\rho^{\\Gamma_A}||_1-1}{2}.\n    \\]\n\n    Calculate the negativity of the quantum state \\(\\rho\\), assuming that the two subsystems on\n    which \\(\\rho\\) acts are of equal dimension (if the local dimensions are unequal, specify\n    them in the optional `dim` argument). The negativity of \\(\\rho\\) is the sum of the\n    absolute value of the negative eigenvalues of the partial transpose of \\(\\rho\\).\n\n    Examples:\n        Example of the negativity of density matrix of Bell state.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import bell\n        from toqito.state_props import negativity\n        rho = bell(0) @ bell(0).conj().T\n        print(negativity(rho))\n        ```\n\n        !!!See Also\n            [log_negativity()][toqito.state_props.log_negativity.log_negativity]\n\n    Raises:\n        ValueError: If dimension of matrix is invalid.\n\n    Args:\n        rho: A density matrix of a pure state vector.\n        dim: The default has both subsystems of equal dimension.\n\n    Returns:\n        A value between 0 and 1 that corresponds to the negativity of \\(\\rho\\).\n\n    \"\"\"\n    # Allow the user to input either a pure state vector or a density matrix.\n    rho = to_density_matrix(rho)\n    rho_dims = rho.shape\n    round_dim = np.round(np.sqrt(rho_dims))\n\n    if dim is None:\n        dim = np.array([round_dim])\n        dim = dim.T\n    if isinstance(dim, list):\n        dim = np.array(dim)\n\n    # Allow the user to enter a single number for dim.\n    if isinstance(dim, int):\n        dim = np.array([dim, rho_dims[0] / dim])\n        if abs(dim[1] - np.round(dim[1])) &gt;= 2 * rho_dims[0] * np.finfo(float).eps:\n            raise ValueError(\n                \"InvalidDim: If `dim` is a scalar, `rho` must be \"\n                \"square and `dim` must evenly divide `len(rho)`. \"\n                \"Please provide the `dim` array containing the \"\n                \"dimensions of the subsystems.\"\n            )\n        dim[1] = np.round(dim[1])\n\n    if np.prod(dim) != rho_dims[0]:\n        raise ValueError(\n            \"InvalidDim: Please provide local dimensions in the argument `dim` that match the size of `rho`.\"\n        )\n\n    dim = [int(x.item()) for x in dim]\n\n    # Compute the negativity.\n    return (np.linalg.norm(partial_transpose(rho, [1], dim), ord=\"nuc\") - 1) / 2\n</code></pre>"},{"location":"reference/toqito/state_props/purity/","title":"purity","text":""},{"location":"reference/toqito/state_props/purity/#toqito.state_props.purity","title":"purity","text":"<p>Calcultes the purity of a quantum state.</p>"},{"location":"reference/toqito/state_props/purity/#toqito.state_props.purity.purity","title":"purity","text":"<pre><code>purity(rho: ndarray) -&gt; float\n</code></pre> <p>Compute the purity of a quantum state <sup>1</sup>.</p> <p>The negativity of a subsystem can be defined in terms of a density matrix \\(\\rho\\): The purity of a quantum state \\(\\rho\\) is defined as</p> \\[     \\text{Tr}(\\rho^2), \\] <p>where \\(\\text{Tr}\\) is the trace function.</p> <p>Examples:</p> <p>Consider the following scaled state defined as the scaled identity matrix</p> \\[     \\rho = \\frac{1}{4} \\begin{pmatrix}                      1 &amp; 0 &amp; 0 &amp; 0 \\\\                      0 &amp; 1 &amp; 0 &amp; 0 \\\\                      0 &amp; 0 &amp; 1 &amp; 0 \\\\                      0 &amp; 0 &amp; 0 &amp; 1                    \\end{pmatrix} \\in \\text{D}(\\mathcal{X}). \\] <p>Calculating the purity of \\(\\rho\\) yields \\(\\frac{1}{4}\\). This can be observed using <code>|toqito\u27e9</code> as follows.</p> <pre><code>from toqito.state_props import purity\nimport numpy as np\nprint(purity(np.identity(4) / 4))\n</code></pre> <p>0.25</p> <p>Calculate the purity of the Werner state:</p> <pre><code>from toqito.states import werner\nrho = werner(2, 1 / 4)\nprint(purity(rho))\n</code></pre> <p>0.26530612244897955</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If matrix is not density operator.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>rho</code>               (<code>ndarray</code>)           \u2013            <p>A density matrix of a pure state vector.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>A value between 0 and 1 that corresponds to the purity of \\(\\rho\\).</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Purity (quantum mechanics). link.</p> Source code in <code>toqito/state_props/purity.py</code> <pre><code>def purity(rho: np.ndarray) -&gt; float:\n    r\"\"\"Compute the purity of a quantum state [@WikiPurity].\n\n    The negativity of a subsystem can be defined in terms of a density matrix \\(\\rho\\): The\n    purity of a quantum state \\(\\rho\\) is defined as\n\n    \\[\n        \\text{Tr}(\\rho^2),\n    \\]\n\n    where \\(\\text{Tr}\\) is the trace function.\n\n    Examples:\n        Consider the following scaled state defined as the scaled identity matrix\n\n        \\[\n            \\rho = \\frac{1}{4} \\begin{pmatrix}\n                             1 &amp; 0 &amp; 0 &amp; 0 \\\\\n                             0 &amp; 1 &amp; 0 &amp; 0 \\\\\n                             0 &amp; 0 &amp; 1 &amp; 0 \\\\\n                             0 &amp; 0 &amp; 0 &amp; 1\n                           \\end{pmatrix} \\in \\text{D}(\\mathcal{X}).\n        \\]\n\n        Calculating the purity of \\(\\rho\\) yields \\(\\frac{1}{4}\\). This can be observed using\n        `|toqito\u27e9` as follows.\n\n        ```python exec=\"1\" source=\"above\" session=\"purity_example\"\n        from toqito.state_props import purity\n        import numpy as np\n        print(purity(np.identity(4) / 4))\n        ```\n\n\n        Calculate the purity of the Werner state:\n\n        ```python exec=\"1\" source=\"above\" session=\"purity_example\"\n        from toqito.states import werner\n        rho = werner(2, 1 / 4)\n        print(purity(rho))\n        ```\n\n    Raises:\n        ValueError: If matrix is not density operator.\n\n    Args:\n        rho: A density matrix of a pure state vector.\n\n    Returns:\n        A value between 0 and 1 that corresponds to the purity of \\(\\rho\\).\n\n    \"\"\"\n    if not is_density(rho):\n        raise ValueError(\"Purity is only defined for density operators.\")\n    # \"np.real\" get rid of the close-to-0 imaginary part.\n    return np.real(np.trace(np.linalg.matrix_power(rho, 2)))\n</code></pre>"},{"location":"reference/toqito/state_props/renyi_entropy/","title":"renyi_entropy","text":""},{"location":"reference/toqito/state_props/renyi_entropy/#toqito.state_props.renyi_entropy","title":"renyi_entropy","text":"<p>Calculates the R\u00e9nyi entropy metric of a quantum state.</p>"},{"location":"reference/toqito/state_props/renyi_entropy/#toqito.state_props.renyi_entropy.renyi_entropy","title":"renyi_entropy","text":"<pre><code>renyi_entropy(rho: ndarray, alpha: float) -&gt; float\n</code></pre> <p>Compute the R\u00e9nyi entropy of a density matrix <sup>1</sup>.</p> <p>Let \\(P \\in \\text{Pos}(\\mathcal{X})\\) be a positive semidefinite operator, for a complex Euclidean space \\(\\mathcal{X}\\). Then one defines the R\u00e9nyi entropy of order \\(\\alpha\\geqslant0\\) as</p> \\[     H_{\\alpha}(P) = H_{\\alpha}(\\lambda(P)), \\] <p>where \\(\\lambda(P)\\) is the vector of eigenvalues of \\(P\\) and where the function \\(H(\\cdot)\\) is the classical R\u00e9nyi entropy of order \\(\\alpha\\) defined as</p> \\[     H_{\\alpha}(u) = \\frac{1}{1-\\alpha}\\log\\left(\\sum_{a \\in \\Sigma} u(a)^{\\alpha}\\right), \\] <p>where the \\(\\log\\) function is assumed to be the base-2 logarithm, and where \\(\\Sigma\\) is an alphabet where \\(u \\in [0, \\infty)^{\\Sigma}\\) is a vector of nonnegative real numbers indexed by \\(\\Sigma\\). It recovers the von Neumann entropy for \\(\\alpha=1\\) and the min-entropy for \\(\\alpha=+\\infty\\).</p> <p>Examples:</p> <p>Consider the following Bell state:</p> \\[     u = \\frac{1}{\\sqrt{2}} \\left(|00 \\rangle + |11 \\rangle \\right) \\in \\mathcal{X}. \\] <p>The corresponding density matrix of \\(u\\) may be calculated by:</p> \\[     \\rho = u u^* = \\frac{1}{2} \\begin{pmatrix}                      1 &amp; 0 &amp; 0 &amp; 1 \\\\                      0 &amp; 0 &amp; 0 &amp; 0 \\\\                      0 &amp; 0 &amp; 0 &amp; 0 \\\\                      1 &amp; 0 &amp; 0 &amp; 1                    \\end{pmatrix} \\in \\text{D}(\\mathcal{X}). \\] <p>Calculating the R\u00e9nyi entropy of order \\(2\\) of \\(\\rho\\) in <code>|toqito\u27e9</code> can be done as follows.</p> <pre><code>from toqito.state_props import renyi_entropy\nimport numpy as np\ntest_input_mat = np.array(\n        [[1 / 2, 0, 0, 1 / 2], [0, 0, 0, 0],\n        [0, 0, 0, 0], [1 / 2, 0, 0, 1 / 2]]\n    )\nprint(renyi_entropy(test_input_mat, 2))\n</code></pre> <p>-0.0</p> <p>Consider the density operator corresponding to the maximally mixed state of dimension two</p> \\[     \\rho = \\frac{1}{2}     \\begin{pmatrix}         1 &amp; 0 \\\\         0 &amp; 1     \\end{pmatrix}. \\] <p>As this state is maximally mixed, the R\u00e9nyi entropy of \\(\\rho\\) is equal to one for all orders \\(\\alpha\\). We can see this in <code>|toqito\u27e9</code> as follows.</p> <pre><code>from toqito.state_props import renyi_entropy\nimport numpy as np\nrho = 1/2 * np.identity(2)\nprint(renyi_entropy(rho, 3/2))\n</code></pre> <p>0.9999999999999998</p> <p>Parameters:</p> <ul> <li> <code>rho</code>               (<code>ndarray</code>)           \u2013            <p>Density operator.</p> </li> <li> <code>alpha</code>               (<code>float</code>)           \u2013            <p>Order for the R\u00e9nyi entropy. Note that numerical instability may happen for small positive values because</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The R\u00e9nyi entropy of order <code>alpha</code> of <code>rho</code>.</p> </li> </ul> <p>References</p> <p><sup>1</sup> M\u00fcller-Lennert, Martin and Dupuis, Fr\u00e9d\u00e9ric and Szehr, Oleg and Fehr, Serge and Tomamichel, Marco. On quantum R\u00e9nyi entropies: A new generalization and some properties. Journal of Mathematical Physics. vol. 54(12). (2013). doi:10.1063/1.4838856.</p> Source code in <code>toqito/state_props/renyi_entropy.py</code> <pre><code>def renyi_entropy(rho: np.ndarray, alpha: float) -&gt; float:\n    r\"\"\"Compute the R\u00e9nyi entropy of a density matrix [@Muller_2013_Renyi_Generalization].\n\n    Let \\(P \\in \\text{Pos}(\\mathcal{X})\\) be a positive semidefinite operator, for a complex\n    Euclidean space \\(\\mathcal{X}\\). Then one defines the *R\u00e9nyi entropy of order*\n    \\(\\alpha\\geqslant0\\) as\n\n    \\[\n        H_{\\alpha}(P) = H_{\\alpha}(\\lambda(P)),\n    \\]\n\n    where \\(\\lambda(P)\\) is the vector of eigenvalues of \\(P\\) and where the function\n    \\(H(\\cdot)\\) is the classical R\u00e9nyi entropy of order \\(\\alpha\\) defined as\n\n    \\[\n        H_{\\alpha}(u) = \\frac{1}{1-\\alpha}\\log\\left(\\sum_{a \\in \\Sigma} u(a)^{\\alpha}\\right),\n    \\]\n\n    where the \\(\\log\\) function is assumed to be the base-2 logarithm, and where\n    \\(\\Sigma\\) is an alphabet where \\(u \\in [0, \\infty)^{\\Sigma}\\) is a vector of\n    nonnegative real numbers indexed by \\(\\Sigma\\). It recovers the von Neumann entropy for\n    \\(\\alpha=1\\) and the min-entropy for \\(\\alpha=+\\infty\\).\n\n    Examples:\n        Consider the following Bell state:\n\n        \\[\n            u = \\frac{1}{\\sqrt{2}} \\left(|00 \\rangle + |11 \\rangle \\right) \\in \\mathcal{X}.\n        \\]\n\n        The corresponding density matrix of \\(u\\) may be calculated by:\n\n        \\[\n            \\rho = u u^* = \\frac{1}{2} \\begin{pmatrix}\n                             1 &amp; 0 &amp; 0 &amp; 1 \\\\\n                             0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                             0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                             1 &amp; 0 &amp; 0 &amp; 1\n                           \\end{pmatrix} \\in \\text{D}(\\mathcal{X}).\n        \\]\n\n        Calculating the R\u00e9nyi entropy of order \\(2\\) of \\(\\rho\\) in `|toqito\u27e9` can be\n        done as follows.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.state_props import renyi_entropy\n        import numpy as np\n        test_input_mat = np.array(\n                [[1 / 2, 0, 0, 1 / 2], [0, 0, 0, 0],\n                [0, 0, 0, 0], [1 / 2, 0, 0, 1 / 2]]\n            )\n        print(renyi_entropy(test_input_mat, 2))\n        ```\n\n        Consider the density operator corresponding to the maximally mixed state of dimension two\n\n        \\[\n            \\rho = \\frac{1}{2}\n            \\begin{pmatrix}\n                1 &amp; 0 \\\\\n                0 &amp; 1\n            \\end{pmatrix}.\n        \\]\n\n        As this state is maximally mixed, the R\u00e9nyi entropy of \\(\\rho\\) is\n        equal to one for all orders \\(\\alpha\\). We can see this in `|toqito\u27e9` as follows.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.state_props import renyi_entropy\n        import numpy as np\n        rho = 1/2 * np.identity(2)\n        print(renyi_entropy(rho, 3/2))\n        ```\n\n    Args:\n        rho: Density operator.\n        alpha: Order for the R\u00e9nyi entropy. Note that numerical instability may happen for small positive values because\n        of the computation of the spectral decomposition.\n\n    Returns:\n        The R\u00e9nyi entropy of order `alpha` of `rho`.\n\n    \"\"\"\n    if not is_density(rho):\n        raise ValueError(\"R\u00e9nyi entropy is only defined for density operators.\")\n    if alpha &lt; 0:\n        raise ValueError(\"R\u00e9nyi entropy is only defined for positive orders.\")\n    if alpha == 0:\n        return np.log2(np.linalg.matrix_rank(rho))\n    if alpha == 1:\n        return von_neumann_entropy(rho)\n\n    eigs = np.linalg.eigvalsh(rho)\n    eigs = eigs[eigs &gt; 0]\n\n    if alpha == float(\"inf\"):\n        return -np.log2(eigs.max())\n\n    return np.log2(pow(eigs, alpha).sum()) / (1 - alpha)\n</code></pre>"},{"location":"reference/toqito/state_props/schmidt_rank/","title":"schmidt_rank","text":""},{"location":"reference/toqito/state_props/schmidt_rank/#toqito.state_props.schmidt_rank","title":"schmidt_rank","text":"<p>Calculate the Schmidt rank of a quantum state.</p>"},{"location":"reference/toqito/state_props/schmidt_rank/#toqito.state_props.schmidt_rank.schmidt_rank","title":"schmidt_rank","text":"<pre><code>schmidt_rank(rho: ndarray, dim: int | list[int] | ndarray | None = None) -&gt; int | float\n</code></pre> <p>Compute the Schmidt rank <sup>1</sup>.</p> <p>For complex Euclidean spaces \\(\\mathcal{X}\\) and \\(\\mathcal{Y}\\), a pure state \\(u \\in \\mathcal{X} \\otimes \\mathcal{Y}\\) possesses an expansion of the form:</p> \\[     u = \\sum_{i} \\lambda_i v_i w_i, \\] <p>where \\(v_i \\in \\mathcal{X}\\) and \\(w_i \\in \\mathcal{Y}\\) are orthonormal states.</p> <p>The Schmidt coefficients are calculated from</p> \\[     A = \\text{Tr}_{\\mathcal{B}}(u^* u). \\] <p>The Schmidt rank is the number of non-zero eigenvalues of \\(A\\). The Schmidt rank allows us to determine if a given state is entangled or separable. For instance:</p> <ul> <li>If the Schmidt rank is 1: The state is separable,</li> <li>If the Schmidt rank &gt; 1: The state is entangled.</li> </ul> <p>Compute the Schmidt rank of the input <code>rho</code>, provided as either a vector or a matrix that is assumed to live in bipartite space, where both subsystems have dimension equal to <code>sqrt(len(vec))</code>.</p> <p>The dimension may be specified by the 1-by-2 vector <code>dim</code> and the rank in that case is determined as the number of Schmidt coefficients larger than <code>tol</code>.</p> <p>Examples:</p> <p>Computing the Schmidt rank of the entangled Bell state should yield a value greater than one.</p> <pre><code>from toqito.states import bell\nfrom toqito.state_props import schmidt_rank\nrho = bell(0) @ bell(0).conj().T\nprint(schmidt_rank(rho))\n</code></pre> <p>4</p> <p>Computing the Schmidt rank of the entangled singlet state should yield a value greater than \\(1\\).</p> <pre><code>from toqito.states import bell\nfrom toqito.state_props import schmidt_rank\nu = bell(2) @ bell(2).conj().T\nprint(schmidt_rank(u))\n</code></pre> <p>4</p> <p>Computing the Schmidt rank of a separable state should yield a value equal to \\(1\\).</p> <pre><code>from toqito.states import basis\nfrom toqito.state_props import schmidt_rank\nimport numpy as np\ne_0, e_1 = basis(2, 0), basis(2, 1)\ne_00 = np.kron(e_0, e_0)\ne_01 = np.kron(e_0, e_1)\ne_10 = np.kron(e_1, e_0)\ne_11 = np.kron(e_1, e_1)\nrho = 1 / 2 * (e_00 - e_01 - e_10 + e_11)\nrho = rho @ rho.conj().T\nprint(schmidt_rank(rho))\n</code></pre> <p>1</p> <p>Parameters:</p> <ul> <li> <code>rho</code>               (<code>ndarray</code>)           \u2013            <p>A bipartite vector or matrix to have its Schmidt rank computed.</p> </li> <li> <code>dim</code>               (<code>int | list[int] | ndarray | None</code>, default:                   <code>None</code> )           \u2013            <p>A 1-by-2 vector or matrix.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int | float</code>           \u2013            <p>The Schmidt rank of <code>rho</code>.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Schmidt decomposition. link.</p> Source code in <code>toqito/state_props/schmidt_rank.py</code> <pre><code>def schmidt_rank(rho: np.ndarray, dim: int | list[int] | np.ndarray | None = None) -&gt; int | float:\n    r\"\"\"Compute the Schmidt rank [@WikiScmidtDecomp].\n\n    For complex Euclidean spaces \\(\\mathcal{X}\\) and \\(\\mathcal{Y}\\), a pure state\n    \\(u \\in \\mathcal{X} \\otimes \\mathcal{Y}\\) possesses an expansion of the form:\n\n    \\[\n        u = \\sum_{i} \\lambda_i v_i w_i,\n    \\]\n\n    where \\(v_i \\in \\mathcal{X}\\) and \\(w_i \\in \\mathcal{Y}\\) are orthonormal states.\n\n    The Schmidt coefficients are calculated from\n\n    \\[\n        A = \\text{Tr}_{\\mathcal{B}}(u^* u).\n    \\]\n\n    The Schmidt rank is the number of non-zero eigenvalues of \\(A\\). The Schmidt rank allows us\n    to determine if a given state is entangled or separable. For instance:\n\n    - If the Schmidt rank is 1: The state is separable,\n    - If the Schmidt rank &gt; 1: The state is entangled.\n\n    Compute the Schmidt rank of the input `rho`, provided as either a vector or a matrix that\n    is assumed to live in bipartite space, where both subsystems have dimension equal to\n    `sqrt(len(vec))`.\n\n    The dimension may be specified by the 1-by-2 vector `dim` and the rank in that case is\n    determined as the number of Schmidt coefficients larger than `tol`.\n\n    Examples:\n        Computing the Schmidt rank of the entangled Bell state should yield a value greater than one.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import bell\n        from toqito.state_props import schmidt_rank\n        rho = bell(0) @ bell(0).conj().T\n        print(schmidt_rank(rho))\n        ```\n\n\n        Computing the Schmidt rank of the entangled singlet state should yield a value greater than\n        \\(1\\).\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import bell\n        from toqito.state_props import schmidt_rank\n        u = bell(2) @ bell(2).conj().T\n        print(schmidt_rank(u))\n        ```\n\n\n        Computing the Schmidt rank of a separable state should yield a value equal to \\(1\\).\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import basis\n        from toqito.state_props import schmidt_rank\n        import numpy as np\n        e_0, e_1 = basis(2, 0), basis(2, 1)\n        e_00 = np.kron(e_0, e_0)\n        e_01 = np.kron(e_0, e_1)\n        e_10 = np.kron(e_1, e_0)\n        e_11 = np.kron(e_1, e_1)\n        rho = 1 / 2 * (e_00 - e_01 - e_10 + e_11)\n        rho = rho @ rho.conj().T\n        print(schmidt_rank(rho))\n        ```\n\n    Args:\n        rho: A bipartite vector or matrix to have its Schmidt rank computed.\n        dim: A 1-by-2 vector or matrix.\n\n    Returns:\n        The Schmidt rank of `rho`.\n\n    \"\"\"\n    # If the input is provided as a matrix, compute the operator Schmidt rank.\n    if len(rho.shape) == 2:\n        if rho.shape[0] != 1 and rho.shape[1] != 1:\n            return _operator_schmidt_rank(rho, dim)\n\n    # Otherwise, compute the Schmidt rank for the vector.\n    slv = int(np.round(np.sqrt(len(rho))))\n\n    if dim is None:\n        dim = slv\n    if isinstance(dim, int):\n        dim = np.array([dim, len(rho) / dim], dtype=int)\n        dim[1] = np.round(dim[1])\n\n    return np.linalg.matrix_rank(np.reshape(rho, dim[::-1]))\n</code></pre>"},{"location":"reference/toqito/state_props/sk_vec_norm/","title":"sk_vec_norm","text":""},{"location":"reference/toqito/state_props/sk_vec_norm/#toqito.state_props.sk_vec_norm","title":"sk_vec_norm","text":"<p>Compute the S(k)-norm of a vector.</p>"},{"location":"reference/toqito/state_props/sk_vec_norm/#toqito.state_props.sk_vec_norm.sk_vector_norm","title":"sk_vector_norm","text":"<pre><code>sk_vector_norm(rho: ndarray, k: int = 1, dim: int | list[int] | None = None) -&gt; float | floating\n</code></pre> <p>Compute the S(k)-norm of a vector <sup>1</sup>.</p> <p>The \\(S(k)\\)-norm of of a vector \\(|v \\rangle\\) is defined as:</p> \\[     \\big|\\big| |v\\rangle \\big|\\big|_{s(k)} := \\text{sup}_{|w\\rangle} \\Big\\{         |\\langle w | v \\rangle| : \\text{Schmidt-rank}(|w\\rangle) \\leq k     \\Big\\} \\] <p>It's also equal to the Euclidean norm of the vector of \\(|v\\rangle\\)'s k largest Schmidt coefficients.</p> <p>This function was adapted from QETLAB.</p> <p>Examples:</p> <p>The smallest possible value of the \\(S(k)\\)-norm of a pure state is \\(\\sqrt{\\frac{k}{n}}\\), and is attained exactly by the \"maximally entangled states\".</p> <pre><code>from toqito.states import max_entangled\nfrom toqito.state_props import sk_vector_norm\nimport numpy as np\n# Maximally entagled state.\nv = max_entangled(4)\nprint(sk_vector_norm(v))\n</code></pre> <p>0.5</p> <p>Parameters:</p> <ul> <li> <code>rho</code>               (<code>ndarray</code>)           \u2013            <p>A vector.</p> </li> <li> <code>k</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>An int.</p> </li> <li> <code>dim</code>               (<code>int | list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The dimension of the two sub-systems. By default it's assumed to be equal.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float | floating</code>           \u2013            <p>The S(k)-norm of <code>rho</code>.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Johnston, Nathaniel and Kribs, David. A family of norms with applications in quantum information theory. Journal of Mathematical Physics. vol. 51(8). (2010). doi:10.1063/1.3459068.</p> Source code in <code>toqito/state_props/sk_vec_norm.py</code> <pre><code>def sk_vector_norm(rho: np.ndarray, k: int = 1, dim: int | list[int] | None = None) -&gt; float | np.floating:\n    r\"\"\"Compute the S(k)-norm of a vector [@Johnston_2010_AFamily].\n\n    The \\(S(k)\\)-norm of of a vector \\(|v \\rangle\\) is\n    defined as:\n\n    \\[\n        \\big|\\big| |v\\rangle \\big|\\big|_{s(k)} := \\text{sup}_{|w\\rangle} \\Big\\{\n            |\\langle w | v \\rangle| : \\text{Schmidt-rank}(|w\\rangle) \\leq k\n        \\Big\\}\n    \\]\n\n    It's also equal to the Euclidean norm of the vector of \\(|v\\rangle\\)'s\n    k largest Schmidt coefficients.\n\n    This function was adapted from QETLAB.\n\n    Examples:\n        The smallest possible value of the \\(S(k)\\)-norm of a pure state is\n        \\(\\sqrt{\\frac{k}{n}}\\), and is attained exactly by the \"maximally entangled\n        states\".\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import max_entangled\n        from toqito.state_props import sk_vector_norm\n        import numpy as np\n        # Maximally entagled state.\n        v = max_entangled(4)\n        print(sk_vector_norm(v))\n        ```\n\n    Args:\n        rho: A vector.\n        k: An int.\n        dim: The dimension of the two sub-systems. By default it's assumed to be equal.\n\n    Returns:\n        The S(k)-norm of `rho`.\n\n    \"\"\"\n    dim_xy = rho.shape[0]\n\n    # Set default dimension if none was provided.\n    if dim is None:\n        dim_val = int(np.round(np.sqrt(dim_xy)))\n    elif isinstance(dim, int):\n        dim_val = dim\n    else:\n        dim_val = None\n\n    # Allow the user to enter in a single integer for dimension.\n    if dim_val is not None:\n        dim_arr = np.array([dim_val, dim_xy / dim_val])\n        dim_arr[1] = int(np.round(dim_arr[1]))\n    else:\n        dim_arr = np.array(dim)\n\n    # It's faster to just compute the norm of `rho` directly if that will give\n    # the correct answer.\n    if k &gt;= min(dim_arr):\n        nrm = np.linalg.norm(rho, 2)\n    else:\n        coef, _, _ = schmidt_decomposition(rho, dim_arr, k)\n        nrm = np.linalg.norm(coef)\n\n    return nrm\n</code></pre>"},{"location":"reference/toqito/state_props/von_neumann_entropy/","title":"von_neumann_entropy","text":""},{"location":"reference/toqito/state_props/von_neumann_entropy/#toqito.state_props.von_neumann_entropy","title":"von_neumann_entropy","text":"<p>Calculates the Von neumann entropy metric of a quantum state.</p>"},{"location":"reference/toqito/state_props/von_neumann_entropy/#toqito.state_props.von_neumann_entropy.von_neumann_entropy","title":"von_neumann_entropy","text":"<pre><code>von_neumann_entropy(rho: ndarray) -&gt; float\n</code></pre> <p>Compute the von Neumann entropy of a density matrix <sup>1</sup>.</p> <p>Let \\(P \\in \\text{Pos}(\\mathcal{X})\\) be a positive semidefinite operator, for a complex Euclidean space \\(\\mathcal{X}\\). Then one defines the von Neumann entropy as</p> \\[     H(P) = H(\\lambda(P)), \\] <p>where \\(\\lambda(P)\\) is the vector of eigenvalues of \\(P\\) and where the function \\(H(\\cdot)\\) is the Shannon entropy function defined as</p> \\[     H(u) = -\\sum_{\\substack{a \\in \\Sigma \\\\ u(a) &gt; 0}} u(a) \\text{log}(u(a)), \\] <p>where the \\(\\text{log}\\) function is assumed to be the base-2 logarithm, and where \\(\\Sigma\\) is an alphabet where \\(u \\in [0, \\infty)^{\\Sigma}\\) is a vector of nonnegative real numbers indexed by \\(\\Sigma\\).</p> <p>Further information for computing the von Neumann entropy of a density matrix can be found in Section: \"Definitions Of Quantum Entropic Functions\" from <sup>2</sup>).</p> <p>Examples:</p> <p>Consider the following Bell state:</p> \\[     u = \\frac{1}{\\sqrt{2}} \\left(|00 \\rangle + |11 \\rangle \\right) \\in \\mathcal{X}. \\] <p>The corresponding density matrix of \\(u\\) may be calculated by:</p> \\[     \\rho = u u^* = \\frac{1}{2} \\begin{pmatrix}                      1 &amp; 0 &amp; 0 &amp; 1 \\\\                      0 &amp; 0 &amp; 0 &amp; 0 \\\\                      0 &amp; 0 &amp; 0 &amp; 0 \\\\                      1 &amp; 0 &amp; 0 &amp; 1                    \\end{pmatrix} \\in \\text{D}(\\mathcal{X}). \\] <p>Calculating the von Neumann entropy of \\(\\rho\\) in <code>|toqito\u27e9</code> can be done as follows.</p> <pre><code>from toqito.state_props import von_neumann_entropy\nimport numpy as np\ntest_input_mat = np.array(\n        [[1 / 2, 0, 0, 1 / 2], [0, 0, 0, 0],\n        [0, 0, 0, 0], [1 / 2, 0, 0, 1 / 2]]\n    )\nprint(von_neumann_entropy(test_input_mat))\n</code></pre> <p>5.88418203051333e-15</p> <p>Consider the density operator corresponding to the maximally mixed state of dimension two</p> \\[     \\rho = \\frac{1}{2}     \\begin{pmatrix}         1 &amp; 0 \\\\         0 &amp; 1     \\end{pmatrix}. \\] <p>As this state is maximally mixed, the von Neumann entropy of \\(\\rho\\) is equal to one. We can see this in <code>|toqito\u27e9</code> as follows.</p> <pre><code>from toqito.state_props import von_neumann_entropy\nimport numpy as np\nrho = 1/2 * np.identity(2)\nprint(von_neumann_entropy(rho))\n</code></pre> <p>1.0</p> <p>Parameters:</p> <ul> <li> <code>rho</code>               (<code>ndarray</code>)           \u2013            <p>Density operator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The von Neumann entropy of <code>rho</code>.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Von Neumann entropy. link. <sup>2</sup> Watrous, John. The Theory of Quantum Information. (2018). doi:10.1017/9781316848142.</p> Source code in <code>toqito/state_props/von_neumann_entropy.py</code> <pre><code>def von_neumann_entropy(rho: np.ndarray) -&gt; float:\n    r\"\"\"Compute the von Neumann entropy of a density matrix [@WikiUVonNeumann].\n\n    Let \\(P \\in \\text{Pos}(\\mathcal{X})\\) be a positive semidefinite operator, for a complex\n    Euclidean space \\(\\mathcal{X}\\). Then one defines the *von Neumann entropy* as\n\n    \\[\n        H(P) = H(\\lambda(P)),\n    \\]\n\n    where \\(\\lambda(P)\\) is the vector of eigenvalues of \\(P\\) and where the function\n    \\(H(\\cdot)\\) is the Shannon entropy function defined as\n\n    \\[\n        H(u) = -\\sum_{\\substack{a \\in \\Sigma \\\\ u(a) &gt; 0}} u(a) \\text{log}(u(a)),\n    \\]\n\n    where the \\(\\text{log}\\) function is assumed to be the base-2 logarithm, and where\n    \\(\\Sigma\\) is an alphabet where \\(u \\in [0, \\infty)^{\\Sigma}\\) is a vector of\n    nonnegative real numbers indexed by \\(\\Sigma\\).\n\n    Further information for computing the von Neumann entropy of a density matrix can be found in Section: \"Definitions\n    Of Quantum Entropic Functions\" from [@Watrous_2018_TQI]).\n\n    Examples:\n        Consider the following Bell state:\n\n        \\[\n            u = \\frac{1}{\\sqrt{2}} \\left(|00 \\rangle + |11 \\rangle \\right) \\in \\mathcal{X}.\n        \\]\n\n        The corresponding density matrix of \\(u\\) may be calculated by:\n\n        \\[\n            \\rho = u u^* = \\frac{1}{2} \\begin{pmatrix}\n                             1 &amp; 0 &amp; 0 &amp; 1 \\\\\n                             0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                             0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                             1 &amp; 0 &amp; 0 &amp; 1\n                           \\end{pmatrix} \\in \\text{D}(\\mathcal{X}).\n        \\]\n\n        Calculating the von Neumann entropy of \\(\\rho\\) in `|toqito\u27e9` can be done as follows.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.state_props import von_neumann_entropy\n        import numpy as np\n        test_input_mat = np.array(\n                [[1 / 2, 0, 0, 1 / 2], [0, 0, 0, 0],\n                [0, 0, 0, 0], [1 / 2, 0, 0, 1 / 2]]\n            )\n        print(von_neumann_entropy(test_input_mat))\n        ```\n\n        Consider the density operator corresponding to the maximally mixed state of dimension two\n\n        \\[\n            \\rho = \\frac{1}{2}\n            \\begin{pmatrix}\n                1 &amp; 0 \\\\\n                0 &amp; 1\n            \\end{pmatrix}.\n        \\]\n\n        As this state is maximally mixed, the von Neumann entropy of \\(\\rho\\) is\n        equal to one. We can see this in `|toqito\u27e9` as follows.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.state_props import von_neumann_entropy\n        import numpy as np\n        rho = 1/2 * np.identity(2)\n        print(von_neumann_entropy(rho))\n        ```\n\n    Args:\n        rho: Density operator.\n\n    Returns:\n        The von Neumann entropy of `rho`.\n\n    \"\"\"\n    if not is_density(rho):\n        raise ValueError(\"Von Neumann entropy is only defined for density operators.\")\n    eigs, _ = np.linalg.eig(rho)\n    eigs = [eig for eig in eigs if eig &gt; 0]\n    return -np.sum(np.real(eigs * np.log2(eigs)))\n</code></pre>"},{"location":"reference/toqito/states/","title":"states","text":""},{"location":"reference/toqito/states/#toqito.states","title":"states","text":"<p>Quantum States is the set of modules that numerically implements the well known quantum states listed below.</p> <p>They are one of the three fundamental objects that <code>toqito</code> provides, the others being <code>channels</code> and <code>measurements</code>.</p>"},{"location":"reference/toqito/states/basis/","title":"basis","text":""},{"location":"reference/toqito/states/basis/#toqito.states.basis","title":"basis","text":"<p>A basis state represents the standard basis vectors of some n-dimensional Hilbert Space.</p> <p>Here, n can be given as a parameter as shown below.</p>"},{"location":"reference/toqito/states/basis/#toqito.states.basis.basis","title":"basis","text":"<pre><code>basis(dim: int, pos: int) -&gt; ndarray\n</code></pre> <p>Obtain the ket of dimension <code>dim</code> <sup>1</sup>.</p> <p>Examples:</p> <p>The standard basis ket vectors given as \\(|0 \\rangle\\) and \\(|1 \\rangle\\) where</p> \\[     |0 \\rangle = \\left[1, 0 \\right]^{\\text{T}} \\quad \\text{and} \\quad     |1 \\rangle = \\left[0, 1 \\right]^{\\text{T}}, \\] <p>can be obtained in <code>|toqito\u27e9</code> as follows.</p> <p>Example:  Ket basis vector: \\(|0\\rangle\\).</p> <pre><code>from toqito.states import basis\nprint(basis(2, 0))\n</code></pre> <p>[[1]  [0]]</p> <p>Example: Ket basis vector: \\(|1\\rangle\\).</p> <pre><code>from toqito.states import basis\nprint(basis(2, 1))\n</code></pre> <p>[[0]  [1]]</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the input position is not in the range [0, dim - 1].</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>dim</code>               (<code>int</code>)           \u2013            <p>The dimension of the column vector.</p> </li> <li> <code>pos</code>               (<code>int</code>)           \u2013            <p>0-indexed position of the basis vector where the 1 will be placed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>The column vector of dimension <code>dim</code> with all entries set to <code>0</code> except the entry at <code>pos</code> which is set to <code>1</code>.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Bra-ket notation. link.</p> Source code in <code>toqito/states/basis.py</code> <pre><code>def basis(dim: int, pos: int) -&gt; np.ndarray:\n    r\"\"\"Obtain the ket of dimension `dim` [@WikiBraKet].\n\n    Examples:\n        The standard basis ket vectors given as \\(|0 \\rangle\\) and \\(|1 \\rangle\\) where\n\n        \\[\n            |0 \\rangle = \\left[1, 0 \\right]^{\\text{T}} \\quad \\text{and} \\quad\n            |1 \\rangle = \\left[0, 1 \\right]^{\\text{T}},\n        \\]\n\n        can be obtained in `|toqito\u27e9` as follows.\n\n        Example:  Ket basis vector: \\(|0\\rangle\\).\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import basis\n        print(basis(2, 0))\n        ```\n\n        Example: Ket basis vector: \\(|1\\rangle\\).\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import basis\n        print(basis(2, 1))\n        ```\n\n    Raises:\n        ValueError: If the input position is not in the range [0, dim - 1].\n\n    Args:\n        dim: The dimension of the column vector.\n        pos: 0-indexed position of the basis vector where the 1 will be placed.\n\n    Returns:\n        The column vector of dimension `dim` with all entries set to `0` except the entry at `pos` which is set to `1`.\n\n    \"\"\"\n    if pos &gt;= dim or pos &lt; 0:\n        raise ValueError(\"Invalid: The `pos` variable needs to be between [0, dim - 1] for ket function.\")\n\n    ret = np.zeros(dim, dtype=np.int64)\n    ret[pos] = 1\n    return ret.reshape(-1, 1)\n</code></pre>"},{"location":"reference/toqito/states/bb84/","title":"bb84","text":""},{"location":"reference/toqito/states/bb84/#toqito.states.bb84","title":"bb84","text":"<p>BB84 states represent the BB84 basis states, which are based on BB84, a quantum key distribution scheme.</p> <p>In the BB884 scheme, each qubit is encoded with one of the 4 polarization states: 0, 1, +45\u00b0 or -45\u00b0.</p>"},{"location":"reference/toqito/states/bb84/#toqito.states.bb84.bb84","title":"bb84","text":"<pre><code>bb84() -&gt; list[list[ndarray]]\n</code></pre> <p>Obtain the BB84 basis states <sup>1</sup>.</p> <p>The BB84 basis states are defined as</p> \\[     |0\\rangle := \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}, \\quad \\\\     |1\\rangle := \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}, \\quad \\\\     |+\\rangle := \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}, \\quad \\\\     |-\\rangle := \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 \\\\ -1 \\end{pmatrix}. \\] <p>Examples:</p> <p>The BB84 basis states can be obtained in <code>|toqito\u27e9</code> as follows in the form of a list of arrays.</p> <pre><code>from toqito.states import bb84\nprint(bb84())\n</code></pre> <p>[[array([[1.],        [0.]]), array([[0.],        [1.]])], [array([[0.70710678],        [0.70710678]]), array([[ 0.70710678],        [-0.70710678]])]]</p> <p>Returns:</p> <ul> <li> <code>list[list[ndarray]]</code>           \u2013            <p>The four BB84 basis states.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. BB84. link.</p> Source code in <code>toqito/states/bb84.py</code> <pre><code>def bb84() -&gt; list[list[np.ndarray]]:\n    r\"\"\"Obtain the BB84 basis states [@WikiBB84].\n\n    The BB84 basis states are defined as\n\n    \\[\n        |0\\rangle := \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}, \\quad \\\\\n        |1\\rangle := \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}, \\quad \\\\\n        |+\\rangle := \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}, \\quad \\\\\n        |-\\rangle := \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 \\\\ -1 \\end{pmatrix}.\n    \\]\n\n    Examples:\n        The BB84 basis states can be obtained in `|toqito\u27e9` as follows in the form of a list of\n        arrays.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import bb84\n        print(bb84())\n        ```\n\n    Returns:\n        The four BB84 basis states.\n\n    \"\"\"\n    # Computational basis states |0&gt;, |1&gt;:\n    e_0, e_1 = standard_basis(2)\n    # Plus/minus basis |+&gt;, |-&gt;\n    e_p, e_m = (e_0 + e_1) / np.sqrt(2), (e_0 - e_1) / np.sqrt(2)\n    return [[e_0, e_1], [e_p, e_m]]\n</code></pre>"},{"location":"reference/toqito/states/bell/","title":"bell","text":""},{"location":"reference/toqito/states/bell/#toqito.states.bell","title":"bell","text":"<p>Bell states represent the simplest examples of quantum entanglement of two qubits.</p> <p>Also known as EPR pairs, Bell states comprise of four quantum states in a superposition of 0 and 1.</p>"},{"location":"reference/toqito/states/bell/#toqito.states.bell.bell","title":"bell","text":"<pre><code>bell(idx: int) -&gt; ndarray\n</code></pre> <p>Produce a Bell state <sup>1</sup>.</p> <p>Returns one of the following four Bell states depending on the value of <code>idx</code>:</p> \\[     \\begin{equation}         \\begin{aligned}             u_0 = \\frac{1}{\\sqrt{2}} \\left( |00 \\rangle + |11 \\rangle \\right), &amp;             \\qquad &amp;             u_1 = \\frac{1}{\\sqrt{2}} \\left( |00 \\rangle - |11 \\rangle \\right), \\\\             u_2 = \\frac{1}{\\sqrt{2}} \\left( |01 \\rangle + |10 \\rangle \\right), &amp;             \\qquad &amp;             u_3 = \\frac{1}{\\sqrt{2}} \\left( |01 \\rangle - |10 \\rangle \\right).         \\end{aligned}     \\end{equation} \\] <p>Examples:</p> <p>When <code>idx = 0</code>, this produces the following Bell state:</p> \\[     u_0 = \\frac{1}{\\sqrt{2}} \\left( |00 \\rangle + |11 \\rangle \\right). \\] <p>Using <code>|toqito\u27e9</code>, we can see that this yields the proper state.</p> <pre><code>from toqito.states import bell\nimport numpy as np\nprint(bell(0))\n</code></pre> <p>[[0.70710678]  [0.        ]  [0.        ]  [0.70710678]]</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>idx</code> is not an integer.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>idx</code>               (<code>int</code>)           \u2013            <p>A parameter in [0, 1, 2, 3]</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Bell state with index <code>idx</code>.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Bell State. link.</p> Source code in <code>toqito/states/bell.py</code> <pre><code>def bell(idx: int) -&gt; np.ndarray:\n    r\"\"\"Produce a Bell state [@WikiBellSt].\n\n    Returns one of the following four Bell states depending on the value of `idx`:\n\n    \\[\n        \\begin{equation}\n            \\begin{aligned}\n                u_0 = \\frac{1}{\\sqrt{2}} \\left( |00 \\rangle + |11 \\rangle \\right), &amp;\n                \\qquad &amp;\n                u_1 = \\frac{1}{\\sqrt{2}} \\left( |00 \\rangle - |11 \\rangle \\right), \\\\\n                u_2 = \\frac{1}{\\sqrt{2}} \\left( |01 \\rangle + |10 \\rangle \\right), &amp;\n                \\qquad &amp;\n                u_3 = \\frac{1}{\\sqrt{2}} \\left( |01 \\rangle - |10 \\rangle \\right).\n            \\end{aligned}\n        \\end{equation}\n    \\]\n\n    Examples:\n        When `idx = 0`, this produces the following Bell state:\n\n        \\[\n            u_0 = \\frac{1}{\\sqrt{2}} \\left( |00 \\rangle + |11 \\rangle \\right).\n        \\]\n\n        Using `|toqito\u27e9`, we can see that this yields the proper state.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import bell\n        import numpy as np\n        print(bell(0))\n        ```\n\n    Raises:\n        ValueError: If `idx` is not an integer.\n\n    Args:\n        idx: A parameter in [0, 1, 2, 3]\n\n    Returns:\n        Bell state with index `idx`.\n\n    \"\"\"\n    match idx:\n        case 0:\n            return 1 / np.sqrt(2) * np.array([[1], [0], [0], [1]])\n        case 1:\n            return 1 / np.sqrt(2) * np.array([[1], [0], [0], [-1]])\n        case 2:\n            return 1 / np.sqrt(2) * np.array([[0], [1], [1], [0]])\n        case 3:\n            return 1 / np.sqrt(2) * np.array([[0], [1], [-1], [0]])\n    raise ValueError(\"Invalid integer value for Bell state.\")\n</code></pre>"},{"location":"reference/toqito/states/brauer/","title":"brauer","text":""},{"location":"reference/toqito/states/brauer/#toqito.states.brauer","title":"brauer","text":"<p>Brauer states are the p_val-fold tensor product of the standard maximally-entangled pure states.</p>"},{"location":"reference/toqito/states/brauer/#toqito.states.brauer.brauer","title":"brauer","text":"<pre><code>brauer(dim: int, p_val: int) -&gt; ndarray\n</code></pre> <p>Produce all Brauer states <sup>1</sup>.</p> <p>Produce a matrix whose columns are all of the (unnormalized) \"Brauer\" states: states that are the <code>p_val</code>-fold tensor product of the standard maximally-entangled pure state on <code>dim</code> local dimensions. There are many such states, since there are many different ways to group the <code>2 * p_val</code> parties into <code>p_val</code> pairs (with each pair corresponding to one maximally-entangled state).</p> <p>The exact number of such states is:</p> <pre><code>import math\nimport numpy as np\np_val = 2\nprint(math.factorial(2 * p_val) / (math.factorial(p_val) * 2**p_val))\n</code></pre> <p>3.0</p> <p>which is the number of columns of the returned matrix.</p> <p>This function has been adapted from QETLAB.</p> <p>Examples:</p> <p>Generate a matrix whose columns are all Brauer states on 4 qubits.</p> <pre><code>from toqito.states import brauer\nprint(brauer(2, 2))\n</code></pre> <p>[[1. 1. 1.]  [0. 0. 0.]  [0. 0. 0.]  [1. 0. 0.]  [0. 0. 0.]  [0. 1. 0.]  [0. 0. 1.]  [0. 0. 0.]  [0. 0. 0.]  [0. 0. 1.]  [0. 1. 0.]  [0. 0. 0.]  [1. 0. 0.]  [0. 0. 0.]  [0. 0. 0.]  [1. 1. 1.]]</p> <p>Parameters:</p> <ul> <li> <code>dim</code>               (<code>int</code>)           \u2013            <p>Dimension of each local subsystem</p> </li> <li> <code>p_val</code>               (<code>int</code>)           \u2013            <p>Half of the number of parties (i.e., the state that this function computes will live in</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Matrix whose columns are all of the unnormalized Brauer states.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Brauer Algebra. link.</p> Source code in <code>toqito/states/brauer.py</code> <pre><code>def brauer(dim: int, p_val: int) -&gt; np.ndarray:\n    r\"\"\"Produce all Brauer states [@WikiBrauer].\n\n    Produce a matrix whose columns are all of the (unnormalized) \"Brauer\" states: states that are the `p_val`-fold\n    tensor product of the standard maximally-entangled pure state on `dim` local dimensions. There are many such\n    states, since there are many different ways to group the `2 * p_val` parties into `p_val` pairs (with\n    each pair corresponding to one maximally-entangled state).\n\n    The exact number of such states is:\n\n    ```python exec=\"1\" source=\"above\"\n    import math\n    import numpy as np\n    p_val = 2\n    print(math.factorial(2 * p_val) / (math.factorial(p_val) * 2**p_val))\n    ```\n\n    which is the number of columns of the returned matrix.\n\n    This function has been adapted from QETLAB.\n\n    Examples:\n        Generate a matrix whose columns are all Brauer states on 4 qubits.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import brauer\n        print(brauer(2, 2))\n        ```\n\n    Args:\n        dim: Dimension of each local subsystem\n        p_val: Half of the number of parties (i.e., the state that this function computes will live in\n        \\((\\mathbb{C}^D)^{\\otimes 2 P})\\)\n\n    Returns:\n        Matrix whose columns are all of the unnormalized Brauer states.\n\n    \"\"\"\n    # The Brauer states are computed from perfect matchings of the complete graph. So compute all\n    # perfect matchings first.\n    phi = tensor(max_entangled(dim, False, False), p_val)\n    matchings = perfect_matchings(2 * p_val)\n    num_matchings = matchings.shape[0]\n    state = np.zeros((dim ** (2 * p_val), num_matchings))\n\n    # Turn these perfect matchings into the corresponding states.\n    for i in range(num_matchings):\n        state[:, i] = permute_systems(phi, matchings[i, :], dim * np.ones((1, 2 * p_val), dtype=int)[0])\n    return state\n</code></pre>"},{"location":"reference/toqito/states/breuer/","title":"breuer","text":""},{"location":"reference/toqito/states/breuer/#toqito.states.breuer","title":"breuer","text":"<p>Breuer states represent the Breuer bound entangled states.</p> <p>These states are based on the Breuer-Hall criterion.</p>"},{"location":"reference/toqito/states/breuer/#toqito.states.breuer.breuer","title":"breuer","text":"<pre><code>breuer(dim: int, lam: float) -&gt; ndarray\n</code></pre> <p>Produce a Breuer state <sup>1</sup>.</p> <p>Gives a Breuer bound entangled state for two qudits of local dimension <code>dim</code>, with the <code>lam</code> parameter describing the weight of the singlet component as described in <sup>1</sup>.</p> <p>This function was adapted from the QETLAB package.</p> <p>Examples:</p> <p>We can generate a Breuer state of dimension \\(4\\) with weight \\(0.1\\). For any weight above \\(0\\), the state will be bound entangled, that is, it will satisfy the PPT criterion, but it will be entangled.</p> <pre><code>from toqito.states import breuer\nprint(breuer(2, 0.1))\n</code></pre> <p>[[0.3 0.  0.  0. ]  [0.  0.2 0.1 0. ]  [0.  0.1 0.2 0. ]  [0.  0.  0.  0.3]]</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>Dimension must be greater than or equal to 1.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>dim</code>               (<code>int</code>)           \u2013            <p>Dimension of the Breuer state.</p> </li> <li> <code>lam</code>               (<code>float</code>)           \u2013            <p>The weight of the singlet component.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Breuer state of dimension <code>dim</code> with weight <code>lam</code>.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Breuer, Heinz-Peter. Optimal Entanglement Criterion for Mixed Quantum States. Physical Review Letters. vol. 97(8). (2006). doi:10.1103/physrevlett.97.080501.</p> Source code in <code>toqito/states/breuer.py</code> <pre><code>def breuer(dim: int, lam: float) -&gt; np.ndarray:\n    r\"\"\"Produce a Breuer state [@Breuer_2006_Optimal].\n\n    Gives a Breuer bound entangled state for two qudits of local dimension `dim`, with the\n    `lam` parameter describing the weight of the singlet component as described in\n    [@Breuer_2006_Optimal].\n\n    This function was adapted from the QETLAB package.\n\n    Examples:\n        We can generate a Breuer state of dimension \\(4\\) with weight \\(0.1\\). For any weight above \\(0\\), the\n        state will be bound entangled, that is, it will satisfy the PPT criterion, but it will be entangled.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import breuer\n        print(breuer(2, 0.1))\n        ```\n\n    Raises:\n        ValueError: Dimension must be greater than or equal to 1.\n\n    Args:\n        dim: Dimension of the Breuer state.\n        lam: The weight of the singlet component.\n\n    Returns:\n        Breuer state of dimension `dim` with weight `lam`.\n\n    \"\"\"\n    if dim % 2 == 1 or dim &lt;= 0:\n        raise ValueError(f\"The value {dim} must be an even positive integer.\")\n\n    v_mat = np.fliplr(np.diag((-1) ** np.mod(np.arange(1, dim + 1), 2)))\n    max_entangled(dim)\n    psi = np.dot(np.kron(np.identity(dim), v_mat), max_entangled(dim))\n\n    return lam * (psi * psi.conj().T) + (1 - lam) * 2 * symmetric_projection(dim) / (dim * (dim + 1))\n</code></pre>"},{"location":"reference/toqito/states/chessboard/","title":"chessboard","text":""},{"location":"reference/toqito/states/chessboard/#toqito.states.chessboard","title":"chessboard","text":"<p>Chessboard state represent the state of a chessboard used in quantum chess.</p> <p>In a quantum chessboard, each chess piece is quantum having a superposition of channel states, giving rise to a unique chess piece.</p>"},{"location":"reference/toqito/states/chessboard/#toqito.states.chessboard.chessboard","title":"chessboard","text":"<pre><code>chessboard(mat_params: list[float], s_param: float | None = None, t_param: float | None = None) -&gt; ndarray\n</code></pre> <p>Produce a chessboard state <sup>1</sup>.</p> <p>Generates the chessboard state defined in <sup>1</sup>. Note that, for certain choices of <code>s_param</code> and <code>t_param</code>, this state will not have positive partial transpose, and thus may not be bound entangled.</p> <p>Examples:</p> <p>The standard chessboard state can be invoked using <code>|toqito\u27e9</code> as</p> <pre><code>from toqito.states import chessboard\nprint(chessboard([1, 2, 3, 4, 5, 6], 7, 8))\n</code></pre> <p>[[ 0.22592593  0.          0.12962963  0.          0.          0.          0.17777778  0.          0.        ]  [ 0.          0.01851852  0.          0.          0.          0.01111111  0.          0.02962963  0.        ]  [ 0.12962963  0.          0.18148148  0.          0.15555556  0.          0.          0.          0.        ]  [ 0.          0.          0.          0.01851852  0.          0.02222222  0.         -0.01481481  0.        ]  [ 0.          0.          0.15555556  0.          0.22592593  0.         -0.14814815  0.          0.        ]  [ 0.          0.01111111  0.          0.02222222  0.          0.03333333  0.          0.          0.        ]  [ 0.17777778  0.          0.          0.         -0.14814815  0.          0.23703704  0.          0.        ]  [ 0.          0.02962963  0.         -0.01481481  0.          0.          0.          0.05925926  0.        ]  [ 0.          0.          0.          0.          0.          0.          0.          0.          0.        ]]</p> <p>Parameters:</p> <ul> <li> <code>mat_params</code>               (<code>list[float]</code>)           \u2013            <p>Parameters of the chessboard state as defined in <sup>1</sup>.</p> </li> <li> <code>s_param</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Default is <code>np.conj(mat_params[2]) / np.conj(mat_params[5])</code>.</p> </li> <li> <code>t_param</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Default is <code>t_param = mat_params[0] * mat_params[3] / mat_params[4]</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>A chessboard state.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Bru\\ss{}, Dagmar and Peres, Asher. Construction of quantum states with bound entanglement. Phys. Rev. A. vol. 61. (2000). doi:10.1103/PhysRevA.61.030301.</p> Source code in <code>toqito/states/chessboard.py</code> <pre><code>def chessboard(mat_params: list[float], s_param: float | None = None, t_param: float | None = None) -&gt; np.ndarray:\n    r\"\"\"Produce a chessboard state [@Bru\u00df_2000_Construction].\n\n    Generates the chessboard state defined in [@Bru\u00df_2000_Construction]. Note that, for certain choices of\n    `s_param` and `t_param`, this state will not have positive partial transpose, and\n    thus may not be bound entangled.\n\n    Examples:\n        The standard chessboard state can be invoked using `|toqito\u27e9` as\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import chessboard\n        print(chessboard([1, 2, 3, 4, 5, 6], 7, 8))\n        ```\n\n    Args:\n        mat_params: Parameters of the chessboard state as defined in [@Bru\u00df_2000_Construction].\n        s_param: Default is `np.conj(mat_params[2]) / np.conj(mat_params[5])`.\n        t_param: Default is `t_param = mat_params[0] * mat_params[3] / mat_params[4]`.\n\n    Returns:\n        A chessboard state.\n\n    \"\"\"\n    if s_param is None:\n        s_param = np.conj(mat_params[2]) / np.conj(mat_params[5])\n    if t_param is None:\n        t_param = mat_params[0] * mat_params[3] / mat_params[4]\n\n    v_1 = np.array([[mat_params[4], 0, s_param, 0, mat_params[5], 0, 0, 0, 0]])\n    v_2 = np.array([[0, mat_params[0], 0, mat_params[1], 0, mat_params[2], 0, 0, 0]])\n    v_3 = np.array([[np.conj(mat_params[5]), 0, 0, 0, -np.conj(mat_params[4]), 0, t_param, 0, 0]])\n    v_4 = np.array([[0, np.conj(mat_params[1]), 0, -np.conj(mat_params[0]), 0, 0, 0, mat_params[3], 0]])\n    rho = v_1.conj().T @ v_1 + v_2.conj().T @ v_2 + v_3.conj().T @ v_3 + v_4.conj().T @ v_4\n    return rho / np.trace(rho)\n</code></pre>"},{"location":"reference/toqito/states/dicke/","title":"dicke","text":""},{"location":"reference/toqito/states/dicke/#toqito.states.dicke","title":"dicke","text":"<p>Dicke states are an equal-weight superposition of all n-qubit states with Hamming Weight k.</p>"},{"location":"reference/toqito/states/dicke/#toqito.states.dicke.dicke","title":"dicke","text":"<pre><code>dicke(num_qubit: int, num_exfootcited: int, return_dm: bool = False) -&gt; ndarray\n</code></pre> <p>Produce a Dicke state with specified excitations.</p> <p>The Dicke state is a quantum state with a fixed number of excitations (i.e., <code>num_exfootcited</code>) distributed across the given number of qubits (i.e., <code>num_qubit</code>). It is symmetric and represents an equal superposition of all possible states with the specified number of exfootcited qubits.</p> <p>Example Consider generating a Dicke state with 3 qubits and 1 excitation:</p> <pre><code>from toqito.states import dicke\nprint(dicke(3, 1))\n</code></pre> <p>[0.         0.57735027 0.57735027 0.         0.57735027 0.         0.         0.        ]</p> <p>If we request the density matrix for this state, the return value is:</p> <pre><code>from toqito.states import dicke\nprint(dicke(3, 1, return_dm=True))\n</code></pre> <p>[[0.         0.         0.         0.         0.         0.         0.         0.        ]  [0.         0.33333333 0.33333333 0.         0.33333333 0.         0.         0.        ]  [0.         0.33333333 0.33333333 0.         0.33333333 0.         0.         0.        ]  [0.         0.         0.         0.         0.         0.         0.         0.        ]  [0.         0.33333333 0.33333333 0.         0.33333333 0.         0.         0.        ]  [0.         0.         0.         0.         0.         0.         0.         0.        ]  [0.         0.         0.         0.         0.         0.         0.         0.        ]  [0.         0.         0.         0.         0.         0.         0.         0.        ]]</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the number of excitations exceeds the number of qubits.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>num_qubit</code>               (<code>int</code>)           \u2013            <p>The total number of qubits in the system.</p> </li> <li> <code>num_exfootcited</code>               (<code>int</code>)           \u2013            <p>The number of qubits that are in the exfootcited state.</p> </li> <li> <code>return_dm</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, returns the state as a density matrix (default is False).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>The Dicke state vector or density matrix as a NumPy array.</p> </li> </ul> Source code in <code>toqito/states/dicke.py</code> <pre><code>def dicke(num_qubit: int, num_exfootcited: int, return_dm: bool = False) -&gt; np.ndarray:\n    r\"\"\"Produce a Dicke state with specified excitations.\n\n    The Dicke state is a quantum state with a fixed number of excitations (i.e., `num_exfootcited`)\n    distributed across the given number of qubits (i.e., `num_qubit`). It is symmetric and represents\n    an equal superposition of all possible states with the specified number of exfootcited qubits.\n\n    Example\n    Consider generating a Dicke state with 3 qubits and 1 excitation:\n\n    ```python exec=\"1\" source=\"above\"\n    from toqito.states import dicke\n    print(dicke(3, 1))\n    ```\n\n    If we request the density matrix for this state, the return value is:\n\n    ```python exec=\"1\" source=\"above\"\n    from toqito.states import dicke\n    print(dicke(3, 1, return_dm=True))\n    ```\n\n\n    Raises:\n        ValueError: If the number of excitations exceeds the number of qubits.\n\n    Args:\n        num_qubit: The total number of qubits in the system.\n        num_exfootcited: The number of qubits that are in the exfootcited state.\n        return_dm: If True, returns the state as a density matrix (default is False).\n\n    Returns:\n        The Dicke state vector or density matrix as a NumPy array.\n\n    \"\"\"\n    if num_exfootcited &gt; num_qubit:\n        raise ValueError(\"Number of excitations cannot exceed the number of qubits.\")\n\n    num_term = int(scipy.special.comb(num_qubit, num_exfootcited))\n    d_base_exfootcited_pos = list(itertools.combinations(range(num_qubit), num_exfootcited))\n\n    index_exfootcited_pos = [sum(2**i for i in pos) for pos in d_base_exfootcited_pos]\n    dicke_state = np.zeros(2**num_qubit, dtype=np.float64)\n\n    for pos in index_exfootcited_pos:\n        dicke_state[pos] = 1\n    dicke_state /= np.sqrt(num_term)\n\n    if return_dm:\n        return dicke_state[:, np.newaxis] @ dicke_state[np.newaxis, :]\n    return dicke_state\n</code></pre>"},{"location":"reference/toqito/states/domino/","title":"domino","text":""},{"location":"reference/toqito/states/domino/#toqito.states.domino","title":"domino","text":"<p>Produce a domino state.</p>"},{"location":"reference/toqito/states/domino/#toqito.states.domino.domino","title":"domino","text":"<pre><code>domino(idx: int) -&gt; ndarray\n</code></pre> <p>Produce a domino state <sup>1</sup><sup>2</sup>.</p> <p>The orthonormal product basis of domino states is given as</p> \\[     \\begin{equation}         \\begin{aligned}         |\\phi_0\\rangle = |1\\rangle |1 \\rangle,         \\qquad         |\\phi_1\\rangle = |0 \\rangle \\left(\\frac{|0 \\rangle + |1 \\rangle}{\\sqrt{2}} \\right),         &amp; \\qquad         |\\phi_2\\rangle = |0\\rangle \\left(\\frac{|0\\rangle - |1\\rangle}{\\sqrt{2}}\\right), \\\\         |\\phi_3\\rangle = |2\\rangle \\left(\\frac{|0\\rangle + |1\\rangle}{\\sqrt{2}}\\right), \\qquad         |\\phi_4\\rangle = |2\\rangle \\left(\\frac{|0\\rangle - |1\\rangle}{\\sqrt{2}}\\right), &amp; \\qquad         |\\phi_5\\rangle = \\left(\\frac{|0\\rangle + |1\\rangle}{\\sqrt{2}}\\right) |0\\rangle, \\\\         |\\phi_6\\rangle = \\left(\\frac{|0\\rangle - |1\\rangle}{\\sqrt{2}}\\right) |0\\rangle, \\qquad         |\\phi_7\\rangle = \\left(\\frac{|0\\rangle + |1\\rangle}{\\sqrt{2}}\\right) |2\\rangle, &amp; \\qquad         |\\phi_8\\rangle = \\left(\\frac{|0\\rangle - |1\\rangle}{\\sqrt{2}}\\right) |2\\rangle.         \\end{aligned}     \\end{equation} \\] <p>Returns one of the following nine domino states depending on the value of <code>idx</code>.</p> <p>Examples:</p> <p>When <code>idx = 0</code>, this produces the following Domino state</p> \\[     |\\phi_0 \\rangle = |11 \\rangle |11 \\rangle. \\] <p>Using <code>|toqito\u27e9</code>, we can see that this yields the proper state.</p> <pre><code>from toqito.states import domino\nprint(domino(0))\n</code></pre> <p>[[0]  [0]  [0]  [0]  [1]  [0]  [0]  [0]  [0]]</p> <p>When <code>idx = 3</code>, this produces the following Domino state</p> \\[     |\\phi_3\\rangle = |2\\rangle \\left(\\frac{|0\\rangle + |1\\rangle}     {\\sqrt{2}}\\right) \\] <p>Using <code>|toqito\u27e9</code>, we can see that this yields the proper state.</p> <pre><code>from toqito.states import domino\nprint(domino(3))\n</code></pre> <p>[[0.        ]  [0.        ]  [0.        ]  [0.        ]  [0.        ]  [0.        ]  [0.        ]  [0.70710678]  [0.70710678]]</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>Invalid value for <code>idx</code>.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>idx</code>               (<code>int</code>)           \u2013            <p>A parameter in [0, 1, 2, 3, 4, 5, 6, 7, 8]</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Domino state of index <code>idx</code>.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Bennett, Charles and DiVincenzo, David and Fuchs, Christopher and Mor, Tal and Rains, Eric and Shor, Peter and Smolin, John and Wootters, William. Quantum nonlocality without entanglement. Physical Review A. vol. 59(2). (1999). doi:10.1103/physreva.59.1070. <sup>2</sup> Bennett, Charles and DiVincenzo, David and Mor, Tal and Shor, Peter and Smolin, John and Terhal, Barbara. Unextendible Product Bases and Bound Entanglement. Physical Review Letters. vol. 82(26). (1999). doi:10.1103/physrevlett.82.5385.</p> Source code in <code>toqito/states/domino.py</code> <pre><code>def domino(idx: int) -&gt; np.ndarray:\n    r\"\"\"Produce a domino state [@Bennett_1999_QuantumNonlocality][@Bennett_1999_UPB].\n\n    The orthonormal product basis of domino states is given as\n\n    \\[\n        \\begin{equation}\n            \\begin{aligned}\n            |\\phi_0\\rangle = |1\\rangle |1 \\rangle,\n            \\qquad\n            |\\phi_1\\rangle = |0 \\rangle \\left(\\frac{|0 \\rangle + |1 \\rangle}{\\sqrt{2}} \\right),\n            &amp; \\qquad\n            |\\phi_2\\rangle = |0\\rangle \\left(\\frac{|0\\rangle - |1\\rangle}{\\sqrt{2}}\\right), \\\\\n            |\\phi_3\\rangle = |2\\rangle \\left(\\frac{|0\\rangle + |1\\rangle}{\\sqrt{2}}\\right), \\qquad\n            |\\phi_4\\rangle = |2\\rangle \\left(\\frac{|0\\rangle - |1\\rangle}{\\sqrt{2}}\\right), &amp; \\qquad\n            |\\phi_5\\rangle = \\left(\\frac{|0\\rangle + |1\\rangle}{\\sqrt{2}}\\right) |0\\rangle, \\\\\n            |\\phi_6\\rangle = \\left(\\frac{|0\\rangle - |1\\rangle}{\\sqrt{2}}\\right) |0\\rangle, \\qquad\n            |\\phi_7\\rangle = \\left(\\frac{|0\\rangle + |1\\rangle}{\\sqrt{2}}\\right) |2\\rangle, &amp; \\qquad\n            |\\phi_8\\rangle = \\left(\\frac{|0\\rangle - |1\\rangle}{\\sqrt{2}}\\right) |2\\rangle.\n            \\end{aligned}\n        \\end{equation}\n    \\]\n\n    Returns one of the following nine domino states depending on the value of `idx`.\n\n    Examples:\n        When `idx = 0`, this produces the following Domino state\n\n        \\[\n            |\\phi_0 \\rangle = |11 \\rangle |11 \\rangle.\n        \\]\n\n        Using `|toqito\u27e9`, we can see that this yields the proper state.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import domino\n        print(domino(0))\n        ```\n\n\n        When `idx = 3`, this produces the following Domino state\n\n        \\[\n            |\\phi_3\\rangle = |2\\rangle \\left(\\frac{|0\\rangle + |1\\rangle}\n            {\\sqrt{2}}\\right)\n        \\]\n\n        Using `|toqito\u27e9`, we can see that this yields the proper state.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import domino\n        print(domino(3))\n        ```\n\n    Raises:\n        ValueError: Invalid value for `idx`.\n\n    Args:\n        idx: A parameter in [0, 1, 2, 3, 4, 5, 6, 7, 8]\n\n    Returns:\n        Domino state of index `idx`.\n\n    \"\"\"\n    e_0, e_1, e_2 = basis(3, 0), basis(3, 1), basis(3, 2)\n    match idx:\n        case 0:\n            return np.kron(e_1, e_1)\n        case 1:\n            return np.kron(e_0, 1 / np.sqrt(2) * (e_0 + e_1))\n        case 2:\n            return np.kron(e_0, 1 / np.sqrt(2) * (e_0 - e_1))\n        case 3:\n            return np.kron(e_2, 1 / np.sqrt(2) * (e_1 + e_2))\n        case 4:\n            return np.kron(e_2, 1 / np.sqrt(2) * (e_1 - e_2))\n        case 5:\n            return np.kron(1 / np.sqrt(2) * (e_1 + e_2), e_0)\n        case 6:\n            return np.kron(1 / np.sqrt(2) * (e_1 - e_2), e_0)\n        case 7:\n            return np.kron(1 / np.sqrt(2) * (e_0 + e_1), e_2)\n        case 8:\n            return np.kron(1 / np.sqrt(2) * (e_0 - e_1), e_2)\n    raise ValueError(\"Invalid integer value for Domino state.\")\n</code></pre>"},{"location":"reference/toqito/states/gen_bell/","title":"gen_bell","text":""},{"location":"reference/toqito/states/gen_bell/#toqito.states.gen_bell","title":"gen_bell","text":"<p>Generalized Bell state represents a bigger set of Bell states.</p> <p>This set includes the standard bell states and other higher dimensional bell states as well. Generalized Bell states are the basis of multidimensional bipartite states having maximum entanglement.</p>"},{"location":"reference/toqito/states/gen_bell/#toqito.states.gen_bell.gen_bell","title":"gen_bell","text":"<pre><code>gen_bell(k_1: int, k_2: int, dim: int) -&gt; ndarray\n</code></pre> <p>Produce a generalized Bell state <sup>1</sup>.</p> <p>Produces a generalized Bell state. Note that the standard Bell states can be recovered as:</p> <pre><code>bell(0) : gen_bell(0, 0, 2)\n\nbell(1) : gen_bell(0, 1, 2)\n\nbell(2) : gen_bell(1, 0, 2)\n\nbell(3) : gen_bell(1, 1, 2)\n</code></pre> <p>Examples:</p> <p>For \\(d = 2\\) and \\(k_1 = k_2 = 0\\), this generates the following matrix</p> \\[     G = \\frac{1}{2} \\begin{pmatrix}                     1 &amp; 0 &amp; 0 &amp; 1 \\\\                     0 &amp; 0 &amp; 0 &amp; 0 \\\\                     0 &amp; 0 &amp; 0 &amp; 0 \\\\                     1 &amp; 0 &amp; 0 &amp; 1                 \\end{pmatrix} \\] <p>which is equivalent to \\(|\\phi_0 \\rangle \\langle \\phi_0 |\\) where</p> \\[     |\\phi_0\\rangle = \\frac{1}{\\sqrt{2}} \\left( |00 \\rangle + |11 \\rangle \\right) \\] <p>is one of the four standard Bell states. This can be computed via <code>|toqito\u27e9</code> as follows.</p> <pre><code>from toqito.states import gen_bell\ndim = 2\nk_1 = 0\nk_2 = 0\nprint(gen_bell(k_1, k_2, dim))\n</code></pre> <p>[[0.5+0.j 0. +0.j 0. +0.j 0.5+0.j]  [0. +0.j 0. +0.j 0. +0.j 0. +0.j]  [0. +0.j 0. +0.j 0. +0.j 0. +0.j]  [0.5+0.j 0. +0.j 0. +0.j 0.5+0.j]]</p> <p>It is possible for us to consider higher dimensional Bell states. For instance, we can consider the \\(3\\)-dimensional Bell state for \\(k_1 = k_2 = 0\\) as follows.</p> <pre><code>from toqito.states import gen_bell\ndim = 3\nk_1 = 0\nk_2 = 0\nprint(gen_bell(k_1, k_2, dim))\n</code></pre> <p>[[0.33333333+0.j 0.        +0.j 0.        +0.j 0.        +0.j 0.33333333+0.j 0.        +0.j 0.        +0.j 0.        +0.j 0.33333333+0.j]  [0.        +0.j 0.        +0.j 0.        +0.j 0.        +0.j 0.        +0.j 0.        +0.j 0.        +0.j 0.        +0.j 0.        +0.j]  [0.        +0.j 0.        +0.j 0.        +0.j 0.        +0.j 0.        +0.j 0.        +0.j 0.        +0.j 0.        +0.j 0.        +0.j]  [0.        +0.j 0.        +0.j 0.        +0.j 0.        +0.j 0.        +0.j 0.        +0.j 0.        +0.j 0.        +0.j 0.        +0.j]  [0.33333333+0.j 0.        +0.j 0.        +0.j 0.        +0.j 0.33333333+0.j 0.        +0.j 0.        +0.j 0.        +0.j 0.33333333+0.j]  [0.        +0.j 0.        +0.j 0.        +0.j 0.        +0.j 0.        +0.j 0.        +0.j 0.        +0.j 0.        +0.j 0.        +0.j]  [0.        +0.j 0.        +0.j 0.        +0.j 0.        +0.j 0.        +0.j 0.        +0.j 0.        +0.j 0.        +0.j 0.        +0.j]  [0.        +0.j 0.        +0.j 0.        +0.j 0.        +0.j 0.        +0.j 0.        +0.j 0.        +0.j 0.        +0.j 0.        +0.j]  [0.33333333+0.j 0.        +0.j 0.        +0.j 0.        +0.j 0.33333333+0.j 0.        +0.j 0.        +0.j 0.        +0.j 0.33333333+0.j]]</p> <p>Parameters:</p> <ul> <li> <code>k_1</code>               (<code>int</code>)           \u2013            <p>An integer 0 &lt;= k_1 &lt;= n.</p> </li> <li> <code>k_2</code>               (<code>int</code>)           \u2013            <p>An integer 0 &lt;= k_2 &lt;= n.</p> </li> <li> <code>dim</code>               (<code>int</code>)           \u2013            <p>The dimension of the generalized Bell state.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Sych, Denis and Leuchs, Gerd. A complete basis of generalized Bell states. New Journal of Physics. vol. 11(1). (2009). doi:10.1088/1367-2630/11/1/013006.</p> Source code in <code>toqito/states/gen_bell.py</code> <pre><code>def gen_bell(k_1: int, k_2: int, dim: int) -&gt; np.ndarray:\n    r\"\"\"Produce a generalized Bell state [@Sych_2009_AComplete].\n\n    Produces a generalized Bell state. Note that the standard Bell states can be recovered as:\n\n        bell(0) : gen_bell(0, 0, 2)\n\n        bell(1) : gen_bell(0, 1, 2)\n\n        bell(2) : gen_bell(1, 0, 2)\n\n        bell(3) : gen_bell(1, 1, 2)\n\n\n    Examples:\n        For \\(d = 2\\) and \\(k_1 = k_2 = 0\\), this generates the following matrix\n\n        \\[\n            G = \\frac{1}{2} \\begin{pmatrix}\n                            1 &amp; 0 &amp; 0 &amp; 1 \\\\\n                            0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                            0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                            1 &amp; 0 &amp; 0 &amp; 1\n                        \\end{pmatrix}\n        \\]\n\n        which is equivalent to \\(|\\phi_0 \\rangle \\langle \\phi_0 |\\) where\n\n        \\[\n            |\\phi_0\\rangle = \\frac{1}{\\sqrt{2}} \\left( |00 \\rangle + |11 \\rangle \\right)\n        \\]\n\n        is one of the four standard Bell states. This can be computed via `|toqito\u27e9` as follows.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import gen_bell\n        dim = 2\n        k_1 = 0\n        k_2 = 0\n        print(gen_bell(k_1, k_2, dim))\n        ```\n\n        It is possible for us to consider higher dimensional Bell states. For instance, we can consider\n        the \\(3\\)-dimensional Bell state for \\(k_1 = k_2 = 0\\) as follows.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import gen_bell\n        dim = 3\n        k_1 = 0\n        k_2 = 0\n        print(gen_bell(k_1, k_2, dim))\n        ```\n\n    Args:\n        k_1: An integer 0 &lt;= k_1 &lt;= n.\n        k_2: An integer 0 &lt;= k_2 &lt;= n.\n        dim: The dimension of the generalized Bell state.\n\n    \"\"\"\n    gen_pauli_w = gen_pauli(k_1, k_2, dim)\n    return 1 / dim * vec(gen_pauli_w) @ vec(gen_pauli_w).conj().T\n</code></pre>"},{"location":"reference/toqito/states/ghz/","title":"ghz","text":""},{"location":"reference/toqito/states/ghz/#toqito.states.ghz","title":"ghz","text":"<p>GHZ (Greenberger-Horne-Zeilinger) is used to represent a maximally entangled state.</p> <p>In the GHZ state, the state of qubits are completely dependent on the state of other qubits. This state is an important part of quantum computing as it is commonly used in algorithms, protocols, error corrections, cryptography, etc.</p>"},{"location":"reference/toqito/states/ghz/#toqito.states.ghz.ghz","title":"ghz","text":"<pre><code>ghz(dim: int, num_qubits: int, coeff: list[int] | None = None) -&gt; ndarray\n</code></pre> <p>Generate a (generalized) GHZ state <sup>1</sup>.</p> <p>Returns a <code>num_qubits</code>-partite GHZ state acting on <code>dim</code> local dimensions, described in <sup>1</sup>. For example, <code>ghz(2, 3)</code> returns the standard 3-qubit GHZ state on qubits. The output of this function is a dense NumPy array.</p> <p>For a system of <code>num_qubits</code> qubits (i.e., <code>dim = 2</code>), the GHZ state can be written as</p> \\[     |GHZ \\rangle = \\frac{1}{\\sqrt{n}} \\left(|0\\rangle^{\\otimes n} +     |1 \\rangle^{\\otimes n} \\right)). \\] <p>Examples:</p> <p>When <code>dim = 2</code>, and <code>num_qubits = 3</code> this produces the standard GHZ state</p> \\[     \\frac{1}{\\sqrt{2}} \\left( |000 \\rangle + |111 \\rangle \\right). \\] <p>Using <code>|toqito\u27e9</code>, we can see that this yields the proper state.</p> <pre><code>from toqito.states import ghz\nprint(ghz(2, 3))\n</code></pre> <p>[[0.70710678]  [0.        ]  [0.        ]  [0.        ]  [0.        ]  [0.        ]  [0.        ]  [0.70710678]]</p> <p>As this function covers the generalized GHZ state, we can consider higher dimensions. For instance here is the GHZ state in \\(\\mathbb{C}^{4^{\\otimes 7}}\\) as</p> \\[     \\frac{1}{\\sqrt{30}} \\left(|0000000 \\rangle + 2|1111111 \\rangle +     3|2222222 \\rangle + 4|3333333\\rangle \\right). \\] <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>Number of qubits is not a positive integer.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>dim</code>               (<code>int</code>)           \u2013            <p>The local dimension.</p> </li> <li> <code>num_qubits</code>               (<code>int</code>)           \u2013            <p>The number of parties (qubits/qudits)</p> </li> <li> <code>coeff</code>               (<code>list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>(default <code>[1, 1, ..., 1])/sqrt(dim)</code>: a 1-by-<code>dim</code> vector of coefficients.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Numpy vector array as GHZ state.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Greenberger, Daniel and Horne, Michael and Zeilinger, Anton. Going Beyond Bell's Theorem. (2007).</p> Source code in <code>toqito/states/ghz.py</code> <pre><code>def ghz(dim: int, num_qubits: int, coeff: list[int] | None = None) -&gt; np.ndarray:\n    r\"\"\"Generate a (generalized) GHZ state [@Greenberger_2007_Going].\n\n    Returns a `num_qubits`-partite GHZ state acting on `dim` local dimensions, described\n    in [@Greenberger_2007_Going]. For example, `ghz(2, 3)` returns the standard 3-qubit GHZ state on\n    qubits. The output of this function is a dense NumPy array.\n\n    For a system of `num_qubits` qubits (i.e., `dim = 2`), the GHZ state can be written\n    as\n\n    \\[\n        |GHZ \\rangle = \\frac{1}{\\sqrt{n}} \\left(|0\\rangle^{\\otimes n} +\n        |1 \\rangle^{\\otimes n} \\right)).\n    \\]\n\n    Examples:\n        When `dim = 2`, and `num_qubits = 3` this produces the standard GHZ state\n\n        \\[\n            \\frac{1}{\\sqrt{2}} \\left( |000 \\rangle + |111 \\rangle \\right).\n        \\]\n\n        Using `|toqito\u27e9`, we can see that this yields the proper state.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import ghz\n        print(ghz(2, 3))\n        ```\n\n        As this function covers the generalized GHZ state, we can consider higher dimensions. For instance here\n        is the GHZ\n        state in \\(\\mathbb{C}^{4^{\\otimes 7}}\\) as\n\n        \\[\n            \\frac{1}{\\sqrt{30}} \\left(|0000000 \\rangle + 2|1111111 \\rangle +\n            3|2222222 \\rangle + 4|3333333\\rangle \\right).\n        \\]\n\n    Raises:\n        ValueError: Number of qubits is not a positive integer.\n\n    Args:\n        dim: The local dimension.\n        num_qubits: The number of parties (qubits/qudits)\n        coeff: (default `[1, 1, ..., 1])/sqrt(dim)`: a 1-by-`dim` vector of coefficients.\n\n    Returns:\n        Numpy vector array as GHZ state.\n\n    \"\"\"\n    if dim &lt; 1:\n        raise ValueError(\"InvalidDim: `dim` must be at least 1.\")\n    if num_qubits &lt; 1:\n        raise ValueError(\"InvalidNumQubits: `num_qubits` must be at least 1.\")\n\n    if coeff is None:\n        coeff = np.ones(dim)\n    else:\n        coeff = np.array(coeff)\n    if len(coeff) != dim:\n        raise ValueError(\"InvalidCoeff: The variable `coeff` must be a vector of length equal to `dim`.\")\n\n    # Normalize coefficients if they are not.\n    norm = np.linalg.norm(coeff)\n    if not np.isclose(norm, 1.0):\n        coeff = coeff / norm\n\n    # Initialize the GHZ state vector.\n    ghz_state = np.zeros((dim**num_qubits, 1))\n    # Fill the state vector with the corresponding coefficients.\n    for i in range(dim):\n        # Calculate the index for the tensor product state |i, i, ..., i&gt;.\n        index = sum(i * (dim**k) for k in range(num_qubits))\n        ghz_state[index] = coeff[i]\n\n    return ghz_state\n</code></pre>"},{"location":"reference/toqito/states/gisin/","title":"gisin","text":""},{"location":"reference/toqito/states/gisin/#toqito.states.gisin","title":"gisin","text":"<p>Gisin states are the mixtures of separable mixed states and some purely entangled states.</p>"},{"location":"reference/toqito/states/gisin/#toqito.states.gisin.gisin","title":"gisin","text":"<pre><code>gisin(lambda_var: float, theta: float) -&gt; ndarray\n</code></pre> <p>Produce a Gisin state <sup>1</sup>.</p> <p>Returns the Gisin state described in <sup>1</sup>. Specifically, the Gisin state can be defined as:</p> \\[     \\begin{equation}         \\rho_{\\lambda, \\theta} = \\lambda                                 \\begin{pmatrix}                                     0 &amp; 0 &amp; 0 &amp; 0 \\\\                                     0 &amp; \\sin^2(\\theta) &amp;                                     -\\sin(\\theta)\\cos(\\theta) &amp; 0 \\\\                                     0 &amp; -\\sin(\\theta)\\cos(\\theta) &amp;                                     \\cos^2(\\theta) &amp; 0 \\\\                                     0 &amp; 0 &amp; 0 &amp; 0                                 \\end{pmatrix} +                                 \\frac{1 - \\lambda}{2}                                 \\begin{pmatrix}                                     1 &amp; 0 &amp; 0 &amp; 0 \\\\                                     0 &amp; 0 &amp; 0 &amp; 0 \\\\                                     0 &amp; 0 &amp; 0 &amp; 0 \\\\                                     0 &amp; 0 &amp; 0 &amp; 1                                 \\end{pmatrix}.     \\end{equation} \\] <p>Examples:</p> <p>The following code generates the Gisin state \\(\\rho_{0.5, 1}\\).</p> <pre><code>from toqito.states import gisin\nprint(gisin(0.5, 1))\n</code></pre> <p>[[ 0.25        0.          0.          0.        ]  [ 0.          0.35403671 -0.22732436  0.        ]  [ 0.         -0.22732436  0.14596329  0.        ]  [ 0.          0.          0.          0.25      ]]</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>lambda_var</code> is not a real number.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>lambda_var</code>               (<code>float</code>)           \u2013            <p>A real parameter in [0, 1].</p> </li> <li> <code>theta</code>               (<code>float</code>)           \u2013            <p>A real parameter.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Gisin state.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Gisin, N.. Hidden quantum nonlocality revealed by local filters. Physics Letters A. vol. 210(3). (1996). doi:https://doi.org/10.1016/S0375-9601(96)80001-6.</p> Source code in <code>toqito/states/gisin.py</code> <pre><code>def gisin(lambda_var: float, theta: float) -&gt; np.ndarray:\n    r\"\"\"Produce a Gisin state [@Gisin_1996_Hidden].\n\n    Returns the Gisin state described in [@Gisin_1996_Hidden]. Specifically, the Gisin state can be defined as:\n\n    \\[\n        \\begin{equation}\n            \\rho_{\\lambda, \\theta} = \\lambda\n                                    \\begin{pmatrix}\n                                        0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                                        0 &amp; \\sin^2(\\theta) &amp;\n                                        -\\sin(\\theta)\\cos(\\theta) &amp; 0 \\\\\n                                        0 &amp; -\\sin(\\theta)\\cos(\\theta) &amp;\n                                        \\cos^2(\\theta) &amp; 0 \\\\\n                                        0 &amp; 0 &amp; 0 &amp; 0\n                                    \\end{pmatrix} +\n                                    \\frac{1 - \\lambda}{2}\n                                    \\begin{pmatrix}\n                                        1 &amp; 0 &amp; 0 &amp; 0 \\\\\n                                        0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                                        0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                                        0 &amp; 0 &amp; 0 &amp; 1\n                                    \\end{pmatrix}.\n        \\end{equation}\n    \\]\n\n    Examples:\n        The following code generates the Gisin state \\(\\rho_{0.5, 1}\\).\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import gisin\n        print(gisin(0.5, 1))\n        ```\n\n    Raises:\n        ValueError: If `lambda_var` is not a real number.\n\n    Args:\n        lambda_var: A real parameter in [0, 1].\n        theta: A real parameter.\n\n    Returns:\n        Gisin state.\n\n    \"\"\"\n    if lambda_var &lt; 0 or lambda_var &gt; 1:\n        raise ValueError(\"InvalidLambda: Variable lambda must be between 0 and 1.\")\n\n    rho_theta = np.array(\n        [\n            [0, 0, 0, 0],\n            [0, np.sin(theta) ** 2, -np.sin(2 * theta) / 2, 0],\n            [0, -np.sin(2 * theta) / 2, np.cos(theta) ** 2, 0],\n            [0, 0, 0, 0],\n        ]\n    )\n\n    rho_uu_dd = np.array([[1, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 1]])\n\n    return lambda_var * rho_theta + (1 - lambda_var) * rho_uu_dd / 2\n</code></pre>"},{"location":"reference/toqito/states/horodecki/","title":"horodecki","text":""},{"location":"reference/toqito/states/horodecki/#toqito.states.horodecki","title":"horodecki","text":"<p>Horodecki states are bound entangled states.</p> <p>These states are entangled, but no pure entangled states can be extracted from these states through local operations and classical communication (LOCC).</p>"},{"location":"reference/toqito/states/horodecki/#toqito.states.horodecki.horodecki","title":"horodecki","text":"<pre><code>horodecki(a_param: float, dim: list[int] | None = None) -&gt; ndarray\n</code></pre> <p>Produce a Horodecki state <sup>1</sup><sup>2</sup>.</p> <p>Returns the Horodecki state in either \\((3 \\otimes 3)\\)-dimensional space or \\((2 \\otimes 4)\\)-dimensional space, depending on the dimensions in the 1-by-2 vector <code>dim</code>.</p> <p>The Horodecki state was introduced in [1] which serves as an example in \\(\\mathbb{C}^3 \\otimes \\mathbb{C}\\) or \\(\\mathbb{C}^2 \\otimes \\mathbb{C}^4\\) of an entangled state that is positive under partial transpose (PPT). The state is PPT for all \\(a \\in [0, 1]\\) and separable only for <code>a_param = 0</code> or <code>a_param = 1</code>.</p> <p>These states have the following definitions:</p> \\[     \\begin{equation}         \\rho_a^{3 \\otimes 3} = \\frac{1}{8a + 1}         \\begin{pmatrix}             a &amp; 0 &amp; 0 &amp; 0 &amp; a &amp; 0 &amp; 0 &amp; 0 &amp; a \\\\             0 &amp; a &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\             0 &amp; 0 &amp; a &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\             0 &amp; 0 &amp; 0 &amp; a &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\             0 &amp; 0 &amp; 0 &amp; 0 &amp; a &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\             0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; a &amp; 0 &amp; 0 &amp; 0 \\\\             0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \\frac{1}{2}             \\left( 1 + a \\right) &amp; 0 &amp; \\frac{1}{2} \\sqrt{1 - a^2} \\\\             0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; a &amp; 0 \\\\             0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \\frac{1}{2} \\sqrt{1 - a^2} &amp; 0             &amp; \\frac{1}{2} \\left(1 + a \\right) \\\\         \\end{pmatrix},     \\end{equation} \\] \\[     \\begin{equation}         \\rho_a^{2 \\otimes 4} = \\frac{1}{7a + 1}         \\begin{pmatrix}             a &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; a &amp; 0 &amp; 0  \\\\             0 &amp; a &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; a &amp; 0 \\\\             0 &amp; 0 &amp; a &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; a  \\\\             0 &amp; 0 &amp; 0 &amp; a &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\\\             0 &amp; 0 &amp; 0 &amp; 0 &amp; \\frac{1}{2} \\left(1 + a\\right) &amp; 0 &amp; 0             &amp; \\frac{1}{2}\\sqrt{1 -a^2} \\\\             a &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; a &amp; 0 &amp; 0 \\\\             0 &amp; a &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; a &amp; 0 \\\\             0 &amp; 0 &amp; a &amp; 0 &amp; \\frac{1}{2}\\sqrt{1 - a^2} &amp; 0 &amp; 0             &amp; \\frac{1}{2}\\left(1 +a \\right)         \\end{pmatrix}.     \\end{equation} \\] <p>Note</p> <p>Refer to <sup>2</sup> (specifically equations (1) and (2)) for more information on this state and its properties. The 3x3 Horodecki state is defined explicitly in Section 4.1 of <sup>1</sup> and the 2x4 Horodecki state is defined explicitly in Section 4.2 of <sup>1</sup>.</p> <p>Examples:</p> <p>The following code generates a Horodecki state in \\(\\mathbb{C}^3 \\otimes \\mathbb{C}^3\\)</p> <pre><code>from toqito.states import horodecki\nprint(horodecki(0.5, [3, 3]))\n</code></pre> <p>[[0.1        0.         0.         0.         0.1        0.         0.         0.         0.1       ]  [0.         0.1        0.         0.         0.         0.         0.         0.         0.        ]  [0.         0.         0.1        0.         0.         0.         0.         0.         0.        ]  [0.         0.         0.         0.1        0.         0.         0.         0.         0.        ]  [0.1        0.         0.         0.         0.1        0.         0.         0.         0.1       ]  [0.         0.         0.         0.         0.         0.1        0.         0.         0.        ]  [0.         0.         0.         0.         0.         0.         0.15       0.         0.08660254]  [0.         0.         0.         0.         0.         0.         0.         0.1        0.        ]  [0.1        0.         0.         0.         0.1        0.         0.08660254 0.         0.15      ]]</p> <p>The following code generates a Horodecki state in \\(\\mathbb{C}^2 \\otimes \\mathbb{C}^4\\).</p> <pre><code>from toqito.states import horodecki\nprint(horodecki(0.5, [2, 4]))\n</code></pre> <p>[[0.11111111 0.         0.         0.         0.         0.11111111 0.         0.        ]  [0.         0.11111111 0.         0.         0.         0.         0.11111111 0.        ]  [0.         0.         0.11111111 0.         0.         0.         0.         0.11111111]  [0.         0.         0.         0.11111111 0.         0.         0.         0.        ]  [0.         0.         0.         0.         0.16666667 0.         0.         0.09622504]  [0.11111111 0.         0.         0.         0.         0.11111111 0.         0.        ]  [0.         0.11111111 0.         0.         0.         0.         0.11111111 0.        ]  [0.         0.         0.11111111 0.         0.09622504 0.         0.         0.16666667]]</p> <p>References</p> <p><sup>1</sup> Horodecki, Pawel. Separability criterion and inseparable mixed states with positive partial transposition. Physics Letters A. vol. 232(5). (1997). doi:10.1016/s0375-9601(97)00416-7. <sup>2</sup> Chru\u015bci\u0144ski, Dariusz and Kossakowski, Andrzej. On the symmetry of the seminal Horodecki state. Physics Letters A. vol. 375(3). (2011). doi:10.1016/j.physleta.2010.11.069.</p> Source code in <code>toqito/states/horodecki.py</code> <pre><code>def horodecki(a_param: float, dim: list[int] | None = None) -&gt; np.ndarray:\n    r\"\"\"Produce a Horodecki state [@Horodecki_1997_Separability][@Chruscinski_2011_OnTheSymmetry].\n\n    Returns the Horodecki state in either \\((3 \\otimes 3)\\)-dimensional space or \\((2 \\otimes 4)\\)-dimensional\n    space, depending on the dimensions in the 1-by-2 vector `dim`.\n\n    The Horodecki state was introduced in [1] which serves as an example in \\(\\mathbb{C}^3 \\otimes \\mathbb{C}\\) or\n    \\(\\mathbb{C}^2 \\otimes \\mathbb{C}^4\\) of an entangled state that is positive under partial transpose (PPT). The\n    state is PPT for all \\(a \\in [0, 1]\\) and separable only for `a_param = 0` or `a_param = 1`.\n\n    These states have the following definitions:\n\n    \\[\n        \\begin{equation}\n            \\rho_a^{3 \\otimes 3} = \\frac{1}{8a + 1}\n            \\begin{pmatrix}\n                a &amp; 0 &amp; 0 &amp; 0 &amp; a &amp; 0 &amp; 0 &amp; 0 &amp; a \\\\\n                0 &amp; a &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                0 &amp; 0 &amp; a &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                0 &amp; 0 &amp; 0 &amp; a &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                0 &amp; 0 &amp; 0 &amp; 0 &amp; a &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; a &amp; 0 &amp; 0 &amp; 0 \\\\\n                0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \\frac{1}{2}\n                \\left( 1 + a \\right) &amp; 0 &amp; \\frac{1}{2} \\sqrt{1 - a^2} \\\\\n                0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; a &amp; 0 \\\\\n                0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \\frac{1}{2} \\sqrt{1 - a^2} &amp; 0\n                &amp; \\frac{1}{2} \\left(1 + a \\right) \\\\\n            \\end{pmatrix},\n        \\end{equation}\n    \\]\n\n    \\[\n        \\begin{equation}\n            \\rho_a^{2 \\otimes 4} = \\frac{1}{7a + 1}\n            \\begin{pmatrix}\n                a &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; a &amp; 0 &amp; 0  \\\\\n                0 &amp; a &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; a &amp; 0 \\\\\n                0 &amp; 0 &amp; a &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; a  \\\\\n                0 &amp; 0 &amp; 0 &amp; a &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\\\\n                0 &amp; 0 &amp; 0 &amp; 0 &amp; \\frac{1}{2} \\left(1 + a\\right) &amp; 0 &amp; 0\n                &amp; \\frac{1}{2}\\sqrt{1 -a^2} \\\\\n                a &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; a &amp; 0 &amp; 0 \\\\\n                0 &amp; a &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; a &amp; 0 \\\\\n                0 &amp; 0 &amp; a &amp; 0 &amp; \\frac{1}{2}\\sqrt{1 - a^2} &amp; 0 &amp; 0\n                &amp; \\frac{1}{2}\\left(1 +a \\right)\n            \\end{pmatrix}.\n        \\end{equation}\n    \\]\n\n    !!! Note\n        Refer to [@Chruscinski_2011_OnTheSymmetry] (specifically equations (1) and (2)) for more information on\n        this state and its properties. The 3x3 Horodecki state is defined explicitly in Section 4.1 of\n        [@Horodecki_1997_Separability] and the 2x4 Horodecki state is defined explicitly in Section 4.2 of\n        [@Horodecki_1997_Separability].\n\n    Examples:\n        The following code generates a Horodecki state in \\(\\mathbb{C}^3 \\otimes \\mathbb{C}^3\\)\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import horodecki\n        print(horodecki(0.5, [3, 3]))\n        ```\n\n\n        The following code generates a Horodecki state in \\(\\mathbb{C}^2 \\otimes \\mathbb{C}^4\\).\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import horodecki\n        print(horodecki(0.5, [2, 4]))\n        ```\n\n    \"\"\"\n    if a_param &lt; 0 or a_param &gt; 1:\n        raise ValueError(\"Invalid: Argument A_PARAM must be in the interval [0, 1].\")\n\n    if dim is None:\n        dim = np.array([3, 3])\n\n    if np.array_equal(dim, np.array([3, 3])):\n        n_a_param = 1 / (8 * a_param + 1)\n        b_param = (1 + a_param) / 2\n        c_param = np.sqrt(1 - a_param**2) / 2\n\n        horo_state = n_a_param * np.array(\n            [\n                [a_param, 0, 0, 0, a_param, 0, 0, 0, a_param],\n                [0, a_param, 0, 0, 0, 0, 0, 0, 0],\n                [0, 0, a_param, 0, 0, 0, 0, 0, 0],\n                [0, 0, 0, a_param, 0, 0, 0, 0, 0],\n                [a_param, 0, 0, 0, a_param, 0, 0, 0, a_param],\n                [0, 0, 0, 0, 0, a_param, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0, b_param, 0, c_param],\n                [0, 0, 0, 0, 0, 0, 0, a_param, 0],\n                [a_param, 0, 0, 0, a_param, 0, c_param, 0, b_param],\n            ]\n        )\n        return horo_state\n\n    if np.array_equal(dim, np.array([2, 4])):\n        n_a_param = 1 / (7 * a_param + 1)\n        b_param = (1 + a_param) / 2\n        c_param = np.sqrt(1 - a_param**2) / 2\n\n        horo_state = n_a_param * np.array(\n            [\n                [a_param, 0, 0, 0, 0, a_param, 0, 0],\n                [0, a_param, 0, 0, 0, 0, a_param, 0],\n                [0, 0, a_param, 0, 0, 0, 0, a_param],\n                [0, 0, 0, a_param, 0, 0, 0, 0],\n                [0, 0, 0, 0, b_param, 0, 0, c_param],\n                [a_param, 0, 0, 0, 0, a_param, 0, 0],\n                [0, a_param, 0, 0, 0, 0, a_param, 0],\n                [0, 0, a_param, 0, c_param, 0, 0, b_param],\n            ]\n        )\n        return horo_state\n    raise ValueError(\"InvalidDim: DIM must be one of [3, 3], or [2, 4].\")\n</code></pre>"},{"location":"reference/toqito/states/isotropic/","title":"isotropic","text":""},{"location":"reference/toqito/states/isotropic/#toqito.states.isotropic","title":"isotropic","text":"<p>Isotropic state is a bipartite quantum state.</p> <p>These states are separable for \u03b1 \u2264 1/(d+1), but are otherwise entangled.</p>"},{"location":"reference/toqito/states/isotropic/#toqito.states.isotropic.isotropic","title":"isotropic","text":"<pre><code>isotropic(dim: int, alpha: float) -&gt; ndarray\n</code></pre> <p>Produce a isotropic state <sup>1</sup>.</p> <p>Returns the isotropic state with parameter <code>alpha</code> acting on (<code>dim</code>-by-<code>dim</code>)-dimensional space. The isotropic state has the following form</p> \\[     \\begin{equation}         \\rho_{\\alpha} = \\frac{1 - \\alpha}{d^2} \\mathbb{I} \\otimes         \\mathbb{I} + \\alpha |\\psi_+ \\rangle \\langle \\psi_+ | \\in         \\mathbb{C}^d \\otimes \\mathbb{C}^2     \\end{equation} \\] <p>where \\(|\\psi_+ \\rangle = \\frac{1}{\\sqrt{d}} \\sum_j |j \\rangle \\otimes |j \\rangle\\) is the maximally entangled state.</p> <p>Examples:</p> <p>To generate the isotropic state with parameter \\(\\alpha=1/2\\), we can make the following call to <code>|toqito\u27e9</code> as</p> <pre><code>from toqito.states import isotropic\nprint(isotropic(3, 1 / 2))\n</code></pre> <p>[[0.22222222 0.         0.         0.         0.16666667 0.         0.         0.         0.16666667]  [0.         0.05555556 0.         0.         0.         0.         0.         0.         0.        ]  [0.         0.         0.05555556 0.         0.         0.         0.         0.         0.        ]  [0.         0.         0.         0.05555556 0.         0.         0.         0.         0.        ]  [0.16666667 0.         0.         0.         0.22222222 0.         0.         0.         0.16666667]  [0.         0.         0.         0.         0.         0.05555556 0.         0.         0.        ]  [0.         0.         0.         0.         0.         0.         0.05555556 0.         0.        ]  [0.         0.         0.         0.         0.         0.         0.         0.05555556 0.        ]  [0.16666667 0.         0.         0.         0.16666667 0.         0.         0.         0.22222222]]</p> <p>Parameters:</p> <ul> <li> <code>dim</code>               (<code>int</code>)           \u2013            <p>The local dimension.</p> </li> <li> <code>alpha</code>               (<code>float</code>)           \u2013            <p>The parameter of the isotropic state.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Isotropic state of dimension <code>dim</code>.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Horodecki, Michal and Horodecki, Pawel. Reduction criterion of separability and limits for a class of protocols of entanglement distillation. (1998).</p> Source code in <code>toqito/states/isotropic.py</code> <pre><code>def isotropic(dim: int, alpha: float) -&gt; np.ndarray:\n    r\"\"\"Produce a isotropic state [@Horodecki_1998_Reduction].\n\n    Returns the isotropic state with parameter `alpha` acting on (`dim`-by-`dim`)-dimensional space.\n    The isotropic state has the following form\n\n    \\[\n        \\begin{equation}\n            \\rho_{\\alpha} = \\frac{1 - \\alpha}{d^2} \\mathbb{I} \\otimes\n            \\mathbb{I} + \\alpha |\\psi_+ \\rangle \\langle \\psi_+ | \\in\n            \\mathbb{C}^d \\otimes \\mathbb{C}^2\n        \\end{equation}\n    \\]\n\n    where \\(|\\psi_+ \\rangle = \\frac{1}{\\sqrt{d}} \\sum_j |j \\rangle \\otimes |j \\rangle\\) is the maximally entangled\n    state.\n\n    Examples:\n        To generate the isotropic state with parameter \\(\\alpha=1/2\\), we can make the following call to\n        `|toqito\u27e9` as\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import isotropic\n        print(isotropic(3, 1 / 2))\n        ```\n\n    Args:\n        dim: The local dimension.\n        alpha: The parameter of the isotropic state.\n\n    Returns:\n        Isotropic state of dimension `dim`.\n\n    \"\"\"\n    psi = max_entangled(dim, False, False)\n    return (1 - alpha) * np.identity(dim**2) / dim**2 + alpha * psi @ psi.conj().T / dim\n</code></pre>"},{"location":"reference/toqito/states/max_entangled/","title":"max_entangled","text":""},{"location":"reference/toqito/states/max_entangled/#toqito.states.max_entangled","title":"max_entangled","text":"<p>Maximally entangled states are states where the qubits are completely dependent on each other.</p> <p>In these states, when a measurement is taken on one of the qubits, the state of the other qubits is automatically known.</p>"},{"location":"reference/toqito/states/max_entangled/#toqito.states.max_entangled.max_entangled","title":"max_entangled","text":"<pre><code>max_entangled(dim: int, is_sparse: bool = False, is_normalized: bool = True) -&gt; ndarray | coo_array\n</code></pre> <p>Produce a maximally entangled bipartite pure state <sup>1</sup>.</p> <p>Produces a maximally entangled pure state as above that is sparse if <code>is_sparse = True</code> and is full if <code>is_sparse = False</code>. The pure state is normalized to have Euclidean norm 1 if <code>is_normalized = True</code>, and it is unnormalized (i.e. each entry in the vector is 0 or 1 and the Euclidean norm of the vector is <code>sqrt(dim)</code> if <code>is_normalized = False</code>.</p> <p>Examples:</p> <p>We can generate the canonical \\(2\\)-dimensional maximally entangled state</p> \\[     u = \\frac{1}{\\sqrt{2}} \\left( |00 \\rangle + |11 \\rangle \\right) \\] <p>using <code>|toqito\u27e9</code> as follows.</p> <pre><code>from toqito.states import max_entangled\nprint(max_entangled(2))\n</code></pre> <p>[[0.70710678]  [0.        ]  [0.        ]  [0.70710678]]</p> <p>By default, the state returned in normalized, however we can generate the unnormalized state</p> \\[     v = |00\\rangle + |11 \\rangle \\] <p>using <code>|toqito\u27e9</code> as follows.</p> <pre><code>from toqito.states import max_entangled\nprint(max_entangled(2, False, False))\n</code></pre> <p>[[1.]  [0.]  [0.]  [1.]]</p> <p>Parameters:</p> <ul> <li> <code>dim</code>               (<code>int</code>)           \u2013            <p>Dimension of the entangled state.</p> </li> <li> <code>is_sparse</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p><code>True</code> if vector is sparse and <code>False</code> otherwise.</p> </li> <li> <code>is_normalized</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p><code>True</code> if vector is normalized and <code>False</code> otherwise.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray | coo_array</code>           \u2013            <p>The maximally entangled state of dimension <code>dim</code>.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Quantum entanglement. link.</p> Source code in <code>toqito/states/max_entangled.py</code> <pre><code>def max_entangled(dim: int, is_sparse: bool = False, is_normalized: bool = True) -&gt; np.ndarray | coo_array:\n    r\"\"\"Produce a maximally entangled bipartite pure state [@WikiMaxEnt].\n\n    Produces a maximally entangled pure state as above that is sparse if `is_sparse = True` and is full if\n    `is_sparse = False`. The pure state is normalized to have Euclidean norm 1 if `is_normalized = True`,\n    and it is unnormalized (i.e. each entry in the vector is 0 or 1 and the Euclidean norm of the vector is\n    `sqrt(dim)` if `is_normalized = False`.\n\n    Examples:\n        We can generate the canonical \\(2\\)-dimensional maximally entangled state\n\n        \\[\n            u = \\frac{1}{\\sqrt{2}} \\left( |00 \\rangle + |11 \\rangle \\right)\n        \\]\n\n        using `|toqito\u27e9` as follows.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import max_entangled\n        print(max_entangled(2))\n        ```\n\n\n        By default, the state returned in normalized, however we can generate the unnormalized state\n\n        \\[\n            v = |00\\rangle + |11 \\rangle\n        \\]\n\n        using `|toqito\u27e9` as follows.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import max_entangled\n        print(max_entangled(2, False, False))\n        ```\n\n    Args:\n        dim: Dimension of the entangled state.\n        is_sparse: `True` if vector is sparse and `False` otherwise.\n        is_normalized: `True` if vector is normalized and `False` otherwise.\n\n    Returns:\n        The maximally entangled state of dimension `dim`.\n\n    \"\"\"\n    # Allow both standard int and numpy integer types\n    if not isinstance(dim, (int, np.integer)) or dim &lt;= 0:\n        raise ValueError(\"Dimension must be a positive integer.\")\n\n    norm_factor = 1 / np.sqrt(dim) if is_normalized else 1.0\n    idx = np.arange(dim) * (dim + 1)  # positions of nonzero entries in flattened form.\n\n    if is_sparse:\n        # Construct sparse vector directly.\n        data = np.full(dim, norm_factor)\n        psi = coo_array((data, (idx, np.zeros(dim))), shape=(dim**2, 1))\n        return psi\n\n    psi = np.zeros((dim**2, 1), dtype=float)\n    psi[idx, 0] = norm_factor\n    return psi\n</code></pre>"},{"location":"reference/toqito/states/max_mixed/","title":"max_mixed","text":""},{"location":"reference/toqito/states/max_mixed/#toqito.states.max_mixed","title":"max_mixed","text":"<p>Maximally mixed states are states which are formed as a uniform mixture of states in an orthonormal basis.</p> <p>The density matrix of a maximally mixed state is directly proportional to the identity matrix.</p>"},{"location":"reference/toqito/states/max_mixed/#toqito.states.max_mixed.max_mixed","title":"max_mixed","text":"<pre><code>max_mixed(dim: int, is_sparse: bool = False) -&gt; ndarray | dia_array\n</code></pre> <p>Produce the maximally mixed state <sup>1</sup>.</p> <p>Produces the maximally mixed state on of <code>dim</code> dimensions. The maximally mixed state is defined as</p> \\[     \\omega = \\frac{1}{d} \\begin{pmatrix}                     1 &amp; 0 &amp; \\ldots &amp; 0 \\\\                     0 &amp; 1 &amp; \\ldots &amp; 0 \\\\                     \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\                     0 &amp; 0 &amp; \\ldots &amp; 1                 \\end{pmatrix}, \\] <p>or equivalently, it is defined as</p> \\[     \\omega = \\frac{\\mathbb{I}}{\\text{dim}(\\mathcal{X})} \\] <p>for some complex Euclidean space \\(\\mathcal{X}\\). The maximally mixed state is sometimes also referred to as the tracial state.</p> <p>The maximally mixed state is returned as a sparse matrix if <code>is_sparse = True</code> and is full if <code>is_sparse = False</code>.</p> <p>Examples:</p> <p>Using <code>|toqito\u27e9</code>, we can generate the \\(2\\)-dimensional maximally mixed state</p> \\[     \\omega_2 = \\frac{1}{2}     \\begin{pmatrix}         1 &amp; 0 \\\\         0 &amp; 1     \\end{pmatrix} \\] <p>as follows.</p> <pre><code>from toqito.states import max_mixed\nprint(max_mixed(2, is_sparse=False))\n</code></pre> <p>[[0.5 0. ]  [0.  0.5]]</p> <p>One may also generate a maximally mixed state returned as a sparse matrix</p> <pre><code>from toqito.states import max_mixed\nprint(max_mixed(2, is_sparse=True))\n</code></pre> <p>   Coords    Values   (0, 0)    0.5   (1, 1)    0.5 <p>Parameters:</p> <ul> <li> <code>dim</code>               (<code>int</code>)           \u2013            <p>Dimension of the entangled state.</p> </li> <li> <code>is_sparse</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p><code>True</code> if vector is sparse and <code>False</code> otherwise.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray | dia_array</code>           \u2013            <p>The maximally mixed state of dimension <code>dim</code>.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Aaronson, Scott. Lecture 6: Mixed States. link.</p> Source code in <code>toqito/states/max_mixed.py</code> <pre><code>def max_mixed(dim: int, is_sparse: bool = False) -&gt; np.ndarray | dia_array:\n    r\"\"\"Produce the maximally mixed state [@Aaronson_2018_MaxMixed].\n\n    Produces the maximally mixed state on of `dim` dimensions. The maximally mixed state is defined as\n\n    \\[\n        \\omega = \\frac{1}{d} \\begin{pmatrix}\n                        1 &amp; 0 &amp; \\ldots &amp; 0 \\\\\n                        0 &amp; 1 &amp; \\ldots &amp; 0 \\\\\n                        \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\\n                        0 &amp; 0 &amp; \\ldots &amp; 1\n                    \\end{pmatrix},\n    \\]\n\n    or equivalently, it is defined as\n\n    \\[\n        \\omega = \\frac{\\mathbb{I}}{\\text{dim}(\\mathcal{X})}\n    \\]\n\n    for some complex Euclidean space \\(\\mathcal{X}\\). The maximally mixed state is sometimes also referred to as the\n    tracial state.\n\n    The maximally mixed state is returned as a sparse matrix if `is_sparse = True` and is full if `is_sparse\n    = False`.\n\n    Examples:\n        Using `|toqito\u27e9`, we can generate the \\(2\\)-dimensional maximally mixed state\n\n        \\[\n            \\omega_2 = \\frac{1}{2}\n            \\begin{pmatrix}\n                1 &amp; 0 \\\\\n                0 &amp; 1\n            \\end{pmatrix}\n        \\]\n\n        as follows.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import max_mixed\n        print(max_mixed(2, is_sparse=False))\n        ```\n\n\n\n        One may also generate a maximally mixed state returned as a sparse matrix\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import max_mixed\n        print(max_mixed(2, is_sparse=True))\n        ```\n\n    Args:\n        dim: Dimension of the entangled state.\n        is_sparse: `True` if vector is sparse and `False` otherwise.\n\n    Returns:\n        The maximally mixed state of dimension `dim`.\n\n    \"\"\"\n    if is_sparse:\n        return 1 / dim * eye_array(dim)\n    return 1 / dim * np.eye(dim)\n</code></pre>"},{"location":"reference/toqito/states/mutually_unbiased_basis/","title":"mutually_unbiased_basis","text":""},{"location":"reference/toqito/states/mutually_unbiased_basis/#toqito.states.mutually_unbiased_basis","title":"mutually_unbiased_basis","text":"<p>Mutually unbiased basis states.</p> <p>If a system prepared in an eigenstate of one of the bases gives an equal probability of (1/d) when measured with respect to the other bases, mutually unbiased basis states are orthonormal bases in the Hilbert space C\u1d48.</p>"},{"location":"reference/toqito/states/mutually_unbiased_basis/#toqito.states.mutually_unbiased_basis.mutually_unbiased_basis","title":"mutually_unbiased_basis","text":"<pre><code>mutually_unbiased_basis(dim: int) -&gt; list[ndarray]\n</code></pre> <p>Generate list of MUBs for a given dimension <sup>1</sup>.</p> <p>Note that this function only works if the dimension provided is prime or a power of a prime. Otherwise, we don't know how to generate general MUBs.</p> <p>Examples:</p> <p>For the case of dimension 2, the three mutually unbiased bases are provided by:</p> \\[     M_0 = \\left\\{|0\\rangle, |1\\rangle \\right\\}, \\\\     M_1 = \\left\\{\\frac{|0\\rangle + |1\\rangle}{\\sqrt{2}}, \\frac{|0\\rangle - |1\\rangle}{\\sqrt{2}}\\right\\}     M_2 = \\left\\{\\frac{|0\\rangle + i|1\\rangle}{\\sqrt{2}}, \\frac{|0\\rangle - i|1\\rangle}{\\sqrt{2}}\\right\\} \\] <p>The six vectors above are obtained accordingly:</p> <pre><code>from toqito.states import mutually_unbiased_basis\nmubs = mutually_unbiased_basis(2)\nprint(len(mubs))\n</code></pre> <p>6</p> <pre><code>lst =[vec.shape for vec in mubs]\nprint(lst)\n</code></pre> <p>[(2,), (2,), (2,), (2,), (2,), (2,)]</p> <p>Args:     dim: The dimension of the mutually unbiased bases to produce.</p> <p>Returns:</p> <ul> <li> <code>list[ndarray]</code>           \u2013            <p>The set of mutually unbiased bases of dimension <code>dim</code> (if known).</p> </li> </ul> <p>References</p> <p><sup>1</sup> Wikipedia. Mutually unbiased bases. link.</p> Source code in <code>toqito/states/mutually_unbiased_basis.py</code> <pre><code>def mutually_unbiased_basis(dim: int) -&gt; list[np.ndarray]:\n    r\"\"\"Generate list of MUBs for a given dimension [@WikiMUB].\n\n    Note that this function only works if the dimension provided is prime or a power of a prime. Otherwise, we don't\n    know how to generate general MUBs.\n\n    Examples:\n        For the case of dimension 2, the three mutually unbiased bases are provided by:\n\n        \\[\n            M_0 = \\left\\{|0\\rangle, |1\\rangle \\right\\}, \\\\\n            M_1 = \\left\\{\\frac{|0\\rangle + |1\\rangle}{\\sqrt{2}}, \\frac{|0\\rangle - |1\\rangle}{\\sqrt{2}}\\right\\}\n            M_2 = \\left\\{\\frac{|0\\rangle + i|1\\rangle}{\\sqrt{2}}, \\frac{|0\\rangle - i|1\\rangle}{\\sqrt{2}}\\right\\}\n        \\]\n\n        The six vectors above are obtained accordingly:\n\n        ```python exec=\"1\" source=\"above\" session=\"mubs\"\n        from toqito.states import mutually_unbiased_basis\n        mubs = mutually_unbiased_basis(2)\n        print(len(mubs))\n        ```\n\n        ```python exec=\"1\" source=\"above\" session=\"mubs\"\n        lst =[vec.shape for vec in mubs]\n        print(lst)\n        ```\n    Args:\n        dim: The dimension of the mutually unbiased bases to produce.\n\n    Returns:\n        The set of mutually unbiased bases of dimension `dim` (if known).\n\n    \"\"\"\n    # The first basis will always be the standard basis:\n    mats = [np.eye(dim)]\n\n    pauli_x = gen_pauli(1, 0, dim)\n    if isprime(dim):\n        pauli_z = gen_pauli(0, 1, dim)\n\n        for j in range(dim, 0, -1):\n            _, eigen_vec = np.linalg.eig(pauli_x @ pauli_z ** (j))\n            mats.append(eigen_vec)\n    elif _is_prime_power(dim) and not isprime(dim):\n        raise ValueError(f\"Dimension {dim} is a prime power but not prime (more complicated no support at the moment).\")\n    else:\n        raise ValueError(f\"No general construction of MUBs is known for dimension: {dim}.\")\n\n    mubs: list[np.ndarray] = []\n    for mat in mats:\n        nrows, ncols = mat.shape[0], mat.shape[1]\n        for row in range(nrows):\n            mub: list[np.ndarray] = []\n            for col in range(ncols):\n                mub.append(mat[col][row])\n            mubs.append(np.array(mub))\n    return mubs\n</code></pre>"},{"location":"reference/toqito/states/pusey_barrett_rudolph/","title":"pusey_barrett_rudolph","text":""},{"location":"reference/toqito/states/pusey_barrett_rudolph/#toqito.states.pusey_barrett_rudolph","title":"pusey_barrett_rudolph","text":"<p>Construct a set of mutually unbiased bases.</p>"},{"location":"reference/toqito/states/pusey_barrett_rudolph/#toqito.states.pusey_barrett_rudolph.pusey_barrett_rudolph","title":"pusey_barrett_rudolph","text":"<pre><code>pusey_barrett_rudolph(n: int, theta: float) -&gt; list[ndarray]\n</code></pre> <p>Produce set of Pusey-Barrett-Rudolph (PBR) states <sup>1</sup>.</p> <p>Let \\(\\theta \\in [0, \\pi/2]\\) be an angle. Define the states</p> \\[     |\\psi_0\\rangle = \\cos(\\frac{\\theta}{2})|0\\rangle +                      \\sin(\\frac{\\theta}{2})|1\\rangle     \\quad \\text{and} \\quad     |\\psi_1\\rangle = \\cos(\\frac{\\theta}{2})|0\\rangle -                      \\sin(\\frac{\\theta}{2})|1\\rangle. \\] <p>For some \\(n \\geq 1\\), define a basis of \\(2^n\\) states where</p> \\[     |\\Psi_i\\rangle = |\\psi_{x_i}\\rangle \\otimes \\cdots \\otimes |\\psi_{x_n}\\rangle. \\] <p>These PBR states are defined in Equation (A6) from <sup>1</sup>.</p> <p>Examples:</p> <p>Generating the PBR states can be done by simply invoking the function with a given choice of <code>n</code> and <code>theta</code>:</p> <pre><code>from toqito.states import pusey_barrett_rudolph\nprint(pusey_barrett_rudolph(n=1, theta=0.5))\n</code></pre> <p>[array([[0.96891242],        [0.24740396]]), array([[ 0.96891242],        [-0.24740396]])]</p> <p>Parameters:</p> <ul> <li> <code>n</code>               (<code>int</code>)           \u2013            <p>The number of states in the set.</p> </li> <li> <code>theta</code>               (<code>float</code>)           \u2013            <p>Angle parameter that defines the states.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[ndarray]</code>           \u2013            <p>Vector of trine states.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Pusey, Matthew and Barrett, Jonathan and Rudolph, Terry. On the reality of the quantum state. Nature Physics. vol. 8(6). (2012). doi:10.1038/nphys2309.</p> Source code in <code>toqito/states/pusey_barrett_rudolph.py</code> <pre><code>def pusey_barrett_rudolph(n: int, theta: float) -&gt; list[np.ndarray]:\n    r\"\"\"Produce set of Pusey-Barrett-Rudolph (PBR) states [@Pusey_2012_On].\n\n    Let \\(\\theta \\in [0, \\pi/2]\\) be an angle. Define the states\n\n    \\[\n        |\\psi_0\\rangle = \\cos(\\frac{\\theta}{2})|0\\rangle +\n                         \\sin(\\frac{\\theta}{2})|1\\rangle\n        \\quad \\text{and} \\quad\n        |\\psi_1\\rangle = \\cos(\\frac{\\theta}{2})|0\\rangle -\n                         \\sin(\\frac{\\theta}{2})|1\\rangle.\n    \\]\n\n    For some \\(n \\geq 1\\), define a basis of \\(2^n\\) states where\n\n    \\[\n        |\\Psi_i\\rangle = |\\psi_{x_i}\\rangle \\otimes \\cdots \\otimes |\\psi_{x_n}\\rangle.\n    \\]\n\n    These PBR states are defined in Equation (A6) from [@Pusey_2012_On].\n\n    Examples:\n        Generating the PBR states can be done by simply invoking the function with a given choice of `n` and\n        `theta`:\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import pusey_barrett_rudolph\n        print(pusey_barrett_rudolph(n=1, theta=0.5))\n        ```\n\n    Args:\n        n: The number of states in the set.\n        theta: Angle parameter that defines the states.\n\n    Returns:\n        Vector of trine states.\n\n    \"\"\"\n    e_0, e_1 = standard_basis(2)\n\n    psi_0 = np.cos(theta / 2) * e_0 + np.sin(theta / 2) * e_1\n    psi_1 = np.cos(theta / 2) * e_0 - np.sin(theta / 2) * e_1\n    psi = [psi_0, psi_1]\n\n    binary_strings = list(itertools.product([0, 1], repeat=n))\n\n    states = []\n    for b_str in binary_strings:\n        state = []\n        for b in b_str:\n            state.append(psi[b])\n        states.append(tensor(state))\n    return states\n</code></pre>"},{"location":"reference/toqito/states/singlet/","title":"singlet","text":""},{"location":"reference/toqito/states/singlet/#toqito.states.singlet","title":"singlet","text":"<p>Generalized singlet state is a singlet state of <code>n</code> qubits in the invariant space of alternating representation.</p>"},{"location":"reference/toqito/states/singlet/#toqito.states.singlet.singlet","title":"singlet","text":"<pre><code>singlet(dim: int) -&gt; ndarray\n</code></pre> <p>Produce a generalized singlet state acting on two n-dimensional systems <sup>1</sup>.</p> <p>Examples:</p> <p>For \\(n = 2\\) this generates the following matrix</p> \\[     S = \\frac{1}{2} \\begin{pmatrix}                     0 &amp; 0 &amp; 0 &amp; 0 \\\\                     0 &amp; 1 &amp; -1 &amp; 0 \\\\                     0 &amp; -1 &amp; 1 &amp; 0 \\\\                     0 &amp; 0 &amp; 0 &amp; 0                 \\end{pmatrix} \\] <p>which is equivalent to \\(|\\phi_s \\rangle \\langle \\phi_s |\\) where</p> \\[     |\\phi_s\\rangle = \\frac{1}{\\sqrt{2}} \\left( |01 \\rangle - |10 \\rangle \\right) \\] <p>is the singlet state. This can be computed via <code>|toqito\u27e9</code> as follows:</p> <pre><code>from toqito.states import singlet\ndim = 2\nprint(singlet(dim))\n</code></pre> <p>[[ 0.   0.   0.   0. ]  [ 0.   0.5 -0.5  0. ]  [ 0.  -0.5  0.5  0. ]  [ 0.   0.   0.   0. ]]</p> <p>It is possible for us to consider higher dimensional singlet states. For instance, we can consider the \\(3\\)-dimensional Singlet state as follows:</p> <pre><code>from toqito.states import singlet\ndim = 3\nprint(singlet(dim))\n</code></pre> <p>[[ 0.          0.          0.          0.          0.          0.          0.          0.          0.        ]  [ 0.          0.16666667  0.         -0.16666667  0.          0.          0.          0.          0.        ]  [ 0.          0.          0.16666667  0.          0.          0.         -0.16666667  0.          0.        ]  [ 0.         -0.16666667  0.          0.16666667  0.          0.          0.          0.          0.        ]  [ 0.          0.          0.          0.          0.          0.          0.          0.          0.        ]  [ 0.          0.          0.          0.          0.          0.16666667  0.         -0.16666667  0.        ]  [ 0.          0.         -0.16666667  0.          0.          0.          0.16666667  0.          0.        ]  [ 0.          0.          0.          0.          0.         -0.16666667  0.          0.16666667  0.        ]  [ 0.          0.          0.          0.          0.          0.          0.          0.          0.        ]]</p> <p>Parameters:</p> <ul> <li> <code>dim</code>               (<code>int</code>)           \u2013            <p>The dimension of the generalized singlet state.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>The singlet state of dimension <code>dim</code>.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Cabello, Ad\\'an. \\(N\\)-Particle \\(N\\)-Level Singlet States: Some Properties and Applications. Phys. Rev. Lett.. vol. 89. (2002). link.</p> Source code in <code>toqito/states/singlet.py</code> <pre><code>def singlet(dim: int) -&gt; np.ndarray:\n    r\"\"\"Produce a generalized singlet state acting on two n-dimensional systems [@Cabello_2002_NParticle].\n\n    Examples:\n        For \\(n = 2\\) this generates the following matrix\n\n        \\[\n            S = \\frac{1}{2} \\begin{pmatrix}\n                            0 &amp; 0 &amp; 0 &amp; 0 \\\\\n                            0 &amp; 1 &amp; -1 &amp; 0 \\\\\n                            0 &amp; -1 &amp; 1 &amp; 0 \\\\\n                            0 &amp; 0 &amp; 0 &amp; 0\n                        \\end{pmatrix}\n        \\]\n\n        which is equivalent to \\(|\\phi_s \\rangle \\langle \\phi_s |\\) where\n\n        \\[\n            |\\phi_s\\rangle = \\frac{1}{\\sqrt{2}} \\left( |01 \\rangle - |10 \\rangle \\right)\n        \\]\n\n        is the singlet state. This can be computed via `|toqito\u27e9` as follows:\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import singlet\n        dim = 2\n        print(singlet(dim))\n        ```\n\n\n        It is possible for us to consider higher dimensional singlet states. For instance, we can consider the\n        \\(3\\)-dimensional Singlet state as follows:\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import singlet\n        dim = 3\n        print(singlet(dim))\n        ```\n\n    Args:\n        dim: The dimension of the generalized singlet state.\n\n    Returns:\n        The singlet state of dimension `dim`.\n\n    \"\"\"\n    return (np.identity(dim**2) - swap_operator([dim, dim])) / ((dim**2) - dim)\n</code></pre>"},{"location":"reference/toqito/states/tile/","title":"tile","text":""},{"location":"reference/toqito/states/tile/#toqito.states.tile","title":"tile","text":"<p>Tile state.</p>"},{"location":"reference/toqito/states/tile/#toqito.states.tile.tile","title":"tile","text":"<pre><code>tile(idx: int) -&gt; ndarray\n</code></pre> <p>Produce a Tile state <sup>1</sup>.</p> <p>The Tile states constitute five states on 3-by-3 dimensional space that form a UPB (unextendible product basis).</p> <p>Returns one of the following five tile states depending on the value of <code>idx</code>:</p> \\[     \\begin{equation}         \\begin{aligned}             |\\psi_0 \\rangle = \\frac{1}{\\sqrt{2}} |0 \\rangle             \\left(|0\\rangle - |1\\rangle \\right),             \\qquad &amp;             |\\psi_1\\rangle = \\frac{1}{\\sqrt{2}}             \\left(|0\\rangle - |1\\rangle \\right) |2\\rangle, \\\\             |\\psi_2\\rangle = \\frac{1}{\\sqrt{2}} |2\\rangle             \\left(|1\\rangle - |2\\rangle \\right),             \\qquad &amp;             |\\psi_3\\rangle = \\frac{1}{\\sqrt{2}}             \\left(|1\\rangle - |2\\rangle \\right) |0\\rangle, \\\\             \\qquad &amp;             |\\psi_4\\rangle = \\frac{1}{3}             \\left(|0\\rangle + |1\\rangle + |2\\rangle)\\right)             \\left(|0\\rangle + |1\\rangle + |2\\rangle \\right).         \\end{aligned}     \\end{equation} \\] <p>Examples:</p> <p>When <code>idx = 0</code>, this produces the following tile state</p> \\[     \\frac{1}{\\sqrt{2}} |0\\rangle \\left( |0\\rangle - |1\\rangle \\right). \\] <p>Using <code>|toqito\u27e9</code>, we can see that this yields the proper state.</p> <pre><code>from toqito.states import tile\nimport numpy as np\nprint(tile(0))\n</code></pre> <p>[[ 0.70710678]  [-0.70710678]  [ 0.        ]  [ 0.        ]  [ 0.        ]  [ 0.        ]  [ 0.        ]  [ 0.        ]  [ 0.        ]]</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>Invalid value for <code>idx</code>.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>idx</code>               (<code>int</code>)           \u2013            <p>A parameter in [0, 1, 2, 3, 4]</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Tile state.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Bennett, Charles and DiVincenzo, David and Mor, Tal and Shor, Peter and Smolin, John and Terhal, Barbara. Unextendible Product Bases and Bound Entanglement. Physical Review Letters. vol. 82(26). (1999). doi:10.1103/physrevlett.82.5385.</p> Source code in <code>toqito/states/tile.py</code> <pre><code>def tile(idx: int) -&gt; np.ndarray:\n    r\"\"\"Produce a Tile state [@Bennett_1999_UPB].\n\n    The Tile states constitute five states on 3-by-3 dimensional space that form a UPB (unextendible product basis).\n\n    Returns one of the following five tile states depending on the value of `idx`:\n\n    \\[\n        \\begin{equation}\n            \\begin{aligned}\n                |\\psi_0 \\rangle = \\frac{1}{\\sqrt{2}} |0 \\rangle\n                \\left(|0\\rangle - |1\\rangle \\right),\n                \\qquad &amp;\n                |\\psi_1\\rangle = \\frac{1}{\\sqrt{2}}\n                \\left(|0\\rangle - |1\\rangle \\right) |2\\rangle, \\\\\n                |\\psi_2\\rangle = \\frac{1}{\\sqrt{2}} |2\\rangle\n                \\left(|1\\rangle - |2\\rangle \\right),\n                \\qquad &amp;\n                |\\psi_3\\rangle = \\frac{1}{\\sqrt{2}}\n                \\left(|1\\rangle - |2\\rangle \\right) |0\\rangle, \\\\\n                \\qquad &amp;\n                |\\psi_4\\rangle = \\frac{1}{3}\n                \\left(|0\\rangle + |1\\rangle + |2\\rangle)\\right)\n                \\left(|0\\rangle + |1\\rangle + |2\\rangle \\right).\n            \\end{aligned}\n        \\end{equation}\n    \\]\n\n    Examples:\n        When `idx = 0`, this produces the following tile state\n\n        \\[\n            \\frac{1}{\\sqrt{2}} |0\\rangle \\left( |0\\rangle - |1\\rangle \\right).\n        \\]\n\n        Using `|toqito\u27e9`, we can see that this yields the proper state.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import tile\n        import numpy as np\n        print(tile(0))\n        ```\n\n    Raises:\n        ValueError: Invalid value for `idx`.\n\n    Args:\n        idx: A parameter in [0, 1, 2, 3, 4]\n\n    Returns:\n        Tile state.\n\n    \"\"\"\n    e_0, e_1, e_2 = basis(3, 0), basis(3, 1), basis(3, 2)\n    match idx:\n        case 0:\n            return 1 / np.sqrt(2) * np.kron(e_0, (e_0 - e_1))\n        case 1:\n            return 1 / np.sqrt(2) * np.kron((e_0 - e_1), e_2)\n        case 2:\n            return 1 / np.sqrt(2) * np.kron(e_2, (e_1 - e_2))\n        case 3:\n            return 1 / np.sqrt(2) * np.kron((e_1 - e_2), e_0)\n        case 4:\n            return 1 / 3 * np.kron((e_0 + e_1 + e_2), (e_0 + e_1 + e_2))\n    raise ValueError(\"Invalid integer value for Tile state.\")\n</code></pre>"},{"location":"reference/toqito/states/trine/","title":"trine","text":""},{"location":"reference/toqito/states/trine/#toqito.states.trine","title":"trine","text":"<p>Trine states are states of linear polarization separated by 60\u00b0.</p>"},{"location":"reference/toqito/states/trine/#toqito.states.trine.trine","title":"trine","text":"<pre><code>trine() -&gt; list[ndarray]\n</code></pre> <p>Produce the set of trine states (Slide 6 of <sup>1</sup>).</p> <p>The trine states are formally defined as:</p> \\[     u_1 = |0\\rangle, \\quad     u_1 = -\\frac{1}{2}\\left(|0\\rangle + \\sqrt{3}|1\\rangle\\right), \\quad \\text{and} \\quad     u_2 = -\\frac{1}{2}\\left(|0\\rangle - \\sqrt{3}|1\\rangle\\right). \\] <p>Examples:</p> <p>Generating the trine states can be done by simply invoking the function:</p> <pre><code>from toqito.states import trine\nprint(trine())\n</code></pre> <p>[array([[1],        [0]]), array([[-0.5      ],        [-0.8660254]]), array([[-0.5      ],        [ 0.8660254]])]</p> <p>Returns:</p> <ul> <li> <code>list[ndarray]</code>           \u2013            <p>Vector of trine states.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Yard, Jon. Introduction to Quantum Information Processing. link.</p> Source code in <code>toqito/states/trine.py</code> <pre><code>def trine() -&gt; list[np.ndarray]:\n    r\"\"\"Produce the set of trine states (Slide 6 of [@Yard_2017_Lecture11]).\n\n    The trine states are formally defined as:\n\n    \\[\n        u_1 = |0\\rangle, \\quad\n        u_1 = -\\frac{1}{2}\\left(|0\\rangle + \\sqrt{3}|1\\rangle\\right), \\quad \\text{and} \\quad\n        u_2 = -\\frac{1}{2}\\left(|0\\rangle - \\sqrt{3}|1\\rangle\\right).\n    \\]\n\n    Examples:\n        Generating the trine states can be done by simply invoking the function:\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import trine\n        print(trine())\n        ```\n\n    Returns:\n        Vector of trine states.\n\n    \"\"\"\n    e_0, e_1 = basis(2, 0), basis(2, 1)\n    return [\n        e_0,\n        -1 / 2 * (e_0 + np.sqrt(3) * e_1),\n        -1 / 2 * (e_0 - np.sqrt(3) * e_1),\n    ]\n</code></pre>"},{"location":"reference/toqito/states/w_state/","title":"w_state","text":""},{"location":"reference/toqito/states/w_state/#toqito.states.w_state","title":"w_state","text":"<p>Generalized w-state is an entangled quantum state of <code>n</code> qubits.</p> <p>This state refers to the quantum superposition in which one of the qubits is in an excited state and others are in the ground state.</p>"},{"location":"reference/toqito/states/w_state/#toqito.states.w_state.w_state","title":"w_state","text":"<pre><code>w_state(num_qubits: int, coeff: list[int] | None = None) -&gt; ndarray\n</code></pre> <p>Produce a W-state <sup>1</sup>.</p> <p>Returns the W-state described in <sup>1</sup>. The W-state on <code>num_qubits</code> qubits is defined by:</p> \\[     |W \\rangle = \\frac{1}{\\sqrt{num\\_qubits}}     \\left(|100 \\ldots 0 \\rangle + |010 \\ldots 0 \\rangle + \\ldots +     |000 \\ldots 1 \\rangle \\right). \\] <p>Examples:</p> <p>Using <code>|toqito\u27e9</code>, we can generate the \\(3\\)-qubit W-state</p> \\[     |W_3 \\rangle = \\frac{1}{\\sqrt{3}} \\left( |100\\rangle + |010 \\rangle +     |001 \\rangle \\right) \\] <p>as follows.</p> <pre><code>from toqito.states import w_state\nprint(w_state(3))\n</code></pre> <p>[[0.    ]  [0.5774]  [0.5774]  [0.    ]  [0.5774]  [0.    ]  [0.    ]  [0.    ]]</p> <p>We may also generate a generalized \\(W\\)-state. For instance, here is a \\(4\\)-dimensional \\(W\\)-state</p> \\[     \\frac{1}{\\sqrt{30}} \\left( |1000 \\rangle + 2|0100 \\rangle + 3|0010     \\rangle + 4 |0001 \\rangle \\right). \\] <p>We can generate this state in <code>|toqito\u27e9</code> as</p> <pre><code>from toqito.states import w_state\nimport numpy as np\ncoeffs = np.array([1, 2, 3, 4]) / np.sqrt(30)\nprint(w_state(4, coeffs))\n</code></pre> <p>[[0.    ]  [0.7303]  [0.5477]  [0.    ]  [0.3651]  [0.    ]  [0.    ]  [0.    ]  [0.1826]  [0.    ]  [0.    ]  [0.    ]  [0.    ]  [0.    ]  [0.    ]  [0.    ]]</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>The number of qubits must be greater than or equal to 1.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>num_qubits</code>               (<code>int</code>)           \u2013            <p>An integer representing the number of qubits.</p> </li> <li> <code>coeff</code>               (<code>list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>default is <code>[1, 1, ..., 1]/sqrt(num_qubits)</code>: a 1-by-<code>num_qubts</code> vector of coefficients.</p> </li> </ul> <p>References</p> <p><sup>1</sup> D\u00fcr, W. and Vidal, G. and Cirac, J.. Three qubits can be entangled in two inequivalent ways. Physical Review A. vol. 62(6). (2000). doi:10.1103/physreva.62.062314.</p> Source code in <code>toqito/states/w_state.py</code> <pre><code>def w_state(num_qubits: int, coeff: list[int] | None = None) -&gt; np.ndarray:\n    r\"\"\"Produce a W-state [@Dur_2000_ThreeQubits].\n\n    Returns the W-state described in [@Dur_2000_ThreeQubits]. The W-state on `num_qubits` qubits is defined by:\n\n    \\[\n        |W \\rangle = \\frac{1}{\\sqrt{num\\_qubits}}\n        \\left(|100 \\ldots 0 \\rangle + |010 \\ldots 0 \\rangle + \\ldots +\n        |000 \\ldots 1 \\rangle \\right).\n    \\]\n\n    Examples:\n        Using `|toqito\u27e9`, we can generate the \\(3\\)-qubit W-state\n\n        \\[\n            |W_3 \\rangle = \\frac{1}{\\sqrt{3}} \\left( |100\\rangle + |010 \\rangle +\n            |001 \\rangle \\right)\n        \\]\n\n        as follows.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import w_state\n        print(w_state(3))\n        ```\n\n        We may also generate a generalized \\(W\\)-state. For instance, here is a \\(4\\)-dimensional \\(W\\)-state\n\n        \\[\n            \\frac{1}{\\sqrt{30}} \\left( |1000 \\rangle + 2|0100 \\rangle + 3|0010\n            \\rangle + 4 |0001 \\rangle \\right).\n        \\]\n\n        We can generate this state in `|toqito\u27e9` as\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import w_state\n        import numpy as np\n        coeffs = np.array([1, 2, 3, 4]) / np.sqrt(30)\n        print(w_state(4, coeffs))\n        ```\n\n    Raises:\n        ValueError: The number of qubits must be greater than or equal to 1.\n\n    Args:\n        num_qubits: An integer representing the number of qubits.\n        coeff: default is `[1, 1, ..., 1]/sqrt(num_qubits)`: a 1-by-`num_qubts` vector of coefficients.\n\n    \"\"\"\n    if num_qubits &lt; 2:\n        raise ValueError(\"InvalidNumQubits: `num_qubits` must be at least 2.\")\n    if coeff is None:\n        coeff_arr = np.ones(num_qubits)\n    else:\n        coeff_arr = np.array(coeff)\n    if len(coeff_arr) != num_qubits:\n        raise ValueError(\"InvalidCoeff: The variable `coeff` must be a vector of length equal to `num_qubits`.\")\n\n    # Normalize coefficients if necessary.\n    norm = np.linalg.norm(coeff_arr)\n    if not np.isclose(norm, 1.0):\n        coeff_arr = coeff_arr / norm\n\n    # Initialize a state vector of appropriate size.\n    ret_w_state = csr_array((2**num_qubits, 1)).toarray()\n    # Fill the vector so that the state has the single excitation distributed according to coeff.\n    # Note: The ordering assumes that the binary representation corresponds to qubits in little-endian order.\n    for i in range(num_qubits):\n        # The position for an excitation on qubit i is at index 2**i.\n        # We assign the coefficient to the position corresponding to an excitation in that qubit.\n        ret_w_state[2**i] = coeff_arr[num_qubits - i - 1]\n    return np.around(ret_w_state, 4)\n</code></pre>"},{"location":"reference/toqito/states/werner/","title":"werner","text":""},{"location":"reference/toqito/states/werner/#toqito.states.werner","title":"werner","text":"<p>Werner states.</p> <p>Werner states are mixtures of projectors onto the symmetric and permutation operator that exchanges the two subsystems.</p>"},{"location":"reference/toqito/states/werner/#toqito.states.werner.werner","title":"werner","text":"<pre><code>werner(dim: int, alpha: float | list[float]) -&gt; ndarray\n</code></pre> <p>Produce a Werner state <sup>1</sup>.</p> <p>A Werner state is a state of the following form</p> \\[     \\begin{equation}         \\rho_{\\alpha} = \\frac{1}{d^2 - d\\alpha} \\left(\\mathbb{I} \\otimes         \\mathbb{I} - \\alpha S \\right) \\in \\mathbb{C}^d \\otimes \\mathbb{C}^d.     \\end{equation} \\] <p>Yields a Werner state with parameter <code>alpha</code> acting on <code>(dim * dim)</code>- dimensional space. More specifically, \\(\\rho\\) is the density operator defined by \\((\\mathbb{I} - \\)alpha<code>S)</code> (normalized to have trace 1), where \\(\\mathbb{I}\\) is the density operator and \\(S\\) is the operator that swaps two copies of <code>dim</code>-dimensional space (see swap and swap_operator for example).</p> <p>If <code>alpha</code> is a vector with \\(p!-1\\) entries, for some integer \\(p &gt; 1\\), then a multipartite Werner state is returned. This multipartite Werner state is the normalization of I - <code>alpha(1)*P(2)</code> - ... - <code>alpha(p!-1)*P(p!)</code>, where P(i) is the operator that permutes p subsystems according to the i-th permutation when they are written in lexicographical order (for example, the lexicographical ordering when p = 3 is: <code>[1, 2, 3], [1, 3, 2], [2, 1,3], [2, 3, 1], [3, 1, 2], [3, 2, 1],</code> so P(4) in this case equals permutation_operator(dim, [2, 3, 1]).</p> <p>Examples:</p> <p>Computing the qutrit Werner state with \\(\\alpha = 1/2\\) can be done in <code>|toqito\u27e9</code> as</p> <pre><code>from toqito.states import werner\nprint(werner(3, 1 / 2))\n</code></pre> <p>[[ 0.06666667  0.          0.          0.          0.          0.          0.          0.          0.        ]  [ 0.          0.13333333  0.         -0.06666667  0.          0.          0.          0.          0.        ]  [ 0.          0.          0.13333333  0.          0.          0.         -0.06666667  0.          0.        ]  [ 0.         -0.06666667  0.          0.13333333  0.          0.          0.          0.          0.        ]  [ 0.          0.          0.          0.          0.06666667  0.          0.          0.          0.        ]  [ 0.          0.          0.          0.          0.          0.13333333  0.         -0.06666667  0.        ]  [ 0.          0.         -0.06666667  0.          0.          0.          0.13333333  0.          0.        ]  [ 0.          0.          0.          0.          0.         -0.06666667  0.          0.13333333  0.        ]  [ 0.          0.          0.          0.          0.          0.          0.          0.          0.06666667]]</p> <p>We may also compute multipartite Werner states in <code>|toqito\u27e9</code> as well.</p> <pre><code>from toqito.states import werner\nprint(werner(2, [0.01, 0.02, 0.03, 0.04, 0.05]))\n</code></pre> <p>[[ 0.11286089  0.          0.          0.          0.          0.          0.          0.        ]  [ 0.          0.12729659 -0.00787402  0.         -0.00656168  0.          0.          0.        ]  [ 0.         -0.00918635  0.1312336   0.         -0.00918635  0.          0.          0.        ]  [ 0.          0.          0.          0.12860892  0.         -0.01049869 -0.00524934  0.        ]  [ 0.         -0.00524934 -0.01049869  0.          0.12860892  0.          0.          0.        ]  [ 0.          0.          0.         -0.00918635  0.          0.1312336  -0.00918635  0.        ]  [ 0.          0.          0.         -0.00656168  0.         -0.00787402  0.12729659  0.        ]  [ 0.          0.          0.          0.          0.          0.          0.          0.11286089]]</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>Alpha vector does not have the correct length.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>dim</code>               (<code>int</code>)           \u2013            <p>The dimension of the Werner state.</p> </li> <li> <code>alpha</code>               (<code>float | list[float]</code>)           \u2013            <p>Parameter to specify Werner state.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>A Werner state of dimension <code>dim</code>.</p> </li> </ul> <p>References</p> <p><sup>1</sup> Werner, Reinhard. Quantum states with Einstein-Podolsky-Rosen correlations admitting a hidden-variable model. Phys. Rev. A. vol. 40. (1989). doi:10.1103/PhysRevA.40.4277.</p> Source code in <code>toqito/states/werner.py</code> <pre><code>def werner(dim: int, alpha: float | list[float]) -&gt; np.ndarray:\n    r\"\"\"Produce a Werner state [@Werner_1989_QuantumStates].\n\n    A Werner state is a state of the following form\n\n    \\[\n        \\begin{equation}\n            \\rho_{\\alpha} = \\frac{1}{d^2 - d\\alpha} \\left(\\mathbb{I} \\otimes\n            \\mathbb{I} - \\alpha S \\right) \\in \\mathbb{C}^d \\otimes \\mathbb{C}^d.\n        \\end{equation}\n    \\]\n\n    Yields a Werner state with parameter `alpha` acting on `(dim * dim)`- dimensional space. More\n    specifically, \\(\\rho\\) is the density operator defined by \\((\\mathbb{I} - \\)alpha` S)` (normalized to have\n    trace 1), where \\(\\mathbb{I}\\) is the density operator and \\(S\\) is the operator that swaps two copies of\n    `dim`-dimensional space (see swap and swap_operator for example).\n\n    If `alpha` is a vector with \\(p!-1\\) entries, for some integer \\(p &gt; 1\\), then a multipartite Werner\n    state is returned. This multipartite Werner state is the normalization of I - `alpha(1)*P(2)` - ... -\n    `alpha(p!-1)*P(p!)`, where P(i) is the operator that permutes p subsystems according to the i-th permutation when\n    they are written in lexicographical order (for example, the lexicographical ordering when p = 3 is: `[1, 2, 3], [1,\n    3, 2], [2, 1,3], [2, 3, 1], [3, 1, 2], [3, 2, 1],` so P(4) in this case equals permutation_operator(dim, [2, 3, 1]).\n\n    Examples:\n        Computing the qutrit Werner state with \\(\\alpha = 1/2\\) can be done in `|toqito\u27e9` as\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import werner\n        print(werner(3, 1 / 2))\n        ```\n\n\n        We may also compute multipartite Werner states in `|toqito\u27e9` as well.\n\n        ```python exec=\"1\" source=\"above\"\n        from toqito.states import werner\n        print(werner(2, [0.01, 0.02, 0.03, 0.04, 0.05]))\n        ```\n\n    Raises:\n        ValueError: Alpha vector does not have the correct length.\n\n    Args:\n        dim: The dimension of the Werner state.\n        alpha: Parameter to specify Werner state.\n\n    Returns:\n        A Werner state of dimension `dim`.\n\n    \"\"\"\n    # Multipartite Werner state.\n    if isinstance(alpha, list):\n        n_fac = len(alpha) + 1\n        # Compute the number of parties from `len(alpha)`.\n        n_var = n_fac\n        # We won't actually go all the way to `n_fac`.\n        for i in range(2, n_fac):\n            n_var = n_var // i\n            if n_var == i + 1:\n                break\n            if n_var &lt; i:\n                raise ValueError(\"InvalidAlpha: The `alpha` vector must contain p!-1 entries for some integer p &gt; 1.\")\n\n        # Done error checking and computing the number of parties\n        # -- now compute the Werner state.\n        perms = list(itertools.permutations(range(n_var)))\n        sorted_perms = np.argsort(perms, axis=1)\n\n        rho = np.identity(dim**n_var)\n        for i in range(2, n_fac):\n            rho -= alpha[i - 1] * permutation_operator(dim, sorted_perms[i - 1, :], False, True)\n        rho = rho / np.trace(rho)\n        return rho\n\n    # Bipartite Werner state (executed only if alpha is a float).\n    if isinstance(alpha, float):\n        n_fac = 2\n        return (np.identity(dim**2) - alpha * swap_operator(dim, True)) / (dim * (dim - alpha))\n\n    raise ValueError(\"Alpha must be either a float or a list of floats.\")\n</code></pre>"}]}