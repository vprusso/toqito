"""Test pauli channel."""

import re

import numpy as np
import pytest
from scipy.linalg import eigvalsh

from toqito.channels import partial_trace, pauli_channel


@pytest.mark.parametrize(
    "in_p",
    [
        # Negative probability.
        ([-0.1, 1.1]),
        # Incorrect length.
        ([0.2, 0.2, 0.2, 0.2, 0.2]),
        # Out of range probabilities.
        ([1.1, 0.1]),
    ],
)
def test_pauli_channel_valid_probability(in_p):
    """Test probability vector validation with various invalid inputs."""
    with pytest.raises(
        ValueError,
        match=(
            re.escape("Probabilities must be non-negative and sum to 1.")
            + "|"
            + re.escape("The length of the probability vector must be 4^Q for some integer Q (number of qubits).")
        ),
    ):
        pauli_channel(prob=in_p)


@pytest.mark.parametrize(
    "Q,expected_dim",
    [
        # Single qubit.
        (1, 4),
        # Two qubits.
        (2, 16),
        # Three qubits.
        (3, 64),
    ],
)
def test_pauli_channel_dimensions(Q, expected_dim):
    """Test Pauli channel generation for different numbers of qubits."""
    p = np.ones(expected_dim) / expected_dim
    Phi = pauli_channel(prob=p)
    assert Phi.shape == (expected_dim, expected_dim), f"Incorrect matrix dimensions for {Q} qubits"


@pytest.mark.parametrize("p", [np.array([0.1, 0.2, 0.3, 0.4]), np.random.rand(16)])
def test_pauli_channel_kraus_operators(p):
    """Test generation of Kraus operators for different probability inputs.

    This function normalizes the probability vector, generates Kraus operators
    using the `pauli_channel` function, and verifies their properties:

    - Ensures the number of Kraus operators matches the number of probabilities.
    - Checks that the Kraus operators satisfy the completeness condition.
    """
    p = p / np.sum(p)
    _, kraus_operators = pauli_channel(prob=p, kraus_ops=True)

    assert len(kraus_operators) == len(p)

    total_ops = np.zeros_like(kraus_operators[0], dtype=np.complex128)
    for K in kraus_operators:
        total_ops += K.conj().T @ K

    np.testing.assert_almost_equal(total_ops, np.eye(total_ops.shape[0]), decimal=10)


@pytest.mark.parametrize(
    "input_mat,p",
    [
        # Identity matrix.
        (np.eye(2), np.array([0.1, 0.2, 0.3, 0.4])),
        # Pure state.
        (np.array([[1, 0], [0, 0]], dtype=complex), np.array([0.25, 0.25, 0.25, 0.25])),
    ],
)
def test_pauli_channel_input_matrix_properties(input_mat, p):
    """Test properties of the output matrix when an input matrix is provided.

    This function ensures that the Pauli channel transformation holds:

    - The output matrix remains Hermitian.
    - The output matrix is positive semidefinite.
    - The trace of the input matrix is preserved in the output.

    """
    p = p / np.sum(p)
    _, output_mat = pauli_channel(prob=p, input_mat=input_mat)

    assert np.allclose(output_mat, output_mat.conj().T), "Output matrix is not Hermitian."

    eig_v = eigvalsh(output_mat)
    assert np.all(eig_v >= -1e-10), "Output matrix is not positive semidefinite."

    in_trace = np.trace(input_mat)
    out_trace = np.trace(output_mat)
    assert np.isclose(out_trace, in_trace), "Trace is not preserved in the output matrix."

    Phi, output_mat, kraus_ops = pauli_channel(prob=p, input_mat=input_mat, kraus_ops=True)

    assert isinstance(output_mat, np.ndarray)
    assert isinstance(kraus_ops, list)
    assert len(kraus_ops) == len(p)


@pytest.mark.parametrize("Q", [1, 2, 3])
def test_pauli_channel_choi_matrix_properties(Q):
    """Test Choi matrix properties for different numbers of qubits.

    This function verifies the following properties of Choi Matrix generated by Pauli Channel:

    - The Choi matrix has the expected dimension `(4**Q, 4**Q)`.
    - It is positive semidefinite.
    - Its partial trace over the output system yields the identity matrix of the input Hilbert space.
    - Its total trace equals the input dimension `(2**Q)`.

    """
    Phi, _ = pauli_channel(prob=Q, kraus_ops=True)
    Phi = np.array(Phi)
    expected_choi_dim = 4**Q
    assert Phi.shape == (expected_choi_dim, expected_choi_dim), (
        f"Expected shape {(expected_choi_dim, expected_choi_dim)}, got {Phi.shape}"
    )

    eigenvalues = eigvalsh(Phi)
    assert np.all(eigenvalues >= -1e-10), f"Phi is not positive semidefinite for {Q} qubits"

    input_dim = 2**Q
    dims = [input_dim, input_dim]
    pt_output = partial_trace(Phi, sys=1, dim=dims)
    identity_input = np.eye(input_dim)
    assert np.allclose(pt_output, identity_input), f"Partial trace does not equal identity for {Q} qubits"

    total_trace = np.trace(Phi)
    assert np.isclose(total_trace, input_dim), (
        f"Total trace ({total_trace}) does not equal input dimension ({input_dim}) for {Q} qubits"
    )


@pytest.mark.parametrize(
    "p",
    [
        # Multiple 0 entries.
        np.array([0.0, 0.5, 0.0, 0.5]),
        # Single 0 entries.
        np.array([0.25, 0.0, 0.25, 0.5]),
    ],
)
def test_pauli_channel_zero_probability(p):
    """Test Pauli Channel when some input probabilities are zero.

    This function ensures that when certain probabilities in `p` are zero,
    their corresponding Kraus operators are effectively zero.
    """
    _, kraus_ops = pauli_channel(prob=p, kraus_ops=True)

    for i, k in enumerate(kraus_ops):
        if p[i] == 0:
            np.testing.assert_almost_equal(k, np.zeros_like(k))
